#+TITLE: isamert's dotfiles

Here in this repository you can find my configurations for various applications and some scripts for managing/automating these programs. I do not expect anybody to copy this repository as-is and start using it, considerable amount of these files consists specific solutions for my specific workflow. Albeit I do recommend you to take a tour of this repository and copy/change the part you're interested in. There is a lot of stuff going on, so I'll try to give a quick summary of what is what and how I use them. Beware, there will be a lot of rambling!

* General workflow and thoughts
My configurations generally focuses on software development with a keyboard-driven workflow. I'm not a pragmatist, I simply try to create a workflow that I can enjoy. Sometimes this means a decrease in productivity but an overall increase in /my/ sanity. Here are some main, overly-talked-about topics that I want to share my views on:

** Keyboard vs. Mouse
I hate mouse. I do not use it unless it's absolutely necessary. It causes physical pain and doing a switch between keyboard and mouse while working simply destroys my focus. I get frustrated pretty easily. If a program is not usable without a mouse, I simply do not use it.

** Simplicity and comprehensiveness
- While I do appreciate the /[[https://github.com/isamert/st][st]]/ as a terminal emulator, I do not use it because it's the /fastest/ and/or it's the lightest terminal emulator out there; I use it because it works quite flawlessly with the programs I use.
- I do my scripting generally in /bash/ instead of /sh/. Yes, bash does not work everywhere and it has it's own quirkiness but writing and maintaining a bash script is just so much easier than a UNIX-compliant /sh/ script. I do not seek for comprehensiveness because I think it's not an achievable goal. But I do try to generalize my solutions whenever it's easy to do.

* The operating system
I use Arch Linux. Arch Linux, unironically, is, the most stable system I've ever used to this date. The large userbase and AUR makes everything pretty easy to install and tinker with. Although I would very much like to use [[https://nixos.org][NixOS]] or, better yet, [[https://guix.gnu.org][GNU Guix]], but it practically seems like a very big undertaking at the moment. Eventually I would like to try both and replace Arch with one of them. My main interest in these systems is that being able to configure whole system declaratively. The only theoretic drawback of this kind of configuration is that it makes you dependent on one specific system. One can argue that both Nix and Guix can be installed on other systems as package managers, but this is the only package management aspect of it and the stability of that kind of setups is questionable. On practical side, the small userbase frightens me. This is especially true for Guix as like I wasn't even able to boot a real computer with a GUIX USB stick and couldn't get any real help.

** Service/Task configuration
I use =systemd= to orchestrate my services and system tasks. You can find all of my unit files under =~/.config/systemd/user=. The most important part of this unit files are the =user-login.target= and =user-graphical-login.target=. The first one is called by the =~/.profile= file using these lines:

#+BEGIN_SRC bash
systemctl --user import-environment
systemctl --user start user-login.target &
#+END_SRC

=systemd --user= does not automatically import user environment variables, so the first line solves this problem. The second line starts =user-login.target= which then simply starts all the startup applications that does not need a graphical environment. The =user-graphical-login.target= is called by the =~/.xprofile= file. This file is sourced by the login manager on startup, then =user-graphical-login.target= starts the startup applications that requires a graphical environment. With this kind of configuration, I'm not bound to use a graphical environment all the time and the switch between non-gui and gui environments are simple.

** TODO NixOs vs GNU Guix
* Window management
I do not use any desktop environment, like KDE and GNOME. I use a window manager called [[https://github.com/baskerville/bspwm][BSPWM]]. BSPWM is one of the most minimal and easy to configure tiling window manager out there. The configuration method it uses is brilliant. It's configured trough a binary, called =bspc=. This kind of configuration does not make you dependent on a home-baked configuration language and it's quirkiness, instead you are free to use any language you want. As my BSPWM initialization, I use a bash script that consists this line:

#+BEGIN_SRC bash
xrandr -q | grep -w "connected" | cut -d' ' -f1 | xargs -I {} bspc monitor "{}" --reset-desktops I II III IV V
#+END_SRC

With this command, I can create 5 virtual desktops for each monitor connected to my computer. See how easy it is to integrate?

I also have a script called =bspwmc= which just contains extra functionally for BSPWM that I wrote. For example I created some functions for moving/resizing floating windows:

[[file:https://user-images.githubusercontent.com/8031017/73112108-17422100-3f1e-11ea-9069-b33861d42388.gif]]

** Display manager
I use =X.org=. While =Wayland= seems promising, it does not have the fraction of tooling that X.org has. There is also no analogues of BSPWM for Wayland. If you have a dual Nvidia+Intel GPU laptop, namely Optimus laptops, you don't really have any other sane choice but using X.org and [[https://github.com/Askannz/optimus-manager][optimus-manager]].

* Keyboard configuration and shortcuts
I modify the keyboard layout with =xmodmap= and create keyboard shortcuts with =sxhkd=. For example, with the help of =xmodmap= I remap =CapsLock= key as the =Hyper= key, which is just another modifier key like =Ctrl= key. Then I create shortcuts using =sxhkd=, for example =Hyper+a= opens up a menu that lists all the applications that are installed in my machine.

I also use =xmodmap= for adding Unicode characters to my layout which enables me to use Unicode characters while coding without depending on any other extensions. Here is a list of characters that I have mapped in my =~/.Xmodmap= file:

#+BEGIN_SRC
AltGr + l → λ  | AltGr + a → →
AltGr + x → ❌ | AltGr + f → ∀
AltGr + n → ¬  | AltGr + d → ⇒
AltGr + , → ≤  | AltGr + . → ≥
AltGr + = → ≠  | AltGr + shift + = → ≔
AltGr + / → ÷  | AltGr + ; → ∷
AltGr + 8 → ×  | AltGr + t -> ✓
#+END_SRC

Here is an example keybinding from my =~/.config/sxhkd/sxhkdrc=:

#+BEGIN_SRC
hyper + {bracketleft, bracketright}
    mediastuff all_seek {-,+}3%
#+END_SRC

When you press =Hyper + [= or =Hyper + ]=, sxhkd grabs this and calls the script named =mediastuff= with given parameters. In this particular case, this script seeks the song by 3 percent forward or backward based on given input. Observe how easy it is to bind multiple keys on same rule.

* Multimedia and entertainment
I use =mpv= for videos, =mpd= for music. I also have some scripts that builds upon the functionalities of =mpv=, =mpd=, =youtube-viewer=, =youtube-dl= etc.

** Music management
I have an =mpd= server running all the time. I control it with =ncmpcpp=. I also have some dmenu scripts that allows me to quickly access my music library.

[[file:https://user-images.githubusercontent.com/8031017/73128764-4cfe0d00-3fe5-11ea-8f9c-81fac77e805a.png]]
[[file:https://user-images.githubusercontent.com/8031017/73128763-4cfe0d00-3fe5-11ea-84f5-ea1744b72856.png]]

The second menu also does a search on YouTube if the input is not found on my local library. (The youtube menu script, under the =~/.scripts/menu=, is kind of an abomination right now, but it does work.)

** Video management
I keep all of the movies and shows under =~/Videos/Movies= and =~/Videos/Shows= respectively. For quick access, I use the shortcut =Hyper+f= which simply lists all the files under my home directory using =dmenu= (The script tries to ignore unrelated files and folders, like hidden ones and temporary ones. So it's kind of fast.).

[[file:https://user-images.githubusercontent.com/8031017/73128976-3908da00-3fea-11ea-83e7-19dbd53ecb96.png]]

I have integrated =subdl=, a program that downloads subtitles for given video file from opensubtitles.org, with =mpv=. To get a subtitle, I simply hit =T= (or =Alt+T= for Turkish subtitles) and it downloads and loads the subtitle automatically for me. Observe these lines from =~/.config/mpv/input.conf=:

#+BEGIN_SRC
T run     "mediastuff" "mpv-subdl" "${path}" "eng" # english subtitle
Alt+t run "mediastuff" "mpv-subdl" "${path}" "tur" # turkish subtitle
#+END_SRC

I also have a shortcut that does a direct search on youtube and plays the result in =mpv=. This search menu is toggled with =Hyper+y=.

** RSS
I use =newsboat= to follow RSS feeds. RSS feeds consists of blogs, YouTube channels, podcasts, subreddits etc. This helps me focus on what I really want to follow and discard the distractions (All kind of /recommendations/ feature on every website is a big distraction, I try to avoid them because my willpower is pretty weak). I also watch YouTube videos using mpv. I created a simple shortcut that opens up YouTube video comments in a terminal window. See how this workflow goes along with =newsboat=:

[[file:https://user-images.githubusercontent.com/8031017/73128975-137bd080-3fea-11ea-862f-4e69ceb484b7.gif]]

* TODO Programming workflow
- tmux sessions for each virtual desktop
- commandline tools, fuzzy script (git etc.)

** emacs vs. vim (and some thoughts on /kakoune/)
I use =emacs= for every kind of project that I have. I also use =neovim=, but I use it as a lightweight editor that I spawn for short periods of time for like quick fixes, previews etc. I try to make the editing experience as same as possible for these two editors. For example I use =evil-mode= to emulate vim keys in =emacs=.

Some may argue that =neovim= is just obsolete in the presence of =emacs= or vice versa. I totally disagree with this. I was a vim-only user back then, until I discovered the =org-mode=. I made the switch to =emacs=. But =emacs= has a lot of problems. First and foremost, the load time is just borderline bad, especially on a 5400 RPM hard-disk. The server mode significantly improves the overall feel but it has it own quirkiness too. Also I really like to use =emacs= in a GUI mode but keeping everything compatible between GUI mode and terminal mode is just not really an option. Some extensions just flat-out does not work in terminal mode, some behave really weird. Emacs term mode is also quite bad and slow. I use a lot of terminal only programs and considering this, going emacs-only is just a hard job with little to none benefits.

You can read my =emacs= configuration in detail from [[file:./.emacs.d/settings.org][here]], it's a self-documenting =.org= file. As for my =neovim= configuration, you can take a look at it from [[file:./.config/nvim/init.vim][here]] (it's not self documenting like the =emacs= one). Although my =neovim= configuration is focused on simplicity, I also maintain a minimal configuration for =vim=, that you can take a look at from [[file:./.config/nvim/minimal.vim][here]]. It's just the plugin-less version of my real configuration. The rationale here is that a lot of programs have some kind of vim emulation mode and I'm able to copy my configuration trough here without dealing with the plugins. It's also nice to copy this file into friends computers without bloating their system and I feel at home while using their computer.

Another nicety of having =neovim=/=vim= under your usage is that it's wildy supported everywhere. For example, it's easy to find a plugin for editing =sxhkd= configuration file wheres there is none for =emacs=. (Well, for this particular case it may be really easy to implement such a mode for =emacs= but you also take the burden of maintaining of that piece of =elisp=.)

Another thing I like about vim is that the plugin called =ALE=. As I said earlier, I use =neovim= for quick edits, like editing my configuration files and bash scripts. =ALE= is just a zero-config plugin that detects gazillions of different linters/syntax checkers/language servers on your system and makes use of them automatically. This significantly improves your /quick-edits/. At most, you only need to install a simple program and you got your =bash= scripts linted, =markdown= files prettified, =yaml= files validated etc. Wheres I use =lsp-mode= on =emacs= and I like to fine tune my setting for the language servers I will be dealing with because it's important to have things in your way when doing long sessions of coding.

*** TODO kakoune
...

** TODO org-mode
...
* TODO Other
** TODO Shell
- zsh customizations
** TODO Password management
** TODO Extra tools
- jaro
- ~/.scripts
** TODO Popups
=~/.scripts/popup=
** TODO On multi-monitor setups and multi-computer setups
** TODO Meta
- how do i keep my dotfiles synced?
