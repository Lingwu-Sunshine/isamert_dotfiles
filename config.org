#+PROPERTY: header-args :mkdirp yes :noweb no-export

* Introduction
This is primarily WIP. I just copied my dotfiles over here and categorized them and nothing else.

- TODO items ::
  - [ ]  Need to convert some global variable hacks into noweb references.
  - [ ]  Create a bash library for my scripts, using noweb references.
  - [ ]  Explain each and every config file with at east 2 sentences.
  - [ ]  Find a way to make scripts exactable after tangling.

** Some general information
- ~org-babel-tangle~ to tangle all files.
- ~C-u org-babel-tangle~ to only tangle current file.
** .profile
#+begin_src bash :tangle ~/.profile
  # For aurin, aursearch... aliases. (Also used in some other scripts)
  export AUR_HELPER=trizen

  # Changing this is not goint to change your keyboard layout. For more info, read ~/.scripts/switch-keyboard-layout
  # See `localectl list-x11-keymap-layouts` for your options. (It's generally 2-char country code.)
  # Set your default layout with `localectl set-keymap` and localectl set-x11-keymap
  export KEYBOARD_LAYOUTS='us(intl)',tr

  # To be able to deploy android apps from commandline.
  if [[ -f /opt/android-sdk ]]; then
      export ANDROID_SDK_ROOT=/opt/android-sdk
  fi

  # Use q5ct program to configure qt themes
  # and gtk-theme-switch2 (aur) for gtk
  export QT_QPA_PLATFORMTHEME=qt5ct

  # Ctrl-Shift-P to search menu items in GTK apps
  if [[ -f /usr/lib/libplotinus.so ]]; then
      export GTK3_MODULES=/usr/lib/libplotinus.so
  fi

  export GOPATH="$HOME/.go"
  export R_LIBS_USER="$HOME/.rlibs"

  # the PATH
  export PATH=$HOME/.scripts:$HOME/.local/bin:$NPM_PACKAGES/bin:$GOPATH/.go/bin:$HOME/.cargo/bin:$PATH

  # fzf stuff {{{
  export FZF_BINDINGS="\
  ctrl-d:page-down,ctrl-u:page-up,\
  alt-j:preview-down,alt-k:preview-up,\
  alt-d:preview-page-down,alt-u:preview-page-up,\
  alt-e:execute($EDITOR {}),\
  alt-y:execute-silent(echo {} | xcopy),\
  ctrl-p:toggle-preview"

  export FZF_DEFAULT_OPTS="
  --bind \"$FZF_BINDINGS\" \
  --header='(c-p: toggle-preview | c-d/u: page up/down | a-j/k: preview up/down | a-y: copy | a-e: edit)' \
  --reverse"
  # }}}

  # Run ts_onfinish when a tsp job is finished
  export TS_ONFINISH=ts_onfinish

  # node/nvm configuration {{{
  export NVM_DIR="$HOME/.nvm"
  # TODO: source nvm
  # source /usr/share/nvm/init-nvm.sh
  # OR
  #[ -z "$NVM_DIR" ] && export NVM_DIR="$HOME/.nvm"
  #source /usr/share/nvm/nvm.sh
  #source /usr/share/nvm/bash_completion
  #source /usr/share/nvm/install-nvm-exec
  # }}}

  if command -v jaro > /dev/null 2>&1; then
      export BROWSER=jaro
      export EDITOR="jaro --method=edit"
      export VISUAL=jaro
  else
      export EDITOR=nvim
  fi

  export SHELL=/bin/zsh

  # Hyper + Y brings up a dmenu that lists the videos found in following playlist
  export YT_MAIN_PLAYLIST=PLXawKvexOu0psiAqHCV5IFxdnWxZN1OVc

  # Some constants
  export PASSWORD_STORE=$HOME/Documents/sync/passwords.kdbx
  export DIR_WALLPAPERS=$HOME/Pictures/wallpapers
  export DIR_SCREENSHOTS=$HOME/Pictures/screenshots
  export DIR_NOTES=$HOME/Documents/notes

  # Nix settings {{{
  # Global installation
  [[ -f /etc/profile.d/nix-daemon.sh ]] && source /etc/profile.d/nix{,-daemon}.sh

  # User dir installation
  [[ -f $HOME/.nix-profile/etc/profile.d/nix.sh ]] && source $HOME/.nix-profile/etc/profile.d/nix{,-daemon}.sh
  # }}}

  if [[ -f $HOME/.extrarc ]]; then
      . $HOME/.extrarc
  fi

  if pgrep systemd > /dev/null 2>&1; then
      systemctl --user import-environment > /dev/null 2>&1
      systemctl --user start user-login.target > /dev/null 2>&1 &
  fi

  # less colors (systemd can't import these) {{{
  export LESS_TERMCAP_mb=$'\E[1;31m'     # begin bold
  export LESS_TERMCAP_md=$'\E[1;36m'     # begin blink
  export LESS_TERMCAP_me=$'\E[0m'        # reset bold/blink
  export LESS_TERMCAP_so=$'\E[01;44;33m' # begin reverse video
  export LESS_TERMCAP_se=$'\E[0m'        # reset reverse video
  export LESS_TERMCAP_us=$'\E[1;32m'     # begin underline
  export LESS_TERMCAP_ue=$'\E[0m'        # reset underline
  export GROFF_NO_SGR=1                  # for konsole and gnome-terminal
  # }}}

  # vi: foldmethod=marker

#+end_src
* Programming languages
** R
#+begin_src R :tangle ~/.Rprofile
  options(repos = c(CRAN = "https://cran.rstudio.com"))
#+end_src

** Guile
Just activate readline.

#+begin_src scheme :tangle ~/.guile
  (use-modules (ice-9 readline))
  (activate-readline)
#+end_src

** Python
Run =ipython= with some defaults.

#+begin_src python :tangle ~/.ipython/profile_default/ipython_config.py
  c.TerminalInteractiveShell.editing_mode = 'vi'
  c.InteractiveShellApp.exec_lines = ['import os, sys, itertools, math\n']
#+end_src

** Javascript
Install global packages to user-local.

#+begin_src bash :tangle ~/.npmrc
prefix=${HOME}/.npm-packages
#+end_src

* X related
** .Xmodmap
This file contains some mappings for my keyboard. I can simply change how a key (or some simple key combinations) behave in  X level which  has little to none performance implications. Also see [[https://isamert.net/2020/05/30/better-keyboard-experience-in-linux.html][this post]] for further details.

#+begin_src xmodmap :tangle ~/.Xmodmap
!! Map CapsLock to Hyper key
!! Unmap capslock
clear Lock
keycode 66 = Hyper_L
!! Leave mod4 as windows key _only_
remove mod4 = Hyper_L

!! Set mod3 to capslock
add mod3 = Hyper_L

!! Fix my bluetooth keyboard:
!! My bluetooth keyboard does not have ESC key, in it's place
!! it has the Backwards key. So I'm simply rebinding it to ESC.
!! (Unfortunately XF86Backwards key gets overridden by ESC in my thinkpad)
keycode 166 = Escape NoSymbol Escape NoSymbol Escape Escape
keycode 166 = Escape
keycode 248 = Super_L

!! Quick access for some unicode chars
!! altgr + b → λ  | altgr + a → →
!! altgr + x → ❌ | altgr + f → ∀
!! altgr + n → ¬  | altgr + d → ⇒
!! altgr + , → ≤  | altgr + . → ≥
!! altgr + = → ≠  | altgr + shift + = → ≔
!! altgr + / → ÷  | altgr + ; → ∷
!! altgr + 8 → ×  | altgr + t -> ✓
keysym b = b B b B U03BB
keysym a = a A a A U2192
keysym x = x X x X U274C
keysym f = f F f F U2200
keysym n = n N n N U00AC
keysym d = d D d D U21D2
keysym t = t T t T U2713
keysym 8 = 8 asterisk 8 asterisk multiply
keysym comma = comma less comma less U2264
keysym period = period greater period greater U2265
keysym equal = equal plus equal plus U2260 U2254
keysym question = slash question slash question division
keysym semicolon = semicolon colon semicolon colon U2237

!! A comfy way to use h,j,k,l as directional keys.
!! With this configuration I'm able to use these keys as arrow key by simply pressing
!! them with AltGr.
keysym h = h H h H Left Home
keysym j = j J j J Down Prior
keysym k = k K k K Up Next
keysym l = l L l L Right End

!! AltGr+[ -> (, AltGr+] -> )
keysym bracketleft = bracketleft braceleft bracketleft braceleft parenleft
keysym bracketright = bracketright braceright bracketright braceright parenright

!! Fix us(intl)
!! I'm using us(intl) to be able to use ISO_Shift_Level3 as AltGr, other
!! keyboards does not permit usage of it AFAIK. But I don't want to use dead_*
!! keys. So I map them to their original bindings.
keysym dead_grave = grave asciitilde
keysym dead_acute = apostrophe quotedbl
#+end_src
** .Xresources
#+begin_src xmodmap :tangle ~/.Xresources
  #include ".Xresources.d/colors"
  #include ".Xresources.d/urxvt"
  #include ".Xresources.d/polybar"
  #include ".Xresources.d/rofi"

  wm.gaps: 0
  wm.border: 2
#+end_src
** .Xresources.d/colors
#+begin_src xmodmap :tangle ~/.Xresources.d/colors
! 0. Black           8.  Dark grey
! 1. Dark red        9.  Red
! 2. Dark green      10. Green
! 3. Dark yellow     11. Yellow
! 4. Dark blue       12. Blue
! 5. Dark magenta    13. Magenta
! 6. Dark cyan       14. Cyan
! 7. Light grey      15. White

#define BACKGROUND #282828
#define FOREGROUND #ebdbb2
#define COLOR0  #282828
#define COLOR8  #928374
#define COLOR1  #cc241d
#define COLOR9  #fb4934
#define COLOR2  #98971a
#define COLOR10 #b8bb26
#define COLOR3  #d79921
#define COLOR11 #fabd2f
#define COLOR4  #458588
#define COLOR12 #83a598
#define COLOR5  #b16286
#define COLOR13 #d3869b
#define COLOR6  #689d6a
#define COLOR14 #8ec07c
#define COLOR7  #a89984
#define COLOR15 #ebdbb2

*background: BACKGROUND
*foreground: FOREGROUND
*color0:  COLOR0
*color8:  COLOR8
*color1:  COLOR1
*color9:  COLOR9
*color2:  COLOR2
*color10: COLOR10
*color3:  COLOR3
*color11: COLOR11
*color4:  COLOR4
*color12: COLOR12
*color5:  COLOR5
*color13: COLOR13
*color6:  COLOR6
*color14: COLOR14
*color7:  COLOR7
*color15: COLOR15

! vi:syntax=xdefaults
#+end_src
** .Xresources.d/polybar
#+begin_src xmodmap :tangle ~/.Xresources.d/polybar
bar.font0: IBM Plex Sans:fontformat=truetype:size=10:antialias=true;0
bar.font1: Ubuntu Mono Nerd Font:fontformat=truetype:size=10:antialias=true;0
bar.font2: Liberation Sans:fontformat=truetype:size=10:antialias=false;0
bar.border: 0
bar.radius: 0
bar.height: 25
bar.width: 100%

! vi:syntax=xdefaults
#+end_src
** .Xresources.d/rofi
#+begin_src xmodmap :tangle ~/.Xresources.d/rofi
  rofi.auto-select: false
  rofi.drun-show-actions: true
  rofi.case-sensitive: false
  rofi.matching: normal

  rofi.theme: andrea
  ! rofi.lines: 15
  ! rofi.width: 70
  ! rofi.columns: 1
  ! rofi.font: Iosevka Black 12
  ! rofi.show-icons: true
  ! rofi.sidebar-mode: true
  ! rofi.separator-style: solid
  ! rofi.hide-scrollbar: true
  ! rofi.color-enabled: true
  ! rofi.fullscreen: false

  ! Keybindings
  rofi.kb-ellipsize:
  rofi.kb-mode-next: alt+period
  rofi.kb-mode-previous: alt+comma


  ! vi:syntax=xdefaults
#+end_src
** .xprofile
Start graphical services.
#+begin_src bash :tangle ~/.xprofile
  systemctl --user start user-graphical-login.target &
#+end_src
** Picom
#+begin_src conf :tangle ~/.config/picom.conf
# Performance etc. {{{
vsync = true
dbe = false;
sw-opti = false;
unredir-if-possible = true;

backend = "glx";
glx-no-stencil = true;
glx-no-rebind-pixmap = true;
glx-swap-methond = "exchange";
# }}}

# Shadows {{{
shadow = true;
shadow-offset-x = -8;
shadow-offset-y = -8;
shadow-opacity = 0.5;
shadow-radius = 5;
# }}}

# Exclude transparent stuff from using shadows {{{
shadow-exclude = [
    "class_g ?= 'st'",
    "class_g ?= 'rofi'",
    "class_g ?= 'slop'", # maim -s
    "class_g ?= 'firefox'"
];
# }}}

# Opacity {{{
active-opacity = 1;
inactive-opacity = 1;
inactive-dim = 0;
# }}}

# Fading {{{
fading = false;
fade-in-step = 0.03;
fade-out-step = 0.05;
fade-exclude = [ "name = 'i3lock'" ];
# }}}

# vi: foldmethod=marker
#+end_src
* Window management/DE
** BSPWM
This is my window manager.

#+begin_src bash :tangle ~/.config/bspwm/bspwmrc
  #!/bin/bash

  bspc config automatic_scheme longest_side
  bspc config initial_polarity second_child

  bspc config pointer_follows_focus false
  bspc config focus_follows_pointer true
  bspc config single_monocle        true
  bspc config gapless_monocle       false
  bspc config borderless_monocle    true
  bspc config window_gap            $(xrdb-get-value wm.gaps)
  bspc config border_width          $(xrdb-get-value wm.border)
  bspc config split_ratio           0.52


  TOP_GAP=$(($(xrdb-get-value bar.height) + $(xrdb-get-value bar.border)))
  SCREEN_WIDTH=$(bspwmc focused_monitor_width)
  SCREEN_HEIGHT=$(bspwmc focused_monitor_height)
  bspc rule --add '*:float'     state=floating
  bspc rule --add '*:tophalf'\
       state=floating\
       sticky=on\
       border=off\
       rectangle=${SCREEN_WIDTH}x$((SCREEN_HEIGHT / 2))+0+${TOP_GAP}

  # TODO: generalize this
  bspc rule --add 'Crow Translate' state=floating rectangle=$((SCREEN_WIDTH / 3 + 100))x400+$((SCREEN_WIDTH / 2 - (SCREEN_WIDTH / 3 + 100) / 2 ))+${TOP_GAP}

  bspc rule --add Pinta            state=floating
  bspc rule --add Sxiv             state=floating
  bspc rule --add Zenity           state=floating
  bspc rule --add feh              state=floating
  bspc rule --add copyq            state=floating border=off
  bspc rule --add 'whatsapp-nativefier-d52542' state=floating

  bspc rule --add mpv           state=floating
  bspc rule --add 'mpv:youtube' focus=off

  bspc rule --add Screenkey     manage=off
  bspc rule --add 'dota2'       border=off


  bspc rule -a Vivaldi-stable desktop='^1' follow=on
  bspc rule -a firefox        desktop='^1' follow=on


  # Start WM related stuff
  pgrep picom || picom &
  pgrep sxhkd || sxhkd &
  init-desktops &
#+end_src
** Polybar
#+begin_src conf :tangle ~/.config/polybar/config
  [colors]
  background = ${xrdb:background}
  background-alt = ${xrdb:background}
  foreground = ${xrdb:foreground}
  foreground-alt = ${xrdb:color7}
  primary = ${xrdb:color3}
  secondary = ${xrdb:color4}
  alert = ${xrdb:color1}

  [bar/main]
  monitor = ${env:MONITOR_MAIN}
  width = ${xrdb:bar.width}
  height = ${xrdb:bar.height}
  radius = ${xrdb:bar.radius}
  fixed-center = true
  wm-restack = bspwm

  background = ${colors.background}
  foreground = ${colors.foreground}

  font-0 = ${xrdb:bar.font0}
  font-1 = ${xrdb:bar.font1}
  font-2 = ${xrdb:bar.font2}

  border-size = ${xrdb:bar.border}
  border-color = #00000000

  line-size = 3
  line-color = #f00

  module-margin = 0
  format-padding = 0
  padding-left = 0
  padding-right = 2
  module-margin-left = 0
  module-margin-right = 1

  modules-left = bspwm xwindow
  modules-center = mpd
  modules-right = pacman optimus xkeyboard volume memory cpu temperature battery date powermenu

  tray-position = right
  tray-padding = 2

  scroll-up = bspwm-wsnext
  scroll-down = bspwm-wsprev

  cursor-click = pointer
  cursor-scroll = ns-resize

  [bar/secondary]
  monitor = ${env:MONITOR_SECONDARY}
  width = ${xrdb:bar.width}
  height = ${xrdb:bar.height}
  radius = ${xrdb:bar.radius}
  fixed-center = true
  wm-restack = bspwm

  background = ${colors.background}
  foreground = ${colors.foreground}

  font-0 = ${xrdb:bar.font0}
  font-1 = ${xrdb:bar.font1}
  font-2 = ${xrdb:bar.font2}

  border-size = ${xrdb:bar.border}
  border-color = #00000000

  line-size = 3
  line-color = #f00

  padding-left = 0
  padding-right = 2

  module-margin-left = 1
  module-margin-right = 2

  modules-left = bspwm xwindowlong
  modules-right = xbacklight

  scroll-up = bspwm-wsnext
  scroll-down = bspwm-wsprev

  cursor-click = pointer
  cursor-scroll = ns-resize

  [module/mail]
  type = custom/script
  exec = PYTHONWARNINGS="ignore" mailcheck --user 'isamertgurbuz@gmail.com' --password $(getpassword '/email/gmail') --server 'imap.gmail.com' --user isamert --password $(getpassword '/email/protonmail') --server proton
  interval = 300

  click-left = popup mail

  format-prefix = " "
  format-underline = ${xrdb:color1}

  [module/optimus]
  type = custom/script
  exec-if = systemctl is-active --quiet optimus-manager
  exec = optimus-manager --print-mode | grep GPU | cut -d: -f2 | tr -d ' ' | sed 's/.*/\u&/'
  interval = 30000000

  format-prefix = " "
  format-underline = ${xrdb:color2}

  [module/pacman]
  type = custom/script
  exec = pacman -Sup | wc -l
  interval = 3600

  format-prefix = " "
  format-underline = ${xrdb:color3}

  [module/github]
  type = internal/github
  token = ${env:GITHUB_ACCESS_TOKEN}
  empty-notifications = false
  interval = 1800

  [module/xbacklight]
  type = internal/xbacklight
  enable-scroll = true

  label = %percentage%%
  format = <ramp> <label>

  ramp-0 = 
  ramp-1 = 
  ramp-2 = 
  ramp-3 = 
  ramp-4 = 

  format-underline = ${xrdb:color4}

  [module/xwindow]
  type = internal/xwindow
  label = %title:0:30:...%

  [module/xwindowlong]
  type = internal/xwindow
  label = %title:0:150:...%

  [module/xkeyboard]
  type = internal/xkeyboard
  blacklist-0 = num lock

  format-prefix = " "
  format-prefix-foreground = ${colors.foreground-alt}
  format-prefix-underline = ${xrdb:color5}

  label-layout = %layout%
  label-layout-underline = ${xrdb:color5}

  label-indicator-padding = 2
  label-indicator-margin = 1
  label-indicator-background = ${xrdb:color5}
  label-indicator-underline = ${xrdb:color5}

  [module/bspwm]
  type = internal/bspwm

  label-focused = %index%
  label-focused-background = ${colors.background-alt}
  label-focused-underline= ${colors.primary}
  label-focused-padding = 2

  label-occupied = %index%
  label-occupied-padding = 2

  label-urgent = %index%!
  label-urgent-background = ${colors.alert}
  label-urgent-padding = 2

  label-empty =
  label-empty-foreground = ${colors.foreground-alt}
  label-empty-padding = 0

  [module/mpd]
  type = internal/mpd

  format-online = %{A1:popup music &:} <icon-prev> <icon-stop>   <label-song>   <toggle> <icon-next> %{A}

  icon-prev = 
  icon-stop = 
  icon-play = 
  icon-pause = 
  icon-next = 

  label-song-maxlen = 100
  label-song-ellipsis = true

  [module/cpu]
  type = internal/cpu
  interval = 2
  format-prefix = " "
  format-prefix-foreground = ${colors.foreground-alt}
  format-underline = ${xrdb:color6}
  label = %percentage:2%%

  [module/memory]
  type = internal/memory
  interval = 2
  format-prefix = " "
  format-prefix-foreground = ${colors.foreground-alt}
  format-underline = ${xrdb:color7}
  label = %{A1:popup htop &:} %percentage_used%% %{A}

  [module/eth]
  type = internal/network
  interface = enp5s0
  interval = 3.0

  format-connected-underline = ${xrdb:color8}
  format-connected-prefix = ""
  format-connected-prefix-foreground = ${colors.foreground-alt}
  label-connected = %local_ip%

  [module/date]
  type = internal/date
  interval = 20

  date = " %d-%m"
  time = %H:%M

  format-underline = ${xrdb:color13}
  label = %{A1:popup calendar&:}  %date%   %time% %{A}

  [module/volume]
  type = internal/volume

  format-volume = <ramp-volume> <label-volume>
  label-volume = %percentage%%

  format-muted-prefix = " "
  format-muted-foreground = ${colors.foreground-alt}
  label-muted-foreground = #66

  ramp-volume-0 =
  ramp-volume-1 =墳
  ramp-volume-2 =

  format-volume-underline = ${xrdb:color10}
  format-muted-underline = ${xrdb:color10}

  [module/battery]
  type = internal/battery
  battery = BAT0
  adapter = AC0
  full-at = 95

  format-full =

  format-charging = <animation-charging> <label-charging>
  format-charging-underline = ${xrdb:color11}

  format-discharging = <ramp-capacity> <label-discharging>
  format-discharging-underline = ${self.format-charging-underline}

  ramp-capacity-0 = 
  ramp-capacity-1 = 
  ramp-capacity-2 = 
  ramp-capacity-foreground = ${colors.foreground-alt}

  animation-charging-0 = 
  animation-charging-1 = 
  animation-charging-2 = 
  animation-charging-foreground = ${colors.foreground-alt}
  animation-charging-framerate = 750

  [module/temperature]
  type = internal/temperature
  thermal-zone = 0
  warn-temperature = 60

  format = <ramp> <label>
  format-underline = ${xrdb:color12}
  format-warn = <ramp> <label-warn>
  format-warn-underline = ${self.format-underline}

  label = %temperature-c%
  label-warn = %temperature-c%
  label-warn-foreground = ${colors.secondary}

  ramp-2 = 
  ramp-1 = 
  ramp-0 = 
  ramp-foreground = ${colors.foreground-alt}

  [module/powermenu]
  type = custom/menu

  expand-right = true

  format-spacing = 1

  label-open = ⏻
  label-open-foreground = ${colors.secondary}
  label-close =  cancel
  label-close-foreground = ${colors.secondary}
  label-separator = |
  label-separator-foreground = ${colors.foreground-alt}

  menu-0-0 = reboot
  menu-0-0-exec = menu-open-1
  menu-0-1 = power off
  menu-0-1-exec = menu-open-2

  menu-1-0 = cancel
  menu-1-0-exec = menu-open-0
  menu-1-1 = reboot
  menu-1-1-exec = reboot

  menu-2-0 = power off
  menu-2-0-exec = poweroff
  menu-2-1 = cancel
  menu-2-1-exec = menu-open-0

  [settings]
  screenchange-reload = true
  ;compositing-background = xor
  ;compositing-background = screen
  ;compositing-foreground = source
  ;compositing-border = over

  ; vim:ft=dosini
#+end_src
** sxhkd
#+begin_src conf :tangle ~/.config/sxhkd/sxhkdrc
  # #############################################################################
  # bspwm
  # #############################################################################

  # focus/swap with left/down/up/right window
  super + {_,shift + } {h,j,k,l}
      {bspwmc focus, euclid_mover} {west,south,north,east}

  # split
  super + {_,shift + } {backslash,minus}
      bspc node -p {east,west,south,north}

  # set the window state
  super + {t,shift + t,s,f}
      bspc node --state "~{tiled,pseudo_tiled,floating,fullscreen}"

  # toggle between fullscreen(monacle) and tiled desktop layout
  super + m
      bspc desktop --layout next

  # focus last floating window
  super + shift + f
      bspwmc focus_toggle_floating

  # close window
  super + w
      bspc node --close

  # kill window
  super + shift + w
      bspc  node -k

  # Make window sticky
  super + i
      bspc node -g sticky

  # next/prev desktop
  super + {comma,period}
      bspc desktop --focus {prev,next}.local.occupied

  # focus/move to the given desktop on current monitor
  super + {_,shift + }{1-5}
      bspc {desktop --focus, node --to-desktop} $(bspc query -D -m | sed -n "{1-5}p")

  # focus the last node
  super + Tab
      bspc node --focus last

  # focus next/prev monitor
  super + {comma, period}
      bspc monitor {prev, next} --focus

  # move current window to next/prev monitor
  super + shift + {comma, period}
      bspc node --to-desktop $(bspc query -D -m {prev, next} -d .active | sed -n "1p")

  # move current window to Nth monitor
  # (no, I don't have 5 monitors but just in case. hehe)
  super + alt + {1-5}
      bspc node --to-desktop $(bspc query -D -m (bspc query -M | sed -n "{1-5}p") -d .active)

  # focus next/prev window
  alt + {_, shift +} Tab
      bspc node -f {next,prev}.local

  # change gap size
  super {_, shift +} g
      bspc config window_gap $(expr $(bspc config window_gap) {-,+} 3)

  # resize windows
  super + alt + {j,l,k,h}
      bspwmc resize {h, w} {+50, -50}

  # center focused floating window
  super + C
      bspwmc center_floating true

  # move floating window to corners
  super + shift + {Q,W,A,S}
      bspwmc move_floating {Q,W,A,S}

  # resize a floating window from all sides
  super + {shift,_} + equal
      xdo resize {-w +50 -h +50, -w -50 -h -50}

  # switch to next card (nvidia/intel)
  super + shift + m
      if [[ $(optimus-manager --print-mode | grep -iE '(intel|nvidia)') == *'intel' ]]; then; optimus-manager --no-confirm --switch nvidia; else; optimus-manager --no-confirm --switch nvidia; fi

  # logout
  super + shift + e
      for node in $(bspc query -N); do bspc node $node --close; done; bspc quit

  # rotate window tree
  super + {r, shift + r}
      bspc node @/ -C {forward,backward}

  super + o
      bspwmc toggle_inactive_opacity

  # #############################################################################
  # apps
  # #############################################################################

  # open a terminal (with shift it floats, with ctrl its opaque, with ctrl + shift its floating opaque)
  {super, hyper} + {_, shift + ctrl +, shift +, ctrl +} Return
      term {_,_} {_, --float --opaque --geometry=100x20, --float --geometry=100x20, --opaque}

  # open a terminal at
  hyper + {_,shift + } {backslash,minus}
      bspc node -p {east,west,south,north}; \
      term

  hyper + {e, d}
      bspwmc {scratchpad_top, scratchpad_bot}

  hyper + q
      copyq toggle

  hyper + x
      /bin/sh -c "term --float --geometry=150x20 -e fuzzy kill"

  hyper + equal
      menu calc

  # run some apps directly
  hyper + r; {f, q, e, r, t, v, w, k}
      focus-or-run {firefox, qutebrowser, emacsclient -c, jaro ~, lxtask, vivaldi-stable, whatsapp-nativefier-dark, /bin/sh -c "getpassword --keepass | keepassxc --pw-stdin $PASSWORD_STORE"}

  hyper + r; p; {s, p, w}
      pqiv {~/Pictures/screenshots/, ~/Pictures/phone/Camera, ~/Pictures/wallpapers/}

  # menus (an escape hatch if hyper key does not work for some reason)
  super + a
      menu menu

  hyper + {a, f, F, m, M, P, o, y, Y, b}
      menu {menu,files --open,file_contents,mpd-artists,mpd-all,mpd-playlist,passwords,youtube --video,youtube --video --playlist=$YT_MAIN_PLAYLIST, bookmarks}

  # popups
  hyper + {c,n,t,i}
      popup {calendar,music,translate,mail}

  # random wallpaper
  hyper + apostrophe
      feh --bg-scale $(find "$DIR_WALLPAPERS" | shuf -n 1)

  # screenshot
  {Print, hyper + s, shift + Print, control + Print, control + shift + Print}
      take-ss --{full,clip-area,area,wait-full,wait-area}

  hyper + S
      take-ss --edit-area

  hyper + alt + s
      if cb-save ~/cb.png; then notify-send "Saved."; else; notify-send "Not saved."; fi

  # toggle notification center
  hyper + N
      kill -s USR1 $(pidof deadd-notification-center)

  # #############################################################################
  # sound/music
  # #############################################################################

  # volume down/up
  hyper + {9,0}
      amixer set Master 5%{-,+}

  # volume down/up
  XF86Audio{Lower,Raise}Volume
      amixer set Master 5%{-,+}

  # audio/mic toggle
  XF86Audio{_,Mic}Mute
      amixer set {Master,Capture} toggle

  # toggle music
  {hyper + p, XF86AudioPlay}
      mediastuff all_toggle

  # seek song
  hyper + {bracketleft, bracketright}
      mediastuff all_seek {-,+}3%

  # next/prev song
  hyper + shift + {bracketleft, bracketright}
      mpc {prev,next}

  # next/prev song
  XF86Audio{Prev,Next}
      mpc {prev,next}

  # #############################################################################
  # various
  # #############################################################################

  control + alt + k
      switch-keyboard-layout

  control + alt + o
      mediastuff switch-audio-channel --interactive

  control + alt + l
      lockscreen
#+end_src
** Rofi theme
#+begin_src js :tangle ~/.config/rofi/andrea.rasi
  configuration {
      /* modi: "drun,window,windowcd"; */
      /* width: 50; */
      /* font: "Inter Regular 14"; */
      /* bw: 10; */
      /* padding: 10; */
      /* yoffset: -100; */
      /* xoffset: 0; */
      fixed-num-lines: true;
      show-icons: true;
      icon-theme: "deepin";
      /* drun-match-fields: "name,generic,exec,categories"; */
      /* drun-show-actions: false; */
      /* drun-display-format: "{icon} {name}"; */
      /* disable-history: false; */
      /* ignored-prefixes: ""; */
      /* sort: false; */
      /* sorting-method: ; */
      /* case-sensitive: false; */
      /* cycle: true; */
      /* sidebar-mode: false; */
      /* eh: 1; */
      /* auto-select: false; */
      /* parse-hosts: false; */
      /* parse-known-hosts: true; */
      /* combi-modi: "drun,window,windowcd"; */
      /* matching: "normal"; */
      /* tokenize: true; */
      /* m: "-5"; */
      /* line-margin: 2; */
      /* line-padding: 1; */
      /* filter:; */
      /* separator-style: "dash"; */
      /* hide-scrollbar: false; */
      fullscreen: true;
      /* fake-transparency: false; */
      /* dpi: -1; */
      /* threads: 0; */
      /* scrollbar-width: 8; */
      /* scroll-method: 0; */
      /* fake-background: "screenshot"; */
      window-format: "{w}\t{t}";
      /* click-to-exit: true; */
      /* show-match: true; */
      /* theme: ; */
      /* color-normal: ; */
      /* color-urgent: ; */
      /* color-active: ; */
      /* color-window: ; */
      /* max-history-size: 25; */
      /* combi-hide-mode-prefix: false; */
      /* matching-negate-char: '-'; */
      /* cache-dir: ; */
      /* pid: "/run/user / 1000/rofi.pid"; */
      display-window: "  ";
      display-windowcd: "  ";
      /* display-run: ; */
      /* display-ssh: ; */
      display-drun: "  ";
      /* display-combi: ; */
      /* display-keys: ; */
      /* kb-primary-paste: "Control+V,Shift+Insert"; */
      /* kb-secondary-paste: "Control+v,Insert"; */
      /* kb-clear-line: "Control+w"; */
      /* kb-move-front: "Control+a"; */
      /* kb-move-end: "Control+e"; */
      /* kb-move-word-back: "Alt+b,Control+Left"; */
      /* kb-move-word-forward: "Alt+f,Control+Right"; */
      /* kb-move-char-back: "Left,Control+b"; */
      /* kb-move-char-forward: "Right,Control+f"; */
      /* kb-remove-word-back: "Control+Alt+h,Control+BackSpace"; */
      /* kb-remove-word-forward: "Control+Alt+d"; */
      /* kb-remove-char-forward: "Delete,Control+d"; */
      /* kb-remove-char-back: "BackSpace,Shift+BackSpace,Control+h"; */
      /* kb-remove-to-eol: "Control+k"; */
      /* kb-remove-to-sol: "Control+u"; */
      /* kb-accept-entry: "Control+j,Control+m,Return,KP_Enter"; */
      /* kb-accept-custom: "Control+Return"; */
      /* kb-accept-alt: "Shift+Return"; */
      /* kb-delete-entry: "Shift+Delete"; */
      /* kb-mode-next: "Shift+Right,Control+Tab"; */
      /* kb-mode-previous: "Shift+Left,Control+ISO_Left_Tab"; */
      /* kb-row-left: "Control+Page_Up"; */
      /* kb-row-right: "Control+Page_Down"; */
      /* kb-row-up: "Up,Control+p,ISO_Left_Tab"; */
      /* kb-row-down: "Down,Control+n"; */
      /* kb-row-tab: "Tab"; */
      /* kb-page-prev: "Page_Up"; */
      /* kb-page-next: "Page_Down"; */
      /* kb-row-first: "Home,KP_Home"; */
      /* kb-row-last: "End,KP_End"; */
      /* kb-row-select: "Control+space"; */
      /* kb-screenshot: "Alt+S"; */
      /* kb-ellipsize: "Alt+period"; */
      /* kb-toggle-case-sensitivity: "grave,dead_grave"; */
      /* kb-toggle-sort: "Alt+grave"; */
      /* kb-cancel: "Escape,Control+g,Control+bracketleft"; */
      /* kb-custom-1: "Alt + 1"; */
      /* kb-custom-2: "Alt + 2"; */
      /* kb-custom-3: "Alt + 3"; */
      /* kb-custom-4: "Alt + 4"; */
      /* kb-custom-5: "Alt + 5"; */
      /* kb-custom-6: "Alt + 6"; */
      /* kb-custom-7: "Alt + 7"; */
      /* kb-custom-8: "Alt + 8"; */
      /* kb-custom-9: "Alt + 9"; */
      /* kb-custom-10: "Alt + 0"; */
      /* kb-custom-11: "Alt+exclam"; */
      /* kb-custom-12: "Alt+at"; */
      /* kb-custom-13: "Alt+numbersign"; */
      /* kb-custom-14: "Alt+dollar"; */
      /* kb-custom-15: "Alt+percent"; */
      /* kb-custom-16: "Alt+dead_circumflex"; */
      /* kb-custom-17: "Alt+ampersand"; */
      /* kb-custom-18: "Alt+asterisk"; */
      /* kb-custom-19: "Alt+parenleft"; */
      /* kb-select-1: "Super + 1"; */
      /* kb-select-2: "Super + 2"; */
      /* kb-select-3: "Super + 3"; */
      /* kb-select-4: "Super + 4"; */
      /* kb-select-5: "Super + 5"; */
      /* kb-select-6: "Super + 6"; */
      /* kb-select-7: "Super + 7"; */
      /* kb-select-8: "Super + 8"; */
      /* kb-select-9: "Super + 9"; */
      /* kb-select-10: "Super + 0"; */
      /* ml-row-left: "ScrollLeft"; */
      /* ml-row-right: "ScrollRight"; */
      /* ml-row-up: "ScrollUp"; */
      /* ml-row-down: "ScrollDown"; */
      /* me-select-entry: "MousePrimary"; */
      /* me-accept-entry: "MouseDPrimary"; */
      /* me-accept-custom: "Control+MouseDPrimary"; */
  }

  ,* {
      background-color: transparent;
      color: white;
  }

  window {
      padding: 100px 400px;
      //border: 1px;
      //border-color: rgba(255, 255, 255, 0.1);
      y-offset: -200px;
      //height: 300px;
      background-color: rgba(2, 4, 8, 0.9);
  }

  inputbar {
      padding: 10px 10px 10px 20px;
      border-radius: 99px;
      margin: 0 0 30px 0;
      background-color: rgba(255, 255, 255, 0.1);
      border: 1px;
      border-color: rgba(255, 255, 255, 0.2);
  }

  prompt {
      margin: 2px 4px 0 0;
      font: "Font Awesome 5 Free 10";
  }

  element {
      border-radius: 2px;
      padding: 4px 8px;
  }

  element.selected {
      background-color: rgba(255, 255, 255, 0.1);
  }
#+end_src
* Alacritty terminal
#+begin_src yaml :tangle ~/.config/alacritty.yml
  window:
    dynamic_title: true

  font:
    normal:
      family: Iosevka
    size: 11.0


  draw_bold_text_with_bright_colors: true
  live_config_reload: true
  background_opacity: 0.8

  shell:
    program: /usr/bin/zsh

  mouse:
    url:
      launcher:
        program: jaro

  # Colors (Gruvbox dark)
  colors:
    # Default colors
    primary:
      # hard contrast: background = '#1d2021'
      background: '#282828'
      # soft contrast: background = '#32302f'
      foreground: '#ebdbb2'

    # Normal colors
    normal:
      black:   '#282828'
      red:     '#cc241d'
      green:   '#98971a'
      yellow:  '#d79921'
      blue:    '#458588'
      magenta: '#b16286'
      cyan:    '#689d6a'
      white:   '#a89984'

    # Bright colors
    bright:
      black:   '#928374'
      red:     '#fb4934'
      green:   '#b8bb26'
      yellow:  '#fabd2f'
      blue:    '#83a598'
      magenta: '#d3869b'
      cyan:    '#8ec07c'
      white:   '#ebdbb2'


  key_bindings:
    - { key: U,  mods: Shift|Control,   mode: ~Alt, action: ScrollPageUp,  }
    - { key: D,  mods: Shift|Control,   mode: ~Alt, action: ScrollPageDown }

    # Vi mode
    - { key: A,                           mode: Vi, action: ToggleViMode            }

    #
    #- { key: Paste,                                action: Paste          }
    #- { key: Copy,                                 action: Copy           }
    #- { key: L,         mods: Control,             action: ClearLogNotice }
    #- { key: L,         mods: Control, mode: ~Vi,  chars: "\x0c"          }
    #- { key: PageUp,    mods: Shift,   mode: ~Alt, action: ScrollPageUp,  }
    #- { key: PageDown,  mods: Shift,   mode: ~Alt, action: ScrollPageDown }
    #- { key: Home,      mods: Shift,   mode: ~Alt, action: ScrollToTop,   }
    #- { key: End,       mods: Shift,   mode: ~Alt, action: ScrollToBottom }
    #

    # Vi Mode
    #- { key: Space,  mods: Shift|Control, mode: Vi, action: ScrollToBottom          }
    #- { key: Space,  mods: Shift|Control,           action: ToggleViMode            }
    #- { key: Escape,                      mode: Vi, action: ClearSelection          }
    #- { key: I,                           mode: Vi, action: ScrollToBottom          }
    #- { key: I,                           mode: Vi, action: ToggleViMode            }
    #- { key: Y,      mods: Control,       mode: Vi, action: ScrollLineUp            }
    #- { key: E,      mods: Control,       mode: Vi, action: ScrollLineDown          }
    #- { key: G,                           mode: Vi, action: ScrollToTop             }
    #- { key: G,      mods: Shift,         mode: Vi, action: ScrollToBottom          }
    #- { key: B,      mods: Control,       mode: Vi, action: ScrollPageUp            }
    #- { key: F,      mods: Control,       mode: Vi, action: ScrollPageDown          }
    #- { key: U,      mods: Control,       mode: Vi, action: ScrollHalfPageUp        }
    #- { key: D,      mods: Control,       mode: Vi, action: ScrollHalfPageDown      }
    #- { key: Y,                           mode: Vi, action: Copy                    }
    #- { key: Y,                           mode: Vi, action: ClearSelection          }
    #- { key: Copy,                        mode: Vi, action: ClearSelection          }
    #- { key: V,                           mode: Vi, action: ToggleNormalSelection   }
    #- { key: V,      mods: Shift,         mode: Vi, action: ToggleLineSelection     }
    #- { key: V,      mods: Control,       mode: Vi, action: ToggleBlockSelection    }
    #- { key: V,      mods: Alt,           mode: Vi, action: ToggleSemanticSelection }
    #- { key: Return,                      mode: Vi, action: Open                    }
    #- { key: K,                           mode: Vi, action: Up                      }
    #- { key: J,                           mode: Vi, action: Down                    }
    #- { key: H,                           mode: Vi, action: Left                    }
    #- { key: L,                           mode: Vi, action: Right                   }
    #- { key: Up,                          mode: Vi, action: Up                      }
    #- { key: Down,                        mode: Vi, action: Down                    }
    #- { key: Left,                        mode: Vi, action: Left                    }
    #- { key: Right,                       mode: Vi, action: Right                   }
    #- { key: Key0,                        mode: Vi, action: First                   }
    #- { key: Key4,   mods: Shift,         mode: Vi, action: Last                    }
    #- { key: Key6,   mods: Shift,         mode: Vi, action: FirstOccupied           }
    #- { key: H,      mods: Shift,         mode: Vi, action: High                    }
    #- { key: M,      mods: Shift,         mode: Vi, action: Middle                  }
    #- { key: L,      mods: Shift,         mode: Vi, action: Low                     }
    #- { key: B,                           mode: Vi, action: SemanticLeft            }
    #- { key: W,                           mode: Vi, action: SemanticRight           }
    #- { key: E,                           mode: Vi, action: SemanticRightEnd        }
    #- { key: B,      mods: Shift,         mode: Vi, action: WordLeft                }
    #- { key: W,      mods: Shift,         mode: Vi, action: WordRight               }
    #- { key: E,      mods: Shift,         mode: Vi, action: WordRightEnd            }
    #- { key: Key5,   mods: Shift,         mode: Vi, action: Bracket                 }

    # (Windows, Linux, and BSD only)
    #- { key: V,        mods: Control|Shift,           action: Paste            }
    #- { key: C,        mods: Control|Shift,           action: Copy             }
    #- { key: C,        mods: Control|Shift, mode: Vi, action: ClearSelection   }
    #- { key: Insert,   mods: Shift,                   action: PasteSelection   }
    #- { key: Key0,     mods: Control,                 action: ResetFontSize    }
    #- { key: Equals,   mods: Control,                 action: IncreaseFontSize }
    #- { key: Add,      mods: Control,                 action: IncreaseFontSize }
    #- { key: Subtract, mods: Control,                 action: DecreaseFontSize }
    #- { key: Minus,    mods: Control,                 action: DecreaseFontSize }

#+end_src

* Shells
** Aliases
This file is sourced by both =zsh= and =bash= (also =eshell= but I don't really use it).

#+begin_src bash :tangle ~/.config/aliases
# NOTE:  Do not use alias xxx='...', use ". (For eshell converting script)

# package management
alias aur="$AUR_HELPER"
alias aurin="$AUR_HELPER -S"
alias aurs="$AUR_HELPER -Ss"
alias aurupg="$AUR_HELPER -Syu"
alias pac="sudo pacman"
alias pacs="pacman -Ss"
alias pacin="sudo pacman -S"
alias pacinf="fuzzy pacman"
alias pacf="fuzzy pacman"
alias pacins="sudo pacman -U"    # Install from file
alias pacupd="sudo pacman -Sy"
alias pacupg="sudo pacman -Syu"
alias pacfile="pacman -Fs"       # Find package that contains given file
alias pacbin="pacman -Fs"        # Same as above
alias pacre="sudo pacman -R"     # Leave dependencies and configurations
alias pacrem="sudo pacman -Rns"
alias pacpac="fuzzy packages"    # A fuzzy, interactive package finder

# process management
alias nameof="ps -o comm= -p" # Get the name of given PID
alias fuckall="killall -s 9"
alias fkill="fuzzy kill"

# utility
alias mktar="tar -cvf"
alias mkbz2="tar -cvjf"
alias mkgz="tar -cvzf"
alias ...="cd ../.."
alias ....="cd ../../.."
alias .....="cd ../../../.."
alias df="df -H"
alias du="ncdu"
alias xpaste="xclip -selection clipboard -o" # paste cb content
alias fastssh="ssh -Y -C -c chacha20-poly1305@openssh.com"

#alias ls="
#alias lls="ls -lthG --color --group-directories-first"
alias ls="lsd --group-dirs first --classify"
alias ll="lsd --group-dirs first --classify --oneline"
alias lls="lsd --group-dirs first --classify --long"
alias lla="lsd --group-dirs first --classify --long --all"
alias tree="lsd --tree"

# abbrv
alias n="nvim"
alias v="jaro --method=view"
alias e="jaro --method=edit"
alias mt="jaro --mime-type"
alias how="howdoi --color --all"
alias mkx="chmod +x"
alias yt="youtube-viewer --player=mpv"
alias ytm="youtube-viewer --player=mpv --no-video"

alias ctl="systemctl "
alias ctlu="systemctl --user"
alias ctls="systemctl status"
alias ctlus="systemctl --user status"
alias ctle="systemctl enable --now"
alias ctlue="systemctl --user enable"

# master Wq
alias :q="exit"
alias :wq="exit"

# git
alias g="git"
alias gs="git status"
alias ga="fuzzy git add"
alias gl="fuzzy git log"
alias gf="fuzzy git files"
alias gc="git commit -m"
alias gpm="git push origin master"

alias cfg="git --git-dir=$HOME/.dotfiles/ --work-tree=$HOME"
alias cfgc="git --git-dir=$HOME/.dotfiles/ --work-tree=$HOME commit -m"
alias cfgs="git --git-dir=$HOME/.dotfiles/ --work-tree=$HOME status"
alias cfgp="git --git-dir=$HOME/.dotfiles/ --work-tree=$HOME push origin master"
alias cfga="fuzzy git add --git-dir=$HOME/.dotfiles/ --work-tree=$HOME"
alias cfgl="fuzzy git log --git-dir=$HOME/.dotfiles/ --work-tree=$HOME"
alias cfgf="fuzzy git files --git-dir=$HOME/.dotfiles/ --work-tree=$HOME"
alias cfge='eval $EDITOR $(git --git-dir=$HOME/.dotfiles/ --work-tree=$HOME ls-files --full-name | fzf --preview "bat --color=always --style=header,numbers {}")'

# useful
alias clearvimswap="rm $HOME/.local/share/nvim/swap/*"
function is-emacs { [[ "$INSIDE_EMACS" = "vterm" ]]; }

# stuff
alias ipaddr="curl https://api.ipify.org"
alias ipinfo="curl https://ipinfo.io"
alias download-website="wget --recursive --page-requisites --html-extension
    --convert-links --no-parent --limit-rate=500K" # Download a website completely
alias git-todo="rg 'FIXME|TODO'"
alias git-todo-count="rg -c --color never 'FIXME|TODO' | cut -d: -f2 | paste -sd+ | bc"
#+end_src
** Zsh
*** Configuration
#+begin_src bash :tangle ~/.zshrc
  [[ $TERM == "dumb" ]] && unsetopt zle && PS1='$ ' && return

  # Plugins {{{
  source ~/.local/bin/antigen.zsh

  antigen use oh-my-zsh
  antigen bundle git
  antigen bundle zsh-users/zsh-autosuggestions
  antigen bundle zsh-users/zsh-syntax-highlighting
  antigen bundle zsh-users/zsh-history-substring-search
  antigen bundle zsh-users/zsh-completions
  antigen bundle kutsan/zsh-system-clipboard
  antigen theme agnoster
  antigen apply
  # }}}

  # history-substring-search settings {{{
  # bind UP and DOWN arrow keys to history substring search
  zmodload zsh/terminfo
  bindkey "$terminfo[kcuu1]" history-substring-search-up
  bindkey "$terminfo[kcud1]" history-substring-search-down
  bindkey -M vicmd 'k' history-substring-search-up
  bindkey -M vicmd 'j' history-substring-search-down
  # }}}

  # General settings {{{
  setopt autocd histignoredups appendhistory incappendhistory histreduceblanks

  zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}'       # Case insensitive tab completion
  zstyle ':completion:*' rehash true                              # automatically find new executables in path
  zstyle ':completion:*' accept-exact '*(N)'
  zstyle ':completion:*' use-cache on
  zstyle ':completion:*' cache-path ~/.zsh/cache

  HISTFILE=~/.zsh_history
  HISTSIZE=100000
  SAVEHIST=100000
  HISTORY_SUBSTRING_SEARCH_FUZZY=1

  bindkey -v                                                      # enable vi keybindings
  # }}}

  # Aliases {{{
  source ~/.config/aliases
  # }}}

  # Source some files {{{
  files=(
      /usr/share/fzf/key-bindings.zsh                              # fzf history search keybindings
      $HOME/.nix-profile/share/fzf/key-bindings.zsh                # fzf history search keybindings
  )

  for file in $files; do
      [[ -f "$file" ]] && source $file
  done
  # }}}

  # vterm integration (check out the file for more info) {{{
  is-emacs && source ~/.config/zsh/emacs.sh
  # }}}

  # Override agnoster themes prompt_dir {{{
  # https://github.com/sorin-ionescu/prezto/blob/master/modules/prompt/functions/prompt-pwd
  function prompt_dir {
      setopt localoptions extendedglob

      # FIXME: this breaks the input line completely
      # If we are in emacs vterm, send the current directory to emacs vterm
      # This establishes directory tracking
      # is-emacs && vterm_printf "51;A$(whoami)@$(hostname):$(pwd)";

      local current_pwd="${PWD/#$HOME/~}"
      local ret_directory

      if [[ "$current_pwd" == (#m)[/~] ]]; then
          ret_directory="$MATCH"
          unset MATCH
      elif zstyle -m ':prezto:module:prompt' pwd-length 'full'; then
          ret_directory=${PWD}
      elif zstyle -m ':prezto:module:prompt' pwd-length 'long'; then
          ret_directory=${current_pwd}
      else
          ret_directory="${${${${(@j:/:M)${(@s:/:)current_pwd}##.#?}:h}%/}//\%/%%}/${${current_pwd:t}//\%/%%}"
      fi

      unset current_pwd
      prompt_segment blue $CURRENT_FG "$ret_directory"
  }
  # }}}

  # Utility functions (functions I only use interactively) {{{
  function mkcd { mkdir -p "$1"; cd "$1"; } # Make and cd to the dir
  function cpcd { cp "$1" "$2" && cd "$2"; } # Copy and go to the directory
  function mvcd { mv "$1" "$2" && cd "$2"; } # Move and cd to the dir
  function cheat { curl http://cheat.sh/"$1"; }
  function shortenurl { curl -F"shorten=$1" "https://0x0.st"; }
  function uploadfile { curl -F"file=@$1" "https://0x0.st"; }
  # }}}

  # vi: foldmethod=marker
#+end_src

install.sh
*** Emacs config
#+begin_src bash :tangle ~/.config/zsh/emacs.sh
#!/bin/bash

# With this function we can send elisp commands while we are on emacs vterm
# for example, "elisp message hey" would send (message "hey") to emacs.
function elisp {
    if [[ -n "$TMUX" ]]; then
        # tell tmux to pass the escape sequences through
        # (Source: http://permalink.gmane.org/gmane.comp.terminal-emulators.tmux.user/1324)
        printf "\ePtmux;\e\e]51;E"
    elif [[ "${TERM%%-*}" = "screen" ]]; then
        # GNU screen (screen, screen-256color, screen-256color-bce)
        printf "\eP\e]51;E"
    else
        printf "\e]51;E"
    fi

    printf "\e]51;E"
    local r
    while [[ $# -gt 0 ]]; do
        r="${1//\\/\\\\}"
        r="${r//\"/\\\"}"
        printf '"%s" ' "$r"
        shift
    done

    if [[ -n "$TMUX" ]]; then
        # tell tmux to pass the escape sequences through
        # (Source: http://permalink.gmane.org/gmane.comp.terminal-emulators.tmux.user/1324)
        printf "\007\e\\"
    elif [[ "${TERM%%-*}" = "screen" ]]; then
        # GNU screen (screen, screen-256color, screen-256color-bce)
        printf "\007\e\\"
    else
        printf "\e\\"
    fi
}

# Helper for clearing screen
function vterm_printf {
    if [[ -n "$TMUX" ]]; then
        # tell tmux to pass the escape sequences through
        # (Source: http://permalink.gmane.org/gmane.comp.terminal-emulators.tmux.user/1324)
        printf "\ePtmux;\e\e]%s\007\e\\" "$1"
    elif [[ "${TERM%%-*}" = "screen" ]]; then
        # GNU screen (screen, screen-256color, screen-256color-bce)
        printf "\eP\e]%s\007\e\\" "$1"
    else
        printf "\e]%s\e\\" "$1"
    fi
}

# Rebind clear so that scrollback is also cleared on emacs vterm
alias clear='vterm_printf "51;Evterm-clear-scrollback";tput clear'
#+end_src
* Utilities
** .tmux.conf
#+begin_src conf :tangle ~/.tmux.conf
  # ####################################################
  #      __                                         ____
  #     / /_____ ___  __  ___  __ _________  ____  / __/
  #    / __/ __ `__ \/ / / / |/_// ___/ __ \/ __ \/ /_
  #  _/ /_/ / / / / / /_/ />  <_/ /__/ /_/ / / / / __/
  # (_)__/_/ /_/ /_/\__,_/_/|_(_)___/\____/_/ /_/_/
  # ####################################################

  # Add plugins (PREFIX I -> install them)
  set -g @plugin 'tmux-plugins/tpm'
  set -g @plugin 'tmux-plugins/tmux-resurrect'        # PREFIX C-s -> save, PREFIX C-r -> restore
  set -g @plugin 'tmux-plugins/tmux-prefix-highlight' # Highlight when prefix is pressed, in copy mode etc.

  # tmux-prefix-highlight settings (Show indicator when in copy mode, and Sync for synchronized panes)
  set -g @prefix_highlight_show_copy_mode 'on'
  set -g @prefix_highlight_copy_mode_attr 'fg=white,bg=yellow,bold' # default is 'fg=default,bg=yellow'
  set -g @prefix_highlight_show_sync_mode 'on'
  set -g @prefix_highlight_sync_mode_attr 'fg=black,bg=green' # default is 'fg=default,bg=yellow'

  # St stuff
  set -g default-terminal "st-256color"
  set -g terminal-overrides ',st-256color:Tc'

  set -g default-shell $PREFIX/bin/zsh
  set -g mouse on
  set -g base-index 1 # Window indexes starts from 1
  setw -g pane-base-index 1 # Pane indexes starts from 1
  set -s escape-time 0 # Remove the delay after hitting <ESC>
  set-option -g set-titles off
  set-window-option -g automatic-rename on

  # Reload config
  bind r source-file ~/.tmux.conf

  # Set prefix to A-a
  unbind C-b
  set -g prefix M-a
  bind-key M-a send-prefix

  # Increase the time of display-panes (PREFIX q)
  set -g display-panes-time 4000

  # Split remaps
  bind \\ split-window -h -c '#{pane_current_path}'
  bind - split-window -v -c '#{pane_current_path}'
  unbind '"'
  unbind %

  # Vim-like pane switches
  bind k selectp -U
  bind j selectp -D
  bind h selectp -L
  bind l selectp -R

  # Pane switches (without prefix key)
  bind -n M-h select-pane -L
  bind -n M-j select-pane -D
  bind -n M-k select-pane -U
  bind -n M-l select-pane -R
  bind -n M-\\ split-window -h -c '#{pane_current_path}'
  bind -n M--  split-window -v -c '#{pane_current_path}'

  # Swapping shortcuts
  bind-key W choose-tree -Zw "swap-window -t '%%'"
  bind-key P choose-tree -Zw "swap-pane -t '%%'"

  # Vi keys for copy-mode
  setw -g mode-keys vi
  bind-key -T copy-mode-vi v send-keys -X begin-selection
  bind-key -T copy-mode-vi Enter send-keys -X copy-selection-and-cancel
  bind-key -T copy-mode-vi y send-keys -X copy-pipe-and-cancel "xclip -selection clipboard"

  # Status bar theme
  set -g status-position bottom
  set -g status-left-length 32

  set -g status-fg white
  set -g status-bg black

  set -g status-left '#[fg=colour235,bg=colour252,bold] #S #[fg=colour252,bg=colour238,nobold]#[fg=colour245,bg=colour238,bold] #(whoami) #[fg=colour238,bg=black,nobold]'
  set -g window-status-format "#[fg=white,bg=black] #I #W "
  set -g window-status-current-format "#[fg=black,bg=colour39]#[fg=colour25,bg=colour39,noreverse,bold] #I  #W #[fg=colour39,bg=black,nobold]"
  set -g status-right "#{prefix_highlight}"

  # Load tmux plugin manager
  run '~/.local/share/tmux/plugins/tpm/tpm'
#+end_src
** jaro
In this file I define some file associations. Please refer to [[https://github.com/isamert/jaro][jaro]] README for more info. It's simply an =xdg-open= alternative.

- To experiment associations/jaro, do:
  #+begin_src bash
    $ guile
    guile> (load ".local/bin/jaro")
    guile> (load ".config/associactions")
  #+end_src

#+begin_src scheme :tangle ~/.config/associations
  ;;
  ;; Associations
  ;;

  (assoc
    #:pattern '("(application|text)/(x-)?(pdf|postscript|ps|epub.*)" "image/(x-)?eps")
    #:program "zathura %f"
    #:view #t)

  (assoc
    #:pattern "\\.org$"
    #:program "emacsclient -c --tty %f"
    #:term "emacsclient -c %f"
    #:on-error "notify-send 'error' 'emacs daemon is not working'"
    #:view (open-with 'bat)
    #:standalone #t)

  (assoc
    #:pattern "^(text|application)/(x-)?csv$"
    #:program "sc-im %f"
    #:term "term -e"
    #:view #t
    #:edit (open-with 'editor))

  (assoc
    #:pattern '("^text/html" "^application/x?htm")
    #:program (open-with 'browser)
    #:view #t
    #:edit (open-with 'editor))

  (assoc
    #:name 'editor
    #:pattern '("^text/" "^application/(x-)?(shellscript|json|javascript)")
    #:program "nvim %f"
    #:term "term -e"
    #:view (open-with 'bat)
    #:edit #t)

  (assoc
    #:pattern "^video/"
    #:program "mpv %f"
    #:on-error "vlc %f"
    #:view #t)

  (assoc
    #:pattern "^audio/"
    #:program "mpc insert %f"
    #:on-success "mpc next"
    #:on-error "mpv %f")

  (assoc
    #:pattern "inode/directory"
    #:program "ranger %f"
    #:term "term -e"
    #:tmux "tmux split-window -h")

  (assoc
    #:pattern '("^https?://(www.)?youtube.com/watch\\?.*v="
                "^https?://(www.)?youtu.be/"
                "^https?://(www.)?v.redd.it/\\w+/DASH"
                "^https?://([a-zA-Z-]+)?streamable.com"
                "^https?://giant.gfycat.com/*+"
                "^https?://.+/.+\\.(gifv|mp4|webm)(\\?.+)?$")
    #:program `("tsp"
                "mpv"
                "--x11-name=youtube"
                "--geometry=-10-10"
                ,(format #f "--ytdl-format=bestvideo[height<=?~a]+bestaudio/best" (screen-height))
                ,(format #f "--autofit=~ax~a" (floor (/ (screen-width) 3)) (floor (/ (screen-height) 3)))
                "%f")
    #:on-error (open-with 'browser))

  (assoc
    #:pattern "^https?://.+/.+\\.(jpg|png|gif)(\\?.+)?$"
    #:program "notify-send 'jaro' 'Opening image...'; TMP_IMG=$(mktemp); curl -L %f > $TMP_IMG && pqiv $TMP_IMG"
    #:on-error "feh --start-at %f"
    #:view #t
    #:edit "pinta %f")

  ;; Open all images in a folder starting with given image in pqiv
  (assoc
    #:pattern "^image/.*$"
    #:program "pqiv --browse --lazy-load --max-depth=3 %f"
    #:on-error "feh --start-at %f"
    #:view #t
    #:edit "pinta %f")

  (assoc
    #:pattern "^https?://(www.)?reddit.com/r/\\w+/comments"
    #:program "tuir %f"
    #:term "term -e"
    #:tmux "tmux split-window -h"
    #:on-error (open-with 'browser))

  (assoc
    #:pattern '("^magnet:" "\\.torrent$")
    #:program "qbittorrent %f"
    #:on-success "notify-send 'Success' 'Torrent added to download list'"
    #:on-error "notify-send 'Fail' 'Can't add torrent"
    #:edit (open-with 'editor))

  (assoc
    #:name 'browser
    #:pattern '("^https?://.*"
                "^.*\\.html?(#[\\w_-]+)?")
    #:program "qutebrowser %f"
    #:test "pgrep qutebrowser"
    #:on-fail "vivaldi-stable %f"
    #:view #t
    #:edit (open-with 'editor))

  (assoc
    #:pattern "^application/(x-)?(tar|gzip|bzip2|lzma|xz|compress|7z|rar|gtar|zip)(-compressed)?"
    #:program "xarchiver %f"
    #:view "xarchiver %f")

  (assoc
    #:pattern "^application/(x-)?(vnd.)?(ms-|ms)?(excel|powerpoint|word)"
    #:program "desktopeditors %F")

  (assoc
    #:pattern ".*"
    #:program (select-alternative-with "fzf")
    #:standalone #t)

  ;;
  ;; Rest is used only with references
  ;;

  (assoc
    #:name 'bat
    #:pattern ".*"
    #:program "bat --paging=always %f"
    #:view #t)

  ;;
  ;; Some utilities
  ;;

  (define (screen-props)
    (map string->number (string-split (string-trim-both (read-sys-out "xrandr | awk ' /*/ {print $1}'")) #\x)))

  (define (screen-width)
    (car (screen-props)))

  (define (screen-height)
    (cadr (screen-props)))

  (define (parent-path path)
    (string-join (reverse (cdr (reverse (string-split path #\/)))) "/"))

  (define (index-of a b)
    (let [(tail (member a (reverse b)))]
      (and tail (length (cdr tail)))))

  ;; vi:syntax=scheme
#+end_src

** scli
Signal messenger for terminal, see [[https://github.com/isamert/scli][scli]].

#+begin_src conf :tangle ~/.config/sclirc
  open-command=jaro %u
  enable-notifications=true
  save-history=true
  use-formatting=true
  wrap-at=75
  contacts-autohide=true
#+end_src
** .inputrc
If I ever need to resort to use bash.

#+begin_src bash :tangle ~/.inputrc
  $include /etc/inputrc

  # Fixes del key
  set enable-keypad on
  # Obvious
  set completion-ignore-case on
  # Treat - and _ as same while completing
  set completion-map-case on
  # Make Alt key work
  set meta-flag on
  set input-meta on
  set convert-meta on
  set output-meta on
  # TAB once
  set show-all-if-ambiguous on
  set show-all-if-unmodified on
  # COLORS
  # Color files by types
  set colored-stats on
  # Append char to indicate type
  set visible-stats on
  # Mark symlinked directories
  set mark-symlinked-directories on
  # Color the common prefix
  set colored-completion-prefix on
  # Color the common prefix in menu-complete
  set menu-complete-display-prefix on

  #
  # Vi mode settings
  #
  set editing-mode vi
  set show-mode-in-prompt on
  # use | cursor in insert mode, block cursor in normal mode
  set vi-ins-mode-string \1\e[6 q\2
  set vi-cmd-mode-string \1\e[2 q\2
  # Search history using what is currently on screen (before cursor)

  # Cycle (tab and shift-tab)
  TAB: menu-complete
  "\e[Z": menu-complete-backward
#+end_src

** .mailcap
Just redirect everything to [[jaro]].
#+begin_src conf :tangle ~/.mailcap
  text/html; w3m -v -F -T text/html %s; edit=jaro --method=edit; compose=jaro --method=edit; nametemplate=%s.html; copiousoutput
  text/*; jaro '%s'; copiousoutput
  application/*; jaro '%s'
  image/*; jaro '%s'
  audio/*; jaro '%s'
  video/*; jaro '%s'
  message/*; jaro '%s'
  model/*; jaro '%s'
  ,*/*; jaro '%s'
#+end_src
** .urlview
Redirect everything to [[jaro]].
#+begin_src conf :tangle ~/.urlview
  COMMAND jaro
#+end_src
* Media
** MPD
*** Config
#+begin_src bash :tangle ~/.config/mpd/mpd.conf
# Files and directories #######################################################
#
# This setting controls the top directory which MPD will search to discover the
# available audio files and add them to the daemon's online database. This
# setting defaults to the XDG directory, otherwise the music directory will be
# be disabled and audio files will only be accepted over ipc socket (using
# file:// protocol) or streaming files over an accepted protocol.
#
music_directory		"~/Music"
#
# This setting sets the MPD internal playlist directory. The purpose of this
# directory is storage for playlists created by MPD. The server will use
# playlist files not created by the server but only if they are in the MPD
# format. This setting defaults to playlist saving being disabled.
#
playlist_directory "~/.config/mpd/playlists"
#
# This setting sets the location of the MPD database. This file is used to
# load the database at server start up and store the database while the
# server is not up. This setting defaults to disabled which will allow
# MPD to accept files over ipc socket (using file:// protocol) or streaming
# files over an accepted protocol.
#
db_file "~/.config/mpd/mpd.db"
#
# These settings are the locations for the daemon log files for the daemon.
# These logs are great for troubleshooting, depending on your log_level
# settings.
#
# The special value "syslog" makes MPD use the local syslog daemon. This
# setting defaults to logging to syslog, otherwise logging is disabled.
#
log_file "~/.config/mpd/mpd.log"
#
# This setting sets the location of the file which stores the process ID
# for use of mpd --kill and some init scripts. This setting is disabled by
# default and the pid file will not be stored.
#
pid_file "~/.config/mpd/mpd.pid"
#
# This setting sets the location of the file which contains information about
# most variables to get MPD back into the same general shape it was in before
# it was brought down. This setting is disabled by default and the server
# state will be reset on server start up.
#
state_file "~/.config/mpd/mpdstate"
#
# The location of the sticker database.  This is a database which
# manages dynamic information attached to songs.
#
sticker_file "~/.config/mpd/sticker.sql"
#
###############################################################################



# General music daemon options ################################################
#
# This setting specifies the user that MPD will run as. MPD should never run as
# root and you may use this setting to make MPD change its user ID after
# initialization. This setting is disabled by default and MPD is run as the
# current user.
#
user "isa"
#
# This setting specifies the group that MPD will run as. If not specified
# primary group of user specified with "user" setting will be used (if set).
# This is useful if MPD needs to be a member of group such as "audio" to
# have permission to use sound card.
#
#group				"nogroup"
#
# This setting sets the address for the daemon to listen on. Careful attention
# should be paid if this is assigned to anything other then the default, any.
# This setting can deny access to control of the daemon.
#
# For network
bind_to_address		"any"
#
# And for Unix Socket
#bind_to_address		"~/.mpd/socket"
#
# This setting is the TCP port that is desired for the daemon to get assigned
# to.
#
#port				"6600"
#
# This setting controls the type of information which is logged. Available
# setting arguments are "default", "secure" or "verbose". The "verbose" setting
# argument is recommended for troubleshooting, though can quickly stretch
# available resources on limited hardware storage.
#
#log_level			"default"
#
# If you have a problem with your MP3s ending abruptly it is recommended that
# you set this argument to "no" to attempt to fix the problem. If this solves
# the problem, it is highly recommended to fix the MP3 files with vbrfix
# (available from <http://www.willwap.co.uk/Programs/vbrfix.php>), at which
# point gapless MP3 playback can be enabled.
#
#gapless_mp3_playback			"yes"
#
# This setting enables MPD to create playlists in a format usable by other
# music players.
#
#save_absolute_paths_in_playlists	"no"
#
# This setting defines a list of tag types that will be extracted during the
# audio file discovery process. Optionally, 'comment' can be added to this
# list.
#
#metadata_to_use	"artist,album,title,track,name,genre,date,composer,performer,disc"
#
# This setting enables automatic update of MPD's database when files in
# music_directory are changed.
#
auto_update	"yes"

audio_output {
    type "alsa"
    name "ALSA device"
    mixer_type "software"
}

audio_output {
    type  "httpd"
    name  "HTTP Stream"
    #encoder  "vorbis"  # optional, vorbis or lame
    port  "8000"
    #quality  "5.0"   # do not define if bitrate is defined
    bitrate  "256"   # do not define if quality is defined
    #format  "44100:16:1"
    max_clients "2"   # optional 0=no limit
}
#+end_src
*** TODO Playlists
- Merge with eradio config.
#+begin_src bash :tangle ~/.config/mpd/playlists/radio.m3u
http://79.120.39.202:8002/postmetal
http://79.111.119.111:8002/melodicblackmetal
http://79.120.39.202:8002/aabmds
http://79.111.14.76:8002/avantgardemetal
http://79.111.14.76:8002/blackdeath
#+end_src
** MPV
*** Configuration
#+begin_src bash :tangle ~/.config/mpv/mpv.conf
input-ipc-server=/tmp/mpvsocket

# Display Turkish subtitles if available, fall back to English otherwise.
slang=tr,en

# Play Korean audio if available, fall back to English otherwise.
# (I watch Korean stuff a lot and they always gets overridden by English audio)
alang=ko,en,eng

# If the file seems to be valid UTF-8, prefer UTF-8, otherwise use Turkish
# encoding.
sub-codepage=cp1254

# Search these directories for subtitles
sub-file-paths=sub:Sub:subs:Subs:subtitle:Subtitle:subtitles:Subtitles

# Load all subtitles from directories listed above
sub-auto=all

# 10 from bottom
sub-pos=90

# Filter subtitle additions for the deaf or hard-of-hearing (SDH)
sub-filter-sdh=yes
sub-filter-sdh-harder=yes
#+end_src
*** Bindings
#+begin_src bash :tangle ~/.config/mpv/input.conf
# Show youtube comments
# This gets the video ID from filename, as mpv sets it this way.
c run "term" "--float" "-e" "/bin/bash" "-c" "ID='https://www.youtube.com/${filename}'; straw-viewer --colorful --comments-order=top --comments=$ID --page=1 --no-interactive | bat --style=plain --paging=always"

# Copy the filename
y run "/bin/sh" "-c" "printf ${filename} | xclip -selection clipboard"; show-text "Filename copied: ${filename}"

! add chapter -1 # skip to previous chapter
@ add chapter 1 # next

# Download subtitle
T run     "mediastuff" "mpv-subdl" "${path}" "eng" # english subtitle
Alt+t run "mediastuff" "mpv-subdl" "${path}" "tur" # turkish subtitle

l seek 5
h seek -5
j seek -60
k seek 60

f cycle fullscreen
p cycle pause
m cycle mute

0 add volume 2
9 add volume -2

s cycle sub
a cycle audio  # switch audio streams

# resize subtitle
+ add sub-scale +0.1
- add sub-scale -0.1

Alt+0 set window-scale 0.25
Alt+1 set window-scale 0.5
Alt+2 set window-scale 0.75
Alt+3 set window-scale 1
Alt+4 set window-scale 1.5
Alt+5 set window-scale 2

CTRL+l script-message osc-playlist

# Do smaller, always exact (non-keyframe-limited), seeks with shift.
# Don't show them on the OSD (no-osd).
Shift+l no-osd seek  1 exact
Shift+h no-osd seek -1 exact
Shift+j no-osd seek  5 exact
Shift+k no-osd seek -5 exact
#+end_src
** ncmpcpp
*** Configuration
#+begin_src bash :tangle ~/.config/ncmpcpp/config
ncmpcpp_directory = ~/.cache/ncmpcpp

##### song format #####
##
## For a song format you can use:
##
## %l - length
## %f - filename
## %D - directory
## %a - artist
## %A - album artist
## %t - title
## %b - album
## %y - date
## %n - track number (01/12 -> 01)
## %N - full track info (01/12 -> 01/12)
## %g - genre
## %c - composer
## %p - performer
## %d - disc
## %C - comment
## %P - priority
## $R - begin right alignment
#song_window_title_format = {%a - }{%t} - ncmpcpp
user_interface = alternative
display_bitrate = yes
enable_window_title = no
progressbar_look = —|
mpd_music_dir = "~/Music" # Needed for tag editor
#+end_src
*** Bindings
#+begin_src bash :tangle ~/.config/ncmpcpp/bindings
  def_key "L"
      show_lyrics
  def_key "?"
      show_lyrics

  def_key "j"
      scroll_down
  def_key "k"
      scroll_up
  def_key "h"
      previous_column
  def_key "l"
      next_column
  def_key "l"
    play_item

  def_key "G"
    move_end
  def_key "g"
    move_home

  def_key "/"
      find
  def_key "/"
      find_item_forward
  def_key "n"
      next_found_item
  def_key "N"
      previous_found_item

  def_key "v"
    select_item

  def_key "d"
    delete_playlist_items
  def_key "d"
    delete_browser_items
  def_key "d"
    delete_stored_playlist

  #
  # The defaults for reference
  #

  #def_key "mouse"
  #  mouse_event
  #
  #def_key "up"
  #  scroll_up
  #
  #def_key "shift-up"
  #  select_item
  #  scroll_up
  #
  #def_key "down"
  #  scroll_down
  #
  #def_key "shift-down"
  #  select_item
  #  scroll_down
  #
  #def_key "["
  #  scroll_up_album
  #
  #def_key "]"
  #  scroll_down_album
  #
  #def_key "{"
  #  scroll_up_artist
  #
  #def_key "}"
  #  scroll_down_artist
  #
  #def_key "page_up"
  #  page_up
  #
  #def_key "page_down"
  #  page_down
  #
  #def_key "home"
  #  move_home
  #
  #def_key "end"
  #  move_end
  #
  #def_key "insert"
  #  select_item
  #
  #def_key "enter"
  #  enter_directory
  #
  #def_key "enter"
  #  toggle_output
  #
  #def_key "enter"
  #  run_action
  #
  #def_key "enter"
  #  play_item
  #
  #def_key "space"
  #  add_item_to_playlist
  #
  #def_key "space"
  #  toggle_lyrics_update_on_song_change
  #
  #def_key "space"
  #  toggle_visualization_type
  #
  #def_key "delete"
  #  delete_playlist_items
  #
  #def_key "delete"
  #  delete_browser_items
  #
  #def_key "delete"
  #  delete_stored_playlist
  #
  #def_key "right"
  #  next_column
  #
  #def_key "right"
  #  slave_screen
  #
  #def_key "right"
  #  volume_up
  #
  #def_key "+"
  #  volume_up
  #
  #def_key "left"
  #  previous_column
  #
  #def_key "left"
  #  master_screen
  #
  #def_key "left"
  #  volume_down
  #
  #def_key "-"
  #  volume_down
  #
  #def_key ":"
  #  execute_command
  #
  #def_key "tab"
  #  next_screen
  #
  #def_key "shift-tab"
  #  previous_screen
  #
  #def_key "f1"
  #  show_help
  #
  #def_key "1"
  #  show_playlist
  #
  #def_key "2"
  #  show_browser
  #
  #def_key "2"
  #  change_browse_mode
  #
  #def_key "3"
  #  show_search_engine
  #
  #def_key "3"
  #  reset_search_engine
  #
  #def_key "4"
  #  show_media_library
  #
  #def_key "4"
  #  toggle_media_library_columns_mode
  #
  #def_key "5"
  #  show_playlist_editor
  #
  #def_key "6"
  #  show_tag_editor
  #
  #def_key "7"
  #  show_outputs
  #
  #def_key "8"
  #  show_visualizer
  #
  #def_key "="
  #  show_clock
  #
  #def_key "@"
  #  show_server_info
  #
  #def_key "s"
  #  stop
  #
  #def_key "p"
  #  pause
  #
  #def_key ">"
  #  next
  #
  #def_key "<"
  #  previous
  #
  #def_key "ctrl-h"
  #  jump_to_parent_directory
  #
  #def_key "ctrl-h"
  #  replay_song
  #
  #def_key "backspace"
  #  jump_to_parent_directory
  #
  #def_key "backspace"
  #  replay_song
  #
  #def_key "f"
  #  seek_forward
  #
  #def_key "b"
  #  seek_backward
  #
  #def_key "r"
  #  toggle_repeat
  #
  #def_key "z"
  #  toggle_random
  #
  #def_key "y"
  #  save_tag_changes
  #
  #def_key "y"
  #  start_searching
  #
  #def_key "y"
  #  toggle_single
  #
  #def_key "R"
  #  toggle_consume
  #
  #def_key "Y"
  #  toggle_replay_gain_mode
  #
  #def_key "T"
  #  toggle_add_mode
  #
  #def_key "|"
  #  toggle_mouse
  #
  #def_key "#"
  #  toggle_bitrate_visibility
  #
  #def_key "Z"
  #  shuffle
  #
  #def_key "x"
  #  toggle_crossfade
  #
  #def_key "X"
  #  set_crossfade
  #
  #def_key "u"
  #  update_database
  #
  #def_key "ctrl-s"
  #  sort_playlist
  #
  #def_key "ctrl-s"
  #  toggle_browser_sort_mode
  #
  #def_key "ctrl-s"
  #  toggle_media_library_sort_mode
  #
  #def_key "ctrl-r"
  #  reverse_playlist
  #
  #def_key "ctrl-f"
  #  apply_filter
  #
  #def_key "ctrl-_"
  #  select_found_items
  #
  #def_key "/"
  #  find
  #
  #def_key "/"
  #  find_item_forward
  #
  #def_key "?"
  #  find
  #
  #def_key "?"
  #  find_item_backward
  #
  #def_key "."
  #  next_found_item
  #
  #def_key ","
  #  previous_found_item
  #
  #def_key "w"
  #  toggle_find_mode
  #
  #def_key "e"
  #  edit_song
  #
  #def_key "e"
  #  edit_library_tag
  #
  #def_key "e"
  #  edit_library_album
  #
  #def_key "e"
  #  edit_directory_name
  #
  #def_key "e"
  #  edit_playlist_name
  #
  #def_key "e"
  #  edit_lyrics
  #
  #def_key "i"
  #  show_song_info
  #
  #def_key "I"
  #  show_artist_info
  #
  #def_key "g"
  #  jump_to_position_in_song
  #
  #def_key "l"
  #  show_lyrics
  #
  #def_key "ctrl-v"
  #  select_range
  #
  #def_key "v"
  #  reverse_selection
  #
  #def_key "V"
  #  remove_selection
  #
  #def_key "B"
  #  select_album
  #
  #def_key "a"
  #  add_selected_items
  #
  #def_key "c"
  #  clear_playlist
  #
  #def_key "c"
  #  clear_main_playlist
  #
  #def_key "C"
  #  crop_playlist
  #
  #def_key "C"
  #  crop_main_playlist
  #
  #def_key "m"
  #  move_sort_order_up
  #
  #def_key "m"
  #  move_selected_items_up
  #
  #def_key "n"
  #  move_sort_order_down
  #
  #def_key "n"
  #  move_selected_items_down
  #
  #def_key "M"
  #  move_selected_items_to
  #
  #def_key "A"
  #  add
  #
  #def_key "S"
  #  save_playlist
  #
  #def_key "o"
  #  jump_to_playing_song
  #
  #def_key "G"
  #  jump_to_browser
  #
  #def_key "G"
  #  jump_to_playlist_editor
  #
  #def_key "~"
  #  jump_to_media_library
  #
  #def_key "E"
  #  jump_to_tag_editor
  #
  #def_key "U"
  #  toggle_playing_song_centering
  #
  #def_key "P"
  #  toggle_display_mode
  #
  #def_key "\\"
  #  toggle_interface
  #
  #def_key "!"
  #  toggle_separators_between_albums
  #
  #def_key "L"
  #  toggle_lyrics_fetcher
  #
  #def_key "F"
  #  fetch_lyrics_in_background
  #
  #def_key "alt-l"
  #  toggle_fetching_lyrics_in_background
  #
  #def_key "ctrl-l"
  #  toggle_screen_lock
  #
  #def_key "`"
  #  toggle_library_tag_type
  #
  #def_key "`"
  #  refetch_lyrics
  #
  #def_key "`"
  #  add_random_items
  #
  #def_key "ctrl-p"
  #  set_selected_items_priority
  #
  #def_key "q"
  #  quit
  #

#+end_src
** pqiv
#+begin_src conf :tangle ~/.config/pqivrc
  [options]
  thumbnail-persistence=yes

  [keybindings]
  ;; next/prev image
  p {
    goto_file_relative(-1);
  }
  n {
    goto_file_relative(1);
  }

  ;; fuzzy search all images in folder/album
  f {
    jump_dialog();
  }

  _ {
    flip_vertically();
  }

  | {
    flip_horizontally();
  }

  <less> {
    rotate_left();
  }

  <greater> {
    rotate_right();
  }

  P {
    animation_step(1);
  }
  p {
    animation_continue();
  }

  dd {
    command(trash $1);
    command(notify-send "pqiv - trash" "`pwd`$1");
  }
  DD {
    command(rm $1);
    command(notify-send "pqiv - removed" "`pwd`$1");
  }

  ;; w/W: set as temp/permenant wallpaper
  w {
    command(feh --bg-scale $1);
  }
  W {
    command(cp $1 $HOME/.config/wall.png);
    command(feh --bg-scale $1);
  }

  ;; y/Y: copy image path/image itself to clipboard
  y {
    command(echo "`pwd`/$1" | xclip -selection clipboard);
    command(notify-send "pqiv - path copied" "`pwd`$1");
  }

  Y {
    command(xcopy $1);
    command(notify-send "pqiv - image copied" "`pwd`$1");
  }

  ;; open image in the editor
  e {
    command(notify-send "pqiv - image editor" "Opening `pwd`$1 in image editor.");
    command(jaro --method edit $1);
  }

  ;;
  ;; Editing
  ;;

  <space> {
    nop();
  }

  <Control><greater> {
    command(echo $1 | xargs -I {} convert -rotate 90 "{}" "{}");
  }

  <Control><less> {
    command(echo $1 | xargs -I {} convert -rotate -90 "{}" "{}");
  }

  <Control><bar> {
    command(echo $1 | xargs -I {} convert -flip "{}" "{}");
  }

  <Control><underscore> {
    command(echo $1 | xargs -I {} convert -flop "{}" "{}");
  }

  <Return> {
    montage_mode_enter();
  }

  @MONTAGE {
      l { montage_mode_shift_x(1); }
      h { montage_mode_shift_x(-1); }
      j { montage_mode_shift_y(1); }
      k { montage_mode_shift_y(-1); }
      f { montage_mode_follow(qwertasdfgcvb); }
  }
#+end_src
* Editors
** Emacs
This file is just used for loading the configuration through an org file.

#+begin_src elisp :tangle ~/.emacs.d/init.el
  (org-babel-load-file "~/.emacs.d/settings.org")
#+end_src
** Neovim
** Configuration
#+begin_src vim :tangle ~/.config/nvim/init.vim
  " ##################################################
  "                   (_)
  "         __   ___ _ __ ___  _ __ ___
  "         \ \ / / | '_ ` _ \| '__/ __|
  "          \ V /| | | | | | | | | (__
  "         (_)_/ |_|_| |_| |_|_|  \___|
  " ##################################################

  " linters:
  " aurin shellcheck-static -> bash linter

  " plugins {{{
  call plug#begin('~/.local/share/nvim/plugged')
  " aesthetics
  Plug 'rakr/vim-one'                " i'm using this as airline theme
  Plug 'dkasak/gruvbox'              " general theme
  Plug 'vim-airline/vim-airline'     " powerline stuff
  Plug 'ryanoasis/vim-devicons'      " icons

  " utility
  Plug 'terryma/vim-multiple-cursors'
  Plug 'junegunn/fzf.vim'                      " Fuzzy finder (s. FZF)
  Plug 'airblade/vim-gitgutter'                " Show git changes
  Plug 'scrooloose/nerdtree'                   " tree like file manager
  Plug 'Xuyuanp/nerdtree-git-plugin'           " git flags for nerdtree
  Plug 'Shougo/deoplete.nvim', { 'do': ':UpdateRemotePlugins' }

  " editing
  Plug 'easymotion/vim-easymotion'   " (s. easymotion)
  Plug 'tpope/vim-surround'          " (y|c)(motion)(anything-to-surround)
  Plug 'tpope/vim-repeat'            " repat more stuff with .
  Plug 'godlygeek/tabular'           " :Tabularize /(thing to align)
  Plug 'milkypostman/vim-togglelist' " \q -> Toggle quicfix, \l -> Toggle list

  " lint, code comp. new languages etc.
  Plug 'w0rp/ale'                    " lint, code completion, other lsp features
  Plug 'neovimhaskell/haskell-vim'   " for better highlighting
  Plug 'dag/vim-fish'                " syntaxh highlighting and stuff for fish
  Plug 'kovetskiy/sxhkd-vim'
  Plug 'gabrielelana/vim-markdown'
  Plug 'leafgarland/typescript-vim'
  Plug 'ianks/vim-tsx'

  Plug 'glacambre/firenvim', { 'do': { _ -> firenvim#install(0) } }

  call plug#end()
  " }}}

  " theme {{{
  colorscheme gruvbox                  " ...
  let g:one_allow_italics = 1          " Italic comments for one theme
  let g:gruvbox_italic=1               " Italic comments for gruvbox
  let g:gruvbox_contrast_dark = 'hard' " ...
  syntax on                            " enable syntax highlighting
  " }}}

  " visuals {{{
  set background=dark                " rearranges colors for dark background
  set colorcolumn=80                 " 80-col line
  set termguicolors                  " true color support
  set number relativenumber          " line numbers relative to current line ()
  set cursorline                     " highlight current line
  hi Normal guibg=none ctermbg=none| " transparent background
  " }}}

  " tabs and spaces {{{
  set mouse=a               " enable mouse (helps precise resizing etc)
  set tabstop=4             " tab-char width
  set shiftwidth=4          " indent-level width
  set softtabstop=4         " column count inserted by the tab key
  set expandtab             " tabs -> spaces
  set smartindent           " do it smart
  filetype plugin indent on " determine indent by plugins
  " }}}

  " better defaults {{{
  " search/completion
  set ignorecase " ignore case while searching
  set smartcase  " abc -> Abc and abc, Abc -> only Abc (works in combination with ^^)
  set splitbelow
  set splitright
  set foldmethod=syntax " (indent, marker: fold between {{{ }}})
  " }}}

  " utility {{{
  set showmatch             " visually indicate matching parens
  set autoread              " update buffer if file is edited externally
  set title                 " terminal inherits title
  set clipboard=unnamedplus " use system clipboard
  set inccommand=nosplit    " show effects of a command live
  set spelllang=en_us       " default spelllang
  set signcolumn=yes        " removes flickering caused by lang server
  set undofile              " saves undo history to file (nvim's undodir default is OK)
  set completeopt=menu,menuone,preview,noselect,noinsert
  " }}}

  " netrw (file browser) {{{
  " :help netrw-quickmap
  let g:netrw_banner = 0       " remove banner
  let g:netrw_liststyle = 3    " tree style listing
  let g:netrw_browse_split = 4 " ...
  let g:netrw_altv = 1         " spawn it at left split
  let g:netrw_usetab = 1       " use tab for expanding/shrinking folders
  let g:netrw_winsize = 10     " occupies 10% of window
  " }}}

  " nerdtree {{{
  " close vim if the nerdtree is the only window remaining
  autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif
  " Use <TAB> as enter in NerdTree
  " autocmd FileType nerdtree nmap <buffer> <CR> <TAB>

  map <A-f> :NERDTreeToggle<CR>
  " }}}

  " trailing spaces {{{
  set listchars=tab:▸\ ,trail:·       " Show trailing spaces and tabs
  set list                            " ^^ enable it
  autocmd BufWritePre * :%s/\s\+$//e  " remove trailing spaces on save
  " }}}

  " airline {{{
  let g:airline_powerline_fonts = 1                " use nice-looking fonts
  let g:airline_theme='one'                        " this is better than gruvbox
  let g:airline#extensions#tabline#enabled = 2     " show buffers as tabs
  let g:airline#extensions#tabline#fnamemod = ':t' " show only filename for buffer tabs
  " }}}

  " startify (the thing that pops up when vim is started) {{{
  let g:startify_session_dir = '~/.config/nvim/sessions'
  let g:startify_bookmarks = ['~/Workspace/projects', '~/Documents/notes']
  let g:startify_lists = [
      \ { 'type': 'files',     'header': ['MRU']            },
      \ { 'type': 'sessions',  'header': ['Sessions']       },
      \ { 'type': 'bookmarks', 'header': ['Bookmarks']      },
      \ { 'type': 'commands',  'header': ['Commands']       },
      \ ]
  " }}}

  " autocomplete key mappings (tab, stab to select next, prev completion from list) {{{
  inoremap <expr> <Tab> pumvisible() ? "\<C-n>" : "\<Tab>"
  inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
  inoremap <expr> <cr> pumvisible() ? "\<C-y>" : "\<cr>"
  autocmd! CompleteDone * if pumvisible() == 0 | pclose | endif " Close preview menu when completion is done
  " }}}

  " ale {{{
  " let g:ale_lint_on_text_changed = 'never' " only lints when file is saved
  let g:airline#extensions#ale#enabled = 1       " ...
  let g:ale_sign_error = '◉'                     " ...
  let g:ale_sign_warning = '◉'                   " ...
  let g:ale_completion_enabled = 1               " ...
  let g:ale_linters_explicit = 1                 " only run linters named in ale_linters settings.

  " ale linter config (only use with linters, see below for lang servers)
  let g:ale_linters             = {}
  let g:ale_linters['sh']       = ['shellcheck']
  let g:ale_linters['fish']     = ['fish']
  let g:ale_linters['awk']      = ['gawk']
  let g:ale_linters['r']        = ['lintr']
  let g:ale_linters['vim']      = ['vint']
  let g:ale_linters['json']     = ['jq']
  let g:ale_linters['markdown'] = ['vale']
  " }}}

  " stuff {{{
  nmap <space> <leader>
  inoremap jk <ESC>|         " jk escapes to normal mode
  tnoremap jk <C-\><C-n>|    " jk escapes to normal mode (in terminal mode)
  tnoremap <Esc> <C-\><C-n>| " esc escapes to normal mode
  " }}}

  " split mappings {{{
  " next sections looks pretty much like my i3 config except Win key is replaced
  " with the Alt key
  " move between buffers with alt+hjkl
  nnoremap <A-h> <C-w>h
  nnoremap <A-j> <C-w>j
  nnoremap <A-k> <C-w>k
  nnoremap <A-l> <C-w>l

  " faster resize for buffers
  nnoremap <A-J> <C-w>+
  nnoremap <A-K> <C-w>-
  nnoremap <A-L> <C-w>>
  nnoremap <A-H> <C-w><
  tnoremap <A-J> <C-\><C-n><C-w>+
  tnoremap <A-K> <C-\><C-n><C-w>-
  tnoremap <A-L> <C-\><C-n><C-w>>
  tnoremap <A-H> <C-\><C-n><C-w><

  " faster split creation/deletion
  nnoremap <silent> <A--> :split<CR>
  nnoremap <silent> <A-\> :vsplit<CR>
  nnoremap <silent> <A-w> :bd<CR>

  " change buffers
  nnoremap <silent> <C-l> :bn<CR>
  nnoremap <silent> <C-h> :bp<CR>
  " }}}

  " tabs {{{
  nnoremap <silent> <A-.> :tabnext<CR>|               " alt-.  -> next tab
  tnoremap <silent> <A-.> <C-\><C-n>:tabnext<CR>|     " alt-.  -> next tab (terminal mode)
  nnoremap <silent> <A-,> :tabprevious<CR>|           " alt-,  -> prev tab
  tnoremap <silent> <A-,> <C-\><C-n>:tabprevious<CR>| " alt-,  -> prev tab (terminal mode)
  nnoremap <silent> <A-1> :1 tabn<CR>|                " alt-1  -> goes to tab 1
  nnoremap <silent> <A-2> :2 tabn<CR>|                " ^^
  nnoremap <silent> <A-3> :3 tabn<CR>|                " ^^
  nnoremap <silent> <A-4> :4 tabn<CR>|                " ^^
  nnoremap <silent> <A-5> :5 tabn<CR>|                " ^^
  nnoremap <silent> <C-t> :tabnew<CR>|                " ctrl-t -> new tab
  " }}}

  " indention mappings {{{
  vnoremap <Tab> >gv|     " tab indents in visual mode
  vnoremap <S-Tab> <gv|   " s-tab de-indents in visual mode
  inoremap <S-Tab> <C-d>| " s-tab de-indents in insert mode
  " }}}

  " easymotion {{{
  map  <leader>w <Plug>(easymotion-bd-w)|             " \w -> jump to word
  nmap <leader>w <Plug>(easymotion-overwin-w)prefix)| " ^^
  nmap s <Plug>(easymotion-overwin-f)|                " jump to character
  map <Leader>j <Plug>(easymotion-j)|                 " jump to line (downwards)
  map <Leader>k <Plug>(easymotion-k)|                 " jump to line (upwards)

  "search
  let g:EasyMotion_smartcase = 1
  map  / <Plug>(easymotion-sn)
  omap / <Plug>(easymotion-tn)
  map  n <Plug>(easymotion-next)
  map  N <Plug>(easymotion-prev)
  " }}}

  " move visual lines (j,k works in traditional way) {{{
  onoremap <silent> j gj
  onoremap <silent> k gk
  nnoremap <silent> j gj
  nnoremap <silent> k gk
  vnoremap <silent> j gj
  vnoremap <silent> k gk
  " }}}

  " fzf (https://github.com/junegunn/fzf/blob/master/README-VIM.md#fzf-inside-terminal-buffer) {{{
  let $FZF_DEFAULT_OPTS = '--layout=reverse --margin=1,4'
  let g:fzf_layout = { 'window': 'call OpenFloatingWin()' }

  function! OpenFloatingWin()
      let height = &lines - 3
      let width = float2nr(&columns - (&columns * 2 / 10))
      let col = float2nr((&columns - width) / 2)

      "Set the position, size, etc. of the floating window.
      "The size configuration here may not be so flexible, and there's room for further improvement.
      let opts = {
                  \ 'relative': 'editor',
                  \ 'row': height * 0.3,
                  \ 'col': col + 30,
                  \ 'width': width * 2 / 3,
                  \ 'height': height / 2
                  \ }

      let buf = nvim_create_buf(v:false, v:true)
      let win = nvim_open_win(buf, v:true, opts)

      "Set Floating Window Highlighting
      call setwinvar(win, '&winhl', 'Normal:Pmenu')

      setlocal
                  \ buftype=nofile
                  \ nobuflisted
                  \ bufhidden=hide
                  \ nonumber
                  \ norelativenumber
                  \ signcolumn=no
  endfunction

  function! RipgrepFzf(query, fullscreen)
      " Rg with bat preview focused on selected line
      let command_fmt = 'rg --column --line-number --no-heading --color=always --smart-case %s || true'
      let initial_command = printf(command_fmt, shellescape(a:query))
      let spec = {'options': ['--layout=reverse', '--query', a:query, '--preview', 'line={}; file=${line%%:*}; linum=${${line#*:}%%:*}; range=$(($linum - $LINES / 2)); range_cmd=$([[ $range -gt -1 ]] && echo "--line-range"); range_cmd_arg=$([[ $range -gt -1 ]] && echo $range:); bat --color=always --style=header,numbers "$file" --highlight-line $linum $range_cmd $range_cmd_arg']}
      call fzf#vim#grep(initial_command, 1, spec, a:fullscreen)
  endfunction

  let $FZF_DEFAULT_OPTS = '--layout=reverse --info=hidden'

  command! -bang -nargs=?  Files call fzf#vim#files(<q-args>, {'options': ['--info=inline', '--preview', 'bat --color=always --style=header,numbers {}'], 'window': ''}, <bang>0)
  command! -bang -nargs=?  GFiles call fzf#vim#files(<q-args>, {'options': ['--layout=reverse', '--info=inline', '--preview', 'bat --color=always --style=header,numbers {}']}, <bang>0)
  command! -nargs=* -bang Rg call RipgrepFzf(<q-args>, <bang>0)
  command! -bang -nargs=? GLog call fzf#vim#grep('git log --graph --color=always --format="%C(auto)%h%d %s %C(black)%C(bold)%cr"', 1, {'options': ['--ansi', '--preview', 'echo {} | grep -o "[a-f0-9]\{7\}" | head -1 | xargs -I % sh -c "git show --color=always %"']}, <bang>0)

  " [Commands] --expect expression for directly executing the command
  let g:fzf_commands_expect = 'alt-enter,ctrl-x'
  inoremap <expr> <c-x><c-k> fzf#vim#complete('cat /usr/share/dict/words')

  nnoremap <leader><space> :Commands<CR>| " \<space> -> lists all commands
  nnoremap <leader>g :GFiles<CR>|         " \g       -> list all git files
  nnoremap <leader>h :History<CR>|        " \h       -> list history
  nnoremap <leader>b :Buffers<CR>|        " \b       -> list buffers
  nnoremap <leader>f :Rg<CR>|             " \b       -> search in all lines of the project
  " }}}

  " Master Wq bindings {{{
  command! Wq wq
  command! W w
  command! Q q
  nnoremap <silent> <CR> :nohlsearch<CR><CR>| " enter -> clear search highlighting
  nnoremap <silent> <C-s> :w<CR>|             " ctrl-s -> save
  nnoremap <silent> <C-q> :q<CR>|             " ctrl-q -> quit
  tnoremap <silent> <C-q> <C-\><C-n>:q<CR>|   " ctrl-q -> quit (term)
  " }}}

  " Turkish keyboard mappings {{{
  nnoremap Ş :
  nnoremap ı i
  nnoremap ğ [
  nnoremap ü ]
  nnoremap Ğ {
  nnoremap Ü }
  nnoremap ç .
  nnoremap Ö <
  nnoremap Ç >
  vnoremap Ş :
  vnoremap ı i
  vnoremap ğ [
  vnoremap ü ]
  vnoremap Ğ {
  vnoremap Ü }
  vnoremap ç .
  vnoremap Ö <
  vnoremap Ç >
  " }}}

  " other {{{
  vnoremap t :Tabularize/
  " }}}

  " utility commands {{{
  command! ConfigReload so $MYVIMRC " reload vim config
  command! ConfigEdit e $MYVIMRC    " edit vim config
  command! Vterm vsplit|term
  command! Term split|term
  command! SpellCheckEn setlocal spell! spelllang=en_us
  command! -range TabularizeHaskellData <line1>,<line2>GTabularize/[{},]\|::
  " }}}

  " autos {{{
  autocmd BufWritePost ~/.Xresources,~/.Xdefaults !xrdb %
  autocmd BufWritePost ~/.Xresources.d/* !xrdb ~/.Xresources
  autocmd BufWritePost ~/.config/sxhkd/sxhkdrc !pkill -USR1 -x sxhkd
  " }}}

  " functions {{{
  function! PreviewToggler(fn, ...)
      " Takes a function that opens previewwindow, if the pwindow is open then
      " closes it, if the pwindow is not open simply calls the function.
      for nr in range(1, winnr('$'))
          if getwinvar(nr, '&pvw') == 1
              pclose
              return 0
          endif
      endfor

      let params = get(a:, 1, [])
      :call call (function(a:fn), params)
  endfunction
  " }}}

  " vi: foldmethod=marker
#+end_src
** Minimal configuration
#+begin_src vim :tangle ~/.config/nvim/minimal.vim
" ##################################################
"                   (_)
"         __   ___ _ __ ___  _ __ ___
"         \ \ / / | '_ ` _ \| '__/ __|
"          \ V /| | | | | | | | | (__
"         (_)_/ |_|_| |_| |_|_|  \___|
" ##################################################


" visuals {{{
set background=dark                " rearranges colors for dark background
set colorcolumn=80                 " 80-col line
set termguicolors                  " true color support
set number relativenumber          " line numbers relative to current line ()
set cursorline                     " highlight current line
"hi Normal guibg=none ctermbg=none| " transparent background
" }}}

" tabs and spaces {{{
set mouse=a               " enable mouse (helps precise resizing etc)
set tabstop=4             " tab-char width
set shiftwidth=4          " indent-level width
set softtabstop=4         " column count inserted by the tab key
set expandtab             " tabs -> spaces
set smartindent           " do it smart
filetype plugin indent on " determine indent by plugins
" }}}

" better defaults {{{
" search/completion
set ignorecase " ignore case while searching
set smartcase  " abc -> Abc and abc, Abc -> only Abc (works in combination with ^^)
set splitbelow
set splitright
set foldmethod=syntax " (indent, marker: fold between {{{ }}})
" }}}

" utility {{{
set showmatch             " visually indicate matching parens
set autoread              " update buffer if file is edited externally
set title                 " terminal inherits title
set clipboard=unnamedplus " use system clipboard
set inccommand=nosplit    " show effects of a command live
set spelllang=en_us       " default spelllang
set signcolumn=yes        " removes flickering caused by lang server
set undofile              " saves undo history to file (nvim's undodir default is OK)
set completeopt=menu,menuone,preview,noselect,noinsert
" }}}

" netrw (file browser) {{{
" :help netrw-quickmap
let g:netrw_banner = 0       " remove banner
let g:netrw_liststyle = 3    " tree style listing
let g:netrw_browse_split = 4 " ...
let g:netrw_altv = 1         " spawn it at left split
let g:netrw_usetab = 1       " use tab for expanding/shrinking folders
let g:netrw_winsize = 10     " occupies 10% of window
" }}}

" trailing spaces {{{
set listchars=tab:▸\ ,trail:·       " Show trailing spaces and tabs
set list                            " ^^ enable it
autocmd BufWritePre * :%s/\s\+$//e  " remove trailing spaces on save
" }}}

" autocomplete key mappings (tab, stab to select next, prev completion from list) {{{
inoremap <expr> <Tab> pumvisible() ? "\<C-n>" : "\<Tab>"
inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
inoremap <expr> <cr> pumvisible() ? "\<C-y>" : "\<cr>"
autocmd! CompleteDone * if pumvisible() == 0 | pclose | endif " Close preview menu when completion is done
" }}}

" stuff {{{
nmap <space> <leader>
inoremap jk <ESC>|         " jk escapes to normal mode
tnoremap jk <C-\><C-n>|    " jk escapes to normal mode (in terminal mode)
tnoremap <Esc> <C-\><C-n>| " esc escapes to normal mode
" }}}

" split mappings {{{
" next sections looks pretty much like my i3 config except Win key is replaced
" with the Alt key
" move between buffers with alt+hjkl
nnoremap <A-h> <C-w>h
nnoremap <A-j> <C-w>j
nnoremap <A-k> <C-w>k
nnoremap <A-l> <C-w>l

" faster resize for buffers
nnoremap <A-J> <C-w>+
nnoremap <A-K> <C-w>-
nnoremap <A-L> <C-w>>
nnoremap <A-H> <C-w><
tnoremap <A-J> <C-\><C-n><C-w>+
tnoremap <A-K> <C-\><C-n><C-w>-
tnoremap <A-L> <C-\><C-n><C-w>>
tnoremap <A-H> <C-\><C-n><C-w><

" faster split creation/deletion
nnoremap <silent> <A--> :split<CR>
nnoremap <silent> <A-\> :vsplit<CR>
nnoremap <silent> <A-w> :bd<CR>

" change buffers
nnoremap <silent> <C-l> :bn<CR>
nnoremap <silent> <C-h> :bp<CR>
" }}}

" tabs {{{
nnoremap <silent> <A-.> :tabnext<CR>|               " alt-.  -> next tab
tnoremap <silent> <A-.> <C-\><C-n>:tabnext<CR>|     " alt-.  -> next tab (terminal mode)
nnoremap <silent> <A-,> :tabprevious<CR>|           " alt-,  -> prev tab
tnoremap <silent> <A-,> <C-\><C-n>:tabprevious<CR>| " alt-,  -> prev tab (terminal mode)
nnoremap <silent> <A-1> :1 tabn<CR>|                " alt-1  -> goes to tab 1
nnoremap <silent> <A-2> :2 tabn<CR>|                " ^^
nnoremap <silent> <A-3> :3 tabn<CR>|                " ^^
nnoremap <silent> <A-4> :4 tabn<CR>|                " ^^
nnoremap <silent> <A-5> :5 tabn<CR>|                " ^^
nnoremap <silent> <C-t> :tabnew<CR>|                " ctrl-t -> new tab
" }}}

" indention mappings {{{
vnoremap <Tab> >gv|     " tab indents in visual mode
vnoremap <S-Tab> <gv|   " s-tab de-indents in visual mode
inoremap <S-Tab> <C-d>| " s-tab de-indents in insert mode
" }}}

" move visual lines (j,k works in traditional way) {{{
onoremap <silent> j gj
onoremap <silent> k gk
nnoremap <silent> j gj
nnoremap <silent> k gk
vnoremap <silent> j gj
vnoremap <silent> k gk
" }}}

" Master Wq bindings {{{
command! Wq wq
command! W w
command! Q q
nnoremap <silent> <CR> :nohlsearch<CR><CR>| " enter -> clear search highlighting
nnoremap <silent> <C-s> :w<CR>|             " ctrl-s -> save
nnoremap <silent> <C-q> :q<CR>|             " ctrl-q -> quit
tnoremap <silent> <C-q> <C-\><C-n>:q<CR>|   " ctrl-q -> quit (term)
" }}}

" Turkish keyboard mappings {{{
nnoremap Ş :
nnoremap ı i
nnoremap ğ [
nnoremap ü ]
nnoremap Ğ {
nnoremap Ü }
nnoremap ç .
nnoremap Ö <
nnoremap Ç >
vnoremap Ş :
vnoremap ı i
vnoremap ğ [
vnoremap ü ]
vnoremap Ğ {
vnoremap Ü }
vnoremap ç .
vnoremap Ö <
vnoremap Ç >
" }}}

" move in insert mode {{{
inoremap <C-l> <right>| " ctrl-l -> move right in insert mode
inoremap <C-h> <left>|  " ...
inoremap <C-j> <down>|  " ...
inoremap <C-k> <up>|    " ...
" }}}

" utility commands {{{
command! ConfigReload so $MYVIMRC " reload vim config
command! ConfigEdit e $MYVIMRC    " edit vim config
command! Vterm vsplit|term
command! Term split|term
command! SpellCheckEn setlocal spell! spelllang=en_us
" }}}

" vi: foldmethod=marker
#+end_src
* SystemD
This needs a bit explanation, like how system stars, where and how the services are started etc. Also see [[.xprofile]].

** .config/systemd/user/clipmenud.service
#+begin_src conf :tangle ~/.config/systemd/user/clipmenud.service
[Unit]
Description=Clipmenu daemon

[Service]
ExecStart=/usr/bin/clipmenud
Restart=always
RestartSec=0
Environment=DISPLAY=:0

MemoryDenyWriteExecute=yes
NoNewPrivileges=yes
ProtectControlGroups=yes
ProtectKernelTunables=yes
RestrictAddressFamilies=
RestrictRealtime=yes

[Install]
WantedBy=user-graphical-login.target
#+end_src
** .config/systemd/user/copyq.service
#+begin_src conf :tangle ~/.config/systemd/user/copyq.service
[Unit]
Description=copyq (clipboard manager)

[Service]
ExecStart=copyq
Restart=always

[Install]
WantedBy=user-graphical-login.target
#+end_src
** .config/systemd/user/emacs.service
#+begin_src conf :tangle ~/.config/systemd/user/emacs.service
[Unit]
Description=emacs daemon

[Service]
ExecStart=/usr/bin/emacs --fg-daemon
ExecStop=/usr/bin/emacsclient --eval "(progn (setq kill-emacs-hook 'nil) (kill-emacs))"
Restart=always

# Remove the limit in startup timeout, since emacs
# cloning and building all packages can take time
TimeoutStartSec=0

[Install]
WantedBy=user-login.target
#+end_src
** .config/systemd/user/geoclue-agent.service
#+begin_src conf :tangle ~/.config/systemd/user/geoclue-agent.service
[Unit]
Description=redshift needs to get a (geo)clue

[Service]
ExecStart=/usr/lib/geoclue-2.0/demos/agent

[Install]
WantedBy=user-graphical-login.target
#+end_src
** .config/systemd/user/hydroxide-imap.service
#+begin_src conf :tangle ~/.config/systemd/user/hydroxide-imap.service
[Unit]
Description=hydroxide: bridge for protonmail, the imap server

[Service]
ExecStart=hydroxide imap

[Install]
WantedBy=user-login.target
#+end_src
** .config/systemd/user/hydroxide-smtp.service
#+begin_src conf :tangle ~/.config/systemd/user/hydroxide-smtp.service
[Unit]
Description=hydroxide: bridge for protonmail, the smtp server

[Service]
ExecStart=hydroxide smtp

[Install]
WantedBy=user-login.target
#+end_src
** .config/systemd/user/mbsync.service
#+begin_src conf :tangle ~/.config/systemd/user/mbsync.service
[Unit]
Description=Mailbox synchronization service

[Service]
Type=oneshot
ExecStart=/usr/bin/mbsync -Va
#+end_src
** .config/systemd/user/mbsync.timer
#+begin_src conf :tangle ~/.config/systemd/user/mbsync.timer
[Unit]
Description=Mailbox synchronization timer
After=user-login.target

[Timer]
OnBootSec=2m
OnUnitActiveSec=10m
Unit=mbsync.service

[Install]
WantedBy=timers.target
#+end_src
** .config/systemd/user/monitor-kb-change.service
#+begin_src conf :tangle ~/.config/systemd/user/monitor-kb-change.service
[Unit]
Description=Detect when a keyboard is attached and make neccesary configurations

[Service]
ExecStart=/usr/bin/env python3 %h/.scripts/monitor-kb-change
Restart=always
RestartSec=10

[Install]
WantedBy=user-graphical-login.target

#+end_src
** .config/systemd/user/mpd.service
#+begin_src conf :tangle ~/.config/systemd/user/mpd.service
[Unit]
Description=Music Player Daemon
Documentation=man:mpd(1) man:mpd.conf(5)
After=network.target sound.target

[Service]
Type=notify
ExecStart=/usr/bin/mpd --no-daemon

# Enable this setting to ask systemd to watch over MPD, see
# systemd.service(5).  This is disabled by default because it causes
# periodic wakeups which are unnecessary if MPD is not playing.
#WatchdogSec=120

# allow MPD to use real-time priority 50
LimitRTPRIO=50
LimitRTTIME=infinity

# disallow writing to /usr, /bin, /sbin, ...
ProtectSystem=yes

# more paranoid security settings
NoNewPrivileges=yes
ProtectKernelTunables=yes
ProtectControlGroups=yes
# AF_NETLINK is required by libsmbclient, or it will exit() .. *sigh*
RestrictAddressFamilies=AF_INET AF_INET6 AF_UNIX AF_NETLINK
RestrictNamespaces=yes

# Note that "ProtectKernelModules=yes" is missing in the user unit
# because systemd 232 is unable to reduce its own capabilities
# ("Failed at step CAPABILITIES spawning /usr/bin/mpd: Operation not
# permitted")

[Install]
WantedBy=user-graphical-login.target
#+end_src
** .config/systemd/user/mpd.socket
#+begin_src conf :tangle ~/.config/systemd/user/mpd.socket
[Socket]
ListenStream=%t/mpd/socket
ListenStream=6600
Backlog=5
KeepAlive=true
PassCredentials=true

[Install]
WantedBy=sockets.target
#+end_src
** .config/systemd/user/mpdscribble.service
#+begin_src conf :tangle ~/.config/systemd/user/mpdscribble.service
[Unit]
Description=mpdscribble: scribble mpd to libre.fm
After=mpd.socket

[Service]
Type=forking
ExecStart=mpdscribble

[Install]
WantedBy=user-login.target
#+end_src
** .config/systemd/user/newsboat-reload.service
#+begin_src conf :tangle ~/.config/systemd/user/newsboat-reload.service
[Unit]
Description=Newsboad reload service

[Service]
Type=oneshot
ExecStartPre=-killall -s SIGINT newsboat
ExecStart=newsboat -x reload
ExecStartPost=-notify-send "Newsboat" "Feeds have been reloaded."
#+end_src
** .config/systemd/user/newsboat-reload.timer
#+begin_src conf :tangle ~/.config/systemd/user/newsboat-reload.timer
[Unit]
Description=Newsboat reload timer
After=user-login.target

[Timer]
OnBootSec=1m
OnUnitActiveSec=60m
Unit=newsboat-reload.service

[Install]
WantedBy=timers.target
#+end_src
** .config/systemd/user/pacupd.service
#+begin_src conf :tangle ~/.config/systemd/user/pacupd.service
#ROOT

# This needs to be run as root, left here as reference.
# Installation of these files are handled by my installer script.
# Run: install.sh configure systemdroot

[Unit]
Description=Automaticly refresh/sync package repositories
After=network-online.target

[Service]
Type=simple
ExecStart=/usr/bin/pacman -Sy --noconfirm
TimeoutStopSec=30
KillMode=process
KillSignal=SIGINT

[Install]
WantedBy=multi-user.target
#+end_src
** .config/systemd/user/redshift.service
#+begin_src conf :tangle ~/.config/systemd/user/redshift.service
[Unit]
Description=Redshift display colour temperature adjustment
After=geoclue-agent.service

[Service]
ExecStart=/usr/bin/redshift
Restart=always

[Install]
WantedBy=user-graphical-login.target
#+end_src
** .config/systemd/user/syncthing.service
#+begin_src conf :tangle ~/.config/systemd/user/syncthing.service
[Unit]
Description=Syncthing - Open Source Continuous File Synchronization
Documentation=man:syncthing(1)

[Service]
ExecStart=/usr/bin/syncthing -no-browser -no-restart -logflags=0
Restart=on-failure
SuccessExitStatus=3 4
RestartForceExitStatus=3 4

# Hardening
ProtectSystem=full
PrivateTmp=true
SystemCallArchitectures=native
MemoryDenyWriteExecute=true
NoNewPrivileges=true

[Install]
WantedBy=default.target
#+end_src
** .config/systemd/user/udiskie.service
#+begin_src conf :tangle ~/.config/systemd/user/udiskie.service
[Unit]
Description=udiskie: a user level daemon for auto-mounting

[Service]
ExecStart=udiskie --smart-tray --notify

[Install]
WantedBy=user-graphical-login.target
#+end_src
** .config/systemd/user/unclutter.service
#+begin_src conf :tangle ~/.config/systemd/user/unclutter.service
[Unit]
Description=Unclutter: Hides mouse when it's inactive for a while

[Service]
ExecStart=unclutter

[Install]
WantedBy=user-graphical-login.target
#+end_src
** .config/systemd/user/user-graphical-login.target
#+begin_src conf :tangle ~/.config/systemd/user/user-graphical-login.target
# This unit is started from ~/.xprofile
# Other units that requires graphical env needs to have
# WantedBy=user-graphical-login.target

[Unit]
Description=User Graphical Login
Requires=default.target user-login.target
After=default.target user-login.target
#+end_src
** .config/systemd/user/user-login.target
#+begin_src conf :tangle ~/.config/systemd/user/user-login.target
# This unit is started from ~/.profile
# Other units that requires graphical env needs to have
# WantedBy=user-login.target

[Unit]
Description=User Login
Requires=default.target
After=default.target
#+end_src
** .config/systemd/user/xcape.service
#+begin_src conf :tangle ~/.config/systemd/user/xcape.service
[Unit]
Description=xcape

[Service]
Type=forking
ExecStart=xcape -e 'Hyper_L=Escape'
Restart=always
RestartSec=2

[Install]
WantedBy=user-graphical-login.target

#+end_src
* Some desktop files
** .local/share/applications/shortcuts.desktop
Some shortcuts to some folders. These stuff appears in rofi so that, for example, I can just search for =screenshots= and hit enter to open my screenshots directory in =pqiv=.

#+begin_src conf :tangle ~/.local/share/applications/shortcuts.desktop
  [Desktop Entry]
  Type=Application
  Name=Shortcut to
  Terminal=false
  Exec=term
  Actions=walls;fkill;phonepics;screenshots;memes;floatingtermopaque;floatingterm;opqueterm

  [Desktop Action walls]
  Name=Wallpapers
  Exec=/bin/sh -c "pqiv -t $DIR_WALLPAPERS"

  [Desktop Action phonepics]
  Name=Phone pictures
  Exec=/bin/sh -c "pqiv -t ~/Pictures/phone/Camera"

  [Desktop Action screenshots]
  Name=Screenshots
  Exec=/bin/sh -c "pqiv -t $DIR_SCREENSHOTS"

  [Desktop Action memes]
  Name=Memes (ayylmao)
  Exec=/bin/sh -c "pqiv -t ~/Pictures/ayylmao"

  [Desktop Action fkill]
  Name=Fuzzy kill (fkill)
  Exec=/bin/sh -c "term --float -g 150x20 -e fuzzy kill"

  [Desktop Action opaqueterm]
  Name=Opaque term terminal (meta + ctrl + enter)
  Exec=/bin/sh -c "term --opaque"

  [Desktop Action floatingterm]
  Name=Floating term terminal (meta + shift + enter)
  Exec=/bin/sh -c "term --float -g 150x30"

  [Desktop Action floatingtermopaque]
  Name=Floating term terminal (opaque)  (meta + shift + ctrl + enter)
  Exec=/bin/sh -c "term --float --opaque -g 150x30"
#+end_src
** .local/share/applications/tools.desktop
Some extra stuff that I want to be able to reach through rofi.

#+begin_src conf :tangle ~/.local/share/applications/tools.desktop
[Desktop Entry]
Type=Application
Name=Tools
Terminal=false
Exec=term
Actions=connectheadphones

[Desktop Action connectheadphones]
Name=Connect to Bluetooth Headphones
Exec=connect-bt-headphones
#+end_src
** .local/share/applications/jaro.desktop
#+begin_src conf :tangle ~/.local/share/applications/jaro.desktop
  [Desktop Entry]
  Name=jaro
  GenericName=Resource opener
  Terminal=false
  Exec=jaro %F
  Type=Application
  Categories=Utility;
#+end_src
** .local/share/applications/keepassxc-nopass.desktop
#+begin_src conf :tangle ~/.local/share/applications/keepassxc-nopass.desktop
[Desktop Entry]
Name=KeePassXC
GenericName=no password
Comment=KeePassXC but no password required
Exec=/bin/sh -c "getpassword --keepass | keepassxc --pw-stdin $HOME/Documents/sync/passwords.kdbx"
Icon=keepassxc
StartupWMClass=keepassxc
Terminal=false
Type=Application
Version=1.0
Categories=Utility;Security;Qt;
MimeType=application/x-keepass2;
#+end_src
** .local/share/applications/maim.desktop
#+begin_src conf :tangle ~/.local/share/applications/maim.desktop
[Desktop Entry]
Type=Application
Name=Take screenshot
Icon=utilities-terminal
Terminal=false
Exec=take-ss --full
Actions=full;area;wait-full;wait-area;clip-full;clip-area;shadow-window;

[Desktop Action full]
Name=Full
Exec=take-ss --full

[Desktop Action area]
Name=Area
Exec=take-ss --area

[Desktop Action wait-full]
Name=Wait 5, full
Exec=take-ss --wait-full

[Desktop Action wait-area]
Name=Wait 5, area
Exec=take-ss --wait-area

[Desktop Action clip-full]
Name=Clipboard full
Exec=take-ss --clip-full

[Desktop Action clip-area]
Name=Clipboard area
Exec=take-ss --clip-area

[Desktop Action shadow-window]
Name=Shadow window
Exec=take-ss --shadow-window
#+end_src
* Scripts
This part is almost completely untouched. Needs some revamp.

** .scripts/askpass
#+begin_src bash :tangle ~/.scripts/askpass
  #!/bin/sh
  zenity --password --title "Enter your password" 2> /dev/null
#+end_src
** .scripts/browser-watch
#+begin_src bash :tangle ~/.scripts/browser-watch
  #!/bin/bash

  # TODO: watch a list of files

  CMD=$1
  while [[ $# -gt 0 ]]; do
      case $1 in
          --*)
              TMP_ARG=${1#--}
              TMP_ARG=${TMP_ARG%=*}
              TMP_ARG=${TMP_ARG//-/_}
              TMP_VAL=${1#*=}
              declare "${TMP_ARG^^}"="$TMP_VAL"
              ;;
      esac
      shift
  done


  if [[ "$CMD" = "--help" ]]; then
      echo "Detect file changes and reload it in browser."
      echo "$(basename "$0") [--browser=(firefox|chrome|vivaldi)] [--reload=(hard|normal)] --file=FILE_TO_WATCH"
      exit 0
  elif [[ ${MODE} = "run" ]]; then
      echo "RELOADING..."

      current_window=$(xdotool getactivewindow)

      if [[ $RELOAD = "hard" ]]; then
          RELOAD_KEYS="CTRL+SHIFT+R"
      else
          RELOAD_KEYS="CTRL+R"
      fi

      xdotool search --name "${BROWSER:=chrome}" windowactivate --sync
      xdotool search --name "${BROWSER}" key --clearmodifiers "${RELOAD_KEYS}"

      xdotool windowfocus --sync "${current_window}"
      xdotool windowactivate --sync "${current_window}"
  else
      echo "$FILE" | entr "$0" "$@" --mode=run
  fi
#+end_src
** .scripts/bspwmc
#+begin_src bash :tangle ~/.scripts/bspwmc
  #!/bin/bash

  size=30

  function focused_monitor_name {
      bspc query --monitors --monitor focused --names
  }

  function focused_monitor_info {
      xrandr -q | grep "$(focused_monitor_name) connected" | tr "+x" " " | sed "s/primary //"
  }

  function focused_monitor_height {
      focused_monitor_info | cut -d" " -f4
  }

  function focused_monitor_width {
      focused_monitor_info | cut -d" " -f3
  }

  function focused_monitor_x_offset {
      focused_monitor_info | cut -d" " -f5
  }

  function focused_monitor_y_offset {
      focused_monitor_info | cut -d" " -f6
  }

  function is_floating {
      bspc query -T -n | grep -q '"state":"floating"'
  }

  # if current node is floating, focus the newest non-floating node
  # otherwise focus the newest floating node
  function focus_toggle_floating {
      if is_floating; then
          bspc node newest.!floating --focus
      else
          bspc node newest.floating --focus
      fi
  }

  # if current node is floating, focus $dir{west,south,north,east} floating node
  # otherwise focus $dir{west,south,north,east} non-floating node
  function focus {
      local dir="$1"
      if is_floating; then
          bspc node --focus "$dir.floating"
      else
          bspc node --focus "$dir.!floating"
      fi
  }

  # if current node is floating, move the node $dir{west,south,north,east} by $size px
  # otherwise swap current node with $dir{west,south,north,east} non-floating node
  function move {
      local dir="$1"
      local switch sign
      if is_floating; then
          case "$dir" in
              west)  switch="-x"; sign="-" ;;
              east)  switch="-x"; sign="+" ;;
              north) switch="-y"; sign="-" ;;
              ,*)     switch="-y"; sign="+" ;;
          esac
          xdo move ${switch} ${sign}${size}
      else
          bspc node --swap $dir.local.!floating
      fi
  }

  function resize {
      local dir="$1"
      local size="$2"
      if is_floating; then
          xdo resize -$dir $size
      else
          case $dir in
              w) bspc node -z right $size 0; bspc node -z left $size 0 ;;
              h) bspc node -z bottom 0 $size; bspc node -z top 0 $size ;;
          esac
      fi
  }

  # normalize_size 100 1200 -> 100
  # normalize_size 50% 1200 -> 600
  function normalize_size {
      local size=$1
      local relative_to=$2
      if [[ $size = *% ]]; then
          local size=$(($relative_to * ${size%\%} / 100))
      fi
      echo $size
  }

  # a scratchpad terminal that is shared across desktops (unique for each monitor)
  function scratchpad_top {
      monitor_name=$(focused_monitor_name)
      class="padtop-${monitor_name,,}"
      id=$(xdotool search --classname --class "$class")
      if [[ -z "$id" ]]; then
          local top_gap=$(($(xrdb-get-value bar.height) + $(xrdb-get-value bar.border)))
          local width=$(normalize_size 100% $(focused_monitor_width))
          local height=$(normalize_size 50% $(focused_monitor_height))

          bspc rule --add "*:$class" state=floating sticky=on border=off rectangle=${width}x${height}+0+${top_gap}
          term --name="$class" -e /bin/sh -c "tmux attach-session -t$class || tmux new-session -s$class"
      else
          bspc node $id --flag hidden
          bspc node -f $id
      fi
  }

  # a scratchpad terminal that is unique to current desktop
  function scratchpad_bot {
      desktop_id=$(($(xdotool get_desktop) + 1))
      class="padbot${desktop_id}"
      id=$(xdotool search --classname --class "$class")
      if [[ -z "$id" ]]; then
          local width=$(normalize_size 100% $(focused_monitor_width))
          local height=$(normalize_size 50% $(focused_monitor_height))

          bspc rule --add "*:$class" state=floating sticky=off border=off rectangle=${width}x${height}+0+$(($(focused_monitor_height) - height))
          term --name="$class" -e /bin/sh -c "tmux attach-session -t$class || tmux new-session -s$class"
      else
          bspc node "$id" --flag hidden
          bspc node -f "$id"
      fi
  }

  # center current floating window in x-axis. if $1 is true, also centers in
  # y-axis. rest of the arguments are passed
  function center_floating {
      wid=''

      center_y=0
      if [[ "$1" = "true" ]]; then
          center_y=1
          shift
      fi

      # wait until the window shows up and set $wid
      if [[ -n "$1" ]]; then
          wid=$(xdotool search --sync "$@")
      else
          wid=$(xdotool getactivewindow)
      fi

      SCREEN_WIDTH=$(focused_monitor_width)
      SCREEN_HEIGHT=$(focused_monitor_height)
      WIDTH=$(xwininfo -id "$wid" | grep Width | cut -d: -f2 | xargs)
      HEIGHT=$(xwininfo -id "$wid" | grep Height | cut -d: -f2 | xargs)
      X=$(((SCREEN_WIDTH - WIDTH) / 2 + $(focused_monitor_x_offset)))
      Y=$(((SCREEN_HEIGHT - HEIGHT) / 2 + $(focused_monitor_y_offset)))

      if [[ "$center_y" = 1 ]]; then
          xdotool windowmove "$wid" $X $Y
      else
          xdotool windowmove "$wid" $X y
      fi
  }

  function move_floating {
      wid=''
      position=$1
      shift

      # wait until the window shows up and set $wid
      if [[ -n "$1" ]]; then
          wid=$(xdotool search --sync "$@")
      else
          wid=$(xdotool getactivewindow)
      fi

      SCREEN_WIDTH=$(focused_monitor_width)
      SCREEN_HEIGHT=$(focused_monitor_height)
      WIDTH=$(xwininfo -id "$wid" | grep Width | cut -d: -f2 | xargs)
      HEIGHT=$(xwininfo -id "$wid" | grep Height | cut -d: -f2 | xargs)
      GAP=10
      OFFSET_X=$(($(focused_monitor_x_offset) + GAP))
      OFFSET_Y=$(($(focused_monitor_y_offset) + GAP))

      case $position in
          Q) xdotool windowmove "$wid" $OFFSET_X $((OFFSET_Y + $(xrdb-get-value bar.height))) ;;
          W) xdotool windowmove "$wid" $((SCREEN_WIDTH + OFFSET_X - 2 * GAP - WIDTH)) $((OFFSET_Y + $(xrdb-get-value bar.height))) ;;
          A) xdotool windowmove "$wid" $OFFSET_X $((SCREEN_HEIGHT + OFFSET_Y - 2 * GAP - HEIGHT)) ;;
          S) xdotool windowmove "$wid" $((SCREEN_WIDTH + OFFSET_X - 2 * GAP - WIDTH)) $((SCREEN_HEIGHT + OFFSET_Y - 2* GAP - HEIGHT)) ;;
      esac
  }

  function toggle_inactive_opacity {
      if grep 'inactive-opacity = 0.9' ~/.config/picom.conf; then
          sed -i 's/inactive-opacity = 0.9/inactive-opacity = 1/g; s/inactive-dim = 0.1/inactive-dim = 0/g' ~/.config/picom.conf
      else
          sed -i 's/inactive-opacity = 1/inactive-opacity = 0.9/g; s/inactive-dim = 0/inactive-dim = 0.1/g' ~/.config/picom.conf
      fi
  }


  cmd="$1"; shift
  "$cmd" "$@"
#+end_src
** .scripts/cb-save
#+begin_src bash :tangle ~/.scripts/cb-save
  #!/bin/sh

  # Save the image in clipboard to given file name.
  # If first argument is `--display` or `-d`, instead
  # of saving, it will show the image in the image viewer.

  if [ "$1" = "--display" ] || [ "$1" = "-d" ]; then
      file=$(mktemp "XXXXX.png")
      if xclip -selection clipboard -t image/png -o > "$file"; then
          feh "$file"
      else
          notify-send "Error" "No images in clipboard"
      fi
  else
      xclip -selection clipboard -t image/png -o > "$*"
  fi
#+end_src
** .scripts/chroot-galileo
#+begin_src bash :tangle ~/.scripts/chroot-galileo
  #!/bin/sh
  udisksctl unmount -b /dev/mmcblk0p3
  sudo mount --bind /dev /run/media/isa/56bea387-98cc-4d93-a36a-268fbcc0213f/dev
  sudo mount --bind /proc /run/media/isa/56bea387-98cc-4d93-a36a-268fbcc0213f/proc
  sudo mount --bind /dev/pts /run/media/isa/56bea387-98cc-4d93-a36a-268fbcc0213f/dev/pts
  sudo mount --bind /sys /run/media/isa/56bea387-98cc-4d93-a36a-268fbcc0213f/sys
  sudo mount --bind /etc/resolv.conf /run/media/isa/56bea387-98cc-4d93-a36a-268fbcc0213f/etc/resolv.conf

  sudo chroot /run/media/isa/56bea387-98cc-4d93-a36a-268fbcc0213f /bin/bash

  sudo umount /run/media/isa/56bea387-98cc-4d93-a36a-268fbcc0213f/{dev/pts,dev,sys,proc,}
#+end_src
** .scripts/focus-or-run
#+begin_src bash :tangle ~/.scripts/focus-or-run
  #!/bin/bash

  declare -A WM_CLASSES
  WM_CLASSES=(
    ["vivaldi"]="Vivaldi-stable"
    ["vivaldi-stable"]="Vivaldi-stable"
    ["emacs"]="Emacs"
    ["emacsclient"]="Emacs"
  )

  # This only gets the first part of the command:
  #   focus-or-run emacsclient -c
  # then EXEC will be emacsclient so that we can easly match from the map above.
  EXEC=$1
  CLASS=${WM_CLASSES["$EXEC"]}

  if [[ -z $CLASS ]] || ! xdo activate -N "$CLASS"; then
      echo "Running."
      "$@"
  else
      echo "Focused."
  fi
#+end_src
** .scripts/fuzzy
#+begin_src bash :tangle ~/.scripts/fuzzy
  #!/bin/bash
  # Some sources that I used:
  # https://bluz71.github.io/2018/11/26/fuzzy-finding-in-bash-with-fzf.html
  # https://github.com/DanielFGray/fzf-scripts

  # These are generally console-spesific stuff. For other interactive fuzzy
  # finding stuff check out ~/.scripts/menu (it uses rofi and there are stuff
  # for music, apps, passwords etc.).

  function fzf_git_add {
      local files=$(git "$@" ls-files --modified --others --exclude-standard | fzf --multi --ansi --preview="git $* diff --color=always {1}")
      if [ -n "$files" ]; then
          git "$@" add --verbose $files
      fi
  }

  function fzf_git_files {
      local files=$(git "$@" ls-files | fzf --multi --ansi)
      if [ -n "$files" ]; then
          $EDITOR $files
      fi
  }

  # FIXME: execute
  function fzf_git_log {
      git "$@" log --graph --color=always --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" |
      fzf --ansi --preview "echo {} | grep -o '[a-f0-9]\{7\}' | head -1 | xargs -I % sh -c 'git $* show --color=always %'" \
                 --bind "enter:execute:
                    (grep -o '[a-f0-9]\{7\}' | head -1 |
                    xargs -I % sh -c 'git show --color=always % | bat') << 'FZF-EOF'
                    {}
                    FZF-EOF"
  }

  function fzf_kill {
      local pids=$( ps -u $USER -o pid:7,comm,pcpu:7,%mem:7,rss:8,cmd:500 --sort=-rss | fzf --multi --preview '' | tr -s [:blank:] | cut -d' ' -f2)
      if [ -n "$pids" ]; then
          echo "$pids" | xargs kill -9 "$@"
      fi
  }

  function fzf_packages_arch {
      local packages=$(fzf --height 100% \
                           --ansi \
                           --multi \
                           --preview="$AUR_HELPER -Si {2}" \
      < <( $AUR_HELPER -Ss "$1" |
        gawk '{
          getline descr;
          sub(/ */,"", descr);
          repo = blue "[" gensub(/\/.*/, "", 1) "]" reset;
          name = green gensub(/.*\//, "", 1, $1) reset;
          info = gensub(/[^ ]* /, "", 1);
          print repo, name, info, descr;
        }' blue="$(tput setaf 4)" green="$(tput setaf 10)" reset="$(tput sgr0)"
      ) | cut -d' ' -f2)
      [[ -n "$packages" ]] && $AUR_HELPER -S ${packages}
  }

  function fzf_file_contents {
      result=$(rg --no-text --line-number --color=always --colors match:fg:white . "$@" | fzf --ansi --preview '
      line={};
      file=${line%%:*};
      linum=${${line#*:}%%:*};
      range=$(($linum - $LINES / 2));
      range_cmd=$([[ $range -gt -1 ]] && echo "--line-range");
      range_cmd_arg=$([[ $range -gt -1 ]] && echo $range:);
      bat --color=always --style=header,numbers "$file" --highlight-line $linum $range_cmd $range_cmd_arg')
      selected_files=$(echo "$result" | cut -d: -f1)
      [[ -n $selected_files ]] && jaro --no-stdin "$selected_files"
  }

  case "$*" in
      ,*help) echo "fuzzy [git (add|files|log)|kill|pacman|file-contents]" ;;
      "git add"*) shift 2; fzf_git_add "$@" ;;
      "git files"*) shift 2; fzf_git_files "$@" ;;
      "git log"*) shift 2; fzf_git_log "$@" ;;
      kill|fuck) shift; fzf_kill "$@" ;;
      pac*) shift; fzf_packages_arch "$@" ;;
      file*|contents) shift; fzf_file_contents "$@" ;;
      "") fzf;;
  esac
#+end_src
** .scripts/getpassword
#+begin_src bash :tangle ~/.scripts/getpassword
  #!/bin/bash

  # This script gets the requested password from a keepass file.
  # It uses gnome-keyring to get password for kdbx file.
  # $KEYRING_ID is the name of password field for your keepass database
  # in gnome-keyring.
  # Save your keepass database password to keyring like this:
  # secret-tool store --label=KeePassDbPassword name keepass

  # Usage:
  # getpassword "/path/to/password/entry"            → prints entry's password from keepass db
  # getpassword "/path/to/password/entry" --username → prints only username
  # getpassword "/path/to/password/entry" --dump     → prints both username and password
  # getpassword --keepass                            → print PASSWORD_STORE's password
  # getpass --list                                   → list PASSWORD_STORE's entries under
  # getpass --list "Social"                          → list PASSWORD_STORE's entries under /Social
  #
  # $PASSWORD_STORE is defined in ~/.profile, it points to a .kdbx file


  KEYRING_ID=keepass
  PASSWORD_PATH="$1"

  function trim {
      local var="${*:-$(</dev/stdin)}"
      var="${var#"${var%%[![:space:]]*}"}"
      var="${var%"${var##*[![:space:]]}"}"
      echo -n "$var"
  }

  if [[ "$1" == "--keepass" ]]; then
      secret-tool lookup name "$KEYRING_ID"
      exit
  elif [[ "$1" == "--list" ]]; then
      secret-tool lookup name keepass | keepassxc-cli ls "$PASSWORD_STORE" "$2"
      exit
  fi

  password=$(secret-tool lookup name "$KEYRING_ID")
  info=$(echo "$password" | keepassxc-cli show --show-protected --quiet "$PASSWORD_STORE" "$PASSWORD_PATH")
  username=$(echo "$info" | grep -i "username: " | cut -d: -f2 | trim)
  password=$(echo "$info" | grep -i "password: " | cut -d: -f2 | trim)

  case "$2" in
      "-dump-all"|"--dump-all") echo "$info" | tail -n +2 ;;
      "-dump"|"--dump")         echo "$username"; echo "$password" ;;
      "-username"|"--username") echo "$username" ;;
      ,*) echo "$password" ;;
  esac
#+end_src
** .scripts/init-desktops
#+begin_src bash :tangle ~/.scripts/init-desktops
  #!/usr/bin/env bash

  # This script is responsible for creating polybar instance and configuring
  # monitors, desktops. You can run this file if you connect a new monitor and
  # it will rearrange everything.

  # Close all instances of polybar
  killall -q polybar
  while pgrep -u $UID -x polybar >/dev/null; do sleep 1; done

  # Check if there are more than one monitors
  # if so, set MONITOR_MAIN and MONITOR_SECONDARY accordingly
  monitors="$(xrandr -q | grep -w "connected" | cut -d' ' -f1)"

  export MONITOR_MAIN=""
  export MONITOR_SECONDARY=""

  # External monitor should be the main monitor, if exists
  case "$monitors" in
      ,*HDMI1*) export MONITOR_MAIN="HDMI1" ;;
      ,*HDMI2*) export MONITOR_MAIN="HDMI2" ;;
      ,*HDMI-1*) export MONITOR_MAIN="HDMI-1" ;;
      ,*HDMI-2*) export MONITOR_MAIN="HDMI-2" ;;
      ,*DP1*) export MONITOR_MAIN="DP1" ;;
      ,*DP2*) export MONITOR_MAIN="DP2" ;;
      ,*VGA1*) export MONITOR_MAIN="VGA1" ;;
      ,*VGA2*) export MONITOR_MAIN="VGA2" ;;
  esac

  if [[ -z "$MONITOR_MAIN" ]]; then
      export MONITOR_MAIN=$(echo "$monitors" | cut -d' ' -f1)
  fi

  polybar main &

  # Run secondary polybar, if there is a secondary monitor
  MONITOR_SECONDARY=$(sed "/$MONITOR_MAIN/d" <<< $monitors)
  [[ -n "$MONITOR_SECONDARY" ]]; polybar secondary &

  # Set background
  feh --bg-scale "$HOME/.config/wall.png"

  # Create 5 desktops for each monitor
  xrandr -q | grep -w "connected" | cut -d' ' -f1 | xargs -I {} bspc monitor "{}" --reset-desktops I II III IV V VI VII VIII IX X
#+end_src
** .scripts/lockscreen
#+begin_src bash :tangle ~/.scripts/lockscreen
  #!/bin/bash


  FIREFOX_PID=$(pidof firefox | awk '{print $1}')
  QUTEBROWSER_PID=$(pidof qutebrowser | awk '{print $1}')

  [[ -n $FIREFOX_PID ]] && FIREFOX_PPID=$(ps -o ppid= "$FIREFOX_PID")
  [[ -n $QUTEBROWSER_PID ]] && QUTEBROWSER_PPID=$(ps -o ppid= "$QUTEBROWSER_PID")

  kill -STOP $FIREFOX_PPID
  mediastuff all_pause

  if [[ ! -d ~/.cache/i3lock/current/ ]] || [[ ~/.config/wall.png -nt ~/.cache/i3lock/current/wall.png ]]; then
      notify-send "Locking" "Updating lockscreen stuff... This may take some time."
      betterlockscreen -u ~/.config/wall.png
  fi

  betterlockscreen --text "I WANNA FUCKING KILL MYSELF" --lock blur

  [[ -n $FIREFOX_PID ]] && kill -CONT "$FIREFOX_PPID"
  [[ -n $QUTEBROWSER_PID ]] && kill -CONT "$QUTEBROWSER_PPID"
#+end_src
** .scripts/mailcheck
#+begin_src bash :tangle ~/.scripts/mailcheck
  #!/usr/bin/env python
  import sys
  import argparse

  parser = argparse.ArgumentParser()
  parser.add_argument('-u', '--user', type=str, action='append',
                      help="You can pass multiple users/passwords/servers. Like 'mailcheck --user user1 --password password1 --server server1 --user user2 --password password2 --server server2'")
  parser.add_argument('-p', '--password', type=str, action='append')
  parser.add_argument('-s', '--server', type=str, action='append',
                      help="The IMAP server address like 'imap.gmail.com'. For ProtonMail, use 'proton' or 'pm'.")
  parser.add_argument('-S', '--separator', type=str, default="/",
                      help="Separator string for separating unread count of different accounts. Default: '/'")
  parser.add_argument('-d', '--dump', type=str, default="",
                      help="Dump output to a file.")
  parser.add_argument('-f', '--fail-on-zero', default=False, action='store_true',
                      help="If set, exit with 1 if all mailboxes have 0 unread mail.")
  cfg, other_cfg = parser.parse_known_args()

  results = []
  for user, password, server in zip(cfg.user, cfg.password, cfg.server):
      try:
          if server in ('pm', 'proton', 'protonmail'):
              from protonmail.client import Client
              import logging
              logging.getLogger('twisted').propagate = False
              for key in logging.Logger.manager.loggerDict:
                  logging.getLogger(key).propagate = False
                  logging.getLogger(key).setLevel(logging.CRITICAL)

              client = Client(Username=user, blocking=True)
              client.api.login(password)
              response = client.api.conversations.count()
              response_code = response['Code']
              total_unread = 0
              if response_code == 1000:
                  for count in response['Counts']:
                      total_unread = total_unread + count['Unread']
              results.append(total_unread)
          else:
              import imaplib
              mail = imaplib.IMAP4_SSL(server)
              mail.login(user, password)
              mail.select("inbox", True)
              return_code, ids = mail.search(None, 'UnSeen')

              if return_code == 'OK':
                  count = len([x for x in ids[0].split(b' ') if x])
                  results.append(count)
              else:
                  print(return_code)
                  sys.exit(255)
      except:
          results.append(-1)

  is_all_zero = all([x == 0 for x in results])
  if cfg.fail_on_zero and is_all_zero:
      sys.exit(1)

  if is_all_zero:
      output = "0"
  else:
      output = cfg.separator.join(map(lambda x: str(x), results))

  print(output)

  if cfg.dump:
      with open(cfg.dump, "w") as f:
          f.write(output)
#+end_src
** .scripts/mediastuff
#+begin_src bash :tangle ~/.scripts/mediastuff
  #!/bin/bash

  # This whole script is based on the fact that I'm not that retard to
  # listen/watch more than one audio/video streams at the same time.
  # If I do, I'll get punished for that sin.

  MPV_SOCKET=/tmp/mpvsocket

  mpv_pause() {
      echo '{ "command": ["set_property", "pause", true] }' | socat - "$MPV_SOCKET"
  }

  mpv_toggle() {
      echo '{"command": ["cycle", "pause"]}' | socat - "$MPV_SOCKET"
  }

  mpv_seek() {
      if [[ $1 == *% ]]; then # seek $1 percent
          echo 'percent'
          echo '{"command": ["seek", "'"${1%\%}"'",  "relative-percent"]}' | socat - "$MPV_SOCKET"
      else # seek $1 seconds
          echo '{"command": ["seek", "'"$1"'"]}' | socat - "$MPV_SOCKET"
      fi
  }

  # TODO: somehow pause videos/audios playing in firefox/qutebrowser
  all_pause() {
      mpv_pause
      mpc pause
  }

  all_toggle() {
      # Give priority to mpv
      if pgrep mpv; then
          mpv_toggle
      else
          mpc toggle
      fi
  }

  all_seek() {
      if pgrep mpv; then
          mpv_seek "$@"
      else
          mpc seek "$@"
      fi
  }

  get_sink_name_from_sink_id() {
      local ids="${1:-$(</dev/stdin)}"
      echo "$ids" | while read -r id; do
          echo "($id) $(pactl list sinks | grep -E "(Sink #$id)|(device.description)" | grep -A1 "Sink #$id" | sed -n "2p" | cut -d'"' -f2)"
      done
  }

  switch_audio_channel() {
      if [[ $1 = "--help" ]]; then
          echo "Changes default sink to next one and moves all inputs to new default sink."
          echo "Try to use it when something is already playing."
      fi

      readarray -t sinks <<< "$(pactl list sinks short | cut -f1)"
      readarray -t inputs <<< "$(pactl list sink-inputs short | cut -f1)"
      current_sink=$(pactl list sinks short | grep "RUNNING" | head -c 1)

      if [[ -z $current_sink ]]; then
          notify-send "Error while switching audio channels" "Could not detect default sink. Playing something may help."
          exit 1
      fi

      if [[ $1 = --interactive ]]; then
          new_sink=$(printf "%s\n" "${sinks[@]}" | get_sink_name_from_sink_id | rofi -dmenu | grep -Po "\(\K[0-9]*")
      else
          new_sink=${sinks[0]}
          for sink in "${sinks[@]}"; do
              if (( sink > current_sink )); then
                  new_sink="$sink"
                  break
              fi
          done
      fi

      [[ -z $new_sink ]] && exit;

      notify-send "Switching audio channel" "New default channel is $(get_sink_name_from_sink_id $new_sink), moving all inputs to that."

      # Move every input to new sink
      for input in "${inputs[@]}"; do
          pacmd move-sink-input "$input" "$new_sink"
      done

      # Make new sink the default
      pactl set-default-sink "$new_sink"
  }

  connect_bt_headphones() {
      if ! rfkill | grep "bluetooth.*unblocked"; then
          notify-send "Bluetooth Headphones" "Activating bluetooth... Please enter your password to unlock it."
          SUDO_ASKPASS="$HOME/.scripts/askpass" sudo rfkill unblock 0
          sleep 2
      fi

      TAB="$(printf '\t')"
      bluetoothctl << EOF
  power on
  connect BC:${TAB}
  quit
  EOF

      notify-send "Bluetooth Headphones" "Connection will be established in just a moment..."
  }

  mpv_subdl() {
      # This script is called from mpv and it downloads subtitle using `subdl`, then
      # loads downloaded subtitle into mpv.

      MPV_SOCKET=/tmp/mpvsocket
      file_path=$1
      language=$2

      echo 'show-text "Downloading subtitle..."' | socat - $MPV_SOCKET
      if subdl --lang="$language" "$file_path"; then
          echo 'show-text "Subtitle downloaded."' | socat - $MPV_SOCKET
          sub_file_path="${file_path%.*}.srt"
          echo "sub-add \"$sub_file_path\"" | socat - $MPV_SOCKET
      else
          echo 'show-text "Error while downloading subtitle!"' | socat - $MPV_SOCKET
      fi
  }


  opt=$1; shift
  case "$opt" in
      ,*help) echo "mediastuff [mpv-(subdl|toggle|pause|seek)|all-(toggle|pause|seek)|switch-audio-channel|connect-bt-headphones]" ;;
      mpv*toggle)              mpv_toggle              "$@" ;;
      mpv*pause)               mpv_pause               "$@" ;;
      mpv*seek)                mpv_seek                "$@" ;;
      all*toggle)              all_toggle              "$@" ;;
      all*pause)               all_pause               "$@" ;;
      all*seek)                all_seek                "$@" ;;
      switch*audio*channel)    switch_audio_channel    "$@" ;;
      connect*bt*headphones)   connect_bt_headphones   "$@" ;;
      mpv*subdl)               mpv_subdl               "$@" ;;
  esac
#+end_src
** .scripts/menu
#+begin_src bash :tangle ~/.scripts/menu
  #!/bin/bash

  # I use API of the invidious to interact with youtube
  # https://github.com/iv-org/invidious/wiki/API
  INVIDIOUS_INSTANCE="https://invidious.snopyta.org/api/v1"

  all_name='[ALL]'

  function trim {
      local var="${*:-$(</dev/stdin)}"
      var="${var#"${var%%[![:space:]]*}"}"
      var="${var%"${var##*[![:space:]]}"}"
      echo -n "$var"
  }

  function dmenu {
      # TODO: use fzf inside terminal
      rofi -dmenu -fuzzy -i "$@"
  }

  function _mpd-artists {
      mpc list artist | sort -f | dmenu -columns 4 -p artist
  }

  function _mpd-albums {
      local artist="$1"
      local albums

      mapfile -t albums < <(mpc list album artist "$artist")
      if (( ${#albums[@]} > 1 )) ; then
          {
              printf '%s\n' "$all_name"
              printf '%s\n' "${albums[@]}" | sort -f
          } | dmenu -p album
      else
          # We only have one album, so just use that.
          printf '%s\n' "${albums[0]}"
      fi
  }

  function mpd-playlist {
      local format="%position% - %title% - %album% - %artist%"
      local track

      track=$(mpc playlist -f "$format" | dmenu -i -p track)
      track=$(printf '%s' "${track%% *}")

      [[ -z $track ]] || mpc play $track
  }

  function mpd-artists {
      local artist=$(_mpd-artists)
      [[ $artist ]] || exit 1

      local album=$(_mpd-albums "$artist")
      #[[ $album ]] || exit 2

      if [[ $album == "$all_name" ]]; then
          mpc clear
          mpc find artist "$artist" | sort | mpc add
          mpc play
      else
          local songs=$(mpc find artist "$artist" album "$album")
          if [[ -z "$songs" ]] && [[ -n "$artist" ]]; then
              [[ -n "$album" ]] && menu youtube "$artist $album"
          else
              mpc clear
              echo "$songs" | sort | mpc add
              mpc play
          fi
      fi
  }

  function mpd-all {
      # Show all music files and play selected one. (If it'ts not found search
      # in youtube.)

      local SONG=$(mpc listall | dmenu)
      if [ -n "$SONG" ]; then
          if ! mpc add "$SONG" && [[ -n "$SONG" ]]; then
              menu youtube "$SONG"
          else
              mpc play "$(mpc playlist | wc -l)" # Play the last (just added) song
          fi
      fi
  }

  function youtube {
      # Search given string in youtube and show results. Play selected one in mpd or mpv.

      for arg; do
          case "$arg" in
              "--audio"|"--music") local AUDIO=1                               ;;
              "--video")           local VIDEO=1                               ;;
              "--playlist="*)      local PLAYLIST=${arg/*=/}                   ;;
              ,*)                   local SEARCH_STRING="${SEARCH_STRING} $arg" ;;
          esac
      done

      local SEARCH_HISTORY_FILE="$HOME/.cache/menu_youtube_history"
      if [[ -z "$PLAYLIST" && -z "$SEARCH_STRING" ]]; then
          SEARCH_STRING=$(dmenu -p "search yt" < "$SEARCH_HISTORY_FILE")
          echo "$SEARCH_STRING" >> "$SEARCH_HISTORY_FILE"
          local HISTORY=$(sort -u "$SEARCH_HISTORY_FILE" | uniq "$SEARCH_HISTORY_FILE" | sed '/^\s*$/d')
          echo "$HISTORY" > "$SEARCH_HISTORY_FILE"
      fi

      [[ -z "$PLAYLIST" && -z "$SEARCH_STRING" ]] && exit

      if [[ -n "$PLAYLIST" ]]; then
          echo "Searching for playlist: $PLAYLIST"
          # TODO: this only fetches first page of the playlist
          # api accepts page url parameter, every page has 100 videos
          local SEARCH_RESULTS=$(curl "$INVIDIOUS_INSTANCE/playlists/$PLAYLIST" | jq '.videos')
      else
          local SEARCH_RESULTS=$(curl -G --data-urlencode "q=$SEARCH_STRING" "$INVIDIOUS_INSTANCE/search")
      fi
      SEARCH_RESULTS=$(echo $SEARCH_RESULTS | sed "s/&/&amp;/g")
      echo "$SEARCH_RESULTS"

      local SELECTED=$( \
          echo "$SEARCH_RESULTS" \
              | jq -r '.[] | "\(.title), <span foreground=\"grey\" size=\"small\">[\((.viewCount // 1000) / 1000 | floor)K views, \(.lengthSeconds / 60 | floor) min]</span>"' \
              | nl -n 'ln' -s '. ' -w1 \
              | dmenu -markup-rows -async-pre-read 0 \
              | cut -d'.' -f1 \
            )

      [[ -z $SELECTED ]] && exit

      local URL="https://youtube.com/watch?v=$(echo "$SEARCH_RESULTS" | jq -r ".[$((SELECTED - 1))].videoId")"
      echo "$URL"

      if [[ $VIDEO = 1 ]]; then
          tsp mpv "$URL"
      else
          mpd-yt play "$URL"
      fi
  }

  function files {
      f=$( ( git --git-dir="$HOME"/.dotfiles/ --work-tree="$HOME" ls-files; fd . --no-ignore-vcs --color=never --max-depth=5 ) | dmenu)

      if [[ "$1" == "--open" ]] && [[ -n "$f" ]]; then
          jaro "$f"
      else
          echo "$f"
      fi
  }

  function folders {
      f=$(fd . "$HOME" --no-ignore-vcs --color=never --type=d --max-depth=5 | dmenu)

      if [[ "$1" == "--open" ]] && [[ -n "$f" ]]; then
          jaro "$f"
      else
          echo "$f"
      fi
  }

  function file_contents {
      term --name="tophalf" -e /bin/sh -c "fuzzy file-contents Documents \$(git --git-dir="$HOME"/.dotfiles/ --work-tree="$HOME" ls-files --full-name)"
  }

  # Use `menu passwords -dump` to print password info into stdout.
  function passwords {
      local PASSWD=$(getpassword --keepass)
      local ENTRY=$(echo "$PASSWD" | keepassxc-cli locate "$PASSWORD_STORE" / | tail -n +2 | dmenu)
      if [ -n "$ENTRY" ]; then
          if [[ "$1" == "-dump" ]]; then
              getpassword "$ENTRY" -dump
          else
              local passinfo=$(getpassword "$ENTRY" --dump-all)
              local otherinfo=$(echo "$passinfo" | awk -F: '/^\[.*]:/ {print $1}')

              local what=$(echo -e "Fill fields (with Tab)\nFill fields (with Enter)\nFill password\n${otherinfo}\nShow all" | dmenu)
              local username=$(echo "$passinfo" | grep -i -m 1 "username" | cut -d: -f2- | trim)
              local password=$(echo "$passinfo" | grep -i -m 1 "password" | cut -d: -f2- | trim)
              case "$what" in
                  "Fill fields (with Tab)")
                      sleep 0.2
                      xdotool type --delay 5 "$username"
                      xdotool key "Tab"
                      xdotool type --delay 5 "$password" ;;
                  "Fill fields (with Enter)")
                      sleep 0.2
                      xdotool type --delay 5 "$username"
                      xdotool key "Return"
                      sleep 0.2
                      xdotool type --delay 5 "$password" ;;
                  "Fill password")
                      sleep 0.2
                      xdotool type --delay 5 "$password" ;;
                  "Show all")
                      local allinfo=$(printf "[username]: $username\\n[password]: $password\\n$passinfo" | awk -F: '/^\[.*]:/ {printf("%-40s%-70s\n",$1,$2)}' | dmenu -i | cut -d']' -f2- | trim | xclip -selection clipboard) ;;
                  ,*)
                      echo "$passinfo" | grep -iF -m 1 "$what" | cut -d: -f2- | trim | xclip -selection clipboard ;;
              esac
              notify-send --expire-time=1000 'password-menu' 'Done.'
          fi
      fi

      # Clear clipboard after 20 secs
      if [[ ! "$1" == "-dump" ]]; then
          local secs=$((20))
          while [ $secs -gt 0 ]; do
             echo -ne "$secs\033[0K\r"
             sleep 1
             : $((secs--))
          done

          echo "" | xclip -selection clipboard
      fi
  }

  function bookmarks {
      grep -E '^*' ~/Documents/notes/bookmarks.org | grep '\[\[' | sed -E 's/\[\[(.*)\]\[(.*)\]\]/\2  <span foreground="grey" size="small">\1<\/span>/; s/\**//' | dmenu -i -markup-rows | grep -Eo 'https?://[^ ]+' | sed 's/<\/span>//' | jaro
  }


  cmd="$1"
  shift
  case $cmd in
      ,*help) echo "menu [mpd-(artists|all|playlist)|youtube|files|folders|file-contents|passwords]";;
      mpd-artists) mpd-artists "$@";;
      mpd-all) mpd-all "$@";;
      mpd-playlist) mpd-playlist "$@";;
      youtube) youtube "$@";;
      files) files "$@";;
      folders) folders "$@";;
      file*contents) file_contents "$@";;
      passwords) passwords "$@";;
      bookmarks) bookmarks "$@";;
      calc*) rofi -show calc -modi calc -no-show-match -no-sort ;;
      ,*) rofi -async-pre-read 0 -modi combi,window,run,vms:rofi_vms,calc -combi-modi window,drun,run -show combi "$@" ;;
  esac
#+end_src
** .scripts/mgm
#+begin_src bash :tangle ~/.scripts/mgm
  #!/bin/bash

  API="https://servis.mgm.gov.tr/web/"
  UA="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36"
  headers=('-H' "Origin: https://mgm.gov.tr" '-H' "Host: mgm.gov.tr" '-H' "User-Agent: $UA")

  parse_event() {
      event=""
      case $1 in
          "A") event="Açık" ;;
          "AB") event="Az Bulutlu" ;;
          "PB") event="Parçalı Bulutlu" ;;
          "CB") event="Çok Bulutlu" ;;
          "HY") event="Hafif Yağmurlu" ;;
          "Y") event="Yağmurlu" ;;
          "KY") event="Kuvvetli Yağmurlu" ;;
          "KKY") event="Karla Karışık Yağmurlu" ;;
          "HKY") event="Hafif Kar Yağışlı" ;;
          "K") event="Kar Yağışlı" ;;
          "YKY") event="Yoğun Kar Yağışlı" ;;
          "HSY") event="Hafif Sağanak Yağışlı" ;;
          "SY") event="Sağanak Yağışlı" ;;
          "KSY") event="Kuvvetli Sağanak Yağışlı" ;;
          "MSY") event="Mevzi Sağanak Yağışlı" ;;
          "DY") event="Dolu" ;;
          "GSY") event="Gökgürültülü Sağanak Yağışlı" ;;
          "KGY") event="Kuvvetli Gökgürültülü Sağanak Yağışlı" ;;
          "SIS") event="Sisli" ;;
          "PUS") event="Puslu" ;;
          "DMN") event="Dumanlı" ;;
          "KF") event="Kum veya Toz Taşınımı" ;;
          "R") event="Rüzgarlı" ;;
          "GKR") event="Güneyli Kuvvetli Rüzgar" ;;
          "KKR") event="Kuzeyli Kuvvetli Rüzgar" ;;
          "SCK") event="Sıcak" ;;
          "SGK") event="Soğuk" ;;
          "HHY") event="Yağışlı" ;;
      esac
      echo "$event"
  }

  find_merkez() {
      curl -Gs "${headers[@]}" "${API}merkezler" --data-urlencode "il=$IL" --data-urlencode "ilce=$ILCE" | jq '.[0]'
  }

  get() {
      query=$(echo "$MERKEZ" | jq ".${3}")
      curl -s  "${headers[@]}" "${API}${1}?${2}=${query}" | jq '.[0]'
  }


  RAW="no"
  if [ $1 = "--help" ] || [ $1 = "-h" ]; then
      echo "mgm IL ILCE"
      echo "mgm --raw IL ILCE"
      echo
      echo "- ILCE is optional."
      exit
  elif [ $1 = "--raw" ] || [ $1 =  "-r" ]; then
      shift
      RAW=yes
  fi

  IL="$1"
  ILCE="$2"
  MERKEZ=$(find_merkez "$IL" "$ILCE")

  #get "sondurumlar" "merkezid" "merkezId"
  #get "tahminler/saatlik" "istno" "saatlikTahminIstNo"
  #get "tahminler/gunluk" "istno" "gunlukTahminIstNo"


  sondurum=$(get "sondurumlar" "merkezid" "merkezId")
  if [ $RAW = "yes" ]; then
      echo "$sondurum"
  else
      humidity=$(echo "$sondurum" | jq '.nem')
      temperature=$(echo "$sondurum" | jq '.sicaklik')
      rainChance=$(echo "$sondurum" | jq '.yagis00Now')
      event=$(parse_event "$(echo "$sondurum" | jq -r '.hadiseKodu')")

      echo "SONDURUM"
      echo "========"
      echo "Hadise:           $event"
      echo "Sicaklik:         $temperature"
      echo "Nem:              $humidity"
      echo "Yagmur olasiligi: $rainChance"
  fi

  # TODO: add peak points
#+end_src
** .scripts/monitor-kb-change
#+begin_src python :tangle ~/.scripts/monitor-kb-change
  #! /usr/bin/env python3

  # Whenever I connect a new keyboard, I need to run xmodmap and restart xcape.
  # This script does this automatically.

  import pyudev
  import time
  import subprocess
  import argparse


  def reload_keyboard_settings(device):
      # My keyboard, from the output of `lsusb`
      if not "045e:07a5".upper() in device.device_path.upper():
          return

      time.sleep(1)
      xmod = subprocess.run("xmodmap ~/.Xmodmap", shell=True, capture_output=True)
      xcape = subprocess.run("killall xcape", shell=True, capture_output=True) # systemd will restart it

  #
  # Init
  #
  ctx = pyudev.Context()
  monitor = pyudev.Monitor.from_netlink(ctx)
  monitor.filter_by("input")

  for device in iter(monitor.poll, None):
      if device.action != "add" or not device.is_initialized:
          continue

      reload_keyboard_settings(device)

#+end_src
** .scripts/mpd-yt
#+begin_src bash :tangle ~/.scripts/mpd-yt
  #!/bin/bash

  # Play youtube link using mpd.
  # Usage: mpd-yt [play|add] [youtube_url|direct_music_link] [OPTIONAL: track_name] [OPTIONAL: album_name] [OPTIONAL: artist_name]

  cmd="$1"
  url="$2"
  track="$3"
  album="$4"
  artist="$5"
  port=6600

  function send_mpd_command {
      mpd_command="$1"
      mpd_id="$2"
      mpd_args="$3"
      echo -e "$mpd_command $mpd_id $mpd_args\nclose" | nc localhost $port
  }

  if [[ $url = *"youtube.com/watch"* ]]; then
      info_all=$(youtube-dl -f 'bestaudio[ext=m4a]' -o "%(title)s ^ %(duration)s ^ %(artist)s ^ %(album)s ^ %(track)s" "$url" -g --get-filename)
      url=$(echo $info_all | cut -d" " -f1)
      info=$(echo $info_all | cut -d" " -f2-)
      echo $info_all

      video_name=$(echo $info | cut -d^ -f1 | xargs)
      [[ -z $artist ]] && artist=$(echo $info | cut -d^ -f3 | xargs)
      [[ -z $album ]] && album=$(echo $info | cut -d^ -f4 | xargs)
      [[ -z $track ]] && track=$(echo $info | cut -d^ -f5 | xargs)
      [[ $track == "NA" ]] && track=$video_name
  fi

  while read answer; do
      read id_answer
      id=$(echo $id_answer | cut -d: -f2 | xargs)
      send_mpd_command addtagid $id "title \"$track\""
      send_mpd_command addtagid $id "artist \"$artist\""
      send_mpd_command addtagid $id "album \"$album\""

      [[ $cmd = "play" ]] && send_mpd_command playid $id
      exit
  done < <(echo -e "addid $url\nclose" | nc localhost $port)
#+end_src
** .scripts/phone
#+begin_src bash :tangle ~/.scripts/phone
  #!/bin/sh

  # - Set SSH_PASSWORD variable if you want to auto-login.
  # - Some commands have interactive versions, they are prefixed with i.
  #   ex. cl = icl

  PORT=2222
  MOUNT_POINT="$HOME/Workspace/phone"

  adb_forward() {
      adb devices | grep -i unauthorized && echo "Look at your phone and accept the connection request." && exit
      adb forward tcp:2222 tcp:2222
  }

  connection_addr() {
      # TODO: if adb devices is empty, connect trough wifi
      adb_forward
      printf "localhost"
  }

  run_command() {
      if command -v sshpass >/dev/null 2>&1 && [ -n "$SSH_PASSWORD" ]; then
          sshpass -p "$SSH_PASSWORD" ssh -p $PORT "$(connection_addr)" "$@"
      else
          ssh -p $PORT "$(connection_addr)" "$@"
      fi
  }

  contact_list_interactive() {
      field=$1
      search_str=$2
      cmd=$3

      output=$(run_command termux-contact-list | jq "map(select(.name | test(\"$search_str\"; \"i\")))")
      echo "$output" | jq '.[]'

      echo "=============="
      printf "Which one? (Indexes start from 0!)\n> "
      read nth
      echo "=============="

      export RESULT=$(echo "$output" | jq -j ".[$nth]$field")
  }

  case "$1" in
      mount|fs)
          mkdir -p "$MOUNT_POINT"
          sshfs -p $PORT u0_a100@"$(connection_addr)":/storage/emulated/0 "$MOUNT_POINT"
          ;;
      umount|ufs)
          fusermount -u  "$MOUNT_POINT" && rmdir "$MOUNT_POINT" ;;
      ssh)
          TERM=xterm run_command
          ;;
      run|exec)
          shift
          run_command "$@"
          ;;
      contact*search|cs|contact*list|cl)
          shift;
          run_command termux-contact-list | jq "map(select(.name | test(\"$1\"; \"i\")))"
          ;;
      icontact*search|ics|icontact*list|icl)
          shift;
          contact_list_interactive ".number" "$1"
          printf "$RESULT" | xclip -selection clipboard
          ;;
      sms*list|sl)
          shift;
          run_command termux-sms-list | jq "map(select(.sender | test(\"$1\"; \"i\")))"
          ;;
      sms*send|ss)
          shift;
          run_command termux-sms-send "$@"
          ;;
      isms*send|iss)
          shift;
          contact_list_interactive ".number" "$1"
          sms_file=$(mktemp)
          $EDITOR "$sms_file"

          run_command <<EOF
              sms=\$(mktemp)
              printf "$(cat "$sms_file")" > "\$sms"
              termux-sms-send -n "$RESULT" < "\$sms"
              rm "\$sms"
  EOF
          rm "$sms_file"
          ;;
      speak)
          shift;
          run_command termux-tts-speak "$@"
          ;;
  esac
#+end_src
** .scripts/popup
#+begin_src bash :tangle ~/.scripts/popup
  #!/bin/bash

  # BAR_BORDER is the border size of top bar (in my case polybar.)
  # BAR_HEIGHT is the height of top bar.
  # WINDOW_BORDER is the border size of windows.
  BAR_BORDER=$(xrdb-get-value "bar.border")
  BAR_HEIGHT=$(xrdb-get-value "bar.height")
  WINDOW_BORDER=$(xrdb-get-value "wm.border")

  function calendar {
      local GEOMETRY="100x20-$((WINDOW_BORDER + BAR_BORDER))+$((BAR_HEIGHT+BAR_BORDER))"
      local WINDOW_TITLE="calendar-popup-window"

      if [[ $(wmctrl -l) != *$WINDOW_TITLE* ]]; then
          term --float --opaque -T $WINDOW_TITLE -g $GEOMETRY -e ikhal
      else
          wmctrl -c $WINDOW_TITLE && vdirsyncer sync calendar
      fi
  }

  function music {
      MUSIC=ncmpcpp

      local SCREEN_WIDTH=$(bspwmc focused_window_width)
      local Y=$((BAR_HEIGHT+BAR_BORDER*2))
      local GEOMETRY="110x20-$(((SCREEN_WIDTH - 822) / 2))+$Y"
      local WINDOW_TITLE="Music Popup"

      if [[ $(wmctrl -l) != *$WINDOW_TITLE* ]]; then
          term --float --opaque -T "$WINDOW_TITLE" -g $GEOMETRY -e $MUSIC 2> /dev/null &
          bspwmc center_floating --name "$WINDOW_TITLE"
      else
          wmctrl -c "$WINDOW_TITLE"
      fi
  }

  function htop {
      local GEOMETRY="80x9-$((2*WINDOW_BORDER))+$((BAR_HEIGHT+BAR_BORDER*2))"
      local WINDOW_TITLE="Task manager"

      if [[ $(wmctrl -l) != *$WINDOW_TITLE* ]]; then
          term --float --opaque -T "$WINDOW_TITLE" -g $GEOMETRY -e htop
      else
          wmctrl -c "$WINDOW_TITLE"
      fi
  }

  function translate-term {
      local GEOMETRY="100x15-$((WINDOW_BORDER + BAR_BORDER))+$((BAR_HEIGHT+BAR_BORDER))"
      local WINDOW_TITLE="Translator (:set verbose 0/1)"
      local COMMAND="trans -sl en -hl tr -to tr -interactive -v -pager bat"

      if [[ $(wmctrl -l) != *$WINDOW_TITLE* ]]; then
          term --float -e $COMMAND
      else
          wmctrl -c "$WINDOW_TITLE"
      fi
  }

  function translate-gui {
      qdbus io.crow_translate.CrowTranslate /io/crow_translate/CrowTranslate/MainWindow open
  }

  function translate {
      # Use crow-translate if its open
      if pgrep crow; then
          translate-gui
      else
          translate-term
      fi
  }

  function mail {
      local GEOMETRY="100x20-$((WINDOW_BORDER + BAR_BORDER))+$((BAR_HEIGHT+BAR_BORDER))"
      local WINDOW_TITLE="neomutt-popup-window"

      if [[ $(wmctrl -l) != *$WINDOW_TITLE* ]]; then
          term --float --opaque -T $WINDOW_TITLE -g $GEOMETRY -e neomutt
      else
          wmctrl -c $WINDOW_TITLE
      fi
  }

  case "$1" in
      "calendar")   calendar;;
      "mail")       mail;;
      "music")      music;;
      "htop")       htop;;
      "translate")  shift; translate "$@";;
  esac
#+end_src
** .scripts/rofi_vms
#+begin_src bash :tangle ~/.scripts/rofi_vms
  #!/bin/sh

  if [ -z "$*" ]; then
      # VBoxManage seems pretty slow
      #VBoxManage list vms | awk '{ print $1 }' | sed 's/"//g'
      find ~/Workspace/vms/ -mindepth 1 -maxdepth 1 -type d -printf "%f\n"
  else
      coproc VBoxManage startvm "$*"
      exit
  fi
#+end_src
** .scripts/sub-extract
#+begin_src python :tangle ~/.scripts/sub-extract
  #!/bin/python

  import os
  import sys

  def extract_auto():
      """ Automatically find the movie and extract SUB_ARCHIVE with proper name """
      movies = get_movies()
      movies_normalized = list(enumerate(map(normalize, movies)))
      movie_index, _ = max(movies_normalized, key=lambda tup: matches(tup[1]))
      movie_full_path = movies[movie_index]

      extract(movie_full_path)

  def extract_interactive():
      import subprocess
      selected_movie = subprocess \
              .run(['/bin/sh', '-c', 'echo -n "' + '\n'.join(get_movies()) + '" | fzf --header="Subtitle name: '+ SUB_ARCHIVE +'" --preview=""'], stdout=subprocess.PIPE) \
          .stdout.decode('utf-8') \
          .strip()

      if selected_movie != "":
          extract(selected_movie)

  def extract(movie_full_path):
      """ Extract sub file from SUB_ARCHIVE """
      srt_full_path = mk_srt_path(movie_full_path)
      srt_archive_ext = os.path.splitext(SUB_ARCHIVE)[1]

      print("Given sub file: " + SUB_ARCHIVE)
      print("Movie: " + movie_full_path)
      print("Sub  : " + srt_full_path)

      yn = 'y' if NOCONFIRM else input("y/n? ")
      if yn != 'y':
          exit(1)

      if srt_archive_ext == ".zip":
          import zipfile
          with zipfile.ZipFile(SUB_ARCHIVE) as z:
              # Just take the first srt file
              srt_file = list(filter(lambda f: ".srt" in f, [file_info.filename for file_info in z.filelist]))[0]
              with open(srt_full_path, 'wb') as f:
                  f.write(z.read(srt_file))
      elif srt_archive_ext == ".rar":
          import rarfile
          with rarfile.RarFile(SUB_ARCHIVE) as z:
              # Just take the first srt file
              srt_file = list(filter(lambda f: ".srt" in f, z.namelist()))[0]
              with open(srt_full_path, 'wb') as f:
                  f.write(z.read(srt_file))
      else:
          print("wut? (for now)")

      print("Done.")

  # #############################################################################
  # Utility functions
  # #############################################################################
  def get_movies():
      movie_exts = [".mkv", ".mp4", ".avi"]
      movies = []
      for movie_dir in MOVIE_DIRS:
          for root, _, fs in os.walk(movie_dir):
              for f in fs:
                  name, ext = os.path.splitext(os.path.basename(f))
                  # Skip non-movie files and sample files
                  # (and hope the movie name does not contain "sample")
                  if ext in movie_exts and not "sample" in name.lower():
                      movies.append(os.path.join(root, f))
      return movies

  def mk_srt_path(movie_full_path):
      """ Replace movie extension with .srt """
      return os.path.splitext(movie_full_path)[0] + ".srt"

  def normalize(s):
      # 1080p, 720p etc makes matching harder because sometimes the downloaded
      # subtitle has different resolution spec
      return s.lower() \
              .replace("-", " ") \
              .replace(".", " ") \
              .replace("_", " ") \
              .replace("1080p", "") \
              .replace("720p", "") \
              .replace("bdrip", "") \
              .replace("blueray", "") \
              .replace("x264", "")

  def matches(text):
      return sum(word in text for word in SUB_NAME)

  # #############################################################################
  # Here we go
  # #############################################################################

  SUB_ARCHIVE = sys.argv[-1]
  SUB_NAME = normalize(SUB_ARCHIVE).split()
  MOVIE_DIRS = [os.path.expanduser("~/Videos")]
  NOCONFIRM = "--no-confirm" in sys.argv

  if "--movie_dirs" in sys.argv:
      arg_index = sys.argv.index("--movie_dirs")
      MOVIE_DIRS = sys.argv[arg_index + 1].split(",")
      MOVIE_DIRS = [os.path.expanduser(x.strip()) for x in MOVIE_DIRS]
      for mdir in MOVIE_DIRS:
          if not os.path.exists(mdir):
              print("Movie directory does not exist: " + mdir)
              exit(1)

  if "--help" in sys.argv:
      print("sub-extract [--(interactive|auto)] [--noconfirm] [--help] archive-file")
      print("This program extracts a subtitle file from an archive file into the selected movie folder.")
      print("")
      print("\t--auto")
      print("\t\tAutomatically matches the sub file with the movie using some heuristics. (Default)")
      print("\t--interactive")
      print("\t\tOpen fzf to find matching movie file.")
      print("\t--no-confirm")
      print("\t\tDo not ask for user consent and automatically copy the sub file.")
      print("\t--movie-dirs")
      print("\t\tA comma separated list of movie directories that you want to be searched. (Default: ~/Videos)")
      print("\t\tExample: sub-extract --movie-dirs ~/Movies,~/Shows")
  elif os.path.exists(SUB_ARCHIVE):
      if "--auto" in sys.argv and "--interactive" not in sys.argv:
          extract_auto("--noconfirm" in sys.argv)
      elif "--interactive" in sys.argv and "--auto" not in sys.argv:
          extract_interactive()
  else:
      print("File not found: " + SUB_ARCHIVE)
      print("Archive path should be the last argument.")
#+end_src
** .scripts/switch-keyboard-layout
#+begin_src bash :tangle ~/.scripts/switch-keyboard-layout
  #!/bin/sh -

  # This script switches between layouts that are defined in ~/.profile.
  # The variable is $KEYBOARD_LAYOUTS and you need to set a comma separated list
  # that contains 2-char country codes. (Or anything that setxkbmap would accept.)
  # To change your default keyboard layout, use localectl. See this:
  # https://wiki.archlinux.org/index.php/Keyboard_configuration_in_Xorg#Using_X_configuration_files
  # Afterwards you need to update `KEYBOARD_LAYOUTS`, first item must be your default layout.
  # Rest are just the ones that you want to switch.

  function get_current_layout {
      setxkbmap -query | grep layout | cut -f2 -d ":" | xargs
  }

  # Switch to next layout
  current_layout=$(get_current_layout)
  layouts=(${KEYBOARD_LAYOUTS//,/ })
  for i in "${!layouts[@]}"
  do
      if [ "$current_layout" == "${layouts[i]}" ]
      then
          if [ ! "${layouts[i+1]}" ]
          then
              setxkbmap ${layouts[0]}
          else
              setxkbmap ${layouts[i+1]}
          fi
      fi
  done

  # Reload .Xmodmap
  [[ -f ~/.Xmodmap ]] && xmodmap ~/.Xmodmap
#+end_src
** .scripts/take-ss
#+begin_src bash :tangle ~/.scripts/take-ss
  #!/bin/bash

  set -e
  set -o pipefail

  CURRENT_DATE=$(date +%F::%R:%S)

  mkpath() {
      SAVE_PATH="$DIR_SCREENSHOTS/$1-$CURRENT_DATE.png"
      echo "$SAVE_PATH" | xclip -selection clipboard
      echo "$SAVE_PATH"
  }

  case "$1" in
      "--full") maim "$(mkpath full)"; ;;
      "--area") maim -s "$(mkpath area)" ;;
      "--wait-full") maim -d 5 "$(mkpath full)" ;;
      "--wait-area") maim -s -d 5 "$(mkpath area)" ;;
      "--clip-full") maim --hidecursor | xclip -selection clipboard -t image/png ;;
      "--clip-area") maim --hidecursor -s | xclip -selection clipboard -t image/png ;;
      "--edit-area") maim --hidecursor -s > /tmp/sssss.png; pinta /tmp/sssss.png ;;
      "--shadow-window") maim -st 9999999 | convert - \( +clone -background black -shadow 80x3+5+5 \) +swap -background none -layers merge +repage "$(mkpath shadowed)" ;;
  esac

  notify-send "Screenshot" "Screenshot saved and path is copied to clipboard (if any)"
#+end_src
** .scripts/tdk
#+begin_src bash :tangle ~/.scripts/tdk
  #!/bin/bash

  get_response() {
      curl --location --get --silent "http://sozluk.gov.tr/gts" --data-urlencode "ara=$*"
  }

  if [ "$1" = "--raw" ] || [ "$1" = "-r" ]; then
      shift
      response=$(get_response "$*")
      echo "$response" | jq -C | less --RAW-CONTROL-CHARS --quit-if-one-screen
  else
      response=$(get_response "$*")
      echo "$response" | jq -C '.[] | .anlamlarListe | map({tur: (try .ozelliklerListe[].tam_adi catch ""), anlam: .anlam, ornek: (try {cumle: .orneklerListe[].ornek, yazar: .orneklerListe[].yazar[].kisa_adi} catch "")})' | less --RAW-CONTROL-CHARS --quit-if-one-screen
  fi

#+end_src
** .scripts/term
#+begin_src bash :tangle ~/.scripts/term
  #!/bin/bash

  # When using st, it expects window class properties while urxvt expects
  # window name properties for enabling floating windows. So
  # Rule for urxvt:
  # bspc rule --add '*:float'   state=floating
  # Rule for st:
  # bspc rule --add 'float'     state=floating

  # st, urxvt, urxvtc, alacritty
  RUNNER='alacritty'
  FLOAT=''
  OPAQUE=''
  GEOMETRY=''
  NAME=''
  OPTS=()

  for arg; do
      case "$arg" in
          "--term="*) RUNNER=${arg#*=}; shift ;;
          "--name="*) NAME=${arg#*=}; shift ;;
          "--geometry="*) GEOMETRY=${arg#*=}; shift ;;
          "--float") FLOAT='1'; shift ;;
          "--opaque") OPAQUE='1'; shift ;;
      esac
  done

  if [[ $RUNNER == 'urxvtc' ]]; then
      if ! pgrep urxvtd; then
          urxvtd & disown
          sleep 0.5
      fi
  fi

  if [[ -n "$FLOAT" ]]; then
      case "$RUNNER" in
          "st")        OPTS+=(-c float) ;;
          "urxvt"*)    OPTS+=(-name float) ;;
          "alacritty") OPTS+=(--class float) ;;
      esac
  fi

  if [[ -n "$NAME" ]]; then
      case "$RUNNER" in
          "st")        OPTS+=(-c "$NAME") ;;
          "urxvt"*)    OPTS+=(-name "$NAME") ;;
          "alacritty") OPTS+=(--class "$NAME") ;;
      esac
  fi

  if [[ -n "$OPAQUE" ]]; then
      case "$RUNNER" in
          "st")        OPTS+=(-A 1) ;;
          "urxvt"*)    OPTS+=(-bg "$(xrdb-get-value '*background')") ;;
          "alacritty") OPTS+=(--option background_opacity=1) ;;
      esac
  fi

  if [[ -n "$GEOMETRY" ]]; then
      case "$RUNNER" in
          "st"|"urxvt"*) OPTS+=(-g "$GEOMETRY") ;;
          "alacritty")
              W=$(echo "$GEOMETRY" | cut -dx -f1)
              H=$(echo "$GEOMETRY" | cut -dx -f2)
              OPTS+=(--dimensions $W $H)
              if echo $GEOMETRY | grep "+"; then
                 X=$(echo "$GEOMETRY" | cut -dx -f2 | cut -d+ -f2)
                 Y=$(echo "$GEOMETRY" | cut -dx -f2 | cut -d+ -f3)
                 OPTS+=(--position $X $Y)
              fi
              ;;
      esac
  fi

  $RUNNER "${OPTS[@]}" "$@"
#+end_src
** .scripts/togif
#+begin_src bash :tangle ~/.scripts/togif
  #!/bin/bash

  in_file="$1"
  out_file="$2"
  height_px=512
  start_sec=00
  end_sec=59
  color_count=256
  framerate=15

  for i in "$@"; do
  case $i in
      -i=*|--input=*)  in_file="${i#*=}"; shift ;;
      -o=*|--output=*) out_file="${i#*=}"; shift ;;
      -h=*|--height=*) height_px="${i#*=}"; shift ;;
      -s=*|--start=*)  start_sec="${i#*=}"; shift ;;
      -e=*|--end=*)    end_sec="${i#*=}"; shift ;;
      -c=*|--color=*)  color_count="${i#*=}"; shift ;;
      -r=*|--framerate=*)  framerate="${i#*=}"; shift ;;
  esac
  done

  if [ $1 = "help" ] || [ $1 = "--help" ] || [ $1 = "-h" ] || [ $1 = "" ]; then
      echo -e "togif in_file out_file [OPTION...]\n"
      echo -e "OPTIONS"
      echo -e "\t-i FILE, --input=FILE\n"
      echo -e "\t-o FILE, --output=FILE\n"
      echo -e "\t-h HEIGHT, --height=HEIGHT"
      echo -e "\t\tWidth will be scaled according to given HEIGHT. Default: 512\n"
      echo -e "\t-s SEC, --start=SEC"
      echo -e "\t\tStarts the video from given SEC. Default: 00\n"
      echo -e "\t-e SEC, --end=SEC"
      echo -e "\t\tEnds the video at the given SEC. Default: 59\n"
      echo -e "\t-c COUNT, --color=COUNT"
      echo -e "\t\tReduce the color palette to COUNT colors. (If it's lower already, does nothing.) (Only works for gif outputs) Default: 256\n"
      echo -e "\t-r COUNT, --framerate=COUNT"
      echo -e "\t\tReduce videos framerate to COUNT. Default: 15"
  else

      echo "=== CONVERTING ==="
      ffmpeg \
        -i "$in_file" \
        -r $framerate \
        -vf scale=$height_px:-1 \
        -ss 00:00:$start_sec -to 00:00:$end_sec \
        "$out_file"
      convert_result=$?
      echo "=== DONE ==="

      # Optimize if it's a gif
      if [[ $convert_result == 0 ]] && [[ "$out_file" == *.gif ]]; then
          echo ""
          echo "=== OPTIMIZING ==="
          gifsicle -i "$out_file" --optimize=3 --colors $color_count -o "${out_file}_optimized"
          rm "$out_file"
          mv "${out_file}_optimized" "$out_file"
          echo "=== DONE ==="
      fi

  fi
#+end_src
** .scripts/ts_onfinish
#+begin_src bash :tangle ~/.scripts/ts_onfinish
  #!/bin/bash

  # When a job that is called with tsp finishes, this script is called.
  # Need to set $TS_ONFINISH variable to path of this script. (See ~/.profile)

  job_id="$1"
  err="$2"
  out_file="$3"
  cmd="$4"

  remaining_job_count=$(($(tsp | tail -n +2 | grep -cvE '^[0-9]+ +finished') - 1))

  if [[ "$err" = 0 ]]; then
      icon=terminal
      title="finished"
      duration=5
  else
      icon=error
      title="failed"
      duration=10

      # Put cmd into clipboard
      echo "$cmd" | xclip -selection clipboard
  fi

  notify-send \
      -i "$icon" \
      -t $((duration*1000))\
      "[TSP] job $title (remaining: $remaining_job_count)" \
      "$cmd"

#+end_src
** .scripts/unmount-sdb
#+begin_src bash :tangle ~/.scripts/unmount-sdb
  #!/bin/bash

  udisksctl unmount -b /dev/sdb
  udisksctl power-off -b /dev/sdb
#+end_src
** .scripts/xcopy
#+begin_src bash :tangle ~/.scripts/xcopy
  #!/bin/sh

  file="$1"
  input="$*"

  if [ -f "$file" ]; then
      xclip -selection clipboard -t "$(file -b --mime-type "$file")" -i "$file"
  elif [ -z "$input" ]; then
      xclip -selection clipboard <&0
  else
      printf "$input" | xclip -selection clipboard
  fi
#+end_src
** .scripts/xrdb-get-value
#+begin_src bash :tangle ~/.scripts/xrdb-get-value
  #!/bin/sh

  # Usage:
  # xrdb-get-value "entry.example"
  xrdb -query | grep "$1" | cut -d ":" -f 2 | xargs
#+end_src
** .scripts/xrdb-set-value
#+begin_src bash :tangle ~/.scripts/xrdb-set-value
  #!/bin/sh

  # Usage:
  # xrdb-set-value "st.alpha" 200

  # This will not override ~/.Xresources, it will just update xrdb for this
  # session.

  echo "$1: $2" | xrdb -merge
#+end_src
** .scripts/xres-read-value
#+begin_src bash :tangle ~/.scripts/xres-read-value
  #!/bin/sh
  grep -v "!"  "$HOME/.Xresources" | grep "$1" | cut -d ":" -f 2 | xargs
#+end_src
