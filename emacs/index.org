#+TITLE: Emacs configuration file
#+AUTHOR: İsa Mert Gürbüz
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes :noweb yes
#+STARTUP: overview
#+OPTIONS: toc:3

* Introduction
This is my emacs configuration. My main focus is sanity. I'm a person who get frustrated pretty easily. So instead of optimizing the time spent on doing things, I try to find ways of doing things that does not make me frustrated. Most of the time you get speed boost as a byproduct.

#+begin_src emacs-lisp
  ;;; settings.el --- isamert's configuration -*- lexical-binding: t; -*-

  ;;; Commentary:

  ;; isamert's configuration

  ;;; Code:
#+end_src

* Usage notes
** General notes and conventions
- This configuration is meant to be used with /emacs daemon/, so I don't really care about the startup time etc.
- I try to split package configurations into multiple org src blocks and unify them using ~noweb~ references under a single =use-package= directive.
- I try to put things in way that easily copyable from the configuration. An example would be using multiple =(setq ...)= lines instead of having one =(setq ... ...)= call and setting multiple variables in one go.
- I make use of =use-package= features quite minimally. See [[id:3d974e67-11fc-4f07-8cd4-ec6fd63152c4][here]] for more information that. This is generally related with the item above and future-proofing.
- I use =verbatim text= and ~code text~ completely randomly.
- I try to prefer built-in packages or packages that enhances built-in ones where possible. I'm also trying to simplify my configuration, so another goal is to reduce the package number. Although I intend to keep packages that enhances the overall experience with no special configuration (just install and forget type of packages).

** Keybinding conventions
- After leader
  - =e= :: is reserved for independent programs, that is not related to editing/programming. For example, "ec" opens calendar, "ee" opens elfeed, "er..." controls the radio.
  - =t= :: is reserved for toggling stuff. Toggle the terminal, toggle a frequently accessed buffer etc.
  - =h= :: is reserved for any menu with fuzzy selection that does not fit anywhere else.
  - =g= :: is for git related functionality.
  - =p= :: is for project related functionality.
  - =/= :: is for search/translate related functionality. (Generally external programs)
  - =b= :: is for buffers.
  - =w= :: is for windows. I also use =C-w= for this, which is default prefix for window-related functions in vim.
  - =o= :: is for org-mode/outline mode.
** Updating packages
Currently, I don't use an external package manager, =package.el= satisfies my needs. Here is how I do the updates:
- =package-refresh-contents=
- =list-packages=
- Hit =U= to mark all packages that needs updating.
- Hit =X= to update all those packages.

I do this quite infrequently. If everything is working fine as it is, I tend to not update anything.

* Preparation
** Package repos
Add ~melpa~ and ~org~ package archives and update them if needed.

#+BEGIN_SRC emacs-lisp
  (require 'package)

  (add-to-list 'package-archives '("nongnu" . "https://elpa.nongnu.org/nongnu/"))
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))

  (package-initialize)

  ;; Update the packages
  (unless package-archive-contents
    (package-refresh-contents))
#+END_SRC

** Installing packages with ~use-package~
:PROPERTIES:
:ID:       3d974e67-11fc-4f07-8cd4-ec6fd63152c4
:END:
I use =use-package= to install packages and configure them but I do absolute minimal usage of it.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  (eval-when-compile
    (require 'use-package))
#+END_SRC

I tend to not use the =use-package= goodies while configuring my packages, meaning that I don't use =:hook=, =:bind= etc. as they have relatively simpler alternatives in Emacs and using =use-package= alternatives of these makes copy/pasting harder. Here are the keywords that I use the most:
- =:init= :: This gets called before the package gets initialized.
- =:config= :: This gets called after the package is initialized.
- =:after= :: This makes the current definition to wait the loading of listed packages, like =:after (evil org)= makes it wait for the =evil= and =org= packages to be loaded.
- =:if= :: Loads the package conditionally, like =:if (eq system-type 'darwin)=.

*** Installing packages from other sources using =quelpa= (like GitHub/GitLab/Web file etc.)
I use =quelpa= for this.
- Use =quelpa-upgrade= and select a package or use =quelpa-upgrade-all= for updating all packages.

#+BEGIN_SRC emacs-lisp
  (use-package quelpa-use-package
    :init (setq quelpa-update-melpa-p nil)
    :config (quelpa-use-package-activate-advice))
#+END_SRC

Here is an example that shows you how to install a package from Github:

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package PACKAGE-NAME
    :diminish
    :quelpa (PACKAGE-NAME
             :fetcher github
             :branch "WIP" ;; Optional
             :repo "yyoncho/company-box"))
#+END_SRC

*** Hiding mode indicators from modeline
~diminish.el~ provides a way to hide mode indicators from mode line. Either pass ~:diminish t~ to use-package while installing or just call ~(diminish 'x-mode)~.

#+BEGIN_SRC emacs-lisp
  (use-package diminish)
#+END_SRC

Currently I use [[mini-modeline]] as my modeline and it already hides minor mode indicators from the modeline. So this package is not needed but better have it as I might change my modeline in the future.

** Essential packages
I use =s.el= and =dash.el= extensively. They already come as a dependency with other packages but I may use them before loading any package, so:

#+begin_src emacs-lisp
  (use-package dash)
  (use-package s)
  (use-package yaml)
#+end_src

** Variables and functions
Some basic variable and function definitions that will be used in configuration.

*** General utilities
#+BEGIN_SRC emacs-lisp
  (defun isamert/mkdir-if-not (dir)
    "Create the DIR if it does not exist return DIR."
    (unless (file-exists-p dir)
      (make-directory dir))
    dir)

  (defun isamert/font-exists-p (font)
    "Check if FONT exists."
    (x-list-fonts font))

  (defun isamert/assoc-regexp (key list &optional fn)
    "Like `assoc` but uses `string-match (car pair) KEY` for
  comparasion and returns all the matching pairs. FN is applied to
  the keys before matching, if present."
    (seq-filter
     (lambda (pair)
       (when (string-match-p (if fn (funcall fn (car pair)) (car pair)) key)
         pair))
     list))

  (defun isamert/region-or (what)
    "Returns currently selected string or WHAT-at-point
  string. WHAT can be 'symbol 'word etc."
    (if (use-region-p)
        (buffer-substring-no-properties (region-beginning) (region-end))
      (thing-at-point what t)))

  (defun isamert/define-key (&rest k+c)
    "Simple wrapper around `define-key' that let's you define-keys
  multiple times in one call."
    (let ((mode (car k+c)))
      (setq k+c (cdr k+c))
      (while k+c
        (define-key mode (car k+c) (cadr k+c))
        (setq k+c (cddr k+c)))))

  (defmacro with-default-browser (&rest body)
    `(let ((browse-url-handlers nil)
           (browse-url-browser-function 'browse-url-default-browser))
       ,@body))

  (defmacro with-completing-read-exact-order (&rest body)
    "Disable any kind of sorting in completing read."
    `(let ((selectrum-should-sort nil))
       ,@body))

  (defun isamert/shell-command-to-string (cmd)
    "Like `shell-command-to-string' but only stdout is returned."
    (with-output-to-string
      (with-current-buffer standard-output
        (process-file
         shell-file-name nil '(t nil)  nil shell-command-switch
         cmd))))

  (defun isamert/serialize-into-file (file data)
    (with-temp-file (expand-file-name file)
      (prin1 data (current-buffer))))

  (defun isamert/deserialize-from-file (file symbol)
    (let ((fpath (expand-file-name file)))
      (if (and (file-exists-p fpath) (boundp symbol))
          (with-temp-buffer
            (insert-file-contents fpath)
            (goto-char (point-min))
            (set symbol (read (current-buffer))))
        (message ">> isamert/deserialize-from-file failed. file-exists-p: %s, boundp: %s" (file-exists-p fpath) (boundp symbol)))))

  (defun isamert/select-window-with-buffer (buffer-name)
    "Select the first visible window that matches given BUFFER-NAME."
    (--first
     (-as-> (window-buffer it) buffer
            (buffer-name buffer)
            (when (string-match buffer-name buffer)
              (select-window it)))
     (window-list)))

  (defmacro isamert/with-visible-buffer (buffer-name &rest body)
    "Evaluate BODY within the BUFFER-NAME that is currently visible."
    `(with-selected-window (selected-window)
       (when (isamert/select-window-with-buffer ,buffer-name)
         ,@body)))

  (defun isamert/sync-async-command-to-string (command &rest args)
    "Run async command and wait until it's finished. This may seem stupid but I had to use it."
    (with-temp-buffer
      (let ((process (apply 'start-process `("sync-async-proc" ,(current-buffer) ,command ,@args))))
        (while (process-live-p process)
          (sit-for 0.1))
        (buffer-string))))

  (defmacro let-plist (plist &rest form)
    "Like `let-alist' but for plists."
    (declare (indent 1))
    `(let-alist (transient-plist-to-alist ,plist)
       ,@form))
#+END_SRC

*** Clipboard functions
#+begin_src emacs-lisp
  (defun isamert/clipboard-command ()
    "Get clipboard command for current system.
        The returned command directly puts the image data into stdout."
    (cond
     ((locate-file "xclip" exec-path) "xclip -selection clipboard -target image/png -out")
     ((locate-file "pngpaste" exec-path) "pngpaste -")))

  (defun isamert/has-clipboard-image ()
    "Check whether the clipboard has image or not."
    (pcase system-type
      ('gnu/linux (s-contains? "image/" (isamert/sync-async-command-to-string "xclip" "-o" "-sel" "c" "-t" "TARGETS")))
      ('darwin (eq (shell-command "pngpaste - &>/dev/null") 0))))

  (defun isamert/save-clipboard-image-to-file (file)
    "Save the image in clipboard (if there is any) to given FILE.

    Also see `isamert/has-clipboard-image' to check if there is one."
    (shell-command (format "%s > %s" (isamert/clipboard-command) file)))
#+end_src
*** User input
#+begin_src emacs-lisp
  (cl-defun isamert/get-input (&key (mode #'org-mode)
                                    (init "")
                                    on-accept
                                    on-reject
                                    pre-process)
    "Display a buffer to user to enter some input."
    (let* ((buffer (get-buffer-create "*isamert-input*"))
           (success-handler (lambda ()
                              (interactive)
                              (let ((pre-proc-result (when pre-process
                                                       (with-current-buffer buffer
                                                         (funcall pre-process))))
                                    (result (substring-no-properties (buffer-string))))
                                (kill-buffer buffer)
                                (if pre-process
                                    (funcall on-accept result pre-proc-result)
                                  (funcall on-accept result)))))
           (reject-handler (lambda ()
                             (interactive)
                             (kill-buffer buffer)
                             (when on-reject
                               (funcall on-reject)))))
      (switch-to-buffer buffer)
      (with-current-buffer buffer
        (funcall mode)
        (use-local-map (copy-keymap (current-local-map)))
        (local-set-key (kbd "C-c C-c") success-handler)
        (local-set-key (kbd "C-c C-k") reject-handler)
        (setq header-line-format "Hit `C-c C-c' to save `C-c C-k' to reject.")
        (insert init))))

  (defun isamert/alist-completing-read (prompt alist)
    "Like `completing-read' but returns value of the selected key in given ALIST."
    (alist-get
     (completing-read prompt alist)
     alist nil nil #'equal))

  (defun isamert/dmenu (prompt items)
    "Like `completing-read' but instead use dmenu.
  Useful for system-wide scripts.  If ITEMS is an alist, then
  returns the value instead of selected key."
    (let* ((alist? (listp (car items)))
           (str (string-trim-left
                 (--reduce-from
                  (format "%s\n%s" acc (if alist? (car it) it))
                  ""
                  items)))
           (dmenu (pcase system-type
                    ('gnu/linux (format "rofi -dmenu -fuzzy -i -p '%s'" prompt))
                    ('darwin "choose")))
           (result (string-trim (shell-command-to-string (format "echo '%s' | %s" str dmenu)))))
      result))

  (cl-defmacro isamert/output-select
      (&key cmd prompt keep-order (split "\n") (drop 0) (filter t) (map 'it) do)
    "Run given CMD and do a `completing-read' on it.
  This macro is intended to quicken up the process of running a
  shell command and doing a completing-read on it and then using
  the result in another context, possibly on another shell
  command."
    (let* ((body `(completing-read
                   ,prompt
                   (seq-map-indexed
                    (lambda (it idx) ,map)
                    (seq-filter
                     (lambda (it) ,filter)
                     (seq-drop
                      (s-split
                       ,split
                       (shell-command-to-string ,cmd)
                       t)
                      ,drop)))))
           (result (if keep-order
                       `(with-completing-read-exact-order
                         ,body)
                     body)))
      `((lambda (it) ,do) ,result)))
#+end_src

*** String utils
#+begin_src emacs-lisp
  ;; Source: https://gist.github.com/jordonbiondo/c4e22b4289be130bc59b
  (defmacro isamert/s-interpolated (str)
    "Elisp string interpolation.
  Uses #{elisp-code} syntax."
    (let ((exprs nil))
      (with-temp-buffer
        (insert str)
        (goto-char 1)
        (while (re-search-forward "#{" nil t 1)
          (let ((here (point))
                (emptyp (eql (char-after) ?})))
            (unless  emptyp (push (read (buffer-substring (point) (progn (forward-sexp 1) (point)))) exprs))
            (delete-region (- here 2) (progn (search-forward "}") (point)))
            (unless emptyp (insert "%s"))
            (ignore-errors (forward-char 1))))
        (append (list 'format (buffer-string)) (reverse exprs)))))

  (defun isamert/s-upcase-until (until s)
    "Make prefix of a string S uppercase until given char UNTIL.
  `(isamert/s-upcase-until \"-\" \"aha-hehe\")' -> \"AHA-hehe\""
    (let ((end (s-index-of until s)))
      (concat
       (s-upcase (substring s 0 end))
       (substring s end))))
#+end_src
*** Quick table
#+begin_src emacs-lisp
  (cl-defun isamert/output-to-tabulated-list (str &key buffer (sep " "))
    (with-current-buffer buffer
      (let* ((lines (s-split "\n" str t))
             (header-items (s-split sep (car lines) t))
             (header (coerce (--map (list it (/ 100 (length header-items)) nil) header-items) 'vector))
             (rows (thread-last lines
                     (-drop 1)
                     (--map-indexed (list (number-to-string it-index) (coerce (s-split sep it t) 'vector))))))
        (tabulated-list-mode)
        (setq tabulated-list-format header)
        (setq tabulated-list-entries rows)
        (setq tabulated-list-padding 4)
        (tabulated-list-init-header)
        (tabulated-list-print t))
      (switch-to-buffer buffer)))
#+end_src
*** API call
This function is for doing easy REST calls and it uses plists for everything because it's more readable and easier to type than alists (but you can still use alists if you want or need to). I use this to quickly prototype stuff in elisp.

#+begin_src emacs-lisp
  (cl-defun isamert/rest
      (endpoint
       &rest params
       &key (-type "GET") (-headers) (-data) (-params)
       &allow-other-keys)
    "Do a basic API call and return the result. Some examples:

      (isamert/rest \"some/endpoint\")

  With url parameters:

      (isamert/rest \"...\" :query \"test\" :page 3 :page_size 15)

  If you wan't to pass an alist as url params:

      (isamert/rest \"...\" :-params '((query . \"test\") (page . 3) (page_size . 15)))

  POST with json body:

      (isamert/rest \"...\" :-type 'POST :-data '(:key1 1 :key2 2))

  With some HTTP headers:

      (isamert/rest \"...\" :-headers '(:Authorization \"Bearer e21ewqfasdwtkl\"))
  "
    (let (json
          (json-object-type 'alist)
          (json-array-type #'list)
          (json-key-type 'symbol))

      ;; Remove request related items from params list
      (dolist (key '(:-type :-headers :-data :-params))
        (cl-remf params key))

      (request
        endpoint
        :type -type
        ;; TODO Maybe roll my own plist-to-alist function
        :headers (if (and -headers (json-alist-p -headers))
                     -headers
                   (transient-plist-to-alist -headers))
        :parser #'json-read
        :success (cl-function
                  (lambda (&key data &allow-other-keys)
                    (setq json data)))
        :sync t
        :data (if (and -data (json-alist-p -data))
                  data
                (transient-plist-to-alist -data))
        :params (if (and -params (json-alist-p -params))
                    -params
                  params))
      json))
#+end_src
*** Other
#+begin_src emacs-lisp
  (defun isamert/kill-this-buffer ()
    "Kill current buffer.
  Function `kill-this-buffer' does not work reliably.  See
  documentation of it."
    (interactive)
    (kill-buffer (current-buffer)))
#+end_src
** Load path
Add =~/.emacs.d/load/= to =load-path=. I have extra configuration kept in this path.

#+begin_src emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/load/")
#+end_src

Also load ~isamert-secrets~ from =load-path=. I'll be utilizing some variables defined here throughout my configuration. It contains some api-keys, some tokens or some passwords etc. that I don't want to leak into public. Instead of doing mutations on an external hidden script, I define variables in this external hidden script and reference them in the configuration. This way the logic stays in the public configuration file so that everyone can take a look, but only the variable itself will be hidden from the public.

#+begin_src emacs-lisp
  (load "isamert-secrets")
#+end_src

* Basics
** Sane defaults
#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold (* 256 1024 1024))
  ;; ^ Better than default
  (setq read-process-output-max (* 1024 1024))
  ;; ^ Better than default
  (setq confirm-kill-processes nil)
  ;; ^ When exitting, kill processes withouh asking
  (setq ring-bell-function 'ignore)
  ;; ^ This completely disables alarms
  (setq column-number-mode t)
  ;; ^ Show column number
  (setq create-lockfiles nil)
  ;; ^ These just clutter the filesystem
  (setq dabbrev-case-fold-search nil)
  ;; ^ Expansions are done respecting the case (Ctrl-n and Ctrl-p was
  ;; not behaving the way I wanted before this in evil mode)
  (setq vc-follow-symlinks nil)
  ;; ^ Don't ask about following symlinks


  ;; Ask y/n instead of yes/no
  (fset 'yes-or-no-p 'y-or-n-p)

  ;; Wrap long lines
  (global-visual-line-mode t)
  (diminish 'visual-line-mode)
#+END_SRC

Some sources about the variables that I changed:
- https://github.com/emacs-lsp/lsp-mode#performance

** Overriding some defaults
*** M-Backspace should delete, instead of killing
#+begin_src emacs-lisp
  ;; https://www.emacswiki.org/emacs/BackwardDeleteWord

  (defun delete-word (arg)
    "Delete characters forward until encountering the end of a word.
  With argument, do this that many times."
    (interactive "p")
    (if (use-region-p)
        (delete-region (region-beginning) (region-end))
      (delete-region (point) (progn (forward-word arg) (point)))))

  (defun backward-delete-word (arg)
    "Delete characters backward until encountering the end of a word.
  With argument, do this that many times."
    (interactive "p")
    (delete-word (- arg)))

  (global-set-key (read-kbd-macro "<M-DEL>") 'backward-delete-word)
#+end_src

** Recent files
Save recent files. Also exclude package files that appears after installing a package or after an update from recent list.

#+BEGIN_SRC emacs-lisp
  (recentf-mode t)
  (add-to-list
   'recentf-exclude
   (format "%s/\\.emacs\\.d/elpa/.*" (getenv "HOME")))
#+END_SRC

** Save minibuffer, kill-ring, search-ring history
#+begin_src emacs-lisp
  (setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
  (setq savehist-file "~/.emacs.d/savehist")
  (savehist-mode 1)

  (setq save-interprogram-paste-before-kill t)
  ;; ^ Clipboard selections are copied into the kill-ring
#+end_src

** Better scrolling
*** Better settings for mouse scroll
#+BEGIN_SRC emacs-lisp
  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
  (setq mouse-wheel-progressive-speed nil)            ;; don't accelerate scrolling
  (setq mouse-wheel-follow-mouse 't)                  ;; scroll window under mouse
#+END_SRC

*** Mouse shortcuts for zooming
- Ctrl-Scroll to zoom in and out

#+BEGIN_SRC emacs-lisp
  (global-set-key [C-mouse-4] 'text-scale-increase)
  (global-set-key [C-mouse-5] 'text-scale-decrease)
  (global-set-key (kbd "C-+") 'text-scale-increase)
  (global-set-key (kbd "C-=") 'text-scale-decrease)
#+END_SRC

*** Conservative scrolling
If the cursor is at the end of the file, when you scroll emacs does a strange jump. This fixes it.

#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 100) ;; When cursor reaches end, just scroll line-by-line
#+END_SRC

** Backups
Instead of having a file that ends with ~ or '# files in same directory, save all backup files in =~/.emacs.d/backups=.

#+BEGIN_SRC emacs-lisp
  (defconst backup-dir (isamert/mkdir-if-not "~/.emacs.d/backups/"))

  (setq backup-directory-alist `((".*" . ,backup-dir)))
  (setq auto-save-file-name-transforms `((".*" ,backup-dir t)))

  (setq backup-by-copying t)
  ;; ^ Don't delink hardlinks
  (setq version-control t)
  ;; ^ Use version numbers on backups
  (setq delete-old-versions t)
  ;; ^ Automatically delete excess backups
  (setq kept-new-versions 20)
  ;; ^ How many of the newest versions to keep
  (setq kept-old-versions 5)
  ;; ^ How many of the old versions to keep
#+END_SRC

** Remove trailing space before save
#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

** Automatically run some commands after saving specific files
This is like =autocmd BufWritePost= of vim. When a particular file is edited, I want to make sure a command runs after the save.

#+BEGIN_SRC emacs-lisp
  (defvar isamert/run-after-save-alist
    '(("~/.\\(Xresources\\|Xdefaults\\)" . "xrdb %; notify-send 'xrdb updated'")
      ("~/.Xresources.d/.*"              . "xrdb ~/.Xresources; notify-send 'xrdb updated'")
      ("~/.config/sxhkd/sxhkdrc"         . "pkill -USR1 -x sxhkd; notify-send 'sxhkd updated'")
      ("~/.config/skhd/skhdrc"           . "skhd --reload; osascript -e 'display notification \"skhd updated\"'"))
    "File association list with their respective command.")

  (add-hook 'after-save-hook #'isamert/post-save-run-command)
  (add-hook 'org-babel-post-tangle-hook #'isamert/post-save-run-command)

  (defun isamert/post-save-run-command ()
    "Execute the specified command after saving specified file."
    (let* ((fname (buffer-file-name))
           (match (isamert/assoc-regexp fname isamert/run-after-save-alist #'expand-file-name)))
      (when match
        (mapcar (lambda (pair) (shell-command (s-replace "%" fname (cdr pair)))) match))))
#+END_SRC

* Visuals
** General
Hide menubar and toolbar and replace blinking cursor with nice static box cursor.

#+BEGIN_SRC emacs-lisp
  (menu-bar-mode 0)                ;; Disable menubar
  (tool-bar-mode 0)                ;; Disable toolbar
  (blink-cursor-mode 0)            ;; Disable blinking cursor
  (scroll-bar-mode -1)             ;; Disable scrollbars
  (global-hl-line-mode t)          ;; Highlight current line
  (setq inhibit-startup-message t) ;; Close startup screen
  (setq frame-resize-pixelwise t)  ;; Fix gap issues with tiling WMs
#+END_SRC

Disable global-hl-line-mode in eshell, ansi-term, vterm

#+begin_src emacs-lisp
  (mapcar
    (lambda (mode) (add-hook mode (lambda () (setq-local global-hl-line-mode nil))))
    '(eshell-mode-hook term-mode-hook vterm-mode-hook))
#+end_src

** Fonts and theme
#+BEGIN_SRC emacs-lisp
  (use-package doom-themes
    :defer t)

  (defconst isamert/font-height 160)
  (defconst isamert/fonts '("Iosevka Nerd Font"))

  (defun isamert/set-font-and-theme-config ()
    "Configure font and theme."
    (interactive)
    ;; Set the first avilable font from the `isamert/fonts' list
    (--each-r-while
        isamert/fonts #'isamert/font-exists-p
      (set-face-attribute 'default nil
                          :font it
                          :weight 'normal
                          :width 'normal
                          :height isamert/font-height))
    ;; ...and load the theme
    (load-theme 'doom-dark+ t))

  (defun isamert/set-font-and-theme-config-in-frame (frame)
    (with-selected-frame frame
      (isamert/set-font-and-theme-config)))

  (if (daemonp)
      ;; Following sets font/font-size for each emacsclients frame
      (add-hook
       'after-make-frame-functions
       #'isamert/set-font-and-theme-config-in-frame)
    ;; Not in daemon mode, set theme etc directly
    (isamert/set-font-and-theme-config))

  ;; https://www.reddit.com/r/emacs/comments/30b67j/how_can_you_reset_emacs_to_the_default_theme/cprkyl0?utm_source=share&utm_medium=web2x&context=3
  (defun isamert/switch-theme (theme)
    "Switch to the THEME.  Also disable already enabled themes first."
    (interactive
     (list
      (intern (completing-read "Load custom theme: "
                               (mapcar 'symbol-name
                                       (custom-available-themes))))))
    (mapc #'disable-theme custom-enabled-themes)
    (load-theme theme t))
#+END_SRC

** all-the-icons
You should run =all-the-icons-install-fonts= command after this.

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)
#+END_SRC

** prettify-symbols-mode
I make use of this mode quite frequently throughout the configuration.

#+begin_src emacs-lisp
  (use-package prog-mode
    :config
    (setq prettify-symbols-unprettify-at-point t))

  (defmacro isamert/prettify-mode (mode pairs)
    "Prettify given PAIRS in given MODE.
    Just a simple wrapper around `prettify-symbols-mode`"
    `(add-hook
      ,mode
      (lambda ()
        (mapc (lambda (pair)
                (push pair prettify-symbols-alist))
              ,pairs)
        (prettify-symbols-mode 1))))
#+end_src

** fira-code-mode (font ligatures)
This adds Fira Code ligatures into Emacs, meaning that it prettifies well-known code symbols. This mode also saves the length of the chars, so it does not break spacing.
- After the first install, you need to call =fira-code-mode-install-fonts= and then maybe restart Emacs etc.

#+begin_src emacs-lisp
  (use-package fira-code-mode
    :config
    (setq fira-code-mode-disabled-ligatures '(":" "x" "[]"))
    (add-hook 'prog-mode-hook #'fira-code-mode)
    (add-hook 'org-mode-hook  #'fira-code-mode))
#+end_src

** Frame title
Make window title contain buffer name so it's easier to identify windows. I use ~rofi~ to switch between windows in my DE, so it helps to have buffer name in window title.

#+BEGIN_SRC emacs-lisp
(setq frame-title-format "%b - emacs")
#+END_SRC

** Parentheses
*** Matching
Just enable parenthesis matching.

#+BEGIN_SRC emacs-lisp
  (setq show-paren-style 'parenthesis)
  (show-paren-mode 1)
#+END_SRC

*** Rainbow
Colors parentheses depending on their dept.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

** Highlight trailing spaces
- Following highlights trailing spaces. Also see: [[Remove trailing space before save]]

#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :diminish global-whitespace-mode
    :config
    (setq whitespace-style '(face empty tabs trailing))
    (setq whitespace-global-modes '(not org-mode markdown-mode vterm-mode magit-log-mode))
    (global-whitespace-mode t))

  (defun isamert/whitespace-mode-toggle ()
    "Toggle between more and less agressive whitespace modes.
  Toggles between showing every whitespace (tabs, spaces, newlines
  etc.) and only showing trailing spaces and tabs.  By default I use
  the latter but sometimes I want to see everything and the
  function helps me go between these modes easily."
    (interactive)
    (if (member 'spaces whitespace-style)
        (setq whitespace-style '(face empty tabs trailing))
      (setq whitespace-style '(face tabs spaces trailing lines space-before-tab newline indentation empty space-after-tab space-mark tab-mark newline-mark)))
    (whitespace-mode 0)
    (whitespace-mode 1))
#+END_SRC

** Spaces instead of tabs
#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 2)
  (setq-default indent-tabs-mode nil)
#+END_SRC

** Shackle windows
Make some temproary windows appear at bottom. This makes buffer management so much easier. Buffers that will match given regex will appear at bottom while covering the given amount of screen.

#+BEGIN_SRC emacs-lisp
  ;; SOURCE: https://www.reddit.com/r/emacs/comments/345vtl/make_helm_window_at_the_bottom_without_using_any/
  (defun isamert/shackle-window (name size)
    "Make the buffer NAME appear at bottom of the window, filling
    SIZE percent of the window."
    (add-to-list 'display-buffer-alist
                 `(,name
                   (display-buffer-in-side-window)
                   (inhibit-same-window . t)
                   (window-height . ,size))))

  (isamert/shackle-window "\\*Help\\*" 0.4)
  (isamert/shackle-window "\\*Warnings*\\*" 0.2)
  (isamert/shackle-window "\\*Backtrace*\\*" 0.4)
  (isamert/shackle-window "\\*Flycheck.*" 0.4)
  (isamert/shackle-window "\\*Org Src.*\\*" 0.4)
  (isamert/shackle-window "\\*Agenda Commands\\*" 0.4)
  (isamert/shackle-window "\\*Org Agenda\\*" 0.4)
  (isamert/shackle-window "\\*Org Select\\*" 0.4)
  (isamert/shackle-window "CAPTURE-*" 0.4)
  (isamert/shackle-window "magit.*" 0.7)
  (isamert/shackle-window "\\*xref\\*" 0.4)
  (isamert/shackle-window "\\*Org-Babel Error Output\\*" 0.4)
  (isamert/shackle-window "\\*curl error\\*" 0.4)
  (isamert/shackle-window "\\*helpful.*\\*" 0.4)
  (isamert/shackle-window "\\*Org Select\\*" 0.4)
#+END_SRC

** Miscellaneous packages
Some small packages that enriches editing experience visually. I don't enable all of them by default, I enable most of them whenever I need the functionality. I utilize an appearance [[Hydra]] to quickly toggle the functionality I need.

#+begin_src emacs-lisp
  ;; Show column guidelines
  (use-package fill-column-indicator)

  ;; By default Emacs scales fonts with text-scale-{increase,decrease}
  ;; per buffer. This scales fonts with
  ;; default-text-scale-{increase,decrease} globally.
  (use-package default-text-scale)

  ;; Highlights changed lines in git. You need to save the buffer to see
  ;; the changes.
  (use-package diff-hl)

  ;; It helps you to find your cursor when you change buffers/windows
  ;; etc with a little animation.
  (use-package beacon
    :config
    (beacon-mode 1)
    (setq beacon-blink-duration 0.5
          beacon-push-mark 50
          beacon-color "#9F72D9"))

  ;; This shows some indent guides and it's highly configurable.
  (use-package highlight-indent-guides
    :config
    (set-face-background 'highlight-indent-guides-odd-face "darkgray")
    (set-face-background 'highlight-indent-guides-even-face "dimgray")
    (set-face-foreground 'highlight-indent-guides-character-face "dimgray")
    (setq highlight-indent-guides-method 'bitmap)
    (setq highlight-indent-guides-bitmap-function 'highlight-indent-guides--bitmap-line))
#+end_src

* evil-mode
** Basic configuration
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :init
    ;; Following two is required by evil-collection. It's probably wiser
    ;; to set evil-want-keybinding to t if you will not use
    ;; evil-collection
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    ;; C-i interferes with TAB key, so disable it
    (setq evil-want-C-i-jump nil)
    ;; Disable evil bindings in insert mode. This needs to be called
    ;; before loading evil mode...
    (setq evil-disable-insert-state-bindings t)
    (setq evil-undo-system 'undo-redo)
    :config
    ;; ...but I want some default evil bindings in insert mode, so just
    ;; remap them
    (evil-define-key 'insert 'global
      (kbd "C-d") #'evil-shift-left-line
      (kbd "C-t") #'evil-shift-right-line
      (kbd "C-n") #'evil-complete-next
      (kbd "C-p") #'evil-complete-previous
      (kbd "C-o") #'evil-execute-in-normal-state)

    (evil-define-key 'normal 'global "Q" #'evil-quit)

    ;; When I paste something in visual mode, I don't want it to take
    ;; over the kill ring I also use evil-exchange, which eliminates the
    ;; need for this totally
    (setq evil-kill-on-visual-paste nil)
    ;; ^ Over the time I found myself utilizing emacs C-u more and more,
    ;; so disable this
    (setq evil-want-C-u-scroll nil)

    ;; Make horizontal movement cross lines
    (setq-default evil-cross-lines t)

    ;; Open ex-mode with `<`> text instead of '<'> by default while
    ;; visual mode is active. This way commands will work on selected
    ;; char range instead of selected line range.
    (setq evil-ex-visual-char-range t)

    ;; Move between visual lines instead of real lines
    (evil-define-key 'normal 'global
      (kbd "<remap> <evil-next-line>") #'evil-next-visual-line
      (kbd "<remap> <evil-previous-line>") #'evil-previous-visual-line)
    (evil-define-key 'motion 'global
      (kbd "<remap> <evil-next-line>") #'evil-next-visual-line
      (kbd "<remap> <evil-previous-line>") #'evil-previous-visual-line)

    ;; Change cursor colors based on current mode.
    (setq evil-normal-state-cursor '("green" box)
          evil-visual-state-cursor '("orange" box)
          evil-emacs-state-cursor '("purple" box)
          evil-insert-state-cursor '("pink" bar)
          evil-replace-state-cursor '("red" bar)
          evil-operator-state-cursor '("red" hollow))

    (evil-mode 1))
#+END_SRC

** evil-collection
#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init 'ibuffer)
    (evil-collection-init 'compile)
    (evil-collection-init 'eshell)
    (evil-collection-init 'geiser)
    (evil-collection-init 'dired)
    (evil-collection-init 'grep)
    (evil-collection-init 'elfeed)
    (evil-collection-init 'consult)
    (evil-collection-init 'vterm)
    (evil-collection-init 'magit)
    (evil-collection-init 'magit-todos)
    (evil-collection-init 'git-timemachine)
    (evil-collection-init 'calendar)
    (evil-collection-init 'eww)
    (evil-collection-unimpaired-setup))
#+end_src
** evil-unimpaired
Apparently [[evil-collection]] has an vim-unimpaired implementation already. It contains bindings like:
  - ~[<SPC>~ ~]<SPC>~ Insert newline above/below.
  - ~[b~ ~]b~ Go to prev/next buffer.
  - ~[p~, ~]p~ Paste up/down.
  - ~[e~, ~]e~ Move line up/down.
  - ~[d~, ~]d~ Delete line above/below.
  - ~[q~ ~]q~ Go to prev/next error.
  - ~[Q~ ~]Q~ Go to first/last error.
  - ~[n~ ~]n~ Go to prev/next conflict marker.
  - ~[t~ ~]t~ Go to prev/next TODO. (This is defined in [[Dummy IDE mode]])

Following are my extensions:

#+begin_src emacs-lisp
  (evil-define-key 'normal 'global
    (kbd "[d") #'isamert/delete-line-above
    (kbd "]d") #'isamert/delete-line-below)

  (defun isamert/delete-line-above ()
    "Delete the line above."
    (interactive)
    (save-excursion
      (previous-line 1)
      (beginning-of-line)
      (kill-line)
      (kill-line)))

  (defun isamert/delete-line-below ()
    "Delete the line below."
    (interactive)
    (save-excursion
      (next-line 1)
      (beginning-of-line)
      (kill-line)
      (kill-line)))
#+end_src
** evil-leader
Enable leader key and bind some keys.

#+BEGIN_SRC emacs-lisp
  (use-package evil-leader
    :after evil
    :config
    (global-evil-leader-mode)

    (evil-leader/set-leader "SPC")
    (evil-leader/set-key
      ;; generic
      ";"   'eval-last-sexp
      ","   'eval-defun

      ;; buffers
      "bq" #'evil-quit
      "bd" #'isamert/kill-this-buffer))
#+END_SRC

** evil-mc (multiple cursors)
Multiple cursors for evil.

- Basics
  - =C-n= / =C-p= are used for creating cursors
  - =A= and =I= creates cursors in visual selection mode as you may expect.
  - =gkk= to clear all cursors.

- To be able to create cursors at arbitrary positions:
  - =gkp= to pause all cursors. (Your main cursors moves freely while mc cursors stays still)
  - =gkr= to resume paused cursors.
  - =gkh= create a cursor at the point of main cursor. (Use after =gkp=).

#+BEGIN_SRC emacs-lisp
  (use-package evil-mc
    :after evil
    :diminish evil-mc-mode
    :config
    ;; I use "gr" (which is the default key combination that brings up evil-mc commands) for something else
    ;; So remove "gr" binding
    (evil-define-key* '(normal visual) evil-mc-key-map (kbd "gr") nil)
    (evil-define-key* '(normal visual) evil-mc-key-map (kbd "M-p") nil)

    ;; Add my bindings using "gk"
    (evil-define-key 'normal evil-mc-key-map
      (kbd "gkk") #'evil-mc-undo-all-cursors
      (kbd "gkp") #'evil-mc-pause-cursors
      (kbd "gkr") #'evil-mc-resume-cursors
      (kbd "gkh") #'evil-mc-make-cursor-here)

    (evil-define-key 'visual evil-mc-key-map
      "A" #'evil-mc-make-cursor-in-visual-selection-end
      "I" #'evil-mc-make-cursor-in-visual-selection-beg)
    (global-evil-mc-mode 1))
#+END_SRC

** evil-surround
Change surroundings. Do =cs"'= to turn ="Hello world!"= into ='Hello world!'=.
- ='Hello world!'= ~cs'<q>~ =<q>Hello world!</q>=
- =Hel|lo= ~ysiw"~ ="Hello"= (| is the cursor position.)
- =Hello= ~ysw{~ ={ Hello }=  (~{[(~ adds spaces)
- =Hello= ~ysw}~ ={Hello}=    (~}])~ does not add spaces)

#+BEGIN_SRC emacs-lisp
  (use-package evil-surround
    :after evil
    :init
    (global-evil-surround-mode 1))
#+END_SRC

** evil-escape
Return back to normal mode using ~jk~ from anywhere. It does not play well with multiple cursors, so use ~ESC~ to when using evil-mc related stuff.

#+BEGIN_SRC emacs-lisp
  (use-package evil-escape
    :diminish
    :after evil
    :config
    (setq evil-escape-key-sequence "jk")
    (setq evil-escape-delay 0.2)
    (setq evil-escape-excluded-major-modes '(magit-status-mode magit-log-mode magit-diff-mode))
    (evil-escape-mode 1))
#+END_SRC

** evil-matchit
Jump between matching tags using ~%~, like =<div>...</div>=, ={...}= etc. =ci%=, =da%= etc. works as expected.

#+BEGIN_SRC emacs-lisp
  (use-package evil-matchit
    :diminish
    :after evil
    :config
    (global-evil-matchit-mode 1))
#+END_SRC

** evil-goggles
~evil-goggles~ gives nice visual feedbacks while editing with evil-mode. When you do =dd=, =yw=, =ciw= or something similar, it will give a visual feedback for the selection. Feels kinda natural to have this.

#+BEGIN_SRC emacs-lisp
  (use-package evil-goggles
    :after evil
    :diminish
    :config
    (setq evil-goggles-duration 0.20
          evil-goggles-pulse nil
          evil-goggles-enable-change t
          evil-goggles-enable-delete t
          evil-goggles-enable-indent t
          evil-goggles-enable-yank t
          evil-goggles-enable-join t
          evil-goggles-enable-fill-and-move t
          evil-goggles-enable-paste t
          evil-goggles-enable-shift t
          evil-goggles-enable-surround t
          evil-goggles-enable-commentary t
          evil-goggles-enable-nerd-commenter t
          evil-goggles-enable-replace-with-register t
          evil-goggles-enable-set-marker t
          evil-goggles-enable-undo t
          evil-goggles-enable-redo t)
    (evil-goggles-mode)
    (evil-goggles-use-diff-faces))

#+END_SRC

** evil-snipe
- Overall better =f/F/t/T= and . Nice visual feedbacks.

#+BEGIN_SRC emacs-lisp
  (use-package evil-snipe
    :after evil
    :diminish evil-snipe-local-mode
    :config
    ;; (evil-snipe-mode 1) ;; This enables s/S bindings. I use those keys with avy
    (evil-snipe-override-mode 1) ;; This overrides default f/F, t/T bindings
    (setq evil-snipe-scope 'visible)
    (setq evil-snipe-skip-leading-whitespace nil)
    ;; ^ See https://github.com/hlissner/evil-snipe/issues/72
    (add-hook 'magit-mode-hook 'turn-off-evil-snipe-override-mode))
#+END_SRC

** evil-exchange
Change two parts of the text.
- Mark some text in visual mode and do =gx=.
- Mark some other text in visual mode and do =gx= again to exchange two parts.
- You can use ~gx<motion>~ instead of visual mode too.

#+begin_src emacs-lisp
  (use-package evil-exchange
    :config
    (evil-exchange-install))
#+end_src

** evil-visualstar
With this package, you can do a visual selection and ~*~, ~#~ keys will work on them.

#+begin_src emacs-lisp
  (use-package evil-visualstar
    :config
    (setq evil-visualstar/persistent t)
    (global-evil-visualstar-mode 1))
#+end_src

** goto-chg
- =g;= goes to the last change. (repeatable)
- There is also =gv= which selects the last selection. Not related to this package, it's a default functionality but I wanted to mention.

#+BEGIN_SRC emacs-lisp
  (use-package goto-chg
    :after evil)
#+END_SRC

* org-mode
** org-plus-contrib
#+begin_src emacs-lisp
  (use-package org-contrib)

  (use-package org
    :config
    (setq org-return-follow-links t)
    ;; ^ Open links with RET
    (setq org-src-fontify-natively t)
    ;; ^ Enable code highlighting in ~SRC~ blocks.
    (setq org-hierarchical-todo-statistics t)
    ;; ^ Show all children in todo statistics [1/5]
    (setq org-imenu-depth 7)
    ;; ^ include up to 7-depth headers in imenu search
    (setq org-image-actual-width nil)
    ;; ^ Disable showing inline images in full width. Now you can add `#+ATTR_*: :width 300` to resize inline images
    (setq org-ellipsis "⤵")
    ;; ^ Replace ... with ⤵ in collapsed sections
    (setq org-habit-show-habits-only-for-today t)
    ;; ^ If a TODO item has the ':STYLE: habit' property, then show it only on todays agenda, does not show recurring times.
    (setq org-log-into-drawer t)
    ;; ^ Log into LOGBOOK drawer instead of directly loging under the heading
    (setq org-extend-today-until 3)
    ;; ^ Consider the current day to end at 3AM
    (setq org-use-effective-time t)
    ;; ^ Make timestamp processing functions aware of the previous config

    (add-to-list 'org-modules 'org-habit t)
    ;; ^ Enable habit tracking

    ;; http://www.foldl.me/2012/disabling-electric-indent-mode/
    (defun isamert/disable-electric-indent ()
      (set (make-local-variable 'electric-indent-functions)
           (list (lambda (arg) 'no-indent))))

    (add-hook 'org-mode-hook #'isamert/disable-electric-indent))
#+end_src

** Keybindings
#+begin_src emacs-lisp
  (evil-leader/set-key-for-mode 'org-mode
    "d" 'org-babel-remove-result
    "D" 'isamert/org-babel-remove-all-results

    "op"  #'org-set-property
    "oi"  #'org-toggle-inline-images
    "oI"  #'org-redisplay-inline-images
    "or"  #'org-mode-restart
    "os"  #'org-schedule
    "od"  #'org-deadline
    "on"  #'org-toggle-narrow-to-subtree

    ;; link stuff
    "oyi" #'org-copy-id
    "o#" #'org-insert-structure-template)

  (evil-leader/set-key
    "oyy" #'org-store-link
    "oo"  #'org-open-at-point
    "oO"  (lambda () (interactive) (with-default-browser (call-interactively 'org-open-at-point)))

    "oa"  #'org-agenda
    "ow"  #'widen

    ;; org-clock
    "occ" #'org-clock-in
    "ocC" #'org-clock-cancel
    "ocl" #'org-clock-in-last
    "oco" #'org-clock-out
    "ocg" #'org-clock-goto)

  (evil-define-key 'normal org-mode-map
    "[[" #'outline-previous-visible-heading
    "]]" #'org-next-visible-heading
    "[{" #'isamert/outline-up-heading-or-backward-same-level
    "]}" #'isamert/outline-up-level-then-forward
    "-"  #'org-cycle-list-bullet

    (kbd "H-h") 'org-shiftleft
    (kbd "H-j") 'org-shiftdown
    (kbd "H-k") 'org-shiftup
    (kbd "H-l") 'org-shiftright

    ;; Hyper for macos is C-M-s
    (kbd "C-S-s-<left>") 'org-shiftleft
    (kbd "C-S-s-<down>") 'org-shiftdown
    (kbd "C-S-s-<up>") 'org-shiftup
    (kbd "C-S-s-<right>") 'org-shiftright

    ;; FIXME: mac hyper already contains shift
    (kbd "M-H") 'org-shiftmetaleft
    (kbd "M-J") 'org-shiftmetadown
    (kbd "M-K") 'org-shiftmetaup
    (kbd "M-L") 'org-shiftmetaright

    ;; FIXME: M-h,j,k,l conflicts with split swithcing shourtcuts
    ;; so I just prefixed them with Hyper but this does not feel natural.
    ;; FIXME: find a solution for M-H-{h,j,k,l} in macOS
    (kbd "M-H-h") 'org-metaleft
    (kbd "M-H-j") 'org-metadown
    (kbd "M-H-k") 'org-metaup
    (kbd "M-H-l") 'org-metaright)

  (defun isamert/outline-up-level-then-forward ()
    "Up one level and then go to next header with same level."
    (interactive)
    (ignore-errors (outline-up-heading 1))
    (outline-forward-same-level 1))

  (defun isamert/outline-up-heading-or-backward-same-level ()
    "Go to one level up or go back same level."
    (interactive)
    (condition-case nil
        (outline-up-heading 1)
      (error (outline-backward-same-level 1))))
#+end_src

** Some vars
#+BEGIN_SRC emacs-lisp
  (when (file-directory-p "~/Documents/notes")
    (defconst watchlist-org "~/Documents/notes/watchlist.org")
    (defconst readinglist-org "~/Documents/notes/readinglist.org")
    (defconst courses-org "~/Documents/notes/courses.org")
    (defconst bullet-org "~/Documents/notes/bullet.org")
    (defconst reality-org "~/Documents/notes/reality.org")
    (defconst projects-org "~/Documents/notes/projects.org")
    (defconst people-org "~/Documents/notes/people.org")
    (defconst diary-org "~/Documents/notes/diary.org")
    (defconst snippets-org "~/Documents/notes/snippets.org")
    (defconst work-org "~/Documents/notes/trendyol.org")
    (defconst temp-org "~/Documents/notes/temp.org")
    (defconst passwords-org "~/Documents/notes/passwords.org")
    (defconst engineering-org "~/Documents/notes/engineering.org")

    ;; Put archive files under an archive/ directory
    ;; I don't want them to pollute my directory
    (setq org-archive-location "archive/%s_archive::")
    (setq org-directory "~/Documents/notes")
    (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)
    ;; ^ org-store-link creates an ID for header only if called interactively and if there is no custom id
    (setq org-agenda-files `(,bullet-org ,projects-org ,work-org ,people-org))

    ;; With the following, I can call functions defined inside this file in other org files
    (org-babel-lob-ingest "~/Documents/notes/utils.org"))
#+END_SRC

** Auto indent subsections
Automatically invoke ~org-indent-mode~ which gives nice little indentation under subsections. It makes reading easier. This does not add any spaces/tabs to the text file, the indentation is only visually apparent in Emacs.

#+BEGIN_SRC emacs-lisp
  (add-hook
   'org-mode-hook
   (lambda ()
     (org-indent-mode t)
     (diminish 'org-indent-mode))
   t)
#+END_SRC

** Babel
*** ob-http
#+begin_src emacs-lisp
  ;; Http request in org-mode babel.
  ;; You can get the generated curl command after executing the code
  ;; block, from *curl command history* buffer
  (use-package ob-http)

  ;; TODO Handle --data-urlencode, -X {POST,GET,etc...}, -L, --data-raw
  (defun isamert/curl-to-org-http (curl-str)
    "Convert CURL-STR into an ob-http block.
  More concretely this function converts given curl command (that
  is copied from Chrome/Firefox dev tools, using the `Copy as curl'
  option) into an ob-http block to be able to use all the goodies
  that is provided by ob-http."
    (interactive
     (list
      (if (use-region-p)
          (buffer-substring-no-properties (region-beginning) (region-end))
        (read-string "Curl string: "))))
    (let* ((curl (s-trim curl-str))
           (url (cadr (s-match "['\"]\\(http.*?\\)['\"]" curl)))
           (headers (--map (format "%s: %s" (s-titleize (nth 1 it)) (nth 2 it))
                           (s-match-strings-all "-H '\\(.*?\\): \\(.*?\\)'" curl)))
           (body (car (s-match "--data-binary '\\(.*?\\)'" curl)))
           (result (format
                    "  %s %s\n  %s%s"
                    (if body "POST" "GET")
                    url
                    (--reduce (format "%s\n  %s" acc it) headers)
                    ;; TODO if json, format it
                    (if body
                        (format "\n\n  %s" body)
                      ""))))
      (when (use-region-p)
        (delete-region (region-beginning) (region-end)))
      (unless (save-excursion
                (goto-char (region-beginning))
                (forward-line -1)
                (s-contains? "begin_src" (thing-at-point 'line t)))
        (insert "#+begin_src http :pretty :wrap src json\n\n#+end_src")
        (forward-line -1))
      (insert result)))
#+end_src

*** General configuration
#+begin_src emacs-lisp
  ;; Typescript
  (use-package ob-typescript)

  ;; Allow these languages to run in code blocks
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (scheme . t)
     (python . t)
     (haskell . t)
     (js . t)
     (sql . t)
     (http . t)
     (plantuml . t)))

  ;; Don't ask permissions for evaluating code blocks
  (setq org-confirm-babel-evaluate nil)

  ;; Make certain files exacutable when tangled
  ;; Source: https://lists.gnu.org/archive/html/emacs-orgmode/2011-02/msg00465.html
  (add-hook 'org-babel-post-tangle-hook #'isamert/make-tangled-files-executable)

  ;; Some codeblocks produce image files as it's result (like dot
  ;; language). Re-executing these blocks removes the image
  ;; overlay. With this hook images are automatically updated after
  ;; code-block execution and not removed from screen.
  (add-hook 'org-babel-after-execute-hook #'isamert/org-redisplay-images-if-enabled)

  (evil-leader/set-key
    "ot" 'isamert/org-babel-tangle-current-block)

  (defun isamert/org-babel-tangle-current-block ()
    (interactive)
    (let ((current-prefix-arg '(16)))
      ;;     ^ '(4) only tangles current file, '(16) tangles all code
      ;;     blocks related to current tangle file target
      (call-interactively 'org-babel-tangle)))

  (defun isamert/make-tangled-files-executable ()
    (when (or (string-match-p  "\\.\\(sh\\|py\\)$" (buffer-file-name))
              (string-match-p  "\\(python\\|sh\\)$" (symbol-name major-mode)))
      (set-file-modes (buffer-file-name) #o755)))

  (defun isamert/org-redisplay-images-if-enabled ()
    (when org-inline-image-overlays
      (org-redisplay-inline-images)))
#+end_src

** Exporting
*** HTML
#+BEGIN_SRC emacs-lisp
  (use-package htmlize)
#+END_SRC

*** iCalendar settings
#+BEGIN_SRC emacs-lisp
  (setq org-icalendar-store-UID t)
  (setq org-icalendar-alarm-time 15)
  (setq org-icalendar-use-scheduled '(todo-start event-if-todo))
  (setq org-icalendar-use-deadline '(todo-due event-if-todo))
#+END_SRC

** Agenda
Some general settings.

#+BEGIN_SRC emacs-lisp
  (evil-set-initial-state 'org-agenda-mode 'normal)
  (evil-define-key 'normal org-agenda-mode-map
    (kbd "<RET>") 'org-agenda-switch-to
    (kbd "\t") 'org-agenda-goto
    "s" 'org-agenda-schedule
    "w" 'org-agenda-week-view
    "d" 'org-agenda-day-view
    "t" 'org-agenda-todo
    "L" 'org-agenda-log-mode
    "q" 'org-agenda-quit
    "R" 'org-agenda-clockreport-mode
    "r" 'org-agenda-redo)

  (setq org-agenda-use-time-grid t)
  (setq org-agenda-time-grid
        '((today remove-match)
          (800 900 1000 1100 1200 1300 1400 1500 1600 1700 1800 1900 2000 2100 2200 2300 2400)
          "......"
          "----------------"))
#+END_SRC

*** Making agenda buffer open faster
Here are the resources:
- https://orgmode.org/manual/Speeding-Up-Your-Agendas.html
- https://orgmode.org/worg/agenda-optimization.html

#+begin_src emacs-lisp
  (setq org-agenda-dim-blocked-tasks nil)
  (setq org-agenda-inhibit-startup t)
  (setq org-agenda-use-tag-inheritance nil)
  (setq org-agenda-ignore-drawer-properties '(effort appt category))
#+end_src

** ToDo keywords
#+BEGIN_SRC emacs-lisp
  ;; Add this to org files if you need:
  ;; #+TODO: TODO PROG WAITING DONE
  ;; OR
  (setq org-todo-keywords
    '((sequence "TODO(t)" "PROG(p)" "WAIT(w)" "DONE(d)")))
  ;; Now you can do C-c C-t {t,p,w,d} to set the state directly

  (setq org-todo-keyword-faces
        '(("WAIT" . (:foreground "yellow" :weight bold))
          ("PROG" . (:foreground "magenta" :weight bold :underline t))))

  (defun isamert/org-set-faces ()
    (set-face-attribute 'org-headline-done nil :strike-through t))

  (add-hook 'org-mode-hook #'isamert/org-set-faces)
#+END_SRC

** org-capture
See [[https://orgmode.org/manual/Template-elements.html#Template-elements][this page]] for more detail on template elements.

#+begin_src emacs-lisp
  (evil-leader/set-key "og" #'org-capture)
  (evil-leader/set-key "oG" #'org-capture-goto-last-stored)

  (setq
   org-capture-templates
   '(("g" "General todo/note")
     ("gi" "Study later" item
      (file+olp bullet-org "Life backlog" "Investigate")
      "- [ ] %a. %?"
      :prepend t)
     ("gt" "Life todo" entry
      (file+headline bullet-org "Life backlog"))
     ("gc" "Computer todo" entry
      (file+headline bullet-org "Computer backlog"))
     ("gw" "Work todo" entry
      (file+headline bullet-org "Work backlog"))

     ("d" "Daily todo/summary/note")
     ("dt" "Daily TODO" entry
      (file+function bullet-org isamert/bullet-focus-today)
      "** [#B] %?\n%a. "
      :prepend t)
     ("ds" "Daily summary" entry
      (file+function bullet-org isamert/org-capture--find-daily-summary)
      "%T ")
     ("dn" "Daily note" item
      (file+function bullet-org isamert/org-capture--find-daily-notes)
      "%a. %?"
      :prepend t)

     ("s" "Snippets")
     ("ss" "Snippet" entry
      (file+function snippets-org isamert/org-capture--find-snippet)
      "** ")
     ("so" "One liner snippet" item
      (file+function snippets-org isamert/org-capture--find-snippet-one-liner)
      "- %? :: ")

     ("D" "Diary" entry
      (file diary-org)
      "* %u\n"
      :prepend t)
     ("m" "Meeting/clock note" item
      (clock))))

  (defun isamert/org-capture--find-daily-notes ()
    (isamert/bullet-focus-today)
    (re-search-forward "^** Notes" nil t))

  (defun isamert/org-capture--find-daily-summary ()
    (isamert/bullet-focus-today)
    (re-search-forward "^** Summary" nil t))

  (defun isamert/org-capture--find-snippet ()
    (let* ((mode-name (with-current-buffer (org-capture-get :original-buffer)
                        (symbol-name major-mode)))
           (result (org-find-exact-headline-in-buffer mode-name)))
      (if result
          (goto-char result)
        (goto-char (point-min))
        (re-search-forward (concat "^\\(" org-outline-regexp "\\)") nil t)
        (forward-line -1)
        (insert (format "\n* %s" mode-name)))))

  (defun isamert/org-capture--find-snippet-one-liner ()
    (isamert/org-capture--find-snippet)
    (unless (re-search-forward "\\*\\* One-liners" nil t)
      (end-of-line)
      (insert "\n** One-liners")))
#+end_src
** Fancy/pretty stuff
#+begin_src emacs-lisp
  (setq org-tags-column 0)
  ;; ^ This does not work well with combination of org-fancy-priorities and org-pretty tags, so I disable it
  ;; And it also makes sense to disable this because it restricts yyour heading char limit.

  ;; Make headings look better with nice bullets.
  ;; It also adjusts the size of headings according to their level.
  (use-package org-bullets
    :hook (org-mode . org-bullets-mode))

  (use-package org-fancy-priorities
    :diminish
    :hook (org-mode . org-fancy-priorities-mode)
    :config
    (setq org-fancy-priorities-list '("🅰" "🅱" "🅲" "🅳" "🅴")))

  ;; Pretty nice website to find unicode stuff: unicode-table.com
  (use-package org-pretty-tags
    :diminish org-pretty-tags-mode
    :config
    (setq org-pretty-tags-surrogate-strings
          '(("work"  . "⚒")
            ("meeting" . "☎")
            ("side"  . "❄")
            ("learning" . "♢")
            ("must"  . "✠")
            ("rutin" . "♟")
            ("study" . "☣")))
    (org-pretty-tags-global-mode))


  (isamert/prettify-mode 'org-mode-hook
                         '(("[ ]" . "☐")
                           ("[X]" . "☑")
                           ("[-]" . "❍")
                           ("#+begin:" . "»")
                           ("#+end" . "«")
                           ("#+BEGIN:" . "»")
                           ("#+END" . "«")
                           ("#+begin_src" . "»" )
                           ("#+end_src" . "«" )
                           ("#+BEGIN_SRC" . "»" )
                           ("#+END_SRC" . "«" )))
#+end_src

** org-clock
#+begin_src emacs-lisp
  ;; For Linux:
  (defun isamert/org-clock-today-all ()
    "Return todays all clocked hours."
    (with-current-buffer "bullet.org"
      (save-excursion
        (save-restriction
          (isamert/bullet-focus-today)
          (let ((range (org-clock-special-range 'untilnow)))
            (format
             "%s %s%s"
             (or (and (org-clocking-p) "") "")
             (org-minutes-to-clocksum-string (org-clock-sum (car range) (cadr range)))
             (or (and (org-clocking-p) (format " (%s)" (org-duration-from-minutes (org-clock-get-clocked-time)))) "")))))))

  ;; For macOS
  ;; https://github.com/koddo/org-clock-statusbar-app

  (defun isamert/org-clock-statusbar-clock-in ()
    (interactive)
    (if (eq system-type 'darwin)
        (call-process "/usr/bin/osascript" nil 0 nil "-e"
                      (concat "tell application \"org-clock-statusbar\" to clock in \""
                              (replace-regexp-in-string "\"" "\\\\\"" org-clock-current-task)
                              "\""))))

  (defun isamert/org-clock-statusbar-clock-out ()
    (interactive)
    (call-process "/usr/bin/osascript" nil 0 nil "-e"
                  "tell application \"org-clock-statusbar\" to clock out"))

  (when (eq system-type 'darwin)
    (add-hook 'org-clock-in-hook #'isamert/org-clock-statusbar-clock-in)
    (add-hook 'org-clock-out-hook #'isamert/org-clock-statusbar-clock-out))
#+end_src

** org-ql
#+BEGIN_SRC emacs-lisp
  (use-package org-ql
    :config
    ;; Load org-ql-search prematurely to be able to use org-ql blocks in
    ;; org-mode
    (require 'org-ql-search))
#+END_SRC

** Linking improvements
Org does not provide an easy way to copy link at point. Here is a fix for that:

#+begin_src emacs-lisp
  ;; Source: https://emacs.stackexchange.com/a/60555
  (defun isamert/org-link-copy (&optional arg)
    "Extract URL from org-mode link and add it to kill ring."
    (interactive "P")
    (let* ((link (org-element-lineage (org-element-context) '(link) t))
           (type (org-element-property :type link))
           (url (org-element-property :path link))
           (url (concat type ":" url)))
      (kill-new url)
      (message (concat "Copied URL: " url))))
#+end_src

This following trick (got it from [[https://www.reddit.com/r/emacs/comments/o68i0v/weekly_tips_tricks_c_thread/h2rizey?utm_source=share&utm_medium=web2x&context=3][this]] comment) simply calls =C-h .= (=display-local-help=) when idle, which shows the destination of links in the echo area (and maybe displays other helpful stuff).

#+begin_src emacs-lisp
  (defun isamert/help-at-point-mode ()
    "Show tooltips in the echo area automatically for current buffer."
    (setq-local help-at-pt-display-when-idle t)
    (setq-local help-at-pt-timer-delay 0)
    (help-at-pt-cancel-timer)
    (help-at-pt-set-timer))

  (add-hook 'org-mode-hook #'isamert/help-at-point-mode)
#+end_src

Insert links/images more intelligently,
- if region is selected and there is a url in the clipboard, convert it to a link directly.
- if nothing is selected and there is a link in clipboard, just insert it as a link with the link's own title.
- if clipboard has in image in it, save that into a file that you interactively select and then insert it into the buffer.
- otherwise call ~org-insert-link~

#+begin_src emacs-lisp
  (evil-leader/set-key "oP" #'isamert/org-insert-dwim)

  (defun isamert/org-insert-dwim ()
    "Like `org-insert-link' but improved with dwim features.
      Based on: https://xenodium.com/emacs-dwim-do-what-i-mean/"
    (interactive)
    (let* ((point-in-link (org-in-regexp org-link-any-re 1))
           (clipboard-url (when (string-match-p "^http" (current-kill 0))
                            (current-kill 0)))
           (region-content (when (region-active-p)
                             (buffer-substring-no-properties (region-beginning)
                                                             (region-end)))))
      (cond
       ((isamert/has-clipboard-image)
        (call-interactively 'isamert/org-attach-image-from-clipboard))
       ((and region-content clipboard-url (not point-in-link))
        (delete-region (region-beginning) (region-end))
        (insert (org-make-link-string clipboard-url region-content)))
       ((and clipboard-url (not point-in-link))
        (insert (org-make-link-string
                 clipboard-url
                 (read-string "title: "
                              (with-current-buffer (url-retrieve-synchronously clipboard-url)
                                (dom-text (car
                                           (dom-by-tag (libxml-parse-html-region
                                                        (point-min)
                                                        (point-max))
                                                       'title))))))))
       (t
        (call-interactively 'org-insert-link)))))

  (defun isamert/org-attach-image-from-clipboard (&optional file-path)
    "Attach the image in the clipboard into your org-buffer.
      This function saves the image file into the FILE-PATH or
      if it's not provided then it saves the image into ~/.cache."
    (interactive "FSave file to (leave empty to create a temp file): ")
    (let ((file (if (and file-path (not (string-empty-p file-path)))
                    file-path
                  (make-temp-file "~/.cache/org_temp_image_" nil ".png"))))
      (if (isamert/save-clipboard-image-to-file file)
          (insert (format "#+ATTR_ORG: :width 400\n[[file:%s]]" file))
        (user-error "Saving file failed!"))))

#+end_src

** Renaming files under cursor
#+begin_src emacs-lisp
  (defun isamert/org-rename-file-at-point ()
    "Interactively rename the file under cursor and update the link."
    (interactive)
    (let* ((link (org-element-context))
           (type (org-element-property :type link))
           (path (org-element-property :path link))
           (begin (org-element-property :begin link))
           (end (org-element-property :end link))
           (cbegin (org-element-property :contents-begin link))
           (cend (org-element-property :contents-end link))
           content)
      (unless (equal type "file")
        (user-error "Link is not a file"))
      (when (and cbegin cend)
        (setq content (format "[%s]" (buffer-substring-no-properties cbegin cend))))
      (let ((use-relative? (not (file-name-absolute-p path)))
            (fname (read-file-name "New name: "
                                   (expand-file-name
                                    (file-name-directory path))
                                   path)))
        (when use-relative?
          (setq fname (concat "./" (file-relative-name fname))))
        (save-excursion
          (rename-file path fname)
          (delete-region begin end)
          (insert (format "[[file:%s]%s]"
                          fname
                          (or content "")))))))
#+end_src

** Project management
I'm doing all of my project management in org-mode. Here you can find some supplementary functionality that makes project management within org-mode easy.

*** Do a regexp search in a project inside a org dynamic block
Here I create a dynamic block for org-mode, named ~project-grep~. You can create a block like the following:

#+begin_example
  ,#+begin: project-grep :root "~/Workspace/projects/dotfiles" :regexp "TODO"
  ,#+end
#+end_example

When you invoke =C-c C-c= on that block, it will automatically run given REGEXP in given ROOT and create a nicely formatted table containing all the results. Results are formatted into org-links you can easily jump into.

#+begin_src emacs-lisp
  (defun org-dblock-write:project-grep (params)
    "Do a regular expression search in given project.
  PARAMS may contain `:root' or `:regexp'.

  `:root' - Where to run the search. If it's skipped, it's
  `default-directory'.

  `:regexp' - Regexp to grep in given folder. If it's skipped it
  searches for TODO/FIXME items in given folder."
    (let* ((root (or (plist-get params :root) default-directory))
           (regexp (or (plist-get params :regexp) "(//|#|--|;)+ ?(TODO|FIXME)"))
           (default-directory root))
      (--map (insert (format "%s | " it)) '("" "ID" "File" "Content"))
      (insert "\n")
      (insert "|-|\n")
      (--each-indexed
          (s-split
           "\n"
           (shell-command-to-string (format "rg --line-number '%s'" regexp))
           'omit-nulls)
        (let* ((data (s-split-up-to ":" it 2))
               (file (s-join ":" (-take 2 data)))
               (file-link (concat "[[file:" default-directory "/" (s-replace ":" "::" file) "][" file "]]"))
               (content (s-replace "|" " \\vert " (-last-item data))))
          (insert "| ")
          (insert (format "%s" it-index))
          (insert " | ")
          (insert file-link)
          (insert " | ")
          (insert content)
          (insert " |\n"))))
    (delete-char 1)
    (org-table-align))
#+end_src

* Other packages
** tabulated-list-mode
- It's a built-in mode that shows some kind of tabulated data.
- It is used by many major modes, like [[docker]], [[prodigy]], etc. I just add these common keybindings to have a consistent way of navigating in them.
- I also try to bind following keys in their respective mode maps:
  - =a= key to a function that lists all the actions that can be taken on current column.
  - =Enter= to the default action (generally opening something etc.)

#+begin_src emacs-lisp
  (use-package tabulated-list
    :config
    (evil-define-key 'normal tabulated-list-mode-map
      (kbd "{") #'tabulated-list-narrow-current-column
      (kbd "}") #'tabulated-list-widen-current-column
      (kbd "H") #'tabulated-list-previous-column
      (kbd "L") #'tabulated-list-next-column
      (kbd "s") #'tabulated-list-sort
      (kbd "r") #'tabulated-list-revert))
#+end_src

** Hydra
Hydra creates a menu for quickly calling/toggling functions/modes in a visually easy way. My main use case for it right now is grouping bunch of appearance related functions/modes that I use infrequently. I believe for hydra's are not very useful for commands that you use frequently, it makes things slower than a plain keybinding but it's quite useful for the stuff that you forget or use infrequently.

#+begin_src emacs-lisp
  (use-package hydra
    :config)

  (use-package use-package-hydra
    :after hydra)

  (use-package pretty-hydra
    :after hydra
    :config
    (pretty-hydra-define appearance
      (:foreign-keys warn :title "Appearance" :quit-key "q" :color amaranth)
      ("Display"
       (("W" writeroom-mode "Writeroom mode" :toggle t)
        ("n" display-line-numbers-mode "Line numbers" :toggle t)
        ("+" default-text-scale-increase "Zoom In")
        ("-" default-text-scale-decrease "Zoom Out"))
       "Highlighting"
       (("g" diff-hl-mode "Highlight git diff" :toggle t)
        ("d" rainbow-delimiters-mode "Rainbow parens" :toggle t)
        ("=" global-hl-line-mode "Highlight current line" :toggle t)
        ("b" beacon-mode "Cursor trailer (baecon)" :toggle t)
        ("w" isamert/whitespace-mode-toggle "Whitespaces" :toggle t)
        ("t" highlight-thing-mode "Highlight current symbol" :toggle t))
       "Miscellaneous"
       (("l" visual-line-mode "Wrap lines" :toggle t)
        ("T" toggle-truncate-lines "Truncate lines")
        ("i" highlight-indent-guides-mode "Indent Guides" :toggle t)
        ("f" fci-mode "Fill column" :toggle t)
        ("<SPC>" nil "Quit" :color blue))))

    (evil-leader/set-key
      "a" #'appearance/body))
#+end_src
** wgrep
With this package, you can make =grep= buffers editable and your edits can be applied to the files itself. Also =embark= has a feature where you can export the current completing-read results into a grep buffer, the action is called =embark-export= and it works on =consult-ripgrep= etc.
- Do ~C-c C-p~ (or =i=, enabled by evil-collection) on a =grep= buffer to make it editable.
- Do ~C-j~ or ~C-k~ (enabled by evil-collection, by default you need to use =n=) to peek at next/prev instance.

#+begin_src emacs-lisp
  (use-package wgrep)
#+end_src
** dired
There is also ~wdired-mode~ which you can use to do bulk rename intuitively.

#+begin_src emacs-lisp
  (defun isamert/dired-up-directory ()
    "Like `dired-up-directory' but it does not create a new frame.
    Uses the existing one."
    (interactive)
    (find-alternate-file ".."))

  (setq dired-dwim-target t
        ls-lisp-dirs-first t
        ls-lisp-use-insert-directory-program nil)
  (put 'dired-find-alternate-file 'disabled nil)

  ;; Other bindings are defined within evil-collection/dired
  ;; Following gives more ranger-y feeling to dired
  (evil-define-key 'normal dired-mode-map
    "h" 'isamert/dired-up-directory
    "l" 'dired-find-alternate-file)

  ;; Add icons to dired buffers
  (add-hook 'dired-mode-hook 'treemacs-icons-dired-mode)

  (evil-leader/set-key "ed" #'dired)
#+end_src
** image-mode
I want to be able to kill image buffers with simply hitting =q=. This does that.

#+begin_src emacs-lisp
  (evil-set-initial-state 'image-mode 'normal)
  (evil-define-key 'normal image-mode-map
    "q" #'evil-delete-buffer
    "r" #'image-rotate)
#+end_src

** calendar & diary
#+begin_src emacs-lisp
  (use-package calendar
    :config
    (evil-leader/set-key "ec" #'calendar)

    ;; Start the week from Monday
    (setq calendar-week-start-day 1)

    ;; lng and lat for my location, to get sunrise/sunset times on my
    ;; calendar (press gs)
    (setq calendar-latitude 41.0082)
    (setq calendar-longitude 28.9784)

    ;; Use 24-hour format to display times
    (setq calendar-time-display-form
          '(24-hours ":" minutes (if time-zone " (") time-zone (if time-zone ")")))

    ;; Enable including other diary entries using the #include "..." syntax
    ;; I use this to separate my work and normal diary
    (add-hook 'diary-list-entries-hook #'diary-include-other-diary-files)
    (add-hook 'diary-list-entries-hook #'diary-sort-entries t)
    (setq diary-display-function #'diary-fancy-display)

    ;; Show calendar at the bottom
    (isamert/shackle-window "Calendar" 0.2)

    ;; https://www.emacswiki.org/emacs/CalendarWeekNumbers
    (defun isamert/calendar-week-number-mode ()
      "Show week numbers in M-x calendar."
      (copy-face font-lock-constant-face 'calendar-iso-week-face)
      (set-face-attribute 'calendar-iso-week-face nil :height 0.7)
      (setq
       calendar-intermonth-text
       '(propertize
         (format "%2d"
                 (car
                  (calendar-iso-from-absolute
                   (calendar-absolute-from-gregorian (list month day year)))))
         'font-lock-face 'calendar-iso-week-face)))

    (isamert/calendar-week-number-mode))
#+end_src

*** Automatically syncing with remote calendars
I'm experimenting with using default Emacs calendar as my work calendar. To do so, I import the remote calendar into my diary using the following function. Set ~isamert/calendar-remote-ics-file~ to the url of ICS file beforehand.

#+begin_src emacs-lisp
  (defconst isamert/work-diary-path (expand-file-name "~/.emacs.d/.cache/work-diary"))

  (defun isamert/update-calendar ()
    "Sync emacs calendar/diary with my remote calendar."
    (interactive)
    (message ">> Updating the calender...")
    (url-retrieve
     isamert/calendar-remote-ics-file
     (lambda (status)
       (delete-region (point-min) url-http-end-of-headers)
       ;; Following is required because some diary entries may contain
       ;; Turkish characters and url-retrieve does not set
       ;; buffer-multibyte to t automatically
       (set-buffer-multibyte t)
       ;; First completely remove the file then import it so that
       ;; importing does not create duplicates
       (mapc
        (lambda (buf)
          (when-let* ((buffile (buffer-file-name buf))
                      (is-open (string-equal (expand-file-name buffile) isamert/work-diary-path)))
            (let ((kill-buffer-hook '()))
              (kill-buffer buf))))
        (buffer-list))
       (--filter it
                 (mapcar
                  (lambda (buf)
                    (buffer-file-name buf))
                  (buffer-list)))
       (delete-file isamert/work-diary-path)
       (icalendar-import-buffer isamert/work-diary-path t)
       (message ">> Updating the calendar... DONE"))))
#+end_src

To sync it automatically:

#+begin_src emacs-lisp
  (run-with-timer 60 (* 30 60) #'isamert/update-calendar)
#+end_src

*** Open zoom meetings easily
Opening a zoom link first redirects you to a browser and then opens the zoom app, but if you just use the ~zoommtg://~ schema to open a zoom meeting, it directly opens the app which is quite nice.

#+begin_src emacs-lisp
  (defun isamert/open-zoom-meeting-dwim (link)
    "Open the zoom meeting at point or the one in the kill-ring."
    (interactive)
    (when-let (zoom (s-match
                     "https://.*zoom\\.us/j/\\(\\w+\\)\\?pwd=\\(\\w+\\)"
                     (or (thing-at-point 'url) (car kill-ring))))
      (message "Opening zoom...")
      (shell-command
       "open 'zoommtg://zoom.us/join?confno=%s&pwd=%s'"
       (nth 1 zoom)
       (nth 2 zoom))))
#+end_src
** tramp
#+begin_src emacs-lisp
  (setq tramp-default-method "ssh")
  (setq tramp-verbose 2)
  ;; ^ Only show errors and warnings
  (setq vc-handled-backends '(Git))
  ;; ^ Only try to handle git, this speeds up things a little bit
#+end_src

** eww
- *eww* lets you browse the web in a simple manner inside Emacs. It synergies well with [[elfeed]] etc.
- I use ~shrface~ to make things look a bit prettier and it also makes buffer somewhat behave like an org-mode buffer, so that's good.

#+begin_src emacs-lisp
  (use-package shrface
    :config
    (shrface-basic)
    (shrface-trial)
    (setq shrface-href-versatile t))

  (use-package eww
    :config
    (add-hook 'eww-after-render-hook #'shrface-mode)
    (setq shr-image-animate nil)
    ;; ^ Gifs make my computer suffer, so I just disable them
    (setq shr-use-fonts nil)
    ;; ^ Monospace fonts are easier to read
    (setq shr-max-image-proportion 0.6)
    (setq shr-discard-aria-hidden t)

    (defvar isamert/url-handlers
      '((".*\\(trendyol\\|gitlab\\|github\\).*" . browse-url-default-browser)
        (".*youtube.*/watch.*" . (lambda (url &rest args) (start-process "mpv-emacs" nil "mpv" url)))
        ("." . eww-browse-url)))

    (if (>= emacs-major-version 28)
        (setq browse-url-handlers isamert/url-handlers)
      (setq browse-url-browser-function isamert/url-handlers))

    (evil-define-key 'normal eww-mode-map
      (kbd "Y") #'eww-copy-page-url
      (kbd "d") #'isamert/eww-save-image)

    (add-hook 'eww-mode-hook #'isamert/help-at-point-mode)

    (evil-define-key 'normal eww-mode-map
      (kbd "<tab>") 'shrface-outline-cycle
      (kbd "S-<tab>") 'shrface-outline-cycle-buffer
      (kbd "C-t") 'shrface-toggle-bullets
      (kbd "[[") 'shrface-previous-headline
      (kbd "]]") 'shrface-next-headline
      (kbd "M-l") 'shrface-links-consult
      (kbd "M-h") 'shrface-headline-consult))

  (defun isamert/eww-save-image ()
    "Save the image at point."
    (interactive)
    (let ((image (get-text-property (point) 'display))
          ;; Disable all save hooks as they might damage the file
          (before-save-hook '())
          (after-save-hook '()))
      (unless (and image
                   (eq (car image) 'image))
        (user-error "No images at point!"))
      (with-temp-buffer
        (setq buffer-file-name
              (read-file-name "Save to: "  nil default-directory nil))
        (insert (plist-get (cdr image) :data))
        (save-buffer))))
#+end_src

** eshell
#+begin_src emacs-lisp
  (use-package eshell
    :config
    (setq eshell-hist-ignoredups t)
    (setq eshell-history-size 1500)
    (setq eshell-error-if-no-glob t)
    (setq eshell-glob-case-insensitive t)
    (setq eshell-kill-processes-on-exit t)
    (evil-define-key 'insert 'eshell-mode-map (kbd "C-r") #'consult-history))

  ;; Adds nice tab completion to eshell (completes subcommands etc.,
  ;; eshell already completes file-paths interactively)
  (use-package pcmpl-args)

  (defun isamert/run-last-command-on-visible-eshell ()
    "Run last command on the currently visible eshell window and return back to current window."
    (interactive)
    (isamert/with-visible-buffer ".*eshell.*"
     (eshell-previous-input 1)
     (eshell-send-input)
     t))
#+end_src

** treemacs
#+BEGIN_SRC emacs-lisp
  (use-package treemacs
    :defer t
    :config
    (setq treemacs-show-hidden-files nil
          treemacs-width 34
          treemacs-space-between-root-nodes nil
          treemacs-indentation 2)
    (add-to-list 'treemacs-ignored-file-predicates (lambda (filename abspath) (string-equal filename "node_modules")))

    (evil-define-key 'treemacs treemacs-mode-map
      ;; Treemacs has it's own mode, named treemacs.
      (kbd "M-f") 'treemacs
      (kbd "M-l") 'evil-window-right
      (kbd "\\") 'treemacs-visit-node-horizontal-split
      (kbd "-") 'treemacs-visit-node-vertical-split
      (kbd "W") 'treemacs-switch-workspace
      (kbd "E") 'treemacs-edit-workspaces
      (kbd "l") 'treemacs-TAB-action
      (kbd "h") 'treemacs-TAB-action
      (kbd "D") 'treemacs-delete
      (kbd "]]") 'treemacs-next-neighbour
      (kbd "[[") 'treemacs-previous-neighbour
      (kbd "]p") 'treemacs-next-project
      (kbd "[p") 'treemacs-previous-project
      (kbd "zm") 'treemacs-collapse-all-projects
      (kbd "za") 'treemacs-toggle-node
      (kbd "s") 'avy-goto-word-1
      (kbd "S") 'avy-goto-char-2
      (kbd "gl") 'avy-goto-line)

    (evil-define-key 'normal 'global
      (kbd "M-f") #'treemacs))

  (use-package treemacs-evil
    :after treemacs evil)

  (use-package treemacs-projectile
    :after treemacs projectile)

  (use-package treemacs-icons-dired
    :after treemacs dired
    :config (treemacs-icons-dired-mode -1))

  (use-package treemacs-magit
    :after treemacs magit)
#+END_SRC

** winner-mode
This mode allows you to do /undo/ /redo/ operations on window layout changes. My most frequent use case is that sometimes I just want to focus on one window for a while and then return back to my old layout setup. These keybindings allows me to do that.

#+BEGIN_SRC emacs-lisp
  (setq winner-dont-bind-my-keys t)
  (winner-mode t)
  (evil-define-key 'normal 'global
    (kbd "C-w 1") 'delete-other-windows
    (kbd "C-w r") 'winner-redo
    (kbd "C-w u") 'winner-undo)
#+END_SRC

** ace-window
- =SPC ws= to swap windows.
- Some shortcuts, after doing =SPC ww=:
  - x - delete window
  - m - swap windows
  - M - move window
  - c - copy window
  - j - select buffer
  - n - select the previous window
  - u - select buffer in the other window
  - c - split window fairly, either vertically or horizontally
  - v - split window vertically
  - b - split window horizontally
  - o - maximize current window
  - ? - show these command bindings

#+begin_src emacs-lisp
  (use-package ace-window
    :config
    (custom-set-faces
     '(aw-leading-char-face
       ((t (:foreground "deep sky blue" :bold t :height 3.0)))))
    (evil-leader/set-key "ww" #'ace-window)
    (evil-leader/set-key "ws" #'ace-swap-window)
    (evil-leader/set-key "wl" #'evil-window-move-far-right)
    (evil-leader/set-key "wh" #'evil-window-move-far-left)
    (evil-leader/set-key "wj" #'evil-window-move-very-bottom)
    (evil-leader/set-key "wk" #'evil-window-move-very-top))
#+end_src

** which-key
A package that shows key combinations. (for example press C-x and wait) It also works with ~evil-leader~, just press leader key and wait to see your options. I made a few adjustment so that it's more compact and you can see full function names (most of the time) and it shows up at the top center instead of bottom left corner. This mostly eliminates the need for creating a [[Hydra]].

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :diminish which-key-mode
    :config
    (setq which-key-min-display-lines 5)
    (setq which-key-max-display-columns 5)
    (setq which-key-max-description-length 70)
    (setq which-key-idle-delay 0.5)
    (setq which-key-sort-order #'which-key-description-order)
    (which-key-mode))

  (unless (eq system-type 'darwin)
    ;; It causes some annoyances on darwin
    (use-package which-key-posframe
      :after (which-key mini-frame)
      :diminish
      :quelpa (which-key-posframe
               :fetcher github
               :repo "yanghaoxie/which-key-posframe")
      :config
      (set-face-attribute 'which-key-posframe nil :background "#373b43")
      (set-face-attribute 'which-key-posframe-border nil :background "#373b43")
      ;; Obtained the "#373b43" by calling `(mini-frame-get-background-color)'

      (setq which-key-posframe-border-width 12)
      (setq which-key-posframe-poshandler 'posframe-poshandler-frame-top-center)
      (which-key-posframe-mode)))
#+END_SRC

** magit & forge
*** Installation
- Read this for some useful status mode keymaps: https://endlessparentheses.com/it-s-magit-and-you-re-the-magician.html
  - y :: Branch viewer (delete branches with ~k~)
  - ll :: Log current
  - bs :: Branch spin-off; create and checkout to a new branch, carry over the ongoing changes. It also undoes the changes in the current branch
  - bc :: Branch create; you can directly create new branch from *origin/develop* for instance

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :config
    ;; Following snippet is needed to update modeline after a checkout happens
    (defun isamert/vc-refresh-state-advice (a &optional b)
      "Refresh VC state after a checkout."
      (vc-refresh-state))
    (advice-add 'magit-checkout :after #'isamert/vc-refresh-state-advice)

    (evil-leader/set-key
      ;; magit/git
      "gs" 'magit-status
      "gf" 'magit-file-dispatch
      "gp" 'magit-pull
      "gP" 'magit-push
      "gr" 'magit-reset
      "gcc" 'magit-checkout
      "gcf" 'magit-file-checkout
      "gB" 'magit-blame
      "gb" 'magit-branch))
#+END_SRC

*** magit-todos
Show TODO/FIXME etc in magit-status buffer.
#+BEGIN_SRC emacs-lisp
  (use-package magit-todos
    :config
    (magit-todos-mode 1))
#+END_SRC

*** git-timemachine
- Toggle with ~git-timemachine~.
- When in timemachine,
  - use =gt<SOMETHING>= to do timemachine specific operations.
  - ~C-j/k~ to go to prev/next revision of the file.

#+begin_src emacs-lisp
  (use-package git-timemachine
    :after magit
    :config

    (evil-leader/set-key  "gt" #'git-timemachine-toggle)

    ;; Override completing-read function to make it use
    ;; `completing-read' no matter what
    (defun git-timemachine-completing-read-fn (&rest args)
      (apply 'completing-read args)))
#+end_src

** persp-mode and eyebrowse
Spacemacs has something called ~layouts~ (or something like that), which let's you have ~persp-mode~ and ~eyebrowse~ work together. Just installing eyebrowse and persp-mode just doesn't work. Hence, I copied the glue code from Spacemacs (using [[https://gist.github.com/gilbertw1/8d963083efea41f28bfdc85ed3c93eb4][this gist]]).


#+BEGIN_SRC emacs-lisp
  (use-package persp-mode
    :config
    (setq persp-nil-hidden nil)
    (setq persp-nil-name "main")
    (setq persp-autokill-buffer-on-remove 'kill-weak)
    (setq persp-set-last-persp-for-new-frames nil)
    (setq persp-set-frame-buffer-predicate nil)
    ;; ^ This breaks {next,previous}-buffer functionality if set to t

    (evil-leader/set-key
      "la" #'persp-add-buffer
      "ls" #'persp-switch
      "lk" #'persp-remove-by-name
      "lr" #'persp-rename
      "li" #'isamert/initialize-perspectives
      "ll" #'isamert/persp-switch-to-last
      "l1" (lambda () (interactive) (persp-switch "personal/planning"))
      "l2" (lambda () (interactive) (persp-switch "personal/dotfiles"))
      "l3" (lambda () (interactive) (persp-switch "work/scratch"))
      "le" #'isamert/persp-show-current-persp-name)

    ;; Add every newly opened buffer to current perspective
    (setq persp-add-buffer-on-after-change-major-mode t)

    ;; Don't open saved perspectives automatically
    (setq persp-auto-resume-time -1)

    ;; ...and filter the ones I don't want to be in the perspective
    (add-hook
     'persp-common-buffer-filter-functions
     #'isamert/filter-buffers-for-persp-mode)

    (defun isamert/filter-buffers-for-persp-mode (b)
      (let ((bname (buffer-name b))
            (mmode (buffer-local-value 'major-mode b)))
        (or (s-prefix? "magit" bname)
            (and (s-prefix? "*" bname) (not (or (s-contains? "eshell" bname) (s-contains? "Org Src" bname))))
            (s-equals? "dired-mode" mmode))))

    (add-hook 'after-init-hook #'(lambda () (persp-mode 1))))


  (use-package eyebrowse
    :config
    (setq eyebrowse-new-workspace t)
    (setq eyebrowse-mode-line-style 'current)

    (evil-define-key '(normal insert) 'global (kbd "M-1") #'eyebrowse-switch-to-window-config-1)
    (evil-define-key '(normal insert) 'global (kbd "M-2") #'eyebrowse-switch-to-window-config-2)
    (evil-define-key '(normal insert) 'global (kbd "M-3") #'eyebrowse-switch-to-window-config-3)
    (evil-define-key '(normal insert) 'global (kbd "M-4") #'eyebrowse-switch-to-window-config-4)
    (evil-define-key '(normal insert) 'global (kbd "M-5") #'eyebrowse-switch-to-window-config-5)
    (evil-define-key '(normal insert) 'global (kbd "M-,") #'eyebrowse-prev-window-config)
    (evil-define-key '(normal insert) 'global (kbd "M-.") #'eyebrowse-next-window-config)

    (eyebrowse-mode)

    ;; For `isamert/persp-switch-to-last'
    (add-hook 'persp-before-switch-functions
              #'isamert/persp-update-last-persp)

    ;; Glue for persp-el and eyebrowse
    (add-hook 'persp-before-switch-functions
              #'workspaces/update-eyebrowse-for-perspective)
    (add-hook 'eyebrowse-post-window-switch-hook
              #'workspaces/save-eyebrowse-for-perspective)
    (add-hook 'persp-activated-functions
              #'workspaces/load-eyebrowse-for-perspective)
    (add-hook 'persp-before-save-state-to-file-functions
              #'workspaces/update-eyebrowse-for-perspective)
    (add-hook 'persp-after-load-state-functions
              #'workspaces/load-eyebrowse-after-loading-layout))

  (defvar isamert/persp-last-persp-name nil
    "Name of the last perspective.")

  (defun isamert/persp-update-last-persp (&rest args)
    (setq
     isamert/persp-last-persp-name
     (or (ignore-errors (persp-name (get-current-persp))) persp-nil-name)))

  (defun isamert/persp-switch-to-last ()
    "Switch to lastly opened perspective."
    (interactive)
    (persp-switch isamert/persp-last-persp-name))

  (defun isamert/initialize-perspectives ()
    "Open my default perspectives with some buffers in them."
    (interactive)
    (message ">> Perspectives are opening...")
    (let ((enable-local-variables :all))
      (progn
        (persp-add-new "personal/dotfiles")
        (persp-switch "personal/dotfiles")
        (find-file "~/Workspace/projects/dotfiles/index.org")
        (eyebrowse-switch-to-window-config-2)
        (find-file "~/Workspace/projects/dotfiles/emacs/index.org"))
      (progn
        (persp-add-new "personal/planning")
        (persp-switch "personal/planning")
        (find-file bullet-org)
        (isamert/bullet-focus-today)
        (eyebrowse-switch-to-window-config-2)
        (find-file engineering-org)
        (eyebrowse-switch-to-window-config-3)
        (find-file snippets-org)
        (eyebrowse-switch-to-window-config-4)
        (find-file projects-org)
        (eyebrowse-switch-to-window-config-5)
        (find-file passwords-org))
      (progn
        (persp-add-new "work/scratch")
        (persp-switch "work/scratch")
        (find-file work-org))
      (persp-switch "main")
      (message ">> Perspectives are opening... Done.")))

  (defun isamert/persp-show-current-persp-name ()
    "Display current persp name and `default-directory' on echo area."
    (interactive)
    (message ">> %s (%s)" (persp-name (get-current-persp)) default-directory))

  ;;
  ;; persp-el & eyebrowse glue code
  ;; Based
  ;;

  (defun workspaces/get-persp-workspace (&optional persp frame)
    "Get the correct workspace parameters for perspective.
  PERSP is the perspective, and defaults to the current perspective.
  FRAME is the frame where the parameters are expected to be used, and
  defaults to the current frame."
    (let ((param-names (if (display-graphic-p frame)
                           '(gui-eyebrowse-window-configs
                             gui-eyebrowse-current-slot
                             gui-eyebrowse-last-slot)
                         '(term-eyebrowse-window-configs
                           term-eyebrowse-current-slot
                           term-eyebrowse-last-slot))))
      (--map (persp-parameter it persp) param-names)))

  (defun workspaces/set-persp-workspace (workspace-params &optional persp frame)
    "Set workspace parameters for perspective.
  WORKSPACE-PARAMS should be a list containing 3 elements in this order:
  - window-configs, as returned by (eyebrowse--get 'window-configs)
  - current-slot, as returned by (eyebrowse--get 'current-slot)
  - last-slot, as returned by (eyebrowse--get 'last-slot)
  PERSP is the perspective, and defaults to the current perspective.
  FRAME is the frame where the parameters came from, and defaults to the
  current frame.
  Each perspective has two sets of workspace parameters: one set for
  graphical frames, and one set for terminal frames."
    (let ((param-names (if (display-graphic-p frame)
                           '(gui-eyebrowse-window-configs
                             gui-eyebrowse-current-slot
                             gui-eyebrowse-last-slot)
                         '(term-eyebrowse-window-configs
                           term-eyebrowse-current-slot
                           term-eyebrowse-last-slot))))
      (--zip-with (set-persp-parameter it other persp)
                  param-names workspace-params)))

  (defun workspaces/load-eyebrowse-for-perspective (type &optional frame)
    "Load an eyebrowse workspace according to a perspective's parameters.
   FRAME's perspective is the perspective that is considered, defaulting to
   the current frame's perspective.
   If the perspective doesn't have a workspace, create one."
    (when (eq type 'frame)
      (let* ((workspace-params (workspaces/get-persp-workspace (get-frame-persp frame) frame))
             (window-configs (nth 0 workspace-params))
             (current-slot (nth 1 workspace-params))
             (last-slot (nth 2 workspace-params)))
        (if window-configs
            (progn
              (eyebrowse--set 'window-configs window-configs frame)
              (eyebrowse--set 'current-slot current-slot frame)
              (eyebrowse--set 'last-slot last-slot frame)
              (eyebrowse--load-window-config current-slot))
          (eyebrowse--set 'window-configs nil frame)
          (eyebrowse-init frame)
          (workspaces/save-eyebrowse-for-perspective frame)))))

  (defun workspaces/load-eyebrowse-after-loading-layout (_state-file _phash persp-names)
    "Bridge between `persp-after-load-state-functions' and
  `workspaces/load-eyebrowse-for-perspective'.
  _PHASH is the hash were the loaded perspectives were placed, and
  PERSP-NAMES are the names of these perspectives."
    (let ((cur-persp (get-current-persp)))
      ;; load eyebrowse for current perspective only if it was one of the loaded
      ;; perspectives
      (when (member (or (and cur-persp (persp-name cur-persp))
                        persp-nil-name)
                    persp-names)
        (workspaces/load-eyebrowse-for-perspective 'frame))))

  (defun workspaces/update-eyebrowse-for-perspective (&rest _args)
    "Update and save current frame's eyebrowse workspace to its perspective."
    (let* ((current-slot (eyebrowse--get 'current-slot))
           (current-tag (nth 2 (assoc current-slot (eyebrowse--get 'window-configs)))))
      (eyebrowse--update-window-config-element
       (eyebrowse--current-window-config current-slot current-tag)))
    (workspaces/save-eyebrowse-for-perspective))

  (defun workspaces/save-eyebrowse-for-perspective (&optional frame)
    "Save FRAME's eyebrowse workspace to FRAME's perspective.
  FRAME defaults to the current frame."
    (workspaces/set-persp-workspace (list (eyebrowse--get 'window-configs frame)
                                          (eyebrowse--get 'current-slot frame)
                                          (eyebrowse--get 'last-slot frame))
                                    (get-frame-persp frame)
                                    frame))
#+END_SRC

** avy
avy is very similar to ~vim-easymotion~. It simply jumps to a visible text using a given char.
- =s= for jumping to beginning of a word
- =S= for jumping any part of the text
- =gl= for going into beginning of a line

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :config
    (setq avy-keys '(?q ?w ?e ?r ?t ?a ?s ?d ?f ?j ?k ?l ?u ?i ?o ?p)
          ;; ^ Only use these for jumping.
          avy-case-fold-search nil
          ;; ^ Case-sensetive (smart case) search
          avy-all-windows nil)
          ;; ^ Only do search in current window
    (evil-define-key 'normal 'global
      (kbd "S") 'avy-goto-char-2 ;; Go to any char
      (kbd "s") 'avy-goto-word-1 ;; Go to beginning of a word
      (kbd "gl") 'avy-goto-line))
#+END_SRC

** vertico
A nice, fast minibuffer narrowing framework. It works well with quite a lot of package.
- =marginalia.el= brings annotations to completing-read, ie. it adds current keybinding of a command, summary of command to M-x.
- =miniframe.el= shows all completing-read prompts in a nice mini popup frame.
- Also see [[embark]].

Keybindings:
- =SPC hl= to repeat/open last vertico window you closed.

Some shortcuts you can use on any vertico window:
- =M-{n,p}= goes {back,forward} in minibuffer history.
- =M-{[,]}= goes {previous,next} group.
- =M-m= cycles the marginalia detail level.
- =M-a= brings up embark-act menu. See [[embark]].
- =TAB= inserts the current candidate (into minibuffer).

#+begin_src emacs-lisp
  (use-package vertico
    :config
    (evil-leader/set-key "hl" #'vertico-repeat)

    ;; Grow and shrink the Vertico minibuffer
    ;; (setq vertico-resize t)

    ;; Show more candidates
    (setq vertico-count 15)
    ;; Enable cycling for `vertico-next' and `vertico-previous'.
    (setq vertico-cycle t)
    ;; Hide commands in M-x which do not work in the current mode.
    (setq read-extended-command-predicate #'command-completion-default-include-p)

    ;; Add prompt indicator to `completing-read-multiple'.
    (defun crm-indicator (args)
      (cons (concat "[CRM] " (car args)) (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

    ;; Enable recursive minibuffers
    (setq enable-recursive-minibuffers t)
    (define-key vertico-map (kbd "M-[") #'vertico-previous-group)
    (define-key vertico-map (kbd "M-]") #'vertico-next-group))

  (use-package orderless
    :config
    (setq completion-styles '(orderless))
    (setq completion-category-defaults nil)
    (setq completion-category-overrides '((file (styles partial-completion)))))

  (use-package marginalia
    :config
    (define-key minibuffer-local-map (kbd "M-m") #'marginalia-cycle)
    (marginalia-mode))

  (use-package mini-frame
    :config
    (setq mini-frame-show-parameters
          '((top . 0.15)
            (width . 0.55)
            (left . 0.5))
          mini-frame-color-shift-step 15)

    ;; Disable mini-frame while using some functions either that does
    ;; not work well with mini-frame or it doesn't make sense to use it
    ;; with mini-frame
    (setq mini-frame-ignore-commands
          '(completion-at-point
            completion-at-point
            ctrlf-forward-default
            consult-line
            consult-ripgrep
            isamert/consult-line
            isamert/consult-ripgrep))
    (mini-frame-mode +1))
#+end_src
** consult
Some key points:
- =SPC RET= brings up =consult-buffer=.
  - Typing =SPC {p,f,b,m}= narrows the list into {project files, files, buffers, bookmarks}.
  - Also see: [[id:90769b1b-7baf-4285-80f9-153ae07d73ab][Perspective integration for consult]]
- =M-y= brings up =consult-yank=, where you can select from clipboard history and paste.
- =C-f= does fuzzy search on current file lines.
- Do =M-,= on a candidate to preview it.
- Also don't forget to utilize =M-a= (=embark-act=) in consult windows.
- Use =M-n= (future-history) to insert current symbol after running a consult command. Normally you would use =M-{p,n}= to cycle between history items but when you open minibuffer, typing =M-n= directly tries to guess what the user input would be.

#+begin_src emacs-lisp
  (use-package consult
    :config
    (advice-add #'register-preview :override #'consult-register-window)

    (setq consult-preview-key (kbd "M-,"))
    ;; ^ When you do M-, on a candidate, it previews it

    (evil-leader/set-key
      "hh"  #'consult-history
      "hy"  #'consult-yank-replace
      "gg"  #'consult-git-grep
      "RET" #'consult-buffer)

    (evil-define-key 'normal 'global
      (kbd "M-i") 'consult-imenu
      (kbd "C-f") 'isamert/consult-line)
    (evil-define-key 'normal org-mode-map
      (kbd "M-i") 'consult-org-heading)

    ;; Hide some buffers from consult-buffer window. Just use
    ;; (switch-to-buffer) or (persp-switch-to-buffer) to switch to the
    ;; hidden ones if you want
    (add-to-list
     'consult-buffer-filter
     "\\`\\*\\(Help\\|Backtrace\\|Messages\\|Buffer List\\|Flycheck.*\\|scratch.*\\)\\'")

    <<consult-project-management>>
    <<consult-perspective-buffers>>
    <<consult-perspective-switch-buffers>>)
#+end_src

*** Project management
Some functionality for project management. I do some fine-tuning for =find= and =ripgrep= commands that consult uses.

#+name: consult-project-management
#+begin_src emacs-lisp :tangle no
  (evil-leader/set-key
    "hr"  #'isamert/consult-ripgrep-current-directory
    "hR"  #'isamert/consult-ripgrep-in-given-directory
    "pg" #'isamert/consult-ripgrep)

  ;; TODO fix search
  (setq
   consult-find-command "fd  --hidden --full-path ARG OPTS"
   consult-ripgrep-command "rg  --hidden --null --line-buffered --color=always --max-columns=500 --no-heading --smart-case --line-number . -e ARG OPTS"
   consult-project-root-function #'isamert/current-project-root)

  (defun isamert/consult-ripgrep (&optional path)
    "`consult-ripgrep' in current project.
  `consult-ripgrep' with `consult-project-root-function' shows full path of the
  file in the results.  I don't want that."
    (interactive)
    (consult-ripgrep (or path (isamert/current-project-root))))

  (defun isamert/consult-ripgrep-current-directory ()
    "Do ripgrep in `default-directory'."
    (interactive)
    (consult-ripgrep default-directory))

  (defun isamert/consult-ripgrep-in-given-directory (dir)
    (interactive "DSelect directory: ")
    (consult-ripgrep dir))
#+end_src

*** Perspective integration
:PROPERTIES:
:ID:       90769b1b-7baf-4285-80f9-153ae07d73ab
:END:
I use =(consult-buffer)= function for switching between buffers/files/marks etc. Here I add two sources for =(consult-buffer)=:
- One that only contains buffers for current perspective. This is quite useful for having a visual reference for current perspectives buffers.
- Another that adds list of my frequently used files. This is also handy in a way that =(consult-buffer)= becomes my go-to place for switching to anything.

#+name: consult-perspective-buffers
#+begin_src emacs-lisp
  (defvar isamert/consult-source-perspective-buffers
    `(:name     "Perspective buffers"
                :narrow   ?P
                :category buffer
                :face     consult-buffer
                :history  buffer-name-history
                :state    ,#'consult--buffer-state
                :default  t
                :items
                ,(lambda ()
                   (let ((filter (consult--regexp-filter consult-buffer-filter)))
                     (seq-remove (lambda (x) (or (not x) (string-match-p filter x)))
                                 (ignore-errors (mapcar #'buffer-name (persp-buffers (get-current-persp))))))))
    "Current persp buffer candidate source for `consult-buffer'.")

  (defvar isamert/consult-source-files
    `(:name     "My files"
                :narrow   ?F
                :category file
                :face     consult-file
                :history  file-name-history
                :state    ,#'consult--file-state
                :default  t
                :items    isamert/my-files)
    "My frequently accessed files source for `consult-buffer'.")

  (setq
   consult-buffer-sources
   `(isamert/consult-source-perspective-buffers
     consult--source-buffer
     consult--source-file
     isamert/consult-source-files
     consult--source-bookmark
     consult--source-project-buffer
     consult--source-project-file))

  (defun isamert/my-files ()
    "Return list of all files I frequently use."
    (mapcar
     (lambda (file) (expand-file-name (concat org-directory "/" file)))
     (if (file-directory-p org-directory)
         (directory-files org-directory nil "^\\w+.*.org$")
       '())))
#+end_src

*** Faster ~consult-line~
~consult-line~ is quite slow on big files. I tried setting ~consult-fontify-max-size~ to a lower number as per [[https://github.com/minad/consult/issues/329][this thread]] but the improvement was not satisfactory. Try setting that first and check if it works for you.

#+begin_src emacs-lisp
  (defun isamert/consult-line ()
    "Like `consult-line' but if the buffer is too big then it calls
  `isamert/consult-ripgrep-buffer'."
    (interactive)
    (if (> (buffer-size) 300000)
        (isamert/consult-ripgrep-buffer)
      (consult-line)))

  (defun isamert/consult-ripgrep-buffer ()
    "Like `consult-ripgrep' but only for the current buffer."
    (interactive)
    (let ((consult-ripgrep-args
           (concat "rg "
                   "--null "
                   "--line-buffered "
                   "--color=never "
                   "--max-columns=1000 "
                   "--smart-case "
                   "--no-heading "
                   "--line-number "
                   "--with-filename "
                   (shell-quote-argument buffer-file-name))))
      (consult-ripgrep)))
#+end_src
** embark
=embark.el= provides contextual command maps.
  - =M-a= activates command mode. Next key should be command. Do =C-h= to list all commands with their keybindings.
  - Commands are context specific, ie. the commands is based on if currently selected item is a file, folder, buffer etc.
  - It's mostly used within the minnibuffer, some example functions:
    - =M-a w= (~embark-save~) saves the current candidate's text into kill-ring.
    - =M-a i= (~embark-insert~) like the one above but instead of saving to the kill-ring, it directly inserts it to the buffer.
    - =M-a S= (~embark-collect-snapshot~) creates a buffer containing all the candidates.

#+begin_src emacs-lisp
  (use-package embark
    :config
    (bind-key (kbd "M-a") #'embark-act)
    (setq embark-prompter #'embark-completing-read-prompter)
    ;; ^ This directly shows the actions in a completing read window.
    ;; By default, it is set to `embark-keymap-prompter' and you need to
    ;; hit `C-h' to bring this menu up.
    (setq embark-indicators '(embark-highlight-indicator embark-isearch-highlight-indicator))
    ;; ^ I removed embark-mixed-indicator from the list because I'm
    ;; using embark-completing-read-prompter by default which already
    ;; provides same functionality
    )

  (use-package embark-consult
    :after (embark consult))
#+end_src

** ~project.el~ and project management
I was using projectile earlier but [[consult]] functions are just more than enough for project management. I only use couple of functions from =project.el= which is already built-in to Emacs.

#+begin_src emacs-lisp
  (defconst isamert/projects-root "~/Workspace/projects")

  (defun isamert/current-project-root ()
    "Return the root path of current project."
    (interactive)
    ;; `project-current' is a function from project.el
    (ignore-errors
      (expand-file-name (cdr (project-current)))))

  (defun isamert/current-project-name ()
    "Return current projects name."
    (when-let ((proot (isamert/current-project-root)))
      (string-trim
       (string-remove-prefix
        (expand-file-name isamert/projects-root)
        proot)
       "/" "/")))
#+end_src

I have all my projects under =~/Workspace/projects=. Some of them are groupped under another directory. This functions loops trough all of the directories and finds the ones without =.git= folder and adds those folders to project paths. Consider this:
#+begin_src
~/Workspace/projects
 ├── groupped_projects
 ├   ├── project3
 ├   └── project4
 ├── project1
 ├   └── .git
 └── project2
     └── .git
#+end_src

#+begin_src emacs-lisp
  (defun isamert/project-cd-root ()
    "CD into current project's root."
    (interactive)
    (cd (isamert/current-project-root)))

  (defun isamert/project-paths ()
    "Find every project dir under `isamert/projects-root'.
  Every folder without a \".git\" folder is considered to be a project group folder."
    (append `(,isamert/projects-root)
            (-flatten (-map (lambda (dir) (if (file-directory-p (concat dir "/.git")) '() `(,dir)))
                            (directory-files isamert/projects-root t "^[^.]")))))

  (defun isamert/find-file-in (dir)
    "Find file in DIR.
  fd is already fast enough, no need for `consult-find's async approach."
    (interactive "D")
    (let ((default-directory dir))
      (->> (shell-command-to-string "fd --exclude '.git' --hidden .")
           (s-split "\n")
           (completing-read "Open file: ")
           (find-file))))

  (defun isamert/find-file-in-current-dir ()
    "Find file in current directory."
    (interactive)
    (isamert/find-file-in default-directory))

  (defun isamert/find-file-in-current-project ()
    "Find file in current project.
  If currently not in a project, switch to a project first and then
  find file."
    (interactive)
    (isamert/find-file-in
     (or (isamert/current-project-root) (isamert/switch-to-project))))

  (defun isamert/switch-to-project ()
    "List all projects found under `isamert/project-paths' and switch to selected."
    "Switch to project: "
    (->> (isamert/project-paths)
         (--map (shell-command-to-string (format "fd --exact-depth 1 --type d . %s" it)))
         (-reduce #'concat)
         (s-split "\n")
         (--map (s-replace (expand-file-name "~") "~" it))
         (completing-read "Switch to project: ")))

  (defun isamert/switch-to-project-and-find-file ()
    (interactive)
    (isamert/find-file-in (isamert/switch-to-project)))

  (defun isamert/switch-to-project-and-grep ()
    (interactive)
    (isamert/consult-ripgrep (isamert/switch-to-project)))

  (evil-leader/set-key
    "pp" #'isamert/switch-to-project-and-find-file
    "pP" #'isamert/switch-to-project-and-grep
    "pf" #'isamert/find-file-in-current-project
    "pF" #'consult-find
    "hf" #'isamert/find-file-in-current-dir)
#+end_src

** flycheck
- Use =ge= (=consult-flycheck=) to list and jump any of the errors/warnings in the buffer.
  - Write ~i SPC~, ~w SPC~, ~e SPC~ to show infos, warnings, errors only in the =consult-flycheck=

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :diminish
    :config
    (setq flycheck-idle-change-delay 1)
    (setq flycheck-check-syntax-automatically '(save new-line mode-enabled))
    ;; ^ Alternatives are (save idle-change new-line mode-enabled)
    (setq flycheck-display-errors-delay 0.3)

    (global-flycheck-mode)

    (evil-define-minor-mode-key 'normal 'flycheck-mode
      (kbd "gE") #'isamert/show-error-list))

  (use-package consult-flycheck
    :after flycheck
    :config
    (evil-define-minor-mode-key 'normal 'flycheck-mode
      (kbd "ge") #'isamert/show-error-list))

  (use-package flycheck-inline
    :after flycheck
    :config
    (global-flycheck-inline-mode))

  (defun isamert/show-error-list (arg)
    "Show all lsp errors or flycheck erros, depending on which is available."
    (interactive "P")
    (if (bound-and-true-p lsp-mode)
        (consult-lsp-diagnostics arg)
      (consult-flycheck)))
#+END_SRC

** company
An in-buffer completion framework. Works nicely with =lsp-mode= and bunch of other stuff.
- =company-box= :: Nice company front-end with icons and very nice documentation on hover thing.
- =company-fuzzy= :: Do fuzzy search in completion, instead of prefix or initials matching. Works quite well with every other backend.
  - Seems to make things slow tho
- =company-org-block= :: Triggers completion when '<' is typed. Also completes block arguments with ':'.

#+BEGIN_SRC emacs-lisp
  (use-package company
    :init
    :config
    (setq company-selection-wrap-around t)
    ;; ^ Return to first completion after the last one (cycles)
    (setq company-global-modes '(not erc-mode message-mode help-mode gud-mode eshell-mode shell-mode markdown-mode slack-message-buffer-mode))
    ;; ^ Disable on some modes
    (setq company-minimum-prefix-length 1)
    ;; ^ Start completing after 1 char

    (evil-define-key 'insert 'global (kbd "C-SPC") 'company-complete)
    ;; ^ C-SPC force triggers company completion at point
    (define-key company-active-map (kbd "<tab>") nil)
    ;; ^ Disable tab key, so yasnippet and tab-out works nicely within company mode
    (define-key company-active-map (kbd "<return>") 'company-complete-selection)
    ;; ^ Enter simply applies the current selection

    (define-key company-active-map (kbd "<up>") 'company-select-previous)
    (define-key company-active-map (kbd "<down>") 'company-select-next)

    (define-key company-active-map (kbd "C-u") 'company-previous-page)
    (define-key company-active-map (kbd "C-b") 'company-previous-page)
    (define-key company-active-map (kbd "C-d") 'company-next-page)

    ;; I want to be able to use evil's C-n/C-p even when company
    ;; suggestions are visible. I disable those bindings in company
    ;; active map, so that evil picks them up and completes the current
    ;; symbol.
    (define-key company-active-map (kbd "C-p") nil)
    (define-key company-active-map (kbd "C-n") nil)

    (add-hook 'after-init-hook 'global-company-mode))

  (use-package company-box
    :after company
    :hook (company-mode . company-box-mode))

  (use-package company-org-block
    :config
    (setq company-org-block-edit-style 'auto) ;; 'auto, 'prompt, or 'inline
    (add-hook 'org-mode-hook
              (lambda ()
                (add-to-list (make-local-variable 'company-backends)
                             'company-org-block))))
#+END_SRC

** origami-mode
This seems working better than =hs-minor-mode= and also it's supposedly works with =lsp-mode=.

#+BEGIN_SRC emacs-lisp
(use-package origami
  :hook ((web-mode js-mode yaml-mode) . origami-mode))
#+END_SRC

** lsp-mode
- See: https://emacs-lsp.github.io/lsp-mode/tutorials/how-to-turn-off/

#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :commands lsp
    :hook ((web-mode . lsp)
           (js-mode . lsp)
           (typescript-mode . lsp)
           (dhall-mode . lsp)
           (haskell-mode . lsp)
           (kotlin-mode . lsp)
           (rust-mode . lsp)
           (go-mode . lsp)
           (java-mode . lsp))
    :config
    (setq lsp-use-native-json t)
    (setq lsp-enable-xref t)
    (setq lsp-enable-links t)
    (setq lsp-enable-folding t)
    (setq lsp-enable-symbol-highlighting nil)
    ;; ^ I use highlight-thing instead and it works pretty well.
    (setq lsp-enable-indentation nil)
    (setq lsp-enable-on-type-formatting nil)
    (setq lsp-before-save-edits nil)
    (setq lsp-eldoc-render-all nil)
    (setq lsp-headerline-breadcrumb-enable nil)
    (setq lsp-enable-snippet nil)
    ;; ^ I handle snippets myself with yasnippet
    ;; (setq lsp-ui-doc-include-signature t)
    ;; ^ Show the signature in the doc posframe. This shows the
    ;; posframe even if there is no documentation for the function
    ;; etc.
    (setq lsp-ui-sideline-show-diagnostics nil)
    ;; ^ Disable showing errors on sideline, because I use
    ;; flycheck-inline already and it does a better job showing
    ;; errors inline

    (setq
     lsp-imenu-index-symbol-kinds
     '(Module
       File
       Namespace
       Package
       Class
       Method
       Constructor
       Property
       Enum
       Struct
       Field
       Interface
       Function))
    ;; ^ Local variables etc. pollute imenu, so just show these in imenu
    ;; Following are the what's left out: Variable Constant String
    ;; Number Boolean Array Object Key Null Struct Event Operator
    ;; TypeParameter

    (evil-define-key 'normal lsp-mode-map
      "gr" #'lsp-ui-peek-find-references
      "gd" #'lsp-ui-peek-find-definitions
      "gi" #'lsp-ui-peek-find-implementation
      "ga" #'lsp-execute-code-action
      "K"  #'isamert/lsp-ui-doc-focus-frame))

  (defun isamert/lsp-ui-doc-focus-frame ()
    "Show and focus to the documentation."
    (interactive)
    (unless lsp-ui-doc-mode
      (lsp-ui-doc-show))
    (lsp-ui-doc-focus-frame))

  (use-package lsp-ui
    :after (lsp-mode)
    :commands lsp-ui-mode
    :config
    (setq lsp-ui-sideline-show-code-actions nil))

  (use-package lsp-treemacs
    :after (lsp-mode)
    :commands lsp-treemacs
    :config
    (lsp-treemacs-sync-mode 1))

  ;; I don't really use this, but it may come handy later
  ;; (use-package dap-mode
  ;;   :after (lsp-mode)
  ;;   :config
  ;;   (dap-mode t)
  ;;   (dap-ui-mode t))

  ;; consult-lsp-diagnostics and consult-lsp-symbols
  (use-package consult-lsp
    :config
    (evil-define-key 'normal lsp-mode-map
      (kbd "M-I") 'consult-lsp-symbols))
#+END_SRC

** vterm
Also check out =~/.zshrc= and =~/.config/zsh/emacs.sh=. These files contains some helpful commands that enriches ~vterm~ usage.

- Use =C-z= to go in/out (you can also use =jk= to go back into normal mode from emacs mode) emacs state so that you can make use of use vi-mode in zsh.

#+BEGIN_SRC emacs-lisp
  (defun evil-collection-vterm-escape-stay ()
    "Go back to normal state but don't move cursor backwards.
    Moving cursor backwards is the default vim behavior but
    it is not appropriate in some cases like terminals."
    (setq-local evil-move-cursor-back nil))

  (use-package vterm
    :config
    (evil-define-key '(normal insert) 'global (kbd "M-t") #'isamert/vterm-toggle-dedicated)
    (evil-leader/set-key
      "tt" 'isamert/vterm-toggle-dedicated
      "tj" 'isamert/jump-to-visible-vterm
      "tl" 'isamert/run-last-command-on-visible-term
      "ty" 'isamert/send-selected-text-to-visible-vterm
      "tr" 'isamert/run-command-on-visible-vterm-with-history)
    (setq vterm-kill-buffer-on-exit t)
    (add-hook 'vterm-mode-hook #'evil-collection-vterm-escape-stay)
    (add-hook 'vterm-mode-hook #'evil-emacs-state))

  (defun isamert/run-last-command-on-visible-term ()
    (interactive)
    (save-buffer)
    (unless (isamert/run-last-command-on-visible-vterm)
      (isamert/run-last-command-on-visible-eshell)))
#+END_SRC

*** Utility functions
#+begin_src emacs-lisp
  (defun vterm-send-M-\\ ()
    (interactive)
    (vterm-send-key "\\" nil t nil))

  (defun vterm-send-M-- ()
    (interactive)
    (vterm-send-key "-" nil t nil))

  (defun isamert/run-command-on-visible-vterm (cmd)
    (isamert/with-visible-buffer ".*vterm.*"
     (vterm-send-string cmd)
     (vterm-send-return)
     cmd))

  (defun isamert/send-selected-text-to-visible-vterm (start end)
    (interactive "r")
    (if (use-region-p)
        (isamert/run-command-on-visible-vterm (buffer-substring-no-properties start end))
      (isamert/run-command-on-visible-vterm (s-trim (buffer-substring-no-properties (line-beginning-position) (line-end-position))))))

  (defvar isamert/vterm-run-history '())
  (defvar isamert/jump-to-vterm-last-window nil)
  (defconst isamert/vterm-dedicated-buffer-name "*vterm-dedicated*")

  (isamert/shackle-window isamert/vterm-dedicated-buffer-name 30)

  (defun isamert/vterm-toggle-dedicated ()
    "Open/toggle a dedicated vterm buffer."
    (interactive)
    (cond
     ((isamert/buffer-visible-p isamert/vterm-dedicated-buffer-name) (isamert/remove-window-with-buffer isamert/vterm-dedicated-buffer-name))
     ((get-buffer isamert/vterm-dedicated-buffer-name) (switch-to-buffer-other-window isamert/vterm-dedicated-buffer-name))
     (t (vterm isamert/vterm-dedicated-buffer-name))))

  (defun isamert/run-last-command-on-visible-vterm ()
    "Run last command on the currently visible vterm window and return back to current window."
    (interactive)
    (isamert/with-visible-buffer ".*vterm.*"
     (vterm-send-up)
     (vterm-send-return)
     t))

  (defun isamert/jump-to-visible-vterm ()
    "Jump to the visible vterm window.
  When invoked in a vterm window, return back to last window that
  this command is invoked from."
    (interactive)
    (cond
     ((string-match ".*vterm.*" (buffer-name (window-buffer (selected-window))))
      (select-window isamert/jump-to-vterm-last-window))
     (t
      (setq isamert/jump-to-vterm-last-window (selected-window))
      (isamert/select-window-with-buffer ".*vterm.*"))))

  (defun isamert/run-command-on-visible-vterm-with-history ()
    (interactive)
    (let ((cmd (isamert/run-command-on-visible-vterm
                (completing-read "Run new command" isamert/vterm-run-history))))
      (when cmd
        (setq isamert/vterm-run-history (cons cmd (delete cmd isamert/vterm-run-history))))))
#+end_src

** moodline modeline
Light weight and nice modeline.

#+begin_src emacs-lisp
  (use-package mood-line
    :diminish
    :quelpa (mood-line
             :fetcher gitlab
             :repo "jessieh/mood-line")
    :config (mood-line-mode))
#+end_src

** TODO mini-modeline
- Moves modeline to the minibuffer and disables modeline in all windows.
- FIXME: does not work with [[moodline modeline]]

#+begin_src
  (use-package mini-modeline
    :quelpa (mini-modeline :repo "kiennq/emacs-mini-modeline" :fetcher github)
    :after mood-line
    :config
    (setq mini-modeline-enhance-visual nil)
    ;; ^ Otherwise it breaks the color of completion menu popup.
    (setq mini-modeline-update-interval 0.5)
    ;; ^ Not sure
    (mini-modeline-mode t))
#+end_src
** howdoyou
When you search for something, it opens the results in an org-mode buffer. Results are fetched from SX (stack-exchange, stackoverflow etc) sites.
- =SPC hs= or =howdoyou-query= :: search function
- =C-M-Left= :: prev answer
- =C-M-Right= :: next answer

#+BEGIN_SRC emacs-lisp
  (use-package howdoyou
    :config
    (setq howdoyou-switch-to-answer-buffer t)
    (setq howdoyou-number-of-answers 5)
    (evil-define-key '(normal motion) howdoyou-mode-map
      "gn" #'howdoyou-next-link
      "gp" #'howdoyou-prev-link)
    (evil-leader/set-key
      "hs" 'howdoyou-query))
#+END_SRC

** yasnippets and yankpad
I use yankpad to manage my snippets. [[./yankpad.org][The file]] has more information on that. =yasnippet= is used while expanding the snippets defined in =yankpad= so that I can utilize all the goodies =yasnippet= offers.

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :config
    (yas-global-mode))

  (use-package yankpad
    :after yasnippet
    :config
    (setq yankpad-file snippets-org)
    (add-to-list 'hippie-expand-try-functions-list #'yankpad-expand)
    (evil-leader/set-key
      "sr" #'yankpad-reload
      "sc" #'yankpad-set-category
      "se" #'yankpad-edit
      "ss" #'yankpad-map
      "sm" #'yankpad-map)

    (evil-define-key 'insert 'global
      (kbd "M-s") #'yankpad-insert
      (kbd "M-e") #'yankpad-expand)

    ;; Enable expanding in minibuffer
    (add-hook 'minibuffer-setup-hook 'yas-minor-mode)
    (define-key minibuffer-local-map (kbd "M-e") #'yankpad-expand)

    ;; Categories returned by the following functions will be used to
    ;; expand snippets
    (setq
     yankpad-auto-category-functions
     '(yankpad-major-mode-category isamert/current-project-name)))

#+END_SRC

** git-link
#+begin_src emacs-lisp
  (use-package git-link
    :config
    (setq git-link-open-in-browser t)
    (evil-leader/set-key
      "glm" 'isamert/git-link-merge-requests
      "gll" 'isamert/git-link-on-branch
      "glh" 'git-link-homepage
      "glc" 'git-link-commit))

  (defun isamert/git-link-homepage ()
    "Like git-link-homepage itself but it does not open in browser, simply returns the address as string."
    (interactive)
    (let ((git-link-open-in-browser nil))
      (call-interactively 'git-link-homepage)
      (car kill-ring)))

  (defun isamert/git-link-on-branch (branch)
    "Like `git-link' but let's you select the branch first when called interactively."
    (interactive
     (list
      (completing-read
       "Select a branch: "
       (vc-git-branches)
       nil nil (isamert/git-current-branch))))
    (let ((git-link-default-branch branch))
      (call-interactively 'git-link)))

  (defun isamert/git-link-merge-requests ()
    "Open MR page."
    (interactive)
    (browse-url
     (let ((homepage (isamert/git-link-homepage)))
       (cond
        ((s-contains? "gitlab" homepage) (concat homepage "/-/merge_requests"))
        ((s-contains? "github" homepage) (concat homepage "/pulls"))
        (t (user-error "Forge undefined."))))))
#+end_src

** bufler
#+begin_src emacs-lisp
  (use-package bufler
    :config
    (evil-define-key 'normal bufler-list-mode-map
      (kbd "K") 'bufler-list-buffer-kill
      (kbd "<return>") 'bufler-list-buffer-switch
      (kbd "q") 'quit-window
      (kbd "M-,") 'bufler-list-buffer-peek
      (kbd "p") 'bufler-list-buffer-peek)

    (evil-leader/set-key
      "bb" #'bufler))
#+end_src

** tab-out
When you press tab, jump out from the current enclosing parens/quotes etc. When there is no enclosing stuff, TAB key automatically fallbacks to it's default behavior.

#+begin_src emacs-lisp
  (use-package tab-jump-out
    :diminish
    :quelpa (tab-jump-out
             :fetcher github
             :repo "zhangkaiyulw/tab-jump-out")
    :config
    ;; This is not defined as a global minor mode, so define one and enable it
    (define-globalized-minor-mode global-tab-jump-out-mode tab-jump-out-mode
      (lambda ()
        (tab-jump-out-mode)
        (push "/" tab-jump-out-delimiters)
        (push "=" tab-jump-out-delimiters)))
    (global-tab-jump-out-mode 1))
#+end_src

** completing-read-xref
Provides an interface to xref based on completing-read.

#+begin_src emacs-lisp
  (use-package completing-read-xref
    :diminish
    :quelpa (completing-read-xref
             :fetcher github
             :repo "travitch/completing-read-xref.el")
    :config
    (setq xref-show-definitions-function #'completing-read-xref-show-defs))
#+end_src
** helpful and elisp-demos
- helpful :: Better help dialogs with syntax highlighting, references, source etc.
- elisp-demos :: Adds code examples into function help buffers.
  - Code examples are maintained [[https://github.com/xuchunyang/elisp-demos/blob/master/elisp-demos.org][here]], don't forget to contribute!
  - Call ~elisp-demos-add-demo~ to add a demo locally.

#+begin_src emacs-lisp
  (use-package helpful
    :config
    ;; Override default help bindings
    (global-set-key (kbd "C-h f") #'helpful-callable)
    (global-set-key (kbd "C-h v") #'helpful-variable)
    (global-set-key (kbd "C-h k") #'helpful-key)
    (global-set-key (kbd "C-h p") #'helpful-at-point)

    (evil-define-key 'normal helpful-mode-map
          "q" 'evil-delete-buffer))

  (use-package elisp-demos
    :after helpful
    :config
    (advice-add 'helpful-update :after #'elisp-demos-advice-helpful-update))
#+end_src

** expand-region
#+begin_src emacs-lisp
  (use-package expand-region
    :config
    (evil-define-key 'normal 'global
      (kbd "M-w") #'er/expand-region))
#+end_src
** aggressive-indent
It keeps your indentation working all the time. Seems like a good idea but I have some concerns about it, so I just use it with elisp for the time being.

#+begin_src emacs-lisp
  (use-package aggressive-indent
    :config
    (add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode)
    (add-hook 'typescript-mode-hook #'aggressive-indent-mode)
    (add-to-list 'aggressive-indent-protected-commands 'evil-undo)
    (add-to-list 'aggressive-indent-protected-commands 'format-all-buffer))
#+end_src
** xmodmap-mode
Simple mode for editing =~/.Xmodmap= file.
- [[https://www.emacswiki.org/emacs/XModMapMode][Source]]

#+begin_src emacs-lisp
  (define-generic-mode 'xmodmap-mode
    '(?!)
    '("add" "clear" "keycode" "keysym" "pointer" "remove")
    nil
    '("[xX]modmap\\(rc\\)?\\'")
    nil
    "Simple mode for xmodmap files.")
#+end_src
** slack
#+begin_src emacs-lisp
  ;; (slack-start)
  ;; (slack-change-current-team)
  ;; (slack-im-list-update)
  ;; (slack-bot-list-update)
  ;; (slack-group-list-update)
  ;; (slack-room-list-update)
  ;; (slack-select-unread-rooms)

  ;; (slack-group-list-update)
  ;; (slack-im-list-update)
  ;; (slack-bot-list-update)
  ;; (slack-user-list-update)
  ;; (slack-channel-list-update)
  ;; (slack-command-list-update)

  (use-package slack
    :quelpa (slack
             :fetcher github
             :repo "isamert/emacs-slack")
    :config
    (setq slack-buffer-emojify t)
    (setq slack-render-image-p t)
    (setq slack-image-max-height nil)
    (setq slack-prefer-current-team t)
    ;; ^ Set current team with `slack-change-current-team'
    (setq slack-buffer-function #'isamert/display-buffer-in-side-window)
    ;; ^ Open slack windows on the right side of the screen

    (setq slack-message-custom-notifier #'isamert/slack-notify)

    (slack-register-team
     :name "trendyol"
     :token ty/slack-token
     :cookie ty/slack-cookie
     :subscribed-channels ty/slack-channels)

    (evil-leader/set-key
      "ess" #'slack-select-rooms
      "esm" #'isamert/slack-send-message
      "esr" #'isamert/slack-recent-messages
      "esl" #'isamert/slack-open-last-message
      "esy" #'isamert/slack-yank-last-message)


    (defun isamert/slack--add-reaction-to-message (reaction)
      (defalias (intern (concat "react-" reaction))
        `(lambda ()
           (interactive)
           (slack-buffer-add-reaction-to-message
            slack-current-buffer
            ,reaction
            (slack-get-ts)))))

    (evil-set-initial-state 'slack-mode-map 'normal)

    (dolist (mode-map (list slack-message-buffer-mode-map slack-thread-message-buffer-mode-map))
      (evil-define-key 'normal mode-map
        "q" #'delete-window

        "@" 'slack-message-embed-mention
        "mc" 'slack-message-embed-channel ;
        "mm" 'slack-message-write-another-buffer
        "md" 'slack-message-delete
        "ml" 'slack-message-copy-link
        "me" 'slack-message-edit
        "mt" 'slack-thread-show-or-create
        "mq" 'isamert/slack-quote-message

        "mrr" 'slack-message-add-reaction
        "mR" 'slack-message-remove-reaction
        "mr1" (isamert/slack--add-reaction-to-message "+1")
        "mr2" (isamert/slack--add-reaction-to-message "ok_hand")
        "mr3" (isamert/slack--add-reaction-to-message "eyes")
        "mr4" (isamert/slack--add-reaction-to-message "ultrafastparrot")
        "mr5" (isamert/slack--add-reaction-to-message "pepedance")

        "[[" 'slack-buffer-goto-prev-message
        "]]" 'slack-buffer-goto-next-message))

    (evil-define-key 'normal slack-message-compose-buffer-mode-map
      "@"  #'slack-message-embed-mention
      "mc" #'slack-message-embed-channel
      "ml" #'markdown-insert-link))

  (use-package alert
    :config
    (if (eq system-type 'gnu/linux)
        (setq alert-default-style 'libnotify)
      (setq alert-default-style 'osx-notifier)))


  (defvar isamert/slack--last-messages '())

  (defun isamert/slack-notify (message room team)
    (when (or
           (slack-message-minep message team)
           (slack-message-notify-p message room team))
      (let* ((sender-name (slack-message-sender-name message team))
             (room-name (slack-room-name room team))
             (title (format "%s - %s" room-name sender-name))
             (msg-str (isamert/slack--stringify-message
                       (list :message message :team team))))
        (push
         (list :room room
               :team team
               :message message
               :sender-name sender-name
               :room-name room-name
               :title title
               :message-string msg-str)
         isamert/slack--last-messages)
        (unless (slack-message-minep message team)
          (alert
           msg-str
           :title title
           :category "slack")
          (message
           ">> Slack: %s // %s"
           title
           msg-str)))))

  (defun isamert/slack-yank-last-message ()
    "Yank the contents of the last received message as text."
    (interactive)
    (kill-new
     (isamert/slack--stringify-message
      (isamert/slack--last-message))))

  (defun isamert/slack-open-last-message ()
    "Open last room that got new message."
    (interactive)
    (isamert/slack--open-message-or-thread (isamert/slack--last-message)))

  (defun isamert/slack--open-message-or-thread (msg)
    (let-plist msg
      (if (ignore-errors (slack-thread-message-p .message))
          (slack-thread-show-messages .message .room .team)
        (slack-room-display
         .room
         .team))
      ;; Focus the message on buffer
      (run-with-timer
       1.3 nil
       (lambda ()
         (goto-char (point-max))
         (goto-char
          (slack-buffer-prev-point
           (point-max)
           (point-min)
           (slack-ts .message)))))))

  (defalias 'isamert/slack-recent-messages #'isamert/slack-last-messages)

  (defun isamert/slack-last-messages ()
    "List and open rooms that had new messages in them recently."
    (interactive)
    (with-completing-read-exact-order
     (let* ((rooms
             (-uniq
              (--map
               (cons
                (let-plist it
                  (format "%s (%s: %s)" .room-name .sender-name .message-string))
                it)
               isamert/slack--last-messages)))
            (selected (isamert/alist-completing-read "Select message: " rooms)))
       (isamert/slack--open-message-or-thread selected))))

  (defun isamert/slack-send-message (msg)
    "Send given MSG or selected region as message to interactively
    selected user."
    (interactive
     (list
      (if (use-region-p)
          (buffer-substring-no-properties (region-beginning) (region-end))
        (read-string "Enter message: "))))
    "Send MSG to interactively selected room."
    (-let* (((room team) (isamert/slack--select-room)))
      (slack-message-send-internal
       msg room team)))

  (defun isamert/slack-clipboard-image-upload ()
    "Uploads png image from clipboard.

    The default `slack-clipboard-image-upload' was not working
    properly in MacOS."
    (interactive)
    (unless (isamert/has-clipboard-image)
      (user-error "No image in clipboard."))
    (let* ((file (make-temp-file "clip" nil ".png")))
      (isamert/save-clipboard-image-to-file file)
      (slack-file-upload file "png" "image.png")))

  ;; TODO multiple message quote
  (defun isamert/slack-quote-message ()
    (interactive)
    (let ((quote-text (->>
                       (isamert/slack-current-message-content)
                       (substring-no-properties)
                       (s-trim)
                       (s-split "\n")
                       (-drop 1)
                       (--map (concat "> " it))
                       (s-join "\n")
                       (s-append "\n"))))
      (slack-message-write-another-buffer)
      (insert quote-text)))

  (defun isamert/slack-current-message-content ()
    (slack-if-let* ((buf slack-current-buffer)
                    (team (slack-buffer-team buf))
                    (room (slack-buffer-room buf))
                    (message (slack-room-find-message room (slack-get-ts))))
        (slack-message-to-string message team)))


  ;;
  ;; Utils/internals
  ;;

  (defun isamert/slack--last-message ()
    (car isamert/slack--last-messages))

  (defun isamert/slack--stringify-message (msg)
    (let ((message (plist-get msg :message))
          (team (plist-get msg :team)))
      (slack-message-to-alert message team)))

  (defun isamert/slack--select-room ()
    "Select interactively and return (room team) pair."
    (let* ((team (slack-team-select))
           (room (slack-room-select
                  (cl-loop for team in (list team)
                           append (append (slack-team-ims team)
                                          (slack-team-groups team)
                                          (slack-team-channels team)))
                  team)))
      (list room team)))
#+end_src

** prodigy
#+begin_src emacs-lisp
  (use-package prodigy
    :diminish
    :quelpa (prodigy
             :fetcher github
             :repo "rejeep/prodigy.el")
    :config
    (evil-define-key 'normal prodigy-mode-map
      "m" #'prodigy-mark
      "u" #'prodigy-unmark
      "x" #'prodigy-stop
      "S" #'prodigy-start
      "r" #'prodigy-restart
      "R" #'prodigy-refresh
      "f" #'prodigy-jump-file-manager
      "M" #'prodigy-jump-magit
      "t" #'prodigy-add-tag-filter
      "T" #'prodigy-clear-filters
      (kbd "RET") #'prodigy-display-process))
#+end_src
** poporg
Pop current comment section into an org (or markdown, as it's more widely used for comments) buffer and edit it there. Pretty useful for writing long comments. Use ~poporg-dwim~ on a comment/comment block.

#+begin_src emacs-lisp
  (use-package poporg
    :config
    (remove-hook 'poporg-edit-hook 'org-mode)
    (add-hook 'poporg-edit-hook 'markdown-mode))
#+end_src
* Editing
** Breaking long texts/comments into multiple lines
I use =M-q= (=fill-paragraph=) to break long texts into multiple
lines. It also works well within comment sections. 80 col length is
quite readable. See how this item is formatted, it's done
automatically by the usage of =M-q=.

  #+begin_src emacs-lisp
    (setq fill-column 80)
  #+end_src

** Spell checking
- Use =flyspell-mode= to start spell checking.
- Use =ispell-change-dictonary= to change dictionaries.
- ~z=~ or ~zw~ to correct current spelling mistake.
  - ~C-u zw~ to correct all mistakes in order.

*** Configuration
See [[https://isamert.net/2021/01/31/emacs-te-turkce-imla-denetimi.html][this]] for rationale behind the following configuration.

#+BEGIN_SRC emacs-lisp
  (setq ispell-program-name "hunspell"
        ispell-local-dictionary "en_US"
        ispell-local-dictionary-alist
        '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)
          ("tr_TR" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "tr_TR") nil utf-8)))

  (add-hook 'org-mode-hook 'flyspell-mode)
  (add-hook 'markdown-mode-hook 'flyspell-mode)
#+END_SRC

*** flyspell-correct
Better way to correct spelling mistakes. By default it uses completing-read. This also makes it easy to save words into personal dictonary or silence warnings for session because it shows these options in the correction menu.
#+begin_src emacs-lisp
  (use-package flyspell-correct
    :config
    ;; Rebind default evil ispell keys to flyspell-correct ones
    (evil-define-key 'normal 'global
      (kbd "z=") #'flyspell-correct-at-point
      (kbd "zw") #'flyspell-correct-wrapper))
      ;; ^ This goes to nearest spelling mistake.
      ;; If called with C-u, it goes into rapid mode where you correct all mistakes in order.
#+end_src

** string-inflection
- In the case of =string-inflection-ruby-style-cycle=   : ~emacs_lisp => EMACS_LISP => EmacsLisp => emacs_lisp~
- In the case of =string-inflection-python-style-cycle= : ~emacs_lisp => EMACS_LISP => EmacsLisp => emacs_lisp~
- In the case of =string-inflection-java-style-cycle=   : ~emacsLisp => EMACS_LISP => EmacsLisp => emacsLisp~
- In the case of =string-inflection-all-cycle=          : ~emacs_lisp => EMACS_LISP => EmacsLisp => emacsLisp => emacs-lisp => Emacs_Lisp => emacs_lisp~

#+begin_src emacs-lisp
  (use-package string-inflection
    :config
    (evil-define-key 'normal 'global (kbd "M-c") #'string-inflection-all-cycle))
#+end_src

** smartparens
#+begin_src emacs-lisp
  (use-package smartparens
    :config
    (require 'smartparens-config)
    ;; (setq sp-autoinsert-pair nil)
    ;; (setq sp-autodelete-pair nil)

    (evil-define-key 'visual sp-keymap
      "S("  #'sp-wrap-round
      "S["  #'sp-wrap-square
      "S'"  #'sp-wrap-quote-single
      "S`"  #'sp-wrap-backtick
      "S<"  #'sp-wrap-angle
      "S\"" #'sp-wrap-quote-double
      "S="  #'sp-wrap-equal
      "S{"  #'sp-wrap-curly
      "S/"  #'sp-wrap-slash
      "S*"  #'sp-wrap-star
      "S+"  #'sp-wrap-plus
      "S#"  #'sp-wrap-star
      "S~"  #'sp-wrap-tilda)

    (sp-local-pair 'org-mode "=" "=" :actions :rem)

    (evil-define-key*
      '(normal insert) sp-keymap
      (kbd "M-[") #'sp-forward-barf-sexp
      (kbd "M-]") #'sp-forward-slurp-sexp
      (kbd "M-{") #'sp-backward-slurp-sexp
      (kbd "M-}") #'sp-backward-barf-sexp)

    (smartparens-global-mode))

  (defun sp-wrap-quote-double () (interactive) (sp-wrap-with-pair "\""))
  (defun sp-wrap-quote-single () (interactive) (sp-wrap-with-pair "'"))
  (defun sp-wrap-backtick () (interactive) (sp-wrap-with-pair "`"))
  (defun sp-wrap-angle () (interactive) (sp-wrap-with-pair "<"))
  (defun sp-wrap-equal () (interactive) (sp-wrap-with-pair "="))
  (defun sp-wrap-tilda () (interactive) (sp-wrap-with-pair "~"))
  (defun sp-wrap-slash () (interactive) (sp-wrap-with-pair "/"))
  (defun sp-wrap-star () (interactive) (sp-wrap-with-pair "*"))
  (defun sp-wrap-plus () (interactive) (sp-wrap-with-pair "+"))
#+end_src

** writeroom-mode
Gives you a nice, uncluttered editing experience by removing all unneeded visual clutter and by justifying the text in the middle.
- =SPC W= to enable it.

#+begin_src emacs-lisp
  (use-package writeroom-mode
    :config
    (setq writeroom-width 150) ;; Better for org-mode
    (evil-leader/set-key
      "W" 'writeroom-mode))
#+end_src

* Dummy IDE mode
I try to use ~lsp-mode~ and other language-specific packages for the languages I use (see [[Language specific]]), but sometimes either they are too slow or the computer I'm currently working on requires some extra setup or I just don't want to use them for some reason. For those cases, I use a collection of packages that gives you the power of IDEs but in some dummy/restricted way.

- <<highlight-thing>> :: Automatically highlights the all instances of the symbol under the cursor in the buffer. Simply use evils ~*~ and ~#~ to jump between them.
- <<devdocs-browser>> :: Let's you browse devdocs in =eww=.
  - ~devdocs-browser-install-doc~ to install docs. ~devdocs-browser-open~ to open a documentation.
- <<dumb-jump>> :: Jumps to definition by using predefined-regexps, generally works fine. Use =gd=.
  - To debug why it's not working: M-x ~set-variable dumb-jump-debug t~, then go to *Messages* buffer.
- <<tree-sitter>> :: This is a generic parser for bunch of languages. You can also inspect the syntax tree on the fly and do whatever you want to do with it. Best feature so far is just better (like, miles ahead better) syntax highlighting for some languages. Especially for JS/TS and Rust. See [[https://ubolonton.github.io/emacs-tree-sitter/][this page]] for more information.
- <<hl-todo>> :: Highlight TODO/FIXME etc.
  - Use ~]t~ and ~[t~ to go next/prev TODO/FIXME item.

#+begin_src emacs-lisp
  (use-package dumb-jump
    :config
    ;; https://github.com/jacktasia/dumb-jump/issues/376
    ;; (setq dumb-jump-prefer-searcher 'rg)
    (setq dumb-jump-force-searcher 'ag
          dumb-jump-ignore-context t
          dumb-jump-fallback-search nil)
    (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))

  (use-package devdocs-browser)

  (use-package highlight-thing
    :after evil
    :config
    (setq-default evil-symbol-word-search t)
    ;; ^ highlight-thing highlights symbols, not words. # and * searches for
    ;; symbols if you set this to true, otherwise they search for words.

    (add-hook
     'highlight-thing-mode-hook
     #'(lambda () (set-face-attribute 'highlight-thing nil :background "dark violet" :foreground "white")))
    ;; ^ Default one with my theme makes some text quite unreadable

    (setq highlight-thing-prefer-active-region nil
          ;; ^ Don't highlight the selected text in visual mode
          highlight-thing-ignore-list '("False" "True" "->" "::" "defun" "def"))
    (add-hook 'prog-mode-hook 'highlight-thing-mode))

  (use-package tree-sitter
    :config
    (global-tree-sitter-mode)
    (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode))

  (use-package tree-sitter-langs
    :after tree-sitter)

  (use-package hl-todo
    :hook (prog-mode . hl-todo-mode)
    :config
    (setq hl-todo-keyword-faces
          '(("TODO"   . "#FF0000")
            ("FIXME"  . "#FF0000")
            ("DEBUG"  . "#A020F0")
            ("GOTCHA" . "#FF4500")
            ("STUB"   . "#1E90FF")))

    (evil-define-key 'normal 'global
      (kbd "]t") #'hl-todo-next
      (kbd "[t") #'hl-todo-previous))
#+end_src

* Media/feed/IRC
I try to maximize my Emacs usage which brings it's own benefits and downsides which I will not go over here. Here are some packages and configurations that are not related to programming/editing.

** elfeed (RSS feeds)
Feed reader.

- Filter examples (after hitting ~s~)
  - +tag OR -tag (unread is also a tag)
  - #number-of-entries-limit (like #20)
  - !inverse-regex (!x?emacs will filter out titles containing x?emacs regex)
  - =regex (entries that contains the regex will be shown)
  - +unread +youtube =emacs #10 @5-months-ago
#+begin_src emacs-lisp
  ;; TODO: experiment with custom faces
  ;; (defface elfeed-comic
  ;;   '((t :foreground "#BFF"))
  ;;   "Marks comics in Elfeed."
  ;;   :group 'elfeed)
  ;;
  ;; (push '(comic elfeed-comic)
  ;;       elfeed-search-face-alist)

  (defun isamert/elfeed-auto-tag-url (pairs)
    "Takes a list of url-regex and tag-list pairs and adds a new entry hook for each of them."
    (--map
     (add-hook 'elfeed-new-entry-hook
               (elfeed-make-tagger :feed-url (car it)
                                   :add (cdr it)))
     pairs))

  (defun isamert/elfeed-auto-tag-title (pairs)
    "Takes a list of title-regex and tag-list pairs and adds a new entry hook for each of them."
    (--map
     (add-hook 'elfeed-new-entry-hook
               (elfeed-make-tagger :entry-title (car it)
                                   :add (cdr it)))
     pairs))

  ;; https://github.com/skeeto/.emacs.d/blob/master/etc/feed-setup.el
  (defvar youtube-feed-format
    '(("^UC" . "https://www.youtube.com/feeds/videos.xml?channel_id=%s")
      ("^PL" . "https://www.youtube.com/feeds/videos.xml?playlist_id=%s")
      (""    . "https://www.youtube.com/feeds/videos.xml?user=%s")))

  (defun isamert/elfeed--expand (listing)
    "Expand feed URLs depending on their tags."
    (cl-destructuring-bind (url . tags) listing
      (cond
       ((member 'youtube tags)
        (let* ((case-fold-search nil)
               (test (lambda (s r) (string-match-p r s)))
               (format (cl-assoc url youtube-feed-format :test test)))
          (cons (format (cdr format) url) tags)))
       ((member 'reddit tags) (cons (format "https://www.reddit.com/r/%s/.rss" url) tags))
       (listing))))

  (use-package elfeed
    :config
    ;; When adding tags, don't add any hierarchical tags like (blog blog-software), or (metal metal-black)
    ;; Just use something like: (blog software) and (metal black)

    (load "feeds")
    (setq elfeed-curl-extra-arguments '("--netrc"))
    (setq elfeed-feeds (mapcar #'isamert/elfeed--expand isamert/feeds))
    (isamert/elfeed-auto-tag-url '(("youtube\\.com" youtube)))
    (isamert/elfeed-auto-tag-title '(("youtube\\.com" youtube)
                                     ("c\\+\\+"  (programming c++))
                                     ("python"   (programming python))
                                     ("haskell"  (programming haskell))))

    ;; To apply hooks to all existing entries, use: elfeed-apply-hooks-now

    (defun isamert/elfeed-search-browse-url-in-default-browser ()
      "Open URL in the default browser."
      (interactive)
      (with-default-browser
        (elfeed-search-browse-url)))

    ;; o -> Open link in eww
    ;; O -> Open link in default web browser
    (evil-define-key 'normal elfeed-search-mode-map
      "o" #'elfeed-search-browse-url
      "O" #'isamert/elfeed-search-browse-url-in-default-browser)

    (evil-leader/set-key "ee" #'elfeed))
#+end_src

** empv (music/media/radio/youtube management)
Manage media and streams through =completing-read=.

#+begin_src emacs-lisp
  (use-package empv
    :diminish
    :quelpa (empv
             :fetcher github
             :repo "isamert/empv.el")
    :config
    (load "radio-channels")
    (setq empv-radio-channels isamert/radio-channels)
    (setq empv-radio-log-file "~/Documents/notes/songs.org")
    (setq empv-base-directory "~/Music")
    (setq empv-allow-insecure-connections t)
    (setq empv-invidious-instance "https://ytprivate.com/api/v1")
    ;; ^ alt: https://invidious.exonip.de/api/v1
    ;; also see https://api.invidious.io/
    (add-to-list 'empv-mpv-args "--ytdl-format=best")

    (evil-leader/set-key
      "erp" #'empv-play
      "erP" #'empv-playlist-select
      "ere" #'empv-enqueue
      "ert" #'empv-toggle
      "err" #'empv-play-radio
      "erR" #'empv-play-random-channel
      "erV" #'empv-toggle-video
      "erv" #'empv-set-volume
      "ery" #'consult-empv-youtube
      "erY" #'consult-empv-youtube-tabulated
      "erk" #'empv-display-current
      "erl" #'empv-log-current-radio-song-name
      "era" #'empv-play-audio
      "erA" #'empv-play-audio-multiple
      "ers" #'empv-exit)
    (evil-make-overriding-map empv-youtube-results-mode-map 'normal))

  (defun isamert/export-radio-channels-as-m3u (file)
    "Export radio list into an M3U FILE."
    (interactive
     (list
      (read-file-name
       "Where to save the .m3u file?"
       "~/Documents/sync/"
       "radiolist.m3u")))
    (with-temp-file file
      (->>
       isamert/radio-channels
       (--map
        (format
         "#EXTINF:0, %s\n%s"
         (car it)
         ;; Replace http:// with icyx://, because VLC on Android can't
         ;; retrieve song name if the stream is on http://
         (if (s-contains? "radcap.ru" (car it))
             (s-replace "http://" "icyx://" (cdr it))
           (cdr it))))
       (--reduce (format "%s\n%s" acc it))
       (s-prepend "#EXTM3U\n")
       (insert))))
#+end_src

** orgmdb (movies & shows)
I have a file called ~watchlist.org~ where I keep list of movies and shows that I watched and going to watch. Here are some packages and functions to deal with them.

#+begin_src emacs-lisp
  (use-package orgmdb
    :diminish
    :quelpa (orgmdb
             :fetcher github
             :repo "isamert/orgmdb.el")
    :config
    (setq orgmdb-omdb-apikey isamert/orgmdb-omdb-apikey)
    (setq orgmdb-fill-property-list '(genre runtime director country imdb-id imdb-rating metascore)))

  (defun isamert/watchlist-select-episode ()
    "List all episodes of current show and act on selected one."
    (interactive)
    (with-completing-read-exact-order
     (let ((show (orgmdb :imdb (org-entry-get nil "IMDB-ID") :episode 'all)))
       (->>
        show
        (alist-get 'Episodes)
        (--map (let-alist it
                 (cons (format "S%02dE%02d - %s"
                               (string-to-number .Season)
                               (string-to-number .Episode)
                               .Title)
                       it)))
        (isamert/alist-completing-read "Select an episode: ")
        (isamert/watchlist--act-on-episode show)))))

  (defun isamert/watchlist--act-on-episode (show episode)
    (let ((show-title (alist-get 'Title show))
          (episode-selector (format
                             "s%02de%02d"
                             (string-to-number (alist-get 'Season episode))
                             (string-to-number (alist-get 'Episode episode)))))
      (pcase (completing-read "Select an action: " '("Open" "Search on 1337x.to"))
        ("Open"
         (message (format "fd --absolute-path --type=file --glob '*%s*%s*' %s"
                          (s-downcase (s-replace " " "*" show-title))
                          episode-selector
                          empv-video-dir))
         (->>
          (format "fd --absolute-path --type=file --glob '*%s*%s*' %s"
                  (s-downcase (s-replace " " "*" show-title))
                  episode-selector
                  empv-video-dir)
          (shell-command-to-string)
          (s-split "\n")
          (--filter (not (s-blank? it)))
          (completing-read "Select file: ")
          (empv-play)))
        ("Search on 1337x.to"
         (browse-url
          (format "https://1337x.to/search/%s+%s/1/"
                  (->>
                   show-title
                   (s-downcase)
                   (s-replace " " "+"))
                  episode-selector))))))

  (defun isamert/watchlist-open-video-at-point ()
    (interactive)
    (->>
     (org-entry-get nil "ITEM")
     (s-replace " " "*")
     (s-downcase)
     ((lambda (it) (format "fd --absolute-path --type=file --glob '*%s*' %s" it empv-video-dir)))
     (shell-command-to-string)
     (s-split "\n")
     (--filter (not (s-blank? it)))
     (completing-read "Select file: ")
     (empv-play)))
#+end_src
** erc (IRC client)
IRC client for Emacs.

- Some shortcuts:
  - C-c C-b :: switch between channels
  - C-c C-j :: join channel

- TODO items:
  - Autologin
  - Autojoin channels
  - Notifications
  - Add registration notes here
  - Colors?

#+begin_src elisp
  (use-package erc
    :config

    ;; More compact and cleaner look, nicks and messages are in seperate
    ;; column and total length for nicks are 15 cols
    (setq erc-fill-function 'erc-fill-static)
    (setq erc-fill-static-center 15)

    ;; The rest is from https://www.emacswiki.org/emacs/ErcNickColors
    ;; It's the Option 5

    (defmacro unpack-color (color red green blue &rest body)
      `(let ((,red   (car ,color))
             (,green (car (cdr ,color)))
             (,blue  (car (cdr (cdr ,color)))))
         ,@body))

    (defun rgb-to-html (color)
      (unpack-color color red green blue
                    (concat "#" (format "%02x%02x%02x" red green blue))))

    (defun hexcolor-luminance (color)
      (unpack-color color red green blue
                    (floor (+ (* 0.299 red) (* 0.587 green) (* 0.114 blue)))))

    (defun invert-color (color)
      (unpack-color color red green blue
                    `(,(- 255 red) ,(- 255 green) ,(- 255 blue))))

    (defun erc-get-color-for-nick (nick dark)
      (let* ((hash     (md5 (downcase nick)))
             (red      (mod (string-to-number (substring hash 0 10) 16) 256))
             (blue     (mod (string-to-number (substring hash 10 20) 16) 256))
             (green    (mod (string-to-number (substring hash 20 30) 16) 256))
             (color    `(,red ,green ,blue)))
        (rgb-to-html (if (if dark (< (hexcolor-luminance color) 85)
                           (> (hexcolor-luminance color) 170))
                         (invert-color color)
                       color))))

    (defun erc-highlight-nicknames ()
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward "\\w+" nil t)
          (let* ((bounds (bounds-of-thing-at-point 'symbol))
                 (nick   (buffer-substring-no-properties (car bounds) (cdr bounds))))
            (when (erc-get-server-user nick)
              (put-text-property
               (car bounds) (cdr bounds) 'face
               (cons 'foreground-color (erc-get-color-for-nick nick 't))))))))

    (add-hook 'erc-insert-modify-hook 'erc-highlight-nicknames))
#+end_src
* Keybindings
Keybindings are generally set in-place, following have no context, so they are here.

** macOS
#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    ;; I set the following in Linux using xmodmap but it's kinda
    ;; impossible to do it in OSX I guess.

    ;; I use an external keyboard, this makes AltGr and Meta (Alt) work as expected
    ;; I have also inverted Meta and Control keys system-wide or something, so
    ;; this setting is done according to that.
    (setq ns-option-modifier 'meta
          ns-right-alternate-modifier 'none)

    ;; (define-key key-translition-map ...) is better than (global-define-key ...)
    ;; because this just remaps key everywhere to given key so that the mappings
    ;; works in command mode, isearch etc.
    ;; AltGr + k -> Up
    ;; AltGr + j -> Down
    ;; AltGr + l -> Right
    ;; AltGr + h -> Left
    (define-key key-translation-map (kbd "˚") (kbd "<up>"))
    (define-key key-translation-map (kbd "∆") (kbd "<down>"))
    (define-key key-translation-map (kbd "¬") (kbd "<right>"))
    (define-key key-translation-map (kbd "˙") (kbd "<left>"))

    (define-key key-translation-map (kbd "") (kbd "S-<up>"))
    (define-key key-translation-map (kbd "Ô") (kbd "S-<down>"))
    (define-key key-translation-map (kbd "Ò") (kbd "S-<right>"))
    (define-key key-translation-map (kbd "Ó") (kbd "S-<left>"))

    ;; AltGr + [ -> (
    ;; AltGr + ] -> )
    (define-key key-translation-map (kbd "“") (kbd "("))
    (define-key key-translation-map (kbd "‘") (kbd ")")))
#+end_src

** Some general keybindings

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
  (global-set-key (kbd "C-x <escape>") 'keyboard-escape-quit)
  (global-set-key (kbd "C-c <escape>") 'keyboard-escape-quit)

  (evil-define-key 'normal prog-mode-map
    "gd" 'xref-find-definitions
    "gr" 'xref-find-references)

  (evil-define-key 'normal prog-mode-map (kbd "M-;") 'comment-line)
  (evil-define-key 'visual prog-mode-map (kbd "M-;") 'comment-dwim)

  (evil-leader/set-key
    "1" #'(lambda () (interactive) (call-interactively (local-key-binding (kbd "C-c C-c")))))
#+END_SRC

** Better split management
- A-- splits below, A-\ splits right.
- A-h,j,k,l to switch between splits.
- A-H,J,K,L shrink, enlarge split.

#+BEGIN_SRC emacs-lisp
  (defun isamert/split-window-right-term ()
    (interactive)
    (split-window-right)
    (other-window 1)
    (eshell t))

  (defun isamert/split-window-below-term ()
    (interactive)
    (split-window-below)
    (other-window 1)
    (eshell t))

  (defun isamert/split-window-below ()
    (interactive)
    (split-window-below)
    (other-window 1))

  (defun isamert/split-window-right ()
    (interactive)
    (split-window-right)
    (other-window 1))

  (evil-define-key 'normal 'global
    (kbd "M-\\") 'isamert/split-window-right
    (kbd "M-|")  'isamert/split-window-right-term
    (kbd "M--")  'isamert/split-window-below
    (kbd "M-_")  'isamert/split-window-below-term
    (kbd "M-J")  'enlarge-window
    (kbd "M-K")  'shrink-window
    (kbd "M-L")  'enlarge-window-horizontally
    (kbd "M-H")  'shrink-window-horizontally)

  ;; This is needed to override other modes mappings
  (define-minor-mode movement-map-mode "Overrides all major and minor mode keys" t)

  (defvar movement-map (make-sparse-keymap "movement-map")
    "Override all major and minor mode keys")

  (evil-define-key '(normal motion emacs) movement-map
    (kbd "M-j") 'evil-window-down
    (kbd "M-k") 'evil-window-up
    (kbd "M-h") 'evil-window-left
    (kbd "M-l") 'evil-window-right)

  (evil-define-key 'normal treemacs-mode-map
    (kbd "M-j") 'evil-window-down
    (kbd "M-k") 'evil-window-up
    (kbd "M-h") 'evil-window-left
    (kbd "M-l") 'evil-window-right)

  (evil-make-intercept-map movement-map)

  (add-to-list
   'emulation-mode-map-alists
   `((movement-map-mode . ,movement-map)))
#+END_SRC

* Language specific
** General/language-agnostic functionality
- Use =format-all-buffer= function to format current buffer. Works for any language.

#+begin_src emacs-lisp
  ;; Automatically format file with `format-all-buffer'. It recognizes
  ;; most language formatters/linters.
  (use-package format-all)

  ;; Pick up .editorconfig settings for current project automatically
  (use-package editorconfig
    :config
    (editorconfig-mode 1))
#+end_src

*** Get currently focused function name
#+begin_src emacs-lisp
  (defun isamert/refactor-debug-log-text ()
    "Return a string in the following format: 'BufferName:FunctionName:LineNumber'.
    This is used in my snippets."
    (format "%s:%s:%s" (buffer-name) (isamert/current-func-name) (line-number-at-pos)))

  (defun isamert/current-func-name ()
    (if-let ((fn-node (isamert/get-current-func-node)))
        (tsc-node-text (tsc-get-child-by-field fn-node :name))
      (which-function)))

  (defun isamert/get-current-func-node ()
    "Return currently focused function node."
    (let ((curr-func nil)
          (curr-node (ignore-errors
                       (tree-sitter-node-at-point))))
      ;; Find first function declaration or definition
      (while (and curr-node
                  (not (-contains? '(method_definition ;; JS
                                     function_declaration ;; JS
                                     arrow_function ;; JS
                                     function_item ;; Rust
                                     )
                                   (tsc-node-type curr-node))))
        (setq curr-node (tsc-get-parent curr-node)))

      ;; Find first named object of the found function definition
      (while (and curr-node
                  (not (ignore-errors
                         (tsc-get-child-by-field curr-node :name))))
        (setq curr-node (tsc-get-parent curr-node)))
        curr-node))


  ;; Experimenting with tree sitter, ts-ls already provides this feature:

  (defun isamert/refactor-move-function-out ()
    ""
    (interactive)
    (let ((curr-indent nil)
          (curr-func (isamert/get-current-func-node))
          (new-func-name (read-string "New function name: ")))
      (kill-region (region-beginning) (region-end))
      (goto-char (tsc-node-end-position curr-func))
      (setq curr-indent (current-indentation))
      (insert "\n\n")
      (insert (make-string curr-indent ? ))
      (pcase (tsc-node-type curr-func)
        ('method_definition (insert (format "%s ()  {\n" new-func-name))
                            (insert (make-string curr-indent ? ))
                            (yank)
                            (insert (make-string curr-indent ? ))
                            (insert "}"))
        ('function_declaration (insert "function FUN_NAME () {\n")
                               (insert (make-string curr-indent ? ))
                               (yank)
                               (insert (make-string curr-indent ? ))
                               (insert "\n}"))
        (t (insert "const FUN_NAME =  () => {\n")
           (insert (make-string curr-indent ? ))
           (insert "}"))))

    (forward-line -1)
    (message "%s"
             (-difference (-uniq (mapcar #'tsc-node-text (jsdoc--tsc-find-descendants-with-type (isamert/get-current-func-node) 'identifier)))
                          (--map (tsc-node-text (tsc-get-child-by-field it :name))  (jsdoc--tsc-find-descendants-with-type (isamert/get-current-func-node) 'variable_declarator)))))
#+end_src
*** Move between functions mode
This minor mode makes =[[= and =]]= move between functions, if tree sitter is enabled otherwise default evil bindings are used.

#+begin_src emacs-lisp
  (define-minor-mode isamert/jump-between-functions-mode
    "Jump between functions."
    :lighter "jump-fns"
    :keymap (make-sparse-keymap))

  (evil-define-minor-mode-key 'normal 'isamert/jump-between-functions-mode
    (kbd "[[") #'isamert/goto-prev-function
    (kbd "]]") #'isamert/goto-next-function)

  (add-hook 'tree-sitter-mode-hook #'isamert/jump-between-functions-mode)

  (defun isamert/goto-next-function ()
    "Go to next function."
    (interactive)
    (->>
     (or (isamert/get-current-func-node)
         (tree-sitter-node-at-point))
     (tsc-get-next-sibling)
     (tsc-node-start-position)
     (goto-char)))

  (defun isamert/goto-prev-function ()
    "Go to previous function."
    (interactive)
    (let* ((curr-func (isamert/get-current-func-node))
           (curr-func-line (ignore-errors
                             (car (tsc-node-start-point curr-func)))))
      (cond
       ((eq curr-func-line (line-number-at-pos))
        (goto-char (tsc-node-start-position (tsc-get-prev-sibling curr-func))))
       (curr-func
        (goto-char (tsc-node-start-position curr-func)))
       (t
        (goto-char
         (->>
          (tree-sitter-node-at-point)
          (tsc-get-prev-sibling)
          (tsc-node-start-position)))))))
#+end_src
** Refactoring
#+begin_src emacs-lisp
  (use-package emr
    :config
    (evil-define-key 'normal prog-mode-map (kbd "gR") #'emr-show-refactor-menu))
#+end_src

** markdown
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :mode
    (("README\\.md\\'" . gfm-mode)
     ("\\.md\\'" . markdown-mode)
     ("\\.markdown\\'" . markdown-mode)
     ("qutebrowser-editor-" . markdown-mode))
    :config
    (setq markdown-command "multimarkdown")
    (setq markdown-fontify-code-blocks-natively t)

    (evil-leader/set-key-for-mode 'markdown-mode
      "oi" #'markdown-toggle-inline-images)

    (evil-define-key 'normal markdown-mode-map
      (kbd "TAB") 'markdown-cycle
      (kbd "]]") 'markdown-outline-next
      (kbd "[[") 'markdown-outline-previous))
#+END_SRC

** haskell
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode)

  (use-package lsp-haskell
    :config
    (setq lsp-haskell-process-path-hie "ghcide"
          lsp-haskell-process-args-hie '()))

  (use-package ormolu
    :hook (haskell-mode . ormolu-format-on-save-mode)
    :bind
    (:map haskell-mode-map
          ("C-c r" . ormolu-format-buffer)))
#+END_SRC

** rust
#+BEGIN_SRC emacs-lisp
(use-package rust-mode
  :after (lsp-mode)
  (setq lsp-rust-server 'rust-analyzer
        lsp-rust-clippy-preference 'on))
;; (setq lsp-rust-server 'rls)
#+END_SRC

** javascript
*** jsdoc.el
This is a package I wrote for inserting JSDoc comments easily. Check out the [[https://github.com/isamert/jsdoc.el][README]].

#+begin_src emacs-lisp
  (use-package jsdoc
    :diminish
    :quelpa ((jsdoc
             :fetcher github
             :repo "isamert/jsdoc.el")))
#+end_src

*** subword-mode
The following enables =CamelCase= aware editing operations.
#+begin_src emacs-lisp
(add-hook 'js-mode-hook 'subword-mode)
#+end_src

*** Helper functions
#+begin_src emacs-lisp
  ;; TODO make this idempotent, it breaks absolute imports
  ;; TODO make it work on a line instead of between quotes
  (defun isamert/js-relative-import-to-abs ()
    "Convert a relative import to an absolute import.
  For example, if you are on the line:
    import Test from '../../test'
  This function transforms the line into:
    import Test from 'src/a/b/test'"
    (interactive)
    (let ((fname (substring-no-properties (thing-at-point 'filename)))
          (bounds (bounds-of-thing-at-point 'filename)))
      (delete-region (car bounds) (cdr bounds))
      (insert (s-chop-prefix (isamert/current-project-root) (expand-file-name fname)))))


  (defun isamert/convert-js-object-to-json ()
    "Convert selected JS object into JSON object.
  Example:
    {a: 3, b: 5}
  is converted into
    {
      \"a\": 3,
      \"b\": 5
    }"
    (interactive)
    (if (use-region-p)
        (shell-command-on-region
         (region-beginning)
         (region-end)
         "node -e 'console.log(JSON.stringify(eval(\"(\" + require(\"fs\").readFileSync(0, \"utf-8\") + \")\"), null, 2))'"
         (current-buffer)
         t)
      (user-error "Select something first")))

  (defun isamert/convert-json-to-js-object ()
    "Convert selected JS object into JSON object.
  Example:
    {
      \"a\": 3,
      \"b\": 5
    }
  is converted into
    {
      a: 3,
      b: 5,
    }"
    (interactive)
    (if (use-region-p)
        (shell-command-on-region
         (region-beginning)
         (region-end)
         "node -e 'console.log(require(\"util\").inspect(JSON.parse(require(\"fs\").readFileSync(0, \"utf-8\")), false, null))'"
         (current-buffer)
         t)
      (user-error "Select something first")))
#+end_src
*** Add node_modules/.bin to PATH automatically
#+begin_src emacs-lisp
  (defun isamert/add-node-modules-to-path ()
    "Add node_modules/.bin to `exec-path'."
    (interactive)
    (-some--> (locate-dominating-file "." "node_modules")
      (expand-file-name it)
      (format "%s/node_modules/.bin" it)
      ;; FIXME check if there is a buffer local exec path?
      (setq-local exec-path `(,it ,@exec-path))
      (message "%s added to buffer-local path." it)))

  (add-hook 'js-mode-hook #'isamert/add-node-modules-to-path)
  (add-hook 'js2-mode-hook #'isamert/add-node-modules-to-path)
  (add-hook 'eshell-mode-hook #'isamert/add-node-modules-to-path)
#+end_src
*** Debug helpers
#+begin_src emacs-lisp
  (defun isamert/js-insert-debug-log-for-current-variable ()
    "Insert a `console.log' line for currently focused variable."
    (interactive)
    (let ((curr-indent)
          (node (tsc-get-child-by-field
                 (car (jsdoc--tsc-find-descendants-with-type
                       (tsc-get-parent (tree-sitter-node-at-point))
                       'variable_declarator))
                 :name)))
      (goto-char (tsc-node-end-position node))
      (end-of-line)
      (setq curr-indent (current-indentation))
      (insert "\n")
      (insert (make-string curr-indent ? ))
      (insert
       (format
        "console.log(\"%s\", %s) // FIXME remove log"
        (isamert/refactor-debug-log-text)
        (->>
         node
         (tsc-node-text)
         (s-split "\n")
         (-map #'s-trim)
         (s-join " "))))))
#+end_src
** typescript
#+begin_src emacs-lisp
  (use-package typescript-mode
    :config
    ;; Create a tsx mode based on ts mode and make tree-sitter use tsx
    ;; parser for that mode
    (define-derived-mode tsx-mode typescript-mode "typescript-tsx")
    (add-to-list 'auto-mode-alist (cons (rx ".tsx" string-end) #'tsx-mode))
    (setf (alist-get 'tsx-mode tree-sitter-major-mode-language-alist) 'tsx)
    (add-hook 'typescript-mode-hook #'isamert/add-node-modules-to-path)
    (add-hook 'tsx-mode-hook #'isamert/add-node-modules-to-path))
#+end_src

** json
#+begin_src emacs-lisp
  (use-package json-mode)

  (defun isamert/jsons-print-path-python ()
    (interactive)
    (let ((jsons-path-printer 'jsons-print-path-python))
      (jsons-print-path)))

  (defun isamert/jsons-print-path-javascript-js-jq ()
    (interactive)
    (let ((jsons-path-printer 'jsons-print-path-jq))
      (jsons-print-path)))

  ;;  Provides jsons-print-path function, it simply kills the path to the key under point
  (use-package json-snatcher
    :config
    ;; Copies paths like:.definition.summary.pastGroup.trackingResults[0].trackingItemReferenceId
    ;; I've created two functions above for the variations
    (setq jsons-path-printer 'jsons-print-path-jq))

  ;; Add execution ability to json blocks inside org-mode. Either add
  ;; `:jq some-jq-query' or `:node it.accessor' to code block's header
  ;; to filter the json
  (defun org-babel-execute:json (body params)
    (let ((jq (cdr (assoc :jq params)))
          (node (cdr (assoc :node params))))
      (cond
       (jq (with-temp-buffer
             (insert body)
             (shell-command-on-region (point-min) (point-max) (format "jq -r \"%s\"" jq) nil 't)
             (buffer-string)))
       (node (shell-command-to-string
              (format
               "node -p \"const it = require('%s'); %s\""
               (make-temp-file "foo" nil ".json" body)
               node))))))
#+end_src

** java
=lsp-java= automatically installs =eclipse.jdt.ls= to get lsp.
#+BEGIN_SRC emacs-lisp
(use-package lsp-java :after lsp
  :config (add-hook 'java-mode-hook 'lsp))

(use-package dap-java :after (lsp-java))
#+END_SRC

** emmet-mode
Hit <C-j> after these and get:
- =a= ~<a href="|">|</a>~
- =.x= ~<div class="x"></div>~
- =br/= ~<br />~
- =p.x.y.z= ~<p className="x y z"></p>~ (Works well with JSX)
- ~input[type=text]~ ~<input type="text" name="" value=""/>~
- =a>b>c= ~<a href=""><b><c></c></b></a>~
- =b*3= ~<b></b><b></b><b></b>~
#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :hook (js-mode css-mode sgml-mode web-mode tsx-mode)
  :init
  (setq emmet-expand-jsx-className? t
        emmet-self-closing-tag-style " /"))
#+END_SRC

** r
#+BEGIN_SRC emacs-lisp
(use-package ess)
#+END_SRC

** kotlin
#+BEGIN_SRC emacs-lisp
(use-package kotlin-mode)
#+END_SRC

** gradle/groovy
#+BEGIN_SRC emacs-lisp
(use-package groovy-mode
  :config
  (add-to-list 'auto-mode-alist '("\\.gradle\\'" . groovy-mode)))
#+END_SRC

** yaml
#+begin_src emacs-lisp
(use-package yaml-mode)
#+end_src

** elisp
#+begin_src emacs-lisp
  (isamert/prettify-mode 'emacs-lisp-mode-hook
                         '((">="     . ?≥)
                           ("<="     . ?≤)
                           ("defun"  . ?ƒ)
                           ("lambda" . ?λ)))

  ;; https://emacs.stackexchange.com/questions/2777/how-to-get-the-function-help-without-typing
  (defun isamert/describe-thing-in-popup ()
    (interactive)
    (let* ((thing (symbol-at-point))
           (help-xref-following t)
           (description (save-window-excursion
                          (with-temp-buffer
                            (help-mode)
                            (help-xref-interned thing)
                            (buffer-string)))))
      (flycheck-inline-hide-errors)
      (popup-tip description
                 :point (point)
                 :around t
                 :height 65
                 :scroll-bar t
                 :margin t)))

  (evil-define-key 'normal emacs-lisp-mode-map (kbd "K") #'isamert/describe-thing-in-popup)
  (evil-define-key 'normal lisp-interaction-mode-map (kbd "K") #'isamert/describe-thing-in-popup)
#+end_src

** dhall
#+begin_src emacs-lisp
  (use-package dhall-mode
    :diminish dhall-format-on-save-mode
    :mode "\\.dhall\\'"
    :config
    ;; I use dhall-lsp-server, so I don't need this
    (setq dhall-use-header-line nil))
#+end_src

** nix
#+begin_src emacs-lisp
  (use-package nix-mode
    :mode "\\.nix\\'")

  (defun isamert/import-env-from-nix-shell ()
    (interactive)
    (let ((default-directory (isamert/current-project-root)))
      (when (not (and (file-exists-p "shell.nix") (executable-find "nix-shell")))
        (error "Failed to find shell.nix or nix-shell"))
      (--> (shell-command-to-string "nix-shell --quiet --run 'env'")
        (split-string it "\n")
        (--map (-let (((name val) (s-split-up-to "=" it 1)))
                 (setenv name val)
                 (when (string-equal name "PATH")
                   (setq exec-path (split-string val path-separator)))
                 `(,name ,val))
               it))
      (message "Done.")))
#+end_src

** swift
#+begin_src emacs-lisp
  (use-package swift-mode)
#+end_src

** scheme
#+begin_src emacs-lisp
  ;; Scheme
  (use-package geiser
    :config
    (setq geiser-default-implementation 'guile))

  (use-package geiser-guile
    :after geiser)
#+end_src

** Docker stuff
Some major modes for editing files.
#+begin_src emacs-lisp
  (use-package dockerfile-mode
    :mode "Dockerfile\\'")
  (use-package docker-compose-mode
    :mode "docker-compose\\'")
#+end_src

A package for  managing docker.

#+begin_src emacs-lisp
  (use-package docker
    :config
    (evil-define-key 'normal docker-container-mode-map (kbd "a") #'docker-container-help)
    (evil-define-key 'normal docker-image-mode-map     (kbd "a") #'docker-image-help)
    (evil-define-key 'normal docker-machine-mode-map   (kbd "a") #'docker-machine-help)
    (evil-define-key 'normal docker-network-mode-map   (kbd "a") #'docker-network-help)
    (evil-define-key 'normal docker-volume-mode-map    (kbd "a") #'docker-volume-help))
#+end_src
** Kubernetes
#+begin_src emacs-lisp
  (use-package kubernetes
    :config
    (setq kubernetes-poll-frequency 3600)
    (setq kubernetes-redraw-frequency 3600)

    (evil-define-key 'normal kubernetes-overview-mode-map
      (kbd "r") #'kubernetes-refresh
      (kbd "a") #'kubernetes-dispatch))

  (use-package kubernetes-evil
    :after kubernetes)
#+end_src
** vimrc
Mostly for editing tridactyl and sometimes real vimrc.

#+begin_src emacs-lisp
  (use-package vimrc-mode)
#+end_src

** Graphviz/dot
#+begin_src emacs-lisp
  (use-package graphviz-dot-mode)
#+end_src
** PlantUML
#+begin_src emacs-lisp
  (use-package plantuml-mode
    :config
    (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
    (setq org-plantuml-jar-path "/nix/store/q0v5nv70zc23fx4hjgghnqf7lvydr6fq-plantuml-1.2021.3/lib/plantuml.jar"))
#+end_src
** Couchbase
Install couchbase-query package for running interactive queries inside emacs.
#+begin_src emacs-lisp
  (use-package couchbase-query
    :diminish
    :quelpa (couchbase-query
             :fetcher github
             :repo "isamert/couchbase-query.el")
    :config
    (setq couchbase-query-command "/Applications/Couchbase Server.app/Contents/Resources/couchbase-core/bin/cbq"))
#+end_src

Create a mode for n1ql and make n1ql code blocks inside org-mode runnable.

#+begin_src emacs-lisp
  ;; Create a dummy derived mode based on sql-mode for n1ql, so that we
  ;; get some syntax highlighting for free
  (define-derived-mode n1ql-mode sql-mode "n1ql-mode")
  (add-to-list 'auto-mode-alist (cons (rx ".n1ql" string-end) #'n1ql-mode))

  ;; Add a function to execute n1ql code blocks in org-mode. It works
  ;; just like how sql-mode code blocks is executed
  (defun org-babel-execute:n1ql (body params)
    (isamert/cbq
     body
     :host (alist-get :host params)
     :username (alist-get :username params)
     :password (alist-get :password params)
     :select (or (alist-get :select params) ".")))


  (cl-defun isamert/cbq (query &key host username password (select "."))
    "Run a couchbase query and return the result."
    (let* ((cmd (format "cbq -q -e %s -c '%s' -script \"%s\" | jq '%s'"
                        (s-chop-suffix ":8091" host)
                        (format "%s:%s" username password)
                        (thread-last query
                          (s-replace "\n" " ")
                          (s-replace "`" "\\`")
                          (s-replace "\"" "\\\""))
                        select)))
      (message "ty/cbq :: %s" cmd)
      (isamert/shell-command-to-string cmd)))
#+end_src

Create a mode for cbc binary and make cbc-mode code blocks runnable inside emacs. cbc is not able to read commands from a file, so it does not really makes sense to create a mode for it but I do this to be able to create code blocks in org mode for cbc commands so that I can save some commands in an org file and re-run them whenever I want.

#+begin_src emacs-lisp
  (define-generic-mode 'cbc-mode
    '(?!)
    '("help" "version" "cat" "create" "create" "cp" "incr" "decr" "touch" "rm" "hash" "stats" "observe" "view" "lock" "unlock" "admin" "bucket" "bucket" "bucket" "role" "user" "user" "user" "connstr" "query" "write" "strerror" "ping" "watch" "keygen")
    nil
    '("cbc\\'")
    nil
    "Simple mode for couchbase cbc commandline utility.")

  (defun org-babel-execute:cbc (body params)
    (isamert/cbc
     body
     :host (alist-get :host params)
     :username (alist-get :username params)
     :password (alist-get :password params)
     :bucket (alist-get :bucket params)
     :select (or (alist-get :select params) ".")))

  (cl-defun isamert/cbc (cbc-command &key host username password bucket (select "."))
    "Run given cbc command."
    (let* ((cmd (format "cbc %s --spec=%s/%s --username=%s --password=%s | jq '%s'"
                        cbc-command
                        host
                        bucket
                        username
                        password
                        select)))
      (message "isamert/cbc :: %s" cmd)
      (isamert/shell-command-to-string cmd)))
#+end_src

* Misc functions
** tmux integration
This integrates tmux with [[vterm]] and [[persp-mode and eyebrowse]]. I generally use Emacs commands instead of command line tools and if I ever need to do something in terminal I just use eshell. Besides this, I also like to use have a tmux instance working, for non-ephemeral stuff. I generally use a dropdown terminal (which may or may not be inside Emacs) to access the tmux instance. Here is how the integration goes:

- I tend to name my perspectives in the following format: =<namespace>/<stuff>=.
- Whenever I change to a different perspective, the code below changes the tmux session to session named =<namespace>= and tmux window to the window named =<stuff>=.

#+begin_src emacs-lisp
  (defcustom isamert/auto-focus-tmux-window t
    "Should automatically sync Emacs and Tmux?")

  (defvar isamert/tmux-session nil)

  (defun isamert/select-tmux-session ()
    "Select a tmux session for other tmux commands to use."
    (interactive)
    (->>
     (shell-command-to-string "tmux list-sessions")
     (s-split "\n")
     (--filter (not (s-blank? it)))
     (completing-read "TMUX session: ")
     (s-split ":")
     (car)
     (setq isamert/tmux-session)))

  (defun isamert/select-tmux-session-if-needed ()
    (interactive)
    (when (not isamert/tmux-session)
      (isamert/select-tmux-session)))

  (defun isamert/tmux-focus-window (window-name)
    "Focus given WINDOW-NAME in `isamert/tmux-session'."
    (interactive)
    (isamert/select-tmux-session-if-needed)
    (shell-command-to-string (format "tmux switch -t%s" isamert/tmux-session))
    (->>
     window-name
     (format "tmux list-windows -t%s | grep %s" isamert/tmux-session)
     (shell-command-to-string)
     (s-split ":")
     (car)
     (format "tmux select-window -t%s:%s" isamert/tmux-session)
     (shell-command-to-string)))

  (defun isamert/tmux-focus-perspective-window (&optional pname &rest rest)
    "Focus to the tmux window that has the same name with current perspective.
  Tmux session is infered from isamert/select-tmux-session"
    (interactive)
    (setq pname (or pname (persp-name (get-current-persp))))
    (when isamert/auto-focus-tmux-window
      (cond
       ((s-contains? "/" pname)
        (let* ((data (s-split "/" pname))
               (isamert/tmux-session (car data))
               (window-name (nth 2 data)))
          (isamert/tmux-focus-window (cadr (s-split "/" pname)))))
       (t
        (isamert/tmux-focus-window pname)))))

  (defun isamert/auto-focus-tmux-advice-after (old-function &rest arguments)
    (apply old-function arguments)
    (when isamert/auto-focus-tmux-window
      (isamert/tmux-focus-perspective-window)))

  (defun isamert/auto-focus-tmux-advice-before (old-function &rest arguments)
    (when isamert/auto-focus-tmux-window
      (isamert/tmux-focus-perspective-window))
    (apply old-function arguments))

  ;; Required hooks and advices

  (add-hook 'persp-before-switch-functions
            #'isamert/tmux-focus-perspective-window)
  (advice-add 'isamert/vterm-toggle-dedicated
              :around #'isamert/auto-focus-tmux-advice-after)
  (advice-add 'isamert/run-last-command-on-visible-vterm
              :around #'isamert/auto-focus-tmux-advice-before)
  (advice-add 'isamert/run-command-on-visible-vterm-with-history
              :around #'isamert/auto-focus-tmux-advice-before)
#+end_src
** Git and GitLab extras
#+begin_src emacs-lisp
  (evil-leader/set-key
    "gmb" 'isamert/gitlab-list-current-branch-merge-requests
    "gmm" 'isamert/gitlab-list-my-merge-requests
    "gma" 'isamert/gitlab-list-group-merge-requests
    "gmc" 'isamert/gitlab-create-merge-request)

  ;;
  ;; Git extras
  ;;

  (defun isamert/git-current-branch ()
    (s-trim (shell-command-to-string "git rev-parse --abbrev-ref HEAD")))

  (defun isamert/git-get-config (conf)
    (->>
     (format "git config --get '%s'" conf)
     (shell-command-to-string)
     (s-trim)))

  (defun isamert/git-user-name ()
    "Return user name."
    (thread-last
        (isamert/git-get-config "user.email")
      (s-split "@")
      (car)))

  (defun isamert/git-remote-homepage ()
    (let ((remote-url (isamert/git-get-config "remote.origin.url")))
      (cond
       ((s-contains? "@" remote-url)
        (->> remote-url
             (s-split "@")
             (nth 1)
             (s-replace ":" "/")
             (s-chop-suffix ".git")
             (s-prepend "https://")))
       (t (s-chop-suffix ".git" remote-url)))))

  ;;
  ;; Gitlab
  ;;

  (defvar isamert/gitlab-token
    nil
    "Gitlab token.")

  (defvar isamert/gitlab-host
    nil
    "Gitlab host.")

  (defvar isamert/gitlab-group
    nil
    "Gitlab group.")

  (defun isamert/gitlab-project-path ()
    "Return hexified project path for current git project.
  This is mostly used while doing an api call for the current
  project."
    (->>
     (isamert/git-remote-homepage)
     (s-chop-prefix isamert/gitlab-host)
     (s-chop-prefix "/")
     (s-chop-prefix "/")
     (s-chop-prefix "/")
     (s-trim)
     (url-hexify-string)))

  (cl-defun isamert/gitlab-request
      (endpoint
       &rest params
       &key (req-type "GET") (req-headers '()) (req-data nil)
       &allow-other-keys)
    (let (json
          (json-object-type 'hash-table)
          (json-array-type #'list)
          (json-key-type 'symbol))

      ;; Remove request related items from params list
      (dolist (key '(:req-type :req-headers :req-data))
        (cl-remf params key))

      (request
        (thread-last (format "%s/api/v4/%s" isamert/gitlab-host endpoint)
          (s-replace "#{group}" (url-hexify-string isamert/gitlab-group))
          (s-replace "#{project}" (isamert/gitlab-project-path)))
        :type req-type
        :headers `((Authorization . ,(format "Bearer %s" isamert/gitlab-token)) ,@req-headers)
        :parser #'json-read
        :success (cl-function
                  (lambda (&key data &allow-other-keys)
                    (setq json data)))
        :sync t
        :data (transient-plist-to-alist req-data)
        ;; TODO Maybe roll my own plist-to-alist function
        :params (transient-plist-to-alist params))
      json))

  (defun isamert/gitlab-list-current-branch-merge-requests ()
    "List all open MRs that the source branch is the current branch."
    (interactive)
    (isamert/gitlab--select-mr-and-apply-action
     (isamert/gitlab-request
      "projects/#{project}/merge_requests"
      :scope 'all
      :state 'opened
      :source_branch (isamert/git-current-branch))))

  (defun isamert/gitlab-list-my-merge-requests ()
    "List all of my currently open merge requests.
  `mine' means either it's created by me or assigned to me."
    (interactive)
    (isamert/gitlab--select-mr-and-apply-action
     `(,@(isamert/gitlab-request
          "merge_requests"
          :scope 'created_by_me
          :state 'opened)
       ,@(isamert/gitlab-request
          "merge_requests"
          :scope 'assigned_to_me
          :state 'opened))))

  (defun isamert/gitlab-list-group-merge-requests ()
    "List all open MRs that belongs to `isamert/gitlab-group'."
    (interactive)
    (isamert/gitlab--select-mr-and-apply-action
     (isamert/gitlab-request
      "groups/#{group}/merge_requests"
      :scope 'all
      :state 'opened)))

  (defun isamert/gitlab-create-merge-request ()
    "Create an MR interactively."
    (interactive)
    (isamert/gitlab--open-web-url
     (isamert/gitlab-request
      "projects/#{project}/merge_requests"
      :req-type "POST"
      :req-data (list :source_branch (completing-read
                                      "Source branch: "
                                      (vc-git-branches)
                                      nil nil (isamert/git-current-branch))
                      :target_branch (completing-read
                                      "Target branch: "
                                      (vc-git-branches)
                                      nil nil "master")
                      :title (read-string "MR Title: "
                                          (s-trim (shell-command-to-string "git log -1 --pretty=%B")))
                      ;; TODO Get description (and maybe title) from a
                      ;; dedicated buffer like how magit commit asks
                      ;; input from a user
                      :description (read-string "Description: " (format "Closes %s" (isamert/git-current-branch)))
                      :remove_source_branch t))))

  (defun isamert/gitlab-select-project ()
    (interactive)
    (isamert/gitlab--select-project-and-apply-action
     (isamert/gitlab-request
      "groups/#{group}/projects"
      :with_shared 'false
      :include_subgroups 'true
      :per_page 100)))

  ;;
  ;; Internal
  ;;

  (defun isamert/gitlab--open-web-url (it)
    (browse-url (gethash 'web_url it)))

  (defun isamert/gitlab--rebase-merge-request (it)
    (isamert/gitlab-request
     (format "projects/%s/merge_requests/%s/rebase" (gethash 'project_id it) (gethash 'iid it))
     :req-type "PUT"))

  (defun isamert/gitlab--mr-format-title (mr)
    (format "%s, [%s], by %s"
            (propertize (gethash 'title mr)
                        'face 'bold)
            (propertize
             (->>
              (gethash 'web_url mr)
              (s-chop-prefix isamert/gitlab-host)
              (s-split "/-/merge_requests/")
              (car)
              (s-split "/")
              (-last-item))
             'face '(:weight thin))
            (propertize (gethash 'name (gethash 'author mr))
                        'face 'italic)))

  (defun isamert/gitlab--select-mr-and-apply-action (mrs)
    (let ((mr-infos (--map
                     (cons (isamert/gitlab--mr-format-title it) it)
                     mrs)))
      (-->
       (completing-read "Select MR: " mr-infos)
       (assoc-string it mr-infos)
       (cdr it)
       (isamert/gitlab--merge-request-actions it))))

  (defun isamert/gitlab--merge-request-actions (mr)
    (with-completing-read-exact-order
     (let ((action (completing-read
                    "Select an action: "
                    '("Open page"
                      "Rebase"))))
       (pcase action
         ("Open page" (isamert/gitlab--open-web-url mr))
         ("Rebase" (isamert/gitlab--rebase-merge-request mr))))))

  ;; TODO actions
  (defun isamert/gitlab--select-project-and-apply-action (projects)
    (let ((project-alist (--map
                          (cons (gethash 'name_with_namespace it) it)
                          projects)))
      (completing-read
       "Project: "
       (--map
        (gethash 'name_with_namespace it)
        projects))))

  ;;
  ;; Gitlab config
  ;;

  (setq isamert/gitlab-host ty/gitlab-url)
  (setq isamert/gitlab-token ty/gitlab-token)
  (setq isamert/gitlab-group ty/gitlab-group)
#+end_src

** Jira
#+begin_src emacs-lisp :lexical yes
  (evil-leader/set-key "oj" #'isamert/open-jira-issue-at-point)
  (evil-leader/set-key "ej" #'isamert/jira-list-issues)

  ;;
  ;; Install required JIRA client
  ;;

  (use-package jiralib2
    :config
    (setq jiralib2-url ty/jira-url)
    (setq jiralib2-auth 'basic)
    (setq jiralib2-user-login-name ty/jira-login)
    (setq jiralib2-token nil))

  ;;
  ;; My completing-read based JIRA utilities
  ;;

  (defvar isamert/git-worktrees-root "~/Workspace/projects/worktrees"
    "Directory to create worktrees in.")

  (defvar isamert/git-main-branch "master"
    "Main branch name.")

  (defvar isamert/jira-projects '(("SAT" . 1))
    "List of projects that I enrolled in JIRA.
  CDR of each item defines which ticket number the caching should
  start.")

  (defvar isamert/jira-base-branch "origin/master"
    "Brach to create feature branches from.
  Consider using origin/something to create the branch from latest
  something.")

  (defvar isamert/jira-feature-branch-prefix "feature/"
    "Prefix to prepend feature branch names.")

  (defvar isamert/jira-my-issues-query "Pair-programmer = currentUser() OR assignee = currentUser() ORDER BY createdDate DESC"
    "Query to find out issues that are assigned to me.")

  (defvar isamert/jira-kanban-board-query
    "project = SAT AND (fixVersion in unreleasedVersions() OR fixVersion is EMPTY) AND createdDate >= -2w ORDER BY Rank ASC"
    "Query to get kanban board issues.")


  ;; Internal state

  (defvar isamert/jira-my-issues '()
    "All of my issues")
  (defvar isamert/jira-new-issues '()
    "New jira issues")
  (defvar isamert/jira-current-sprint-issues '()
    "Current sprint issues")
  (defvar isamert/jira-kanban-issues '()
    "Kanban issues")
  (defvar isamert/jira--users '()
    "Users list")

  (when (file-exists-p "~/.emacs.d/.cache/isamert-jira-my-issues")
    (isamert/deserialize-from-file
     "~/.emacs.d/.cache/isamert-jira-my-issues"
     'isamert/jira-my-issues)
    (isamert/deserialize-from-file
     "~/.emacs.d/.cache/isamert-jira-new-issues"
     'isamert/jira-new-issues)
    (isamert/deserialize-from-file
     "~/.emacs.d/.cache/isamert-jira-current-sprint-issues"
     'isamert/jira-current-sprint-issues)
    (isamert/deserialize-from-file
     "~/.emacs.d/.cache/isamert-jira--users"
     'isamert/jira--users)
    (isamert/deserialize-from-file
     "~/.emacs.d/.cache/isamert-jira-kanban-issues"
     'isamert/jira-kanban-issues))

  ;; Functions

  (defun isamert/open-jira-issue (issue-number)
    "Open given Jira ISSUE-NUMBER."
    (interactive "sIssue: ")
    (browse-url (format "%s/browse/%s" jiralib2-url (car (s-split " " issue-number)))))

  (defun isamert/open-jira-issue-at-point ()
    "Open issue at point."
    (interactive)
    (isamert/open-jira-issue (thing-at-point 'symbol)))

  (defun isamert/jira-refresh-issue-lists ()
    (interactive)
    (when isamert/jira-my-issues
      (message ">> Updating my issues...")
      (setq isamert/jira-my-issues (jiralib2-jql-search isamert/jira-my-issues-query)))

    (message ">> Updating new issues...")
    (setq isamert/jira-new-issues '())
    (mapcar
     (lambda (project)
       (setq
        isamert/jira-new-issues
        (thread-last (format "project = \"%s\" AND issuekey >= \"%s-%s\""
                             (car project) (car project) (cdr project))
          (jiralib2-jql-search)
          (append isamert/jira-new-issues))))
     isamert/jira-projects)

    (message ">> Updating current sprint...")
    (setq isamert/jira-current-sprint-issues '())
    (mapcar
     (lambda (project)
       (setq
        isamert/jira-current-sprint-issues
        (thread-last (format "project = \"%s\" AND Sprint in openSprints()"
                             (car project) (car project) (cdr project))
          (jiralib2-jql-search)
          (append isamert/jira-current-sprint-issues))))
     isamert/jira-projects)

    (when isamert/jira-kanban-board-query
      (message ">> Updating kanban issues...")
      (setq isamert/jira-kanban-issues (jiralib2-jql-search isamert/jira-kanban-board-query)))

    (message ">> DONE")

    ;; Persist
    (isamert/serialize-into-file
     "~/.emacs.d/.cache/isamert-jira-my-issues"
     isamert/jira-my-issues)
    (isamert/serialize-into-file
     "~/.emacs.d/.cache/isamert-jira-new-issues"
     isamert/jira-new-issues)
    (isamert/serialize-into-file
     "~/.emacs.d/.cache/isamert-jira-current-sprint-issues"
     isamert/jira-current-sprint-issues)
    (isamert/serialize-into-file
     "~/.emacs.d/.cache/isamert-jira-kanban-issues"
     isamert/jira-kanban-issues))

  (defun isamert/jira-list-issues (&optional arg)
    (interactive "P")
    (when arg
      (isamert/jira-refresh-issue-lists))
    (thread-last (pcase (completing-read "Issue list: " '("My issues" "Current Sprint" "New issues" "Kanban"))
                   ("My issues" isamert/jira-my-issues)
                   ("New issues" isamert/jira-new-issues)
                   ("Current Sprint" isamert/jira-current-sprint-issues)
                   ("Kanban" isamert/jira-kanban-issues))
      (--map (cons (isamert/jira--format-ticket-name it) it))
      (isamert/alist-completing-read "Select ticket: ")
      (isamert/jira--issue-actions)))

  (defun isamert/jira-ticket-to-branch (issue-name)
    "Create a new branch from given ISSUE-NAME and switch to it."
    (interactive "sIssue name: ")
    (let ((branch-name (isamert/jira--create-branch-name-from-ticket issue-name)))
      (unless (equal isamert/git-main-branch (isamert/git-current-branch))
        (user-error "Please switch to `%s' branch first." isamert/git-main-branch))
      (message "Updating...")
      (magit-fetch-all nil)
      (message "Creating branch...")
      (magit-branch-and-checkout branch-name isamert/jira-base-branch)
      (vc-refresh-state)
      (message "Currently on %s." (magit-get-current-branch))))

  (defun isamert/jira-ticket-to-worktree (issue-name)
    (interactive "sIssue name: ")
    (let* ((branch-name (isamert/jira--create-branch-name-from-ticket issue-name))
           (worktree (expand-file-name (format "%s/%s" isamert/git-worktrees-root (s-replace "/" "-" branch-name)))))
      (message "Updating...")
      (magit-fetch-all nil)
      (message "Creating worktree...")
      (if (-contains? (vc-git-branches) branch-name)
          (magit-worktree-checkout worktree branch-name)
        (magit-worktree-branch worktree branch-name isamert/jira-base-branch))
      (persp-add-new branch-name)
      (persp-switch branch-name)
      (cd worktree)
      (isamert/find-file-in-current-project)
      (vc-refresh-state)
      (message "Currently on %s." (magit-get-current-branch))))

  (defun isamert/jira-create-ticket ()
    (interactive)
    (let ((project (isamert/jira--select-project))
          (issue-type (isamert/jira--select-issue-type))
          (summary (read-string "Issue summary: ")))
      (isamert/get-input
       :init (format "* %s\n:PROPERTIES:\n:PROJECT-ID: %s\n:ISSUE-TYPE: %s\n:END:\n" summary project issue-type)
       :pre-process (lambda ()
                      (goto-char (point-min))
                      (let* ((all (org-entry-properties nil 'standard))
                             (rest (--remove (-contains? '("CATEGORY" "ISSUE-TYPE" "PROJECT-ID") (car it)) all)))
                        (list
                         :summary (org-entry-get nil "ITEM")
                         :project-id (org-entry-get nil "PROJECT-ID")
                         :type (org-entry-get nil "ISSUE-TYPE")
                         :rest rest)))
       :on-accept (lambda (description props)
                    (setq description (org-export-string-as description 'confluence t))
                    (message ">> (isamert/jira-create-ticket %s :description %s)" props description)
                    (thread-last
                        (apply #'jiralib2-create-issue
                               `(,(plist-get props :project-id)
                                 ,(plist-get props :type)
                                 ,(plist-get props :summary)
                                 ,description
                                 ,@(plist-get props :rest)))
                      (isamert/jira--issue-actions))))))

  ;;
  ;; Utility
  ;;

  (defun isamert/jira--get-users ()
    (unless isamert/jira--users
      (setq
       isamert/jira--users
       (mapcar
        (lambda (project) (cons project (jiralib2-get-users project)))
        (mapcar #'car isamert/jira-projects)))
      (isamert/serialize-into-file
       "~/.emacs.d/.cache/isamert-jira--users"
       isamert/jira--users))
    isamert/jira--users)

  (defun isamert/jira--select-user (project)
    (thread-last (isamert/jira--get-users)
      (assoc-string (isamert/jira--select-project))
      (cdr)
      (--map (cons (alist-get 'name it) it))
      (isamert/alist-completing-read "Select a user: ")))

  (defun isamert/jira--select-project ()
    "Interactively select one of enrolled projects."
    (if (eq (length isamert/jira-projects) 1)
        (caar isamert/jira-projects)
      (completing-read "Select project: " isamert/jira-projects)))

  (defun isamert/jira--select-issue-type ()
    (completing-read
     "Issue type: "
     (--map
      (let-alist it (cons .name .id))
      (jiralib2-get-issuetypes))))

  (defun isamert/jira--create-branch-name-from-ticket (issue-name)
    "Create a branch name from given Jira ISSUE-NAME"
    (thread-last issue-name
      (s-replace-all '((" " . "-") (":" . "-") ("\"" . "") ("/" . "-") ("&" . "") ("(" . "-") (")" . "-")))
      (s-replace "---" "-")
      (s-replace "--" "-")
      (s-downcase)
      (isamert/s-upcase-until "-")
      (s-prepend isamert/jira-feature-branch-prefix)
      (read-string "Branch name: ")))

  (defun isamert/jira--format-ticket-name (it)
    "Format ticket name for displaying in completing-read window."
    (let-alist it
      (format
       "%-7s [%-11s] %-15s - %s"
       (propertize .key
                   'face 'bold)
       (propertize (s-truncate 11 .fields.status.name)
                   'face 'italic)
       (propertize (s-truncate 15 (or .fields.assignee.name "N/A"))
                   'face 'italic)
       .fields.summary)))

  (defun isamert/jira--issue-actions (issue)
    (cl-loop
     (with-completing-read-exact-order
      (let-alist issue
        (let* ((action
                (completing-read
                 (format "Act on %s: " (s-truncate 20 .fields.summary))
                 '("Open" "To branch" "To worktree" "Assign to..." "Insert as task" "[Cancel]"))))
          (pcase action
            ("Open"
             (isamert/open-jira-issue .key)
             (cl-return))
            ("To branch"
             (isamert/jira-ticket-to-branch (concat .key "-" .fields.summary))
             (cl-return))
            ("To worktree"
             (isamert/jira-ticket-to-worktree (concat .key "-" .fields.summary))
             (cl-return))
            ("Assign to..."
             (jiralib2-assign-issue
              .key
              (alist-get 'name (isamert/jira--select-user (isamert/jira--select-project)))))
            ("Insert as task"
             (insert (format "** TODO [#A] %s %s :work:" .key .fields.summary)))
            ("[Cancel]"
             (cl-return))))))))
#+end_src

** My Android phone and Emacs
I have an Android phone that is running [[https://termux.com/][Termux]] all the time. If you install Termux through [[https://www.f-droid.org/][F-Droid]] you can also install [[https://f-droid.org/en/packages/com.termux.api/][Termux:API]] package which brings bunch of commands like =termux-clipboard-set=, =termux-sms-list= etc. Much of the commands requires to be called in foreground, so they are not very useful over SSH but you can work around that by starting a =tmux= session on the phone and executing commands on that tmux session through SSH. This way I can send arbitrary text to my phones clipboard using the commands below.

#+begin_src emacs-lisp
  (evil-leader/set-key
    "ept" #'isamert/send-text-to-my-phone
    "epc" #'isamert/send-clipboard-to-my-phone)

  (defvar isamert/phone-hostname
    "f3"
    "Hostname or local address to connect to my phone by SSH.")

  (defun isamert/send-termux-command (cmd)
    "Send CMD to my phone."
    (interactive "sText: ")
    (shell-command-to-string (format "ssh %s \"tmux pipe-pane -t0 '%s'\"" isamert/phone-hostname cmd)))

  (cl-defun isamert/send-notification-to-my-phone
      (&key
       title
       content
       url-to-open)
    "Send a notification to my phone."
    (isamert/send-termux-command
     (format "termux-notification --title \\\"%s\\\" --content \\\"%s\\\" %s"
             title
             (or content "")
             (if url-to-open
                 (format "--action \\\"termux-open %s\\\"" url-to-open)
               ""))))

  (defun isamert/send-text-to-my-phone (text)
    "Send TEXT to my phones clipboard."
    (interactive "sText: ")
    (shell-command-to-string (format "ssh %s \"tmux pipe-pane -t0 'echo \\\"%s\\\" | termux-clipboard-set'\"" isamert/phone-hostname text)))

  (defun isamert/send-clipboard-to-my-phone ()
    "Send current clipboard content to my phones clipboard."
    (interactive)
    (isamert/send-text-to-my-phone (current-kill 0)))
#+end_src

** Signal
#+begin_src emacs-lisp :tangle (if (eq system-type 'gnu/linux) "yes" "no")
  (require 'dbus)

  (evil-leader/set-key
    "epn" #'isamert/signal-send-note-to-myself
    "epm" #'isamert/signal-send-message)

  (defconst isamert/signal-dbus-args '(:session "org.asamk.Signal"
                                                "/org/asamk/Signal"
                                                "org.asamk.Signal"))

  (defun isamert/signal (&rest args)
    "Send a signal DBUS command with ARGS."
    (apply #'dbus-call-method `(,@isamert/signal-dbus-args ,@args)))

  (defun isamert/signal-async (&rest args)
    "Send an async Signal DBUS command with ARGS."
    (apply #'dbus-call-method-asynchronously `(,@isamert/signal-dbus-args ,@args)))

  (defun isamert/signal-send-note-to-myself (note &optional attachments)
    "Send a NOTE with attachments to my phone."
    (interactive
     (list
      (if (use-region-p)
          (buffer-substring (region-beginning) (region-end))
        (read-string "Enter note: "))
      (when (y-or-n-p "Want to attach something? ")
        (list (read-file-name "Attachment: ")))))
    (isamert/signal-async
     "sendNoteToSelfMessage"
     (lambda (msg) (message ">> Signal %s" msg))
     note
     (or (mapcar 'expand-file-name attachments)
         '(:array))))

  (defun isamert/signal-send-message (recipient content &optional attachments)
    "Send message to RECIPIENT with CONTENT."
    (interactive
     (list
      (isamert/signal-select-contact)
      (if (use-region-p)
          (buffer-substring (region-beginning) (region-end))
        (read-string "Enter message: "))
      (when (y-or-n-p "Want to attach something? ")
        (list (read-file-name "Attachment: ")))))
    (isamert/signal-async
     (if (plist-get recipient :number)
         "sendMessage"
       "sendGroupMessage")
     (lambda (msg) (message ">> Signal %s" msg))
     content
     (or (mapcar 'expand-file-name attachments)
         '(:array))
     (cadr recipient)))

  (defun isamert/signal-select-contact ()
    "Select a contact interactively."
    (let* ((contacts (--map
                      (cons (isamert/signal "getContactName" it) it)
                      (isamert/signal "listNumbers")))
           (groups (--map
                    (cons (format
                           "%s [GROUP]"
                           (isamert/signal "getGroupName"
                                           (dbus-string-to-byte-array (dbus-byte-array-to-string it))))
                          it)
                    (isamert/signal "getGroupIds")))
           (all (append contacts groups))
           (selected (cdr (assoc (completing-read "Send message to: " all) all))))
      (if (stringp selected)
          (list :number selected)
        (list :group (dbus-string-to-byte-array (dbus-byte-array-to-string selected))))))

  (defun isamert/signal-sync-message-received-handler (ts source receiver _ msg attchs)
    (when (and (string= receiver source)
               (string= isamert/my-phone-number source))
      (cond
       ((s-prefix? "run" msg)
        (isamert/signal-send-note-to-myself
         (shell-command-to-string (s-chop-prefix "run " msg))))
       ((string= "help" msg)
        (isamert/signal-send-note-to-myself
         (concat "run <shell-command>\n"
                 "grab <file-path>\n"
                 "help")))
       ((s-prefix? "grab" msg)
        (isamert/signal-send-note-to-myself
         "" (list (s-chop-prefix "grab " msg)))))))

  (defvar isamert/signal-bot-object nil)

  (defun isamert/start-signal-bot ()
    (interactive)
    (setq
     isamert/signal-bot-object
     (apply
      #'dbus-register-signal
      `(,@isamert/signal-dbus-args
        ,"SyncMessageReceived"
        ,#'isamert/signal-sync-message-received-handler))))

  (defun isamert/stop-signal-bot ()
    (interactive)
    (dbus-unregister-object isamert/signal-bot-object))

  (isamert/start-signal-bot)
#+end_src
** people.org - Contact management
Please see [[https://isamert.net/2021/04/21/managing-your-contacts-in-org-mode-and-syncing-them-to-your-phone-android-ios-whatever-.html][this post]] for further information.

#+begin_src emacs-lisp
  (defun isamert/build-contact-item (template-string contact-property)
    (if-let ((stuff (org-entry-get nil contact-property)))
        (concat (format template-string stuff) "\n")
      ""))

  (defun isamert/export-contacts-as-vcard (file-name)
    "Create a .vcf file containing all contact information."
    (interactive
     (list
      (read-file-name
       "Where to save the .vcf file?"
       "~/Documents/sync/"
       "contacts.vcf")))
    (write-region
     (string-join
      (org-map-entries
       (lambda ()
         (string-join
          `("BEGIN:VCARD\nVERSION:2.1\n"
            ,(isamert/build-contact-item "FN:%s" "ITEM")
            ,(isamert/build-contact-item "TEL;CELL:%s" "PHONE")
            ,(isamert/build-contact-item "TEL;WORK:%s" "PHONE_WORK")
            ,(isamert/build-contact-item "EMAIL:%s" "EMAIL")
            ,(isamert/build-contact-item "ORG:%s" "GROUP")
            ,(isamert/build-contact-item "ADR;HOME:;;%s" "ADDRESS_HOME")
            ,(isamert/build-contact-item "ADR;WORK:;;%s" "ADDRESS_WORK")
            ,(format "REV:%s\n" (format-time-string "%Y-%m-%dT%T"))
            "END:VCARD")
          ""))
       "LEVEL=1")
      "\n")
     nil
     file-name))
#+end_src
** Google search
#+begin_src emacs-lisp
  (defun isamert/google-this ()
    "Search selected region or current word in Google. Let's you edit the query beforehand."
    (interactive)
    (browse-url
     (format
      "https://google.com/search?q=%s"
      (read-string
       "Googling: "
       (isamert/region-or 'word)))))

  (evil-leader/set-key
    "/g"   'isamert/google-this)
#+end_src

** Google translate
#+begin_src emacs-lisp
  (defun isamert/google-translate-this (from to)
    "Translate selected region or current word from FROM to TO.
  Let's you edit the query beforehand.  Result is printed into minibuffer.
  You need to install `translate-shell' to make this work."
    (interactive
     `(,(read-string "From: " "en") ,(read-string "To: " "tr")))
    (message
     (shell-command-to-string
      (format
       "trans %s:%s \"%s\""
       from to
       (read-string
        "Translating: "
        (isamert/region-or 'word))))))

  (defun isamert/google-translate-this-en-to-tr ()
    (interactive)
    (isamert/google-translate-this "en" "tr"))

  (defun isamert/google-translate-this-tr-to-en ()
    (interactive)
    (isamert/google-translate-this "tr" "en"))

  (evil-leader/set-key
    "/tt"   'isamert/google-translate-this-en-to-tr
    "/te"   'isamert/google-translate-this-tr-to-en)
#+end_src

** TODO org-mode enhancements
I need to rewrite these functions using [[https://github.com/isamert/marks][marks]] for both speed and accuracy.

#+begin_src emacs-lisp
  ;; Keybindings

  (evil-leader/set-key
    "ol" 'isamert/org-link-header
    ;; TODO: rewrite this:
    ;;"oL" 'isamert/org-backlinks
  )

  ;;
  ;; Utility
  ;;

  (defun isamert/org-header-line-to-title (line)
    "Remove TODO/*/unnecessary whitespace from given LINE.
  Then return the title of given `org-mode` header.
  Just like (org-entry-get nil \"ITEM\") but works on given string."
    (->> line
      (s-replace-regexp "\\(\\*\\|TODO\\|PROG\\|DONE\\|WAIT\\)" "") ;; Remove TODO states
      (s-replace-regexp "\\(\\[#.\\{1\\}\\]\\\)" "") ;; Remove priorities
      (s-replace-regexp ":\\(\\w+:\\)+$"  "") ;; Remove tags
      (replace-regexp-in-string "\\[\\[.*\\]\\[\\(.*\\)\\]\\]"  "\\1") ;; Fix links
      (replace-regexp-in-string "\\[\\[\\(.*\\)\\]\\]"  "\\1") ;; Fix links
      (s-trim)))

  (defun isamert/org-file-get-header-id (file-path header-line)
    "Return the id of given header at HEADER-LINE in FILE-PATH."
    (interactive)
    (save-excursion
      (with-current-buffer (let ((enable-local-variables nil)) (find-file-noselect file-path))
        (goto-char 0)
        (forward-line header-line)
        (org-id-get nil 'create)
        (save-buffer)
        (org-id-get nil 'create))))

  (defun isamert/org-all-headers ()
    "Return all headers in `org-directory'."
    (->> (concat "cd " org-directory "; "
                 "rg"
                 " --no-heading" " --with-filename"
                 " --line-number" " -t org"
                 " " "\"^\\*+ \" ")
      (shell-command-to-string)
      (s-split "\n")
      (--filter (not (s-blank? it)))
      (--map
       (-let* (((fname line . content) (split-string it ":"))
               (header (isamert/org-header-line-to-title (string-join content ":"))))
         `(,(format
             "%s:%s %s %s"
             (propertize fname 'face '(:foreground "plum"  :slant italic))
             (propertize line 'face '(:slant italic :weight thin))
             (propertize "»" 'face '(:foreground "green"))
             (propertize header 'face '(:foreground "sky blue" :weight bold)))
           .
           (:fname ,fname :line ,(1- (string-to-number line)) :header ,header))))))

  (defun isamert/org-link-header ()
    "Interactively select a header and insert it as a link into the buffer.
  Headers are gathered from all the org files found in `org-directory'."
    (interactive)
    (let* ((headers (isamert/org-all-headers))
           (selected (cdr (assoc-string (completing-read "Select header:" headers) headers)))
           (link-name (read-string "Enter link text: " (plist-get selected :header)))
           (header-id (isamert/org-file-get-header-id (plist-get selected :fname) (plist-get selected :line)))
           (selected-link (concat "[[id:" header-id "][" link-name "]]")))
      (insert selected-link)))

  ;; TODO Removed backlinks implementation, I will implement it once
  ;; minimal functionality within "marks" is done
#+end_src

** bullet.org
I have a ~bullet.org~ file that I keep my daily journal and here are some utility functions that use with it. I may document this later (or even publish it as a package?)

#+begin_src emacs-lisp
  ;; Keybindings

  (evil-leader/set-key
    "obb" 'isamert/bullet-focus-non-day-header
    "oby" 'isamert/bullet-focus-yesterday
    "obt" 'isamert/bullet-focus-today
    "obf" 'isamert/bullet-focus-given-day
    "obr" 'isamert/bullet-focus-recurring
    "obw" 'isamert/bullet-focus-work
    "obl" 'isamert/bullet-focus-life
    "obc" 'isamert/bullet-focus-computer)

  ;;
  ;; Date utils
  ;;

  (defun isamert/today ()
    "Get todays date in format YYYY-MM-DD Day."
    (format-time-string "%Y-%m-%d %a"))

  (defun isamert/u ()
    "Get day of week as number."
    (string-to-number (format-time-string "%u")))

  (defun isamert/d ()
    "Get day of month as number."
    (string-to-number (format-time-string "%d")))

  (defun isamert/V ()
    "Get week number."
    (string-to-number (format-time-string "%V")))

  (defun isamert/date (date)
    "Display the time described by DATE.
  DATE can be 'now', 'yesterday', 'two days ago' etc."
    (s-trim-right
     (shell-command-to-string
      (concat (locate-file "date" exec-path) " --date='" date "' +'%Y-%m-%d %a'"))))

  ;;
  ;; Create utils
  ;;

  (defun isamert/bullet-create-a-day (date)
    "Create given DATE heading in bullet.org in the appropriate place..
  DATE should be in the form of YYYY-MM-DD."
    (when-let ((point (isamert/bullet-find-a-day date)))
      (goto-char point)
      (user-error "The day already exists"))
    (widen)
    (goto-char (point-max))
    (cl-loop
     (when (not (re-search-backward "^* \\[\\([0-9]+-[0-9]+-[0-9]+\\)\\( \\w+\\)?\\].*" nil t))
       (cl-return))
     (when (time-less-p
            (date-to-time (concat (match-string 1) "T000"))
            (date-to-time (concat date "T000")))
       (org-insert-heading-after-current)
       (insert (format "[%s %s] [/]" date (format-time-string "%a" (date-to-time (concat date "T000")))))
       (org-narrow-to-subtree)
       (cl-return))))

  ;;
  ;; Focus a day
  ;;

  (defun isamert/bullet-find-a-day (day)
    (save-excursion
      (widen)
      (goto-char (point-max))
      (when (re-search-backward (concat "^* \\[" day "\\( \\w+\\)?\\]") nil t)
        (point-marker))))

  (defun isamert/bullet-focus-a-day (day)
    "Focus to given DAY."
    (widen)
    (when-let ((day-entry (isamert/bullet-find-a-day day)))
      (goto-char day-entry)
      (beginning-of-line)
      (org-narrow-to-subtree)
      t))

  (defun isamert/bullet-focus-given-day (date)
    "Focus given DATE's header.
  If it does not exists, create it."
    (interactive
     (list (org-read-date)))
    (when (not (isamert/bullet-focus-a-day date))
      (isamert/bullet-create-a-day date)))

  (defun isamert/bullet-focus-today ()
    "Focus todays header.
  If it does not exists, create it."
    (interactive)
    (let ((today (if (<= (string-to-number (format-time-string "%H")) 3)
                     (isamert/date "yesterday")
                   (format-time-string "%Y-%m-%d"))))
      (when (not (isamert/bullet-focus-a-day today))
        (isamert/bullet-create-a-day today))))


  (defun isamert/bullet-focus-yesterday ()
    "Focus yesterdays header."
    (interactive)
    (isamert/bullet-focus-a-day (isamert/date "yesterday")))

  (defun isamert/bullet-focus-heading (heading)
    "Focus yesterdays header."
    (interactive)
    (widen)
    (goto-char (point-min))
    (when (re-search-forward (format "^*+ %s" heading))
      (beginning-of-line)
      (org-narrow-to-subtree)
      t))

  (defun isamert/bullet-focus-recurring ()
    (interactive)
    (isamert/bullet-focus-heading "Recurring"))

  (defun isamert/bullet-focus-work ()
    (interactive)
    (isamert/bullet-focus-heading "Work backlog"))

  (defun isamert/bullet-focus-life ()
    (interactive)
    (isamert/bullet-focus-heading "Life backlog"))

  (defun isamert/bullet-focus-computer ()
    (interactive)
    (isamert/bullet-focus-heading "Computer backlog"))

  ;;
  ;; Focus non-day
  ;;

  (defun isamert/bullet-focus-non-day-header ()
    "Interactively select and focus a non-day header."
    (interactive)
    (save-match-data
      (widen)
      (goto-char 0)
      (re-search-forward "^\\*+ \\[[0-9]+-" nil t)
      (narrow-to-region (point-min) (point-at-bol))
      (consult-org-heading)
      (org-narrow-to-subtree)))

  ;;
  ;; Template utils
  ;;

  (defun isamert/bullet-current-date ()
    "Return current date."
    (save-excursion
      (re-search-backward "^* \\[")
      (thread-last
          (org-get-heading t t t t)
        (s-match "\\[.*?\\]")
        (car)
        (substring-no-properties)
        (s-chop-prefix "[")
        (s-chop-suffix "]"))))

  (defmacro isamert/when-weekday (template &rest template-args)
    `(when (<= (isamert/u) 5)
       (s-trim (isamert/s-interpolated ,template ,@template-args))))

  (defmacro isamert/when-weekday-n (n template &rest template-args)
    `(when (= (isamert/u) ,n)
       (s-trim (isamert/s-interpolated ,template ,@template-args))))

  (defmacro isamert/when-monthday-n (n template &rest template-args)
    `(when (= (isamert/d) ,n)
       (s-trim (isamert/s-interpolated ,template ,@template-args))))

  (defmacro isamert/when-weekend (template &rest template-args)
    `(when (> (isamert/u) 5)
       (s-trim (isamert/s-interpolated ,template ,@template-args))))

  (defmacro isamert/when-saturday (template &rest template-args)
    `(when (= (isamert/u) 6)
       (s-trim (isamert/s-interpolated ,template ,@template-args))))

  (defmacro isamert/when-sunday (template &rest template-args)
    `(when (= (isamert/u) 7)
       (s-trim (isamert/s-interpolated ,template ,@template-args))))

  ;;
  ;; Daily summary
  ;;

  ;; Implementation is a bit cumbersome but it's easy to adopt for my ad-hoc requests
  (defun org-dblock-write:daily-summary (params)
    "Create a daily summary for my bullet.org."
    (let* ((items (org-map-entries
                   (lambda nil
                     (list
                      :name
                      (org-entry-get nil "ITEM")
                      :clock
                      (org-clock-sum-current-item)
                      :tags
                      (or (org-get-tags) '(empty))
                      :level
                      (org-current-level)
                      :parent
                      (save-excursion
                        (when (org-up-heading-safe)
                          (org-entry-get nil "ITEM")))))
                   "LEVEL>1"))
           (total-time (->> items
                            (--filter (= (plist-get it :level) 2))
                            (--map (plist-get it :clock))
                            (-sum)
                            (org-minutes-to-clocksum-string)))
           (routines (--filter (s-equals? (plist-get it :parent) "Routines") items))
           (work (--filter (-contains? (plist-get it :tags) "work") items))
           (others (--filter (not (or
                                   (-contains? (plist-get it :tags) "work")
                                   (s-equals? (plist-get it :parent) "Routines")
                                   (s-equals? (plist-get it :name) "Routines"))) items)))

      (insert "| [Event] | [Duration] ||\n")
      (insert "|-|\n")

      (->> items
           (--find (s-equals? "Routines" (plist-get it :name)))
           (funcall (-flip #'plist-get) :clock)
           (org-minutes-to-clocksum-string)
           (format "|Routines|%s||\n")
           (insert))

      (->> routines
           (--filter (-contains? '("Breakfast" "Dinner") (plist-get it :name)))
           (--map (plist-get it :clock))
           (-sum)
           (org-minutes-to-clocksum-string)
           (format "|\\-- Eating||%s|\n")
           (insert))

      (->> routines
           (--filter (not (-contains? '("Breakfast" "Dinner") (plist-get it :name))))
           (--map (plist-get it :clock))
           (-sum)
           (org-minutes-to-clocksum-string)
           (format "|\\-- Other||%s|\n")
           (insert))

      (insert "|-|\n")

      (->> work
           (--map (plist-get it :clock))
           (-sum)
           (org-minutes-to-clocksum-string)
           (format "|Work|%s||\n")
           (insert))

      (->> work
           (--filter (-contains? (plist-get it :tags) "meeting"))
           (--map (plist-get it :clock))
           (-sum)
           (org-minutes-to-clocksum-string)
           (format "|\\-- Meetings||%s|\n")
           (insert))

      (->> work
           (--filter (not (-contains? (plist-get it :tags) "meeting")))
           (--map (plist-get it :clock))
           (-sum)
           (org-minutes-to-clocksum-string)
           (format "|\\-- Other||%s|\n")
           (insert))

      (insert "|-|\n")

      (->> others
           (--map (plist-get it :clock))
           (-sum)
           (org-minutes-to-clocksum-string)
           (format "|Other|%s||\n")
           (insert))

      (->> others
           (--filter (-contains? (plist-get it :tags) "side"))
           (--map (plist-get it :clock))
           (-sum)
           (org-minutes-to-clocksum-string)
           (format "|\\-- Side projects||%s|\n")
           (insert))

      (->> others
           (--filter (not (-contains? (plist-get it :tags) "side")))
           (--map (plist-get it :clock))
           (-sum)
           (org-minutes-to-clocksum-string)
           (format "|\\-- Other||%s|\n")
           (insert))

      (insert "|-|\n")
      (insert (format "|Total|%s||\n" total-time))
      (delete-char 1)
      (org-table-align)))
#+end_src

#+RESULTS:
: org-dblock-write:daily-summary

** Scratch/temporary buffers in side windows
Here I define two important functions and their helpers.  The following functions are pretty useful for quick note taking or evaluating elisp. Having these buffers in a side window makes them immune to some window commands which is what I want.

- isamert/display-side-scratch-buffer :: This one opens (or closes if it's open) the *scratch* buffer in a side window, on the right. This is nice for quickly evaluating elisp, taking elisp related notes.
- isamert/display-side-temp-org-buffer :: This one opens (or closes if it's open) the ~temp.org~ file in a in a side window, on the right. This is nice for taking some quick notes, writing some temporary todos etc.

#+begin_src emacs-lisp
  (defun isamert/buffer-visible-p (buffer)
   "Check if given BUFFER is visible or not.  BUFFER is a string representing the buffer name."
    (or (eq buffer (window-buffer (selected-window))) (get-buffer-window buffer)))

  (defun isamert/display-buffer-in-side-window (buffer)
    "Just like `display-buffer-in-side-window` but only takes a BUFFER and rest of the parameters are for my taste."
    (set-window-dedicated-p
     ;; ^ Setting this to nil so that `pop-to-buffer-same-window' calls works in this window
     ;;   otherwise it'll set `window-dedicated-p' to `side' and this will cause `pop-to-buffer-same-window'
     ;;   to open stuff in another window.
     (select-window
      (display-buffer-in-side-window
       buffer
       '((side . right)
         (slot . 0)
         (window-width . 84)
         (window-parameters
          (no-delete-other-windows . t)
          (no-other-window . nil)))))
     nil))

  (defun isamert/remove-window-with-buffer (the-buffer-name)
    "Remove window containing given THE-BUFFER-NAME."
    (mapc (lambda (window)
            (when (string-equal (buffer-name (window-buffer window)) the-buffer-name)
              (delete-window window)))
          (window-list (selected-frame))))

  (defun isamert/toggle-side-buffer-with-file (file-path)
    "Toggle FILE-PATH in a side buffer. The buffer is opened in side window so it can't be accidentaly removed."
    (interactive)
    (let ((fname (file-name-nondirectory file-path)))
    (if (isamert/buffer-visible-p fname)
        (isamert/remove-window-with-buffer fname)
      (isamert/display-buffer-in-side-window
       (save-window-excursion
         (find-file file-path)
         (current-buffer))))))

  (defun isamert/toggle-side-buffer-with-name (buffer-name)
    "Hide/show given BUFFER-NAME in a side window."
    (interactive)
    (if (isamert/buffer-visible-p buffer-name)
        (isamert/remove-window-with-buffer buffer-name)
      (isamert/display-buffer-in-side-window (get-buffer buffer-name))))

  (defun isamert/toggle-side-scratch-buffer ()
    "Toggle the scratch buffer in side window.  The buffer is opened in side window so it can't be accidentaly removed."
    (interactive)
    (isamert/toggle-side-buffer-with-name "*scratch*"))

  (defun isamert/toggle-side-temp-org-buffer ()
    "Toggle `temp.org` in a side buffer for quick note taking.  The buffer is opened in side window so it can't be accidentaly removed."
    (interactive)
    (isamert/toggle-side-buffer-with-file temp-org))

  (defun isamert/toggle-side-bullet-org-buffer ()
    "Toggle `bullet.org` in a side buffer for quick note taking.  The buffer is opened in side window so it can't be accidentaly removed."
    (interactive)
    (isamert/toggle-side-buffer-with-file bullet-org))

  (defun isamert/toggle-side-projects-buffer ()
    "Toggle `projects.org` in a side buffer for quick note taking.  The buffer is opened in side window so it can't be accidentaly removed."
    (interactive)
    (isamert/toggle-side-buffer-with-file projects-org))

  (defun isamert/toggle-side-messages-buffer ()
    "Toggle `projects.org` in a side buffer for quick note taking.  The buffer is opened in side window so it can't be accidentaly removed."
    (interactive)
    (isamert/toggle-side-buffer-with-name "*Messages*"))

  ;; Toggle temproary buffers
  (evil-leader/set-key
    "ts" 'isamert/toggle-side-scratch-buffer
    "to" 'isamert/toggle-side-temp-org-buffer
    "th" 'isamert/toggle-side-bullet-org-buffer
    "tp" 'isamert/toggle-side-projects-buffer
    "tm" 'isamert/toggle-side-messages-buffer
    "tf" 'treemacs)
#+end_src

** org-babel extension functions
#+BEGIN_SRC emacs-lisp
  (defun isamert/org-babel-remove-all-results nil
    (interactive)
    (goto-char 1)
    (let ((total-removed 0))
      (while (org-babel-next-src-block)
        (when (org-babel-remove-result)
          (setq total-removed (+ total-removed 1))))
      (message (format "%d result blocks are removed." total-removed))))
#+END_SRC

** Functions for easy indentation switching
- http://blog.binchen.org/posts/easy-indentation-setup-in-emacs-for-web-development.html

#+BEGIN_SRC emacs-lisp
  (defun isamert/setup-indent-local (n)
    (interactive "nHow many spaces do you want? ")
    (setq-local tab-width n)
    (setq-local c-basic-offset n)
    (setq-local coffee-tab-width n) ; coffeescript
    (setq-local javascript-indent-level n) ; javascript-mode
    (setq-local js-indent-level n) ; js-mode
    (setq-local web-mode-markup-indent-offset n) ; web-mode, html tag in html file
    (setq-local web-mode-css-indent-offset n) ; web-mode, css in html file
    (setq-local web-mode-code-indent-offset n) ; web-mode, js code in html file
    (setq-local css-indent-offset n) ; css-mode
    (setq-local typescript-indent-level n) ; typescript-mode
    (message "OK!"))

  (defun isamert/setup-indent-global (n)
    (interactive "nHow many spaces do you want? ")
    (setq tab-width n)
    (setq c-basic-offset n)
    (setq coffee-tab-width n) ; coffeescript
    (setq javascript-indent-level n) ; javascript-mode
    (setq js-indent-level n) ; js-mode
    (setq web-mode-markup-indent-offset n) ; web-mode, html tag in html file
    (setq web-mode-css-indent-offset n) ; web-mode, css in html file
    (setq web-mode-code-indent-offset n) ; web-mode, js code in html file
    (setq css-indent-offset n) ; css-mode
    (setq typescript-indent-level n) ; typescript-mode
    (message "OK!"))
#+END_SRC

** Current file functionality
Sometimes I just want to delete/rename/move etc. the current file without resorting to dired or any other file manager. Here are some interactive functions to do that.

#+begin_src emacs-lisp
  ;; Slightly modified from:
  ;; http://steve.yegge.googlepages.com/my-dot-emacs-file
  (defun isamert/rename-current-file-name-and-buffer (new-name)
    "Renames both current buffer and file it's visiting to NEW-NAME."
    (interactive "FNew name: ")
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (when (not filename)
        (user-error "Buffer '%s' is not visiting a file!" name))
      (when (get-buffer new-name)
        (user-error "A buffer named '%s' already exists!" new-name))
      (rename-file filename new-name 1)
      (rename-buffer new-name)
      (set-visited-file-name new-name)
      (set-buffer-modified-p nil)))

  ;; Slightly modified version of: http://www.ergoemacs.org/emacs/elisp_delete-current-file.html
  (defun isamert/delete-current-file ()
    "Delete the current file and copy it's content to `kill-ring'."
    (interactive)
    (when (y-or-n-p (format "Do you really want to remove this: \"%s\"?" (buffer-file-name)))
      (kill-new (buffer-string))
      (message "Buffer content copied to kill-ring.")
      (when (and (buffer-file-name) (file-exists-p (buffer-file-name)))
        (delete-file (buffer-file-name))
        (message "Deleted file: 「%s」." (buffer-file-name)))
      (let ((buffer-offer-save nil))
        (set-buffer-modified-p nil)
        (kill-buffer (current-buffer)))))
#+end_src

** xah-open-file-at-cursor
This is better than =find-file-at-point= because it takes line numbers etc. into account.

#+begin_src emacs-lisp
  (defun xah-open-file-at-cursor ()
    "Open the file path under cursor.
  If there is text selection, uses the text selection for path.
  If the path starts with “http://”, open the URL in browser.
  Input path can be {relative, full path, URL}.
  Path may have a trailing “:‹n›” that indicates line number, or “:‹n›:‹m›” with line and column number. If so, jump to that line number.
  If path does not have a file extension, automatically try with “.el” for elisp files.
  This command is similar to `find-file-at-point' but without prompting for confirmation.

  URL `http://ergoemacs.org/emacs/emacs_open_file_path_fast.html'
  Version 2020-10-17"
    (interactive)
    (let* (
           ($inputStr
            (if (use-region-p)
                (buffer-substring-no-properties (region-beginning) (region-end))
              (let ($p0 $p1 $p2
                        ;; chars that are likely to be delimiters of file path or url, e.g. whitespace, comma. The colon is a problem. cuz it's in url, but not in file name. Don't want to use just space as delimiter because path or url are often in brackets or quotes as in markdown or html
                        ($pathStops "^  \t\n\"`'‘’“”|[]{}「」<>〔〕〈〉《》【】〖〗«»‹›❮❯❬❭〘〙·。\\"))
                (setq $p0 (point))
                (skip-chars-backward $pathStops)
                (setq $p1 (point))
                (goto-char $p0)
                (skip-chars-forward $pathStops)
                (setq $p2 (point))
                (goto-char $p0)
                (buffer-substring-no-properties $p1 $p2))))
           ($path
            (replace-regexp-in-string
             "^file:///" "/"
             (replace-regexp-in-string
              ":\\'" "" $inputStr))))
      (if (string-match-p "\\`https?://" $path)
          (if (fboundp 'xahsite-url-to-filepath)
              (let (($x (xahsite-url-to-filepath $path)))
                (if (string-match "^http" $x )
                    (browse-url $x)
                  (find-file $x)))
            (progn (browse-url $path)))
        (progn ; not starting “http://”
          (if (string-match "#" $path )
              (let (
                    ( $fpath (substring $path 0 (match-beginning 0)))
                    ( $fractPart (substring $path (1+ (match-beginning 0)))))
                (if (file-exists-p $fpath)
                    (progn
                      (find-file $fpath)
                      (goto-char 1)
                      (search-forward $fractPart ))
                  (when (y-or-n-p (format "file no exist: 「%s」. Create?" $fpath))
                    (find-file $fpath))))
            (if (string-match "^\\`\\(.+?\\):\\([0-9]+\\)\\(:[0-9]+\\)?\\'" $path)
                (let (
                      ($fpath (match-string 1 $path))
                      ($line-num (string-to-number (match-string 2 $path))))
                  (if (file-exists-p $fpath)
                      (progn
                        (find-file $fpath)
                        (goto-char 1)
                        (forward-line (1- $line-num)))
                    (when (y-or-n-p (format "file no exist: 「%s」. Create?" $fpath))
                      (find-file $fpath))))
              (if (file-exists-p $path)
                  (progn ; open f.ts instead of f.js
                    (let (($ext (file-name-extension $path))
                          ($fnamecore (file-name-sans-extension $path)))
                      (if (and (string-equal $ext "js")
                               (file-exists-p (concat $fnamecore ".ts")))
                          (find-file (concat $fnamecore ".ts"))
                        (find-file $path))))
                (if (file-exists-p (concat $path ".el"))
                    (find-file (concat $path ".el"))
                  (when (y-or-n-p (format "file no exist: 「%s」. Create?" $path))
                    (find-file $path ))))))))))

(define-key evil-normal-state-map (kbd "gf") 'xah-open-file-at-cursor)
#+end_src

** xah-{escape,unescape}-quotes
#+begin_src emacs-lisp
  (defun xah-escape-quotes (@begin @end)
    "Replace 「\"」 by 「\\\"」 in current line or text selection.
    See also: `xah-unescape-quotes'

    URL `http://ergoemacs.org/emacs/elisp_escape_quotes.html'
    Version 2017-01-11"
    (interactive
     (if (use-region-p)
         (list (region-beginning) (region-end))
       (list (line-beginning-position) (line-end-position))))
    (save-excursion
      (save-restriction
        (narrow-to-region @begin @end)
        (goto-char (point-min))
        (while (search-forward "\"" nil t)
          (replace-match "\\\"" "FIXEDCASE" "LITERAL")))))

  (defun xah-unescape-quotes (@begin @end)
    "Replace  「\\\"」 by 「\"」 in current line or text selection.
  See also: `xah-escape-quotes'

  URL `http://ergoemacs.org/emacs/elisp_escape_quotes.html'
  Version 2017-01-11"
    (interactive
     (if (use-region-p)
         (list (region-beginning) (region-end))
       (list (line-beginning-position) (line-end-position))))
    (save-excursion
      (save-restriction
        (narrow-to-region @begin @end)
        (goto-char (point-min))
        (while (search-forward "\\\"" nil t)
          (replace-match "\"" "FIXEDCASE" "LITERAL")))))
#+end_src

** eksisozluk gundem
#+begin_src emacs-lisp
  (defun isamert/eksi-gundem-sirali ()
    "Eksi gundemini entry sayisina gore sirala ve `completing-read' yap."
    (interactive)
    (with-completing-read-exact-order
     (let ((results (->> (shell-command-to-string "curl --silent https://eksisozluk.com/basliklar/gundem | grep '?a=popular' | sed -E 's/[ ]*href=\"(.*)\">(.*) <small>(.*)<\\/small>(.*)/(\\3) \\2|||\\1/' | sort -V -r | uniq")
                         (s-split "\n")
                         (--map (s-split "|||" it))
                         (--map `(,(car it) . ,(cadr it))))))
       (->> results
            (completing-read "Baslik: ")
            (funcall (-flip 'assoc-string) results)
            (cdr)
            (format "https://eksisozluk.com/%s")
            (browse-url)))))
#+end_src
** insert uuid
#+begin_src emacs-lisp
  (defun isamert/uuid ()
    "Generate a UUID."
    (s-trim (shell-command-to-string "uuidgen")))

  (defun isamert/insert-uuid ()
    "Insert UUID."
    (interactive)
    (insert (isamert/uuid)))
#+end_src

** isamert/start-shell-command
#+begin_src emacs-lisp :lexical yes
  (defvar-local isamert/shell-command-mode-command nil
    "Current shell command that belongs to the buffer.")

  (define-minor-mode isamert/shell-command-mode
    "Shell command mode."
    :lighter "iscm"
    :keymap (make-sparse-keymap))

  (evil-define-key 'normal isamert/shell-command-mode-map
    (kbd "gr") #'isamert/shell-command-mode-rerun-command)

  (defun isamert/shell-command-mode-rerun-command ()
    "Re-run the shell command."
    (interactive)
    (apply #'isamert/shell-command isamert/shell-command-mode-command))

  (cl-defun isamert/shell-command
      (&key
       command
       (switch t)
       (buffer-name (concat "*" command "*"))
       (on-start (lambda ()))
       (on-finish (lambda ()))
       (on-fail (lambda ())))
    "Run given shell COMMAND and redirect output to given BUFFER-NAME.
  This is a wrapper around `start-process-shell-command' that adds
  support for ANSI term colors and some syntactic convenience.

  When called interactively, asks for a command to run (with eshell
  completion)."
    (interactive
     (let ((eshell-non-interactive-p t)
           (command))
       (minibuffer-with-setup-hook (lambda ()
                                     (eshell-mode)
                                     (eshell-command-mode +1))
         (setq command (read-from-minibuffer "Shell command: "))
         (if (eshell-using-module 'eshell-hist)
             (eshell-add-input-to-history command))
         (list
          :command command
          :on-finish (lambda () (message ">> \"%s\" finished successfully." command))
          :on-fail (lambda () (message ">> \"%s\" failed." command))))))
    (let* ((proc (start-process-shell-command command buffer-name command)))
      (set-process-sentinel
       proc
       (lambda (p e)
         (with-current-buffer buffer-name
           (read-only-mode -1)
           (undo-tree-mode t))
         (if (= 0 (process-exit-status p))
             (funcall on-finish)
           (funcall on-fail))))
      (set-process-filter
       proc
       (lambda (proc str)
         (with-current-buffer buffer-name
           (let ((inhibit-read-only t))
             (goto-char (point-max))
             (insert (ansi-color-apply str))))))
      (with-current-buffer buffer-name
        (read-only-mode)
        (font-lock-mode)
        (isamert/shell-command-mode 1)
        (evil-normal-state)
        (setq-local
         isamert/shell-command-mode-command
         (list
          :command command
          :buffer-name buffer-name
          :on-start on-start
          :on-finish on-finish
          :on-fail on-fail))
        (funcall on-start))
      (when switch
        (switch-to-buffer buffer-name))))
#+end_src

** Copy current/buffers filename into clipboard
#+begin_src emacs-lisp
  (defun isamert/copy-file-name-to-clipboard (&optional uri)
    "Copy the current buffer file name to the clipboard.
  If the URI is non-nil, then add file:// in front of the
  file-path."
    (interactive "P")
    (let* ((fname (if (equal major-mode 'dired-mode)
                         default-directory
                       (buffer-file-name)))
           (filename (if (and fname uri)
                         (concat "file://" fname)
                       fname)))
      (if filename
          (progn
            (kill-new filename)
            (message ">> Copied buffer file name '%s' to the clipboard." filename))
        (user-error ">> Failed to copy"))))
#+end_src
** Password manager
#+begin_src emacs-lisp
  ;; TODO Better matching algorithm Check if full string matches any,
  ;; then check if host matches. Return full string match only if it
  ;; exists. Also check if toplevel domain matches, if it does not match
  ;; fully

  (defun isamert/find-password-for (url)
    "Return matching accounts for given URL."
    (interactive)
    (let ((urlobj (url-generic-parse-url url)))
      (setq url (url-host urlobj))
      (when-let ((port (url-port-if-non-default urlobj)))
        (setq url (format "%s:%s" url port))))
    (with-current-buffer "passwords.org"
      (let* ((candidates
              (seq-filter
               #'identity
               (org-map-entries
                (lambda  ()
                  (let ((link "")
                        (match (org-entry-get nil "MATCH"))
                        (header-link (save-excursion
                                       (forward-char 5)
                                       (org-element-context)))
                        (title (org-entry-get nil "ITEM")))
                    (when (eq (org-element-type header-link) 'link)
                      (setq link (org-element-property :raw-link header-link))
                      (save-excursion
                        (setq title
                              (buffer-substring-no-properties
                               (org-element-property :contents-begin header-link)
                               (org-element-property :contents-end header-link)))))
                    (when (or (ignore-errors (s-match match url))
                              (s-contains? url link))
                      `(("ITEM" . ,title) ,@(org-entry-properties)))))))))
        (-flatten-n
         1
         (-map (lambda (info)
                 (let ((unames (s-split " " (cdr (assoc-string "USERNAME" info))))
                       (pwds (s-split " " (cdr (assoc-string "PASSWORD" info)))))
                   (-zip  (--map (format "%s - %s" (cdr (assoc-string "ITEM" info)) it) unames)
                          (--map (list :info info :acc it)
                                 (-zip unames pwds)))))
               candidates)))))

  (defun isamert/qutebrowser-pass (url fifo)
    (let* ((candidates (isamert/find-password-for url))
           (result (plist-get (alist-get (isamert/dmenu "Select account: " candidates) candidates nil nil #'equal) :acc))
           (username (car result))
           (password (cdr result)))
      (when (and username password)
        (write-region "mode-enter insert\n" nil fifo 'append)
        (write-region (format "fake-key %s\n" username) nil fifo 'append)
        (write-region "fake-key <Tab>\n" nil fifo 'append)
        (write-region (format "fake-key %s\n" password) nil fifo 'append))))
#+end_src
** Kubernetes
My main use case is drop into a shell of a pod. The code below makes it quite easy. Use ~isamert/kube-select-pod~ to select a pod and do some actions on it.

#+begin_src emacs-lisp
  (defun isamert/kube--current-context ()
    (s-trim (shell-command-to-string "kubectl config current-context")))

  (defun isamert/kube-use-context ()
    (isamert/output-select
     :cmd "kubectl config get-contexts --output=name"
     :drop 1
     :keep-order t
     :prompt (format "Select context (current=%s): " (isamert/kube--current-context))
     :do (shell-command-to-string (format "kubectl config use-context '%s'" it))))

  (defun isamert/kube-select-pod (&optional switch-context)
    "Select a pod and act on it.
  If SWITCH-CONTEXT is non nil, switch to another context before
  selecting a pod."
    (interactive "P")
    (when switch-context
      (isamert/kube-use-context))
    (isamert/output-select
     :cmd "kubectl get pods --all-namespaces"
     :drop 1
     :prompt (format "Select a pod from '%s': " (isamert/kube--current-context))
     :keep-order t
     :do (let ((info (s-split " " it t)))
           (isamert/kube-pod--act (list :name (nth 1 info) :namespace (nth 0 info))))))

  (defun isamert/kube-pod--act (pod)
    (with-completing-read-exact-order
     (let ((namespace (plist-get pod :namespace))
           (name (plist-get pod :name)))
       (pcase (completing-read (format "Act on '%s'" name) '("Exec into default container" "Exec into container" "Logs" "Remove"))
         ("Exec into default container"
          (with-current-buffer (vterm (format "pod: %s" name))
            (vterm-insert (format "kubectl exec --namespace='%s' -i -t '%s' -- bash"
                                  namespace
                                  name))))
         ("Exec into container"
          (let ((container (isamert/kube-pod--select-container pod)))
            (with-current-buffer (vterm (format "pod: %s" name))
              (vterm-insert (format "kubectl exec --namespace='%s' --container='%s' -i -t '%s' -- bash"
                                    namespace
                                    container
                                    name)))))
         ("Logs" (user-error "Not implemented"))
         ("Remove" (user-error "Not implemented"))))))

  (defun isamert/kube-pod--select-container (pod)
    (isamert/output-select
     :cmd (format
           "kubectl get pods '%s' --namespace='%s' -o jsonpath='{.spec.containers[*].name}'"
           (plist-get pod :name)
           (plist-get pod :namespace))
     :prompt (format "Container for %s: " (plist-get pod :name))
     :split " "))
#+end_src
** Kafka
#+begin_src emacs-lisp
  (defun isamert/kafka-describe-consumer-group ()
    (interactive)
    ;; `isamert/select-kafka-consumers' is a private function that
    ;; returns a kafka server list
    (let ((servers (isamert/select-kafka-consumers)))
      (isamert/output-select
       :cmd (format "kafka-consumer-groups.sh --list --bootstrap-server %s" servers)
       :prompt "Select a consumer group: "
       :do (isamert/output-to-tabulated-list
            (shell-command-to-string
             (format "kafka-consumer-groups.sh --describe --group %s --bootstrap-server %s" it servers))
            :buffer (get-buffer-create "*kafka-describe:%s*" it)))))
#+end_src
** Global snippets
The code below let's you select your yankpad snippets outside of the Emacs using ~dmenu~.

#+begin_src emacs-lisp
  (define-derived-mode desktop-snippets-mode nil "desktop-snippets-mode"
    "A dummy mode for expanding desktop snippets. Add
    desktop-specific (non-Emacs) snippets under
    `desktop-snippets-mode' header in the yankpad file.")

  (defun isamert/desktop-yankpad (&optional select-category)
    "Select a snippet from yankpad snippets using `isamert/dmenu'.
  If SELECT-CATEGORY is non-nil, then prompts for a category first
  and then let's you select a snippet.  Put the snippet into the
  clipboard.

  This command is meant to be used externally (from outside of
  Emacs)."
    (interactive)
    (let ((text
           (with-temp-buffer
             (desktop-snippets-mode)
             ;; Activate yas snippet on the temp buffer
             (let ((yas-dont-activate-functions '()))
               (yas-minor-mode-on))
             (when select-category
               ;; Same as `yankpad-set-category' but uses `isamert/dmenu' instead of
               ;; `completing-read'
               (let ((categories (yankpad--categories)))
                 (setq yankpad-category (isamert/dmenu "Category: " categories))
                 (run-hooks 'yankpad-switched-category-hook)))
             (unless yankpad-category
               (yankpad-local-category-to-major-mode))
             (let* ((snippets (yankpad-active-snippets))
                    (snippet-name (isamert/dmenu "Snippet: " snippets)))
               (if-let ((snippet (assoc snippet-name snippets)))
                   (yankpad--run-snippet snippet)
                 ;; TODO Show this message as a notification
                 (message (concat "No snippet named " snippet-name))))
             (buffer-substring-no-properties (point-min) (point-max)))))
      (kill-new text)))
#+end_src

* TY (work stuff)
Company/work related stuff.

#+begin_src emacs-lisp
  (defun company/is-company ()
    "Return if current computer is Well computer or not."
    (string= (treemacs-workspace->name (treemacs-current-workspace)) "seller-ads"))
#+end_src

** Packages
#+begin_src emacs-lisp
  (when (company/is-company)
    ;; Enable org jira/confluence exporter (org-confluence-export-as-confluence)
    (require 'ox-confluence)
    (defalias 'org-export-as-jira-confluence-markup 'org-confluence-export-as-confluence))
#+end_src
** Automatically insert issue numbers into commit messages
#+begin_src emacs-lisp
  ;; TODO: maybe find all changed functions/files and append them into
  ;; the buffer as default message so that I can simply construct my
  ;; commit message based on those
  (defun company/git-commit-message-setup ()
    "Insert the JIRA ticket number in front of the commit message.
  If it already exists (like for example when you use --amend),
  does not do anything."
    (when-let (ticket-no (s-match "\\w+-[0-9]+" (magit-get-current-branch)))
      (let* ((issue-prefix (format "%s - " (car ticket-no)))
             (issue-prefix-exists (save-excursion
                                    (goto-char (point-min))
                                    (search-forward issue-prefix nil t))))
        (when (not issue-prefix-exists)
          (goto-char (point-min))
          (insert issue-prefix)))))

  (when (company/is-company)
    (add-hook 'git-commit-setup-hook 'company/git-commit-message-setup))
#+end_src

** Misc bindings
#+begin_src emacs-lisp
  (defun isamert/toggle-side-trendyol-org-buffer ()
    "Toggle `well.org` in a side buffer for quick note taking.  The buffer is opened in side window so it can't be accidentaly removed."
    (interactive)
    (isamert/toggle-side-buffer-with-file "~/Documents/notes/trendyol.org"))

  (evil-leader/set-key
    "tw" 'isamert/toggle-side-trendyol-org-buffer)
#+end_src

** Token management
#+begin_src emacs-lisp
  ;; (defvar ty/stage-token nil)

  (defun ty/stage-token ()
    (or
     ty/stage-token
     (ty/set-stage-token)))

  (defun ty/set-stage-token ()
    (interactive)
    (let ((token (read-string "Token: ")))
      (setq ty/stage-token token)
      token))

  (defun ty/copy-kill-token ()
    (interactive)
    (kill-new ty/stage-token))
#+end_src

** Utilities
#+begin_src emacs-lisp
  (evil-leader/set-key "jt" #'ty/jump-to-test-file)

  (cl-defun isamert/toggle-config-in-file (&key file val1 val2)
    (let ((fpath (expand-file-name file))
          (e-val1 (s-replace "/" "\\/" val1))
          (e-val2 (s-replace "/" "\\/" val2)))
      (if (eq 0 (shell-command (format "grep -E '%s' '%s'" e-val1 fpath)))
          (progn
            (shell-command (format "sed -i 's/%s/%s/' '%s'" e-val1 e-val2 fpath))
            (message ">> Switched to %s" val2))
        (progn
          (shell-command (format "sed -i 's/%s/%s/' '%s'" e-val2 e-val1 fpath))
          (message ">> Switched to %s" val1)))))

  (defun ty/toggle-editor-backend-url ()
    "Toggle between local/stage editor-bff instace."
    (interactive)
    (isamert/toggle-config-in-file
     :file "~/Workspace/projects/editor/src/config.ts"
     :val1 "https://stage-discovery-sellerads-editorbff-service.earth.trendyol.com"
     :val2 "http://localhost:3031"))

  (defun ty/toggle-ebff-advert-statistics-url ()
    "Toggle between local/stage advert-statistics instace."
    (interactive)
    (isamert/toggle-config-in-file
     :file "~/Workspace/projects/editor-bff/config/stage.yaml"
     :val1 "https://stageselleradsadvertstatisticapi.trendyol.com"
     :val2 "http://localhost:8086/"))

  (defun ty/open-test-code-coverage-report (run-test-before)
    "Open code coverage report for current project.
  With RUN-TEST-BEFORE is non-nil, then run tests before and then
  open coverage.  You can simply call \"gf\" or
  `xah-open-file-at-cursor' to navigate to a file shown on the
  output."
    (interactive "P")
    (let ((default-directory (isamert/current-project-root))
          (cov-file (format "file://%s/coverage/lcov-report/index.html" (isamert/current-project-root))))
      (if run-test-before
          (isamert/shell-command
           :command "yarn test:cov --colors"
           :buffer-name (format "%s-test-cov" persp-last-persp-name)
           :on-finish (lambda () (browse-url-default-browser cov-file))
           :on-fail (lambda () (user-error ">> Tests are failed!")))
        (browse-url-default-browser cov-file))))

  (defun ty/run-test-code-coverage-report ()
    "Run all tests and then open coverage."
    (interactive)
    (ty/open-test-code-coverage-report t))

  (defun ty/find-test-file ()
    (let ((test-file
           (concat
            (file-name-directory buffer-file-name)
            "__tests__/"
            (s-replace ".ts" ".spec.ts" (file-name-nondirectory buffer-file-name)))))
      (if (file-exists-p test-file)
          test-file
        buffer-file-name)))

  (defun ty/jump-to-test-file ()
    "Jump to test file of current file."
    (interactive)
    (find-file (ty/find-test-file)))

  (defun ty/run-current-test-file (run-only-focused-test)
    (interactive "P")
    (let* ((default-directory (isamert/current-project-root))
           (test-file (ty/find-test-file))
           (current-test-name
            (ignore-errors
              (save-excursion
                (end-of-line)
                (re-search-backward "it(['\"]" nil t)
                (nth 1 (s-match "it(['\"]\\(.*\\)['\"]," (substring-no-properties (thing-at-point 'line))))))))
      (isamert/shell-command
       :command (format "yarn test --colors %s %s"
                        (file-relative-name test-file  (isamert/current-project-root))
                        (if (and run-only-focused-test current-test-name)
                            (format "-t \"%s\"" current-test-name)
                          "")))))

  (defun ty/run-current-test-only ()
    "Run currently focused test only."
    (interactive)
    (ty/run-current-test-file t))

  (defun ty/get-current-kafka-config ()
    "Read kafka configuration from projects stage.yaml."
    (let* ((kafka-config (->>
                          (with-temp-buffer
                            (insert-file-contents (concat (isamert/current-project-root) "/config/stage.yaml"))
                            (buffer-string))
                          (yaml-parse-string)
                          (gethash 'default)
                          (gethash 'kafka)))
           (kafka-hosts (or (gethash 'hosts kafka-config)
                            (gethash 'uri kafka-config)))
           (kafka-items (->> kafka-config
                             (hash-table-keys)
                             (--remove (-contains? '(hosts uri) it))))
           (kafka-topics (or (ignore-errors
                               (hash-table-values (gethash 'topics kafka-config)))
                             (--map (->> kafka-config
                                         (gethash it)
                                         (gethash 'topic))
                                    kafka-items))))
      (list
       :hosts kafka-hosts
       :topics kafka-topics)))
#+end_src
** Projects/services
#+begin_src emacs-lisp
  (prodigy-define-service
    :name "Seller-Ads/Editor"
    :command "yarn"
    :args '("start")
    :cwd "~/Workspace/projects/editor/"
    :tags '(work ui)
    :stop-signal 'sigkill
    :kill-process-buffer-on-stop t)

  (prodigy-define-service
    :name "Seller-Ads/Editor BFF"
    :command "yarn"
    :args '("start")
    :cwd "~/Workspace/projects/editor-bff/"
    :tags '(work bff)
    :stop-signal 'sigkill
    :kill-process-buffer-on-stop t)

  (prodigy-define-service
    :name "Seller-Ads/Advert Api"
    :command "yarn"
    :args '("start:dev")
    :cwd "~/Workspace/projects/advert-api/"
    :tags '(work api)
    :stop-signal 'sigkill
    :kill-process-buffer-on-stop t)

  (prodigy-define-service
    :name "Seller-Ads/SP/Advert Consumer"
    :command "yarn"
    :args '("start:dev")
    :cwd "~/Workspace/projects/consumers/sponsored-product-advert-update-consumer/"
    :tags '(work consumer)
    :stop-signal 'sigkill
    :kill-process-buffer-on-stop t)

  (prodigy-define-service
    :name "Seller-Ads/SP/DS Consumer"
    :command "yarn"
    :args '("start:dev")
    :cwd "~/Workspace/projects/consumers/sponsored-product-data-science-consumer/"
    :tags '(work consumer)
    :stop-signal 'sigkill
    :kill-process-buffer-on-stop t)

  (prodigy-define-service
    :name "Seller-Ads/SP/Content Invalidation Consumer"
    :command "yarn"
    :args '("start:dev")
    :cwd "~/Workspace/projects/consumers/sponsored-product-content-invalidation-consumer/"
    :tags '(work consumer)
    :stop-signal 'sigkill
    :kill-process-buffer-on-stop t)
#+end_src

;; Local Variables:
;; eval: (add-hook 'after-save-hook (lambda () (if (y-or-n-p "Tangle?") (org-babel-tangle))) nil t)
;; End:
