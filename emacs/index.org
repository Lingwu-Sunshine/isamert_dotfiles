#+TITLE: Emacs configuration file
#+AUTHOR: İsa Mert Gürbüz
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes :noweb yes
#+PROPERTY: header-args:emacs-lisp :lexical yes
#+STARTUP: overview
#+OPTIONS: toc:3

* Introduction
This is my emacs configuration. My main focus is sanity. I'm a person who get frustrated pretty easily. So instead of optimizing the time spent on doing things, I try to find ways of doing things that does not make me frustrated. Most of the time you get speed boost as a byproduct.

#+begin_src emacs-lisp
  ;;; index.el --- isamert's configuration -*- lexical-binding: t; -*-

  ;;; Commentary:

  ;; isamert's configuration

  ;;; Code:
#+end_src

* Usage notes
** General notes and conventions
- This configuration is meant to be used with /emacs daemon/, so I don't really care about the startup time etc.
- I try to split package configurations into multiple org src blocks and unify them using ~noweb~ references under a single =use-package= directive.
- I try to put things in way that easily copyable from the configuration. An example would be using multiple =(setq ...)= lines instead of having one =(setq ... ...)= call and setting multiple variables in one go.
- I make use of =use-package= features quite minimally. See [[id:3d974e67-11fc-4f07-8cd4-ec6fd63152c4][here]] for more information that. This is generally related with the item above and future-proofing.
- I use =verbatim text= and ~code text~ completely randomly.
- I try to prefer built-in packages or packages that enhances built-in ones where possible. I'm also trying to simplify my configuration, so another goal is to reduce the package number. Although I intend to keep packages that enhances the overall experience with no special configuration (just install and forget type of packages).

** Keybinding conventions
- After leader
  - =e= :: is reserved for independent programs, that is not related to editing/programming. For example, "ec" opens calendar, "ee" opens elfeed, "er..." controls the radio.
  - =t= :: is reserved for toggling stuff. Toggle the terminal, toggle a frequently accessed buffer etc.
  - =h= :: is reserved for any menu with fuzzy selection that does not fit anywhere else.
  - =g= :: is for git related functionality.
  - =p= :: is for project related functionality.
  - =/= :: is for search/translate related functionality. (Generally external programs)
  - =b= :: is for buffers.
  - =w= :: is for windows. I also use =C-w= for this, which is default prefix for window-related functions in vim.
  - =o= :: is for org-mode/outline mode.
** Updating packages
Currently, I don't use an external package manager, =package.el= satisfies my needs. Here is how I do the updates:
- =package-refresh-contents=
- =list-packages=
- Hit =U= to mark all packages that needs updating.
- Hit =X= to update all those packages.

I do this quite infrequently. If everything is working fine as it is, I tend to not update anything.

* early-init.el
#+begin_src emacs-lisp :tangle ~/.emacs.d/early-init.el
  ;; Some stuff are taken from:
  ;; https://github.com/emacs-lsp/lsp-mode#performance

  (setq package-enable-at-startup nil)
  (setq-default lexical-binding 'lv)
  (setq native-comp-async-report-warnings-errors nil)

  (setq gc-cons-threshold 3000000)
  ;; ^ Set gc threshold to ~30MB
  (setq read-process-output-max (* 1024 1024))
  ;; ^ Better than default
  (setq confirm-kill-processes nil)
  ;; ^ When exitting, kill processes withouh asking
  (setq ring-bell-function 'ignore)
  ;; ^ This completely disables alarms
  (setq column-number-mode t)
  ;; ^ Show column number
  (setq create-lockfiles nil)
  ;; ^ These just clutter the filesystem
  (setq dabbrev-case-fold-search nil)
  ;; ^ Expansions are done respecting the case (Ctrl-n and Ctrl-p was
  ;; not behaving the way I wanted before this in evil mode)
  (setq vc-follow-symlinks t)
  ;; ^ Don't ask about following symlinks
  ;; Ask y/n instead of yes/no
  (fset 'yes-or-no-p 'y-or-n-p)

  ;; Visuals
  (menu-bar-mode 0)                ;; Disable menubar
  (tool-bar-mode 0)                ;; Disable toolbar
  (blink-cursor-mode 0)            ;; Disable blinking cursor
  (scroll-bar-mode -1)             ;; Disable scrollbars
  (setq inhibit-startup-message t) ;; Close startup screen
  (setq frame-resize-pixelwise t)  ;; Fix gap issues with tiling WMs
  (defconst im-init-file (expand-file-name "~/.emacs.d/scratch.el"))
  (setq initial-buffer-choice im-init-file)
  (add-to-list 'default-frame-alist '(undecorated . t))
#+end_src
* Preparation
** straight.el and use-package

#+begin_src emacs-lisp
  ;; Install straight.el
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" (or (ignore-errors straight-base-dir) user-emacs-directory)))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  ;; Install use-package
  (straight-use-package 'use-package)

  (use-package straight
    :custom (straight-use-package-by-default t))
#+END_SRC

I tend to not use the =use-package= goodies while configuring my packages, meaning that I don't use =:hook=, =:bind= etc. as they have relatively simpler alternatives in Emacs and using =use-package= alternatives of these makes copy/pasting harder. Here are the keywords that I use the most:
- =:init= :: This gets called before the package gets initialized.
- =:config= :: This gets called after the package is initialized.
- =:after= :: This makes the current definition to wait the loading of listed packages, like =:after (evil org)= makes it wait for the =evil= and =org= packages to be loaded.
- =:if= :: Loads the package conditionally, like =:if (eq system-type 'darwin)=.

*** Hiding mode indicators from modeline
~diminish.el~ provides a way to hide mode indicators from mode line. Either pass ~:diminish t~ to use-package while installing or just call ~(diminish 'x-mode)~.

#+BEGIN_SRC emacs-lisp
  (use-package diminish)
#+END_SRC

Currently I use [[mini-modeline]] as my modeline and it already hides minor mode indicators from the modeline. So this package is not needed but better have it as I might change my modeline in the future.

** Essential packages
I use =s.el= and =dash.el= extensively. They already come as a dependency with other packages but I may use them before loading any package, so:

#+begin_src emacs-lisp
  (use-package dash)
  (use-package s)

  ;; For parsing yaml.
  (use-package yaml)

  ;; Following provides defmemoize macro. Use (memoize-restore
  ;; 'fn-name) to restore the original function.
  (use-package memoize)
#+end_src

** Variables and functions
Some basic variable and function definitions that will be used in configuration.

*** General utilities
#+BEGIN_SRC emacs-lisp
  (defun im-mkdir-if-not (dir)
    "Create the DIR if it does not exist return DIR."
    (unless (file-exists-p dir)
      (make-directory dir))
    dir)

  (defun im-font-exists-p (font)
    "Check if FONT exists."
    (x-list-fonts font))

  (defun im-assoc-regexp (key list &optional fn)
    "Like `assoc` but uses `string-match (car pair) KEY` for
  comparasion and returns all the matching pairs. FN is applied to
  the keys before matching, if present."
    (seq-filter
     (lambda (pair)
       (when (string-match-p (if fn (funcall fn (car pair)) (car pair)) key)
         pair))
     list))

  (defun im-region-or (what)
    "Returns currently selected string or WHAT-at-point string. WHAT
  can be 'symbol 'word or a function that returns string etc."
    (if (use-region-p)
        (buffer-substring-no-properties (region-beginning) (region-end))
      (if (functionp what)
          (funcall what)
        (thing-at-point what t))))

  (defun im-inner-back-quote-at-point ()
    "Return text inside the back quotes at point."
    (let ((bounds (evil-inner-back-quote)))
      (buffer-substring-no-properties
       (nth 0 bounds)
       (nth 1 bounds))))

  (defmacro with-completing-read-exact-order (&rest body)
    "Disable any kind of sorting in completing read."
    `(let ((selectrum-should-sort nil)
           (vertico-sort-function nil))
       ,@body))

  (defun im-shell-command-to-string (cmd)
    "Like `shell-command-to-string' but only stdout is returned."
    (string-trim
     (with-output-to-string
       (with-current-buffer standard-output
         (process-file
          shell-file-name nil '(t nil)  nil shell-command-switch
          cmd)))))

  (defun im-serialize-into-file (file data)
    (with-temp-file (expand-file-name file)
      (prin1 data (current-buffer))))

  (defun im-deserialize-from-file (file)
    (let ((fpath (expand-file-name file)))
      (when (and (file-exists-p fpath))
        (with-temp-buffer
          (insert-file-contents fpath)
          (goto-char (point-min))
          (read (current-buffer))))))

  ;; TODO Add a way to invalidate the file after given date
  (defmacro defmemoizefile (name arglist file &rest body)
    "Like a normal memoize function but persist the memoize cache to
  a file so that when Emacs is opened freshly, it'll continue using
  the memoize cache."
    (declare (indent 3) (doc-string 4))
    (let ((origfn (intern (concat (symbol-name name) "---defmemoizefile-origfn")))
          (memoizemap (intern (concat (symbol-name name) "---defmemoizefile-memoizemap"))))
      `(progn
         (setq ,memoizemap (make-hash-table :test 'equal))
         (when (file-exists-p (expand-file-name ,file))
           (setq ,memoizemap (im-deserialize-from-file ,file)))

         (defun ,origfn ,arglist
           ,@body)

         (defun ,name (&rest ___args)
           (if-let ((memoizedresult (gethash ___args ,memoizemap)))
               memoizedresult
             (let ((___result (apply #',origfn ___args)))
               (map-put! ,memoizemap ___args ___result)
               (im-serialize-into-file ,file ,memoizemap)
               ___result))))))

  (defun im-select-window-with-buffer (buffer-name)
    "Select the first visible window that matches given BUFFER-NAME."
    (declare (indent 1))
    (--first
     (-as-> (window-buffer it) buffer
            (buffer-name buffer)
            (when (string-match buffer-name buffer)
              (select-window it)))
     (window-list)))

  (defmacro im-with-visible-buffer (buffer-name &rest body)
    "Evaluate BODY within the BUFFER-NAME that is currently visible."
    `(with-selected-window (selected-window)
       (when (im-select-window-with-buffer ,buffer-name)
         ,@body)))

  (defun im-sync-async-command-to-string (command &rest args)
    "Run async command and wait until it's finished. This may seem stupid but I had to use it."
    (with-temp-buffer
      (let ((process (apply 'start-process `("sync-async-proc" ,(current-buffer) ,command ,@args))))
        (while (process-live-p process)
          (sit-for 0.1))
        (buffer-string))))

  (defmacro let-plist (plist &rest form)
    "Like `let-alist' but for plists."
    (declare (indent 1))
    `(let-alist (transient-plist-to-alist ,plist)
       ,@form))

  (defun im-mimetype (path)
    "Return mimetype of given file at PATH."
    (string-trim (shell-command-to-string (format "file --brief --mime-type '%s'" path))))

  (defun im-to-keyword (it)
    "Convert given string or symbol to a :keyword."
    (thread-last
      (cond
       ((stringp it) it)
       ((symbolp it) (symbol-name it))
       (t (error "Trying to convert %s to symbol" it)))
      (string-remove-prefix ":")
      (concat ":")
      (downcase)
      (intern)))

  (defun im-alist-to-plist (alist)
    "Convert association list ALIST into the equivalent property-list form.
  The plist is returned.  This converts from

  \((a . 1) (b . 2) (c . 3))

  into

  \(:a 1 :b 2 :c 3)

  The original alist is not modified.

  This function is taken from `mm-decode.el' and modified."
    (let (plist)
      (while alist
        (let ((el (car alist)))
          (setq plist (cons (cdr el) (cons (im-to-keyword (car el)) plist))))
        (setq alist (cdr alist)))
      (nreverse plist)))

  (defmacro λ-interactive (&rest body)
    "Useful for defining keybindings."
    `(lambda () (interactive) ,@body))

  (defun im-kill (x &optional replace)
    (kill-new x replace)
    x)
#+end_src

*** Elisp utils
#+begin_src emacs-lisp
  (defmacro im-tap (form)
    `(let ((result ,form))
       (message "[im-tap :: %s] → %s" ,(prin1-to-string form) result)
       result))

  (defmacro im-append! (lst item)
    "Append ITEM to end of the LST.
  Modifies LST. Only meant to be used in configuration."
    `(setq ,lst (append ,lst (list ,item))))
#+end_src
*** Clipboard functions
#+begin_src emacs-lisp
  (defun im-clipboard-command ()
    "Get clipboard command for current system.
        The returned command directly puts the image data into stdout."
    (cond
     ((locate-file "xclip" exec-path) "xclip -selection clipboard -target image/png -out")
     ((locate-file "pngpaste" exec-path) "pngpaste -")))

  (defun im-clipboard-contains-image-p ()
    "Check whether the clipboard has image or not."
    (pcase system-type
      ('gnu/linux (s-contains? "image/" (im-sync-async-command-to-string "xclip" "-o" "-sel" "c" "-t" "TARGETS")))
      ('darwin (eq (shell-command "pngpaste - &>/dev/null") 0))))

  (defun im-save-clipboard-image-to-file (file)
    "Save the image in clipboard (if there is any) to given FILE.
    Also see `im-clipboard-contains-image-p' to check if there is one."
    (interactive "FFile to save the image: ")
    (shell-command (format "%s > %s" (im-clipboard-command) file)))
#+end_src
*** User input
#+begin_src emacs-lisp
  (cl-defun im-get-input (&key (mode #'org-mode)
                                    (init "")
                                    on-accept
                                    on-reject
                                    pre-process)
    "Display a buffer to user to enter some input."
    (let* ((buffer (get-buffer-create "*isamert-input*"))
           (success-handler (lambda ()
                              (interactive)
                              (let ((pre-proc-result (when pre-process
                                                       (with-current-buffer buffer
                                                         (funcall pre-process))))
                                    (result (substring-no-properties (buffer-string))))
                                (kill-buffer buffer)
                                (if pre-process
                                    (funcall on-accept result pre-proc-result)
                                  (funcall on-accept result)))))
           (reject-handler (lambda ()
                             (interactive)
                             (kill-buffer buffer)
                             (when on-reject
                               (funcall on-reject)))))
      (switch-to-buffer buffer)
      (with-current-buffer buffer
        (funcall mode)
        (use-local-map (copy-keymap (current-local-map)))
        (local-set-key (kbd "C-c C-c") success-handler)
        (local-set-key (kbd "C-c C-k") reject-handler)
        (setq header-line-format "Hit `C-c C-c' to save `C-c C-k' to reject.")
        (insert init))))

  (defun im-alist-completing-read (prompt alist &optional initial)
    "Like `completing-read' but returns value of the selected key in given ALIST."
    (alist-get
     (completing-read prompt alist nil nil initial)
     alist nil nil #'equal))

  (defun im-dmenu (prompt items &rest ignored)
    "Like `completing-read' but instead use dmenu.
  Useful for system-wide scripts."
    (with-temp-buffer
      (thread-first
        (cond
         ((functionp items)
          (funcall items "" nil t))
         ((listp (car items))
          (mapcar #'car items))
         (t
          items))
        (string-join "\n")
        string-trim
        insert)
      (shell-command-on-region
       (point-min)
       (point-max)
       (pcase system-type
         ('gnu/linux (format "rofi -dmenu -fuzzy -i -p '%s'" prompt))
         ('darwin "choose"))
       nil t "*im-dmenu error*" nil)
      (string-trim (buffer-string))))

  (cl-defmacro im-output-select
      (&key cmd prompt keep-order (split "\n") (drop 0) (filter t) (map 'it) (do 'it) category)
    "Run given CMD and do a `completing-read' on it.
  This macro is intended to quicken up the process of running a
  shell command and doing a completing-read on it and then using
  the result in another context, possibly on another shell
  command."
    (let* ((result `(lab--completing-read-object
                     ,prompt
                     (seq-map-indexed
                      (lambda (it idx) ,map)
                      (seq-filter
                       (lambda (it) ,filter)
                       (seq-drop
                        (s-split
                         ,split
                         (shell-command-to-string ,cmd)
                         t)
                        ,drop)))
                     :sort? ,(not keep-order)
                     :category ,category)))
      `((lambda (it) ,do) ,result)))

  (defun im-read-string (prompt &rest rest)
    "Like `read-string' but returns `nil' on empty input."
    (let ((result (string-trim (apply #'read-string prompt rest))))
      (if (string-equal result "")
          nil
        result)))
#+end_src

*** String utils
#+begin_src emacs-lisp
  ;; Source: https://gist.github.com/jordonbiondo/c4e22b4289be130bc59b
  (defmacro im-s-interpolated (str)
    "Elisp string interpolation.
  Uses #{elisp-code} syntax."
    (let ((exprs nil))
      (with-temp-buffer
        (insert str)
        (goto-char 1)
        (while (re-search-forward "#{" nil t 1)
          (let ((here (point))
                (emptyp (eql (char-after) ?})))
            (unless  emptyp (push (read (buffer-substring (point) (progn (forward-sexp 1) (point)))) exprs))
            (delete-region (- here 2) (progn (search-forward "}") (point)))
            (unless emptyp (insert "%s"))
            (ignore-errors (forward-char 1))))
        (append (list 'format (buffer-string)) (reverse exprs)))))

  (defun im-s-upcase-until (until s)
    "Make prefix of a string S uppercase until given char UNTIL.
  `(im-s-upcase-until \"-\" \"aha-hehe\")' -> \"AHA-hehe\""
    (let ((end (s-index-of until s)))
      (concat
       (s-upcase (substring s 0 end))
       (substring s end))))

  (defun im-string-url-case (str)
    "Convert STR to something like `a-string-appropriate-for-urls'."
    (->> (downcase str)
         (s-replace-all
          '(("," . "")
            ("'" . "")
            ("ö" . "o")
            ("ı" . "i")
            ("ğ" . "g")
            ("ü" . "u")
            ("ş" . "s")
            ("ö" . "o")
            ("ç" . "c")))
         (s-trim)
         (replace-regexp-in-string "[^a-zA-Z0-9]" "-" str)
         (replace-regexp-in-string "-+" "-")))

  (defun im-human-readable-size (size-in-bytes)
    (let* ((units '("B" "KB" "MB" "GB" "TB" "PB" "EB" "ZB" "YB"))
           (unit (car units))
           (bytes (float size-in-bytes))
           (exponent (floor (log bytes 1024))))
      (setq units (cdr units))
      (while (> exponent 0)
        (setq bytes (/ bytes 1024.0))
        (setq exponent (1- exponent))
        (setq unit (car units))
        (setq units (cdr units)))
      (format "%.2f %s" bytes unit)))
#+end_src
*** List/hash-table/vector utils
#+begin_src emacs-lisp
  (defun im-ht-to-alist (val)
    "Bad way to convert hash-tables with vectors into alists. I use
  this only for debugging."
    (cond
     ((hash-table-p val) (im-ht-to-alist (ht-to-alist val)))
     ((vectorp val) (mapcar #'im-ht-to-alist (cl-coerce val 'list)))
     ((json-alist-p val) (map-apply (lambda (key it) (cons key (im-ht-to-alist it))) val))
     ((listp val) (mapcar (lambda (key it) (cons key (im-ht-to-alist it))) val))
     (t val)))
#+end_src
*** Quick table
#+begin_src emacs-lisp
  (cl-defun im-output-to-tabulated-list (str &key buffer (sep " "))
    (with-current-buffer buffer
      (let* ((lines (s-split "\n" str t))
             (header-items (s-split sep (car lines) t))
             (header (cl-coerce (--map (list it (/ 100 (length header-items)) nil) header-items) 'vector))
             (rows (thread-last lines
                     (-drop 1)
                     (--map-indexed (list (number-to-string it-index) (coerce (s-split sep it t) 'vector))))))
        (tabulated-list-mode)
        (setq tabulated-list-format header)
        (setq tabulated-list-entries rows)
        (setq tabulated-list-padding 4)
        (tabulated-list-init-header)
        (tabulated-list-print t))
      (switch-to-buffer buffer)))
#+end_src
*** API call
This function is for doing easy REST calls and it uses plists for everything because it's more readable and easier to type than alists (but you can still use alists if you want or need to). I use this to quickly prototype stuff in elisp.

#+begin_src emacs-lisp
  (cl-defun im-request
      (endpoint
       &rest params
       &key (-type "GET") (-headers) (-data) (-params) (-async?) (-success) (-raw)
       &allow-other-keys)
    "Like `request' but plist and JSON oriented. JSON responses are
  automatically parsed, query parameters are constructed from
  top-level keywords, request body can be a plist (which will be
  serialized into JSON). Examples:

      (im-request \"some/endpoint\")

  With url parameters:

      (im-request \"...\" :query \"test\" :page 3 :page_size 15)

  If you want to pass an alist as url params:

      (im-request \"...\" :-params '((query . \"test\") (page . 3) (page_size . 15)))

  POST with json body:

      (im-request \"...\" :-type 'POST :-data '(:key1 1 :key2 2))

  With some HTTP headers:

      (im-request \"...\" :-headers '(:Authorization \"Bearer e21ewqfasdwtkl\"))

  Async request:

      (im-request \"...\"
        :-async? t
        :-success (cl-function
                    (lambda (&key data &allow-other-keys)
                      ...use the parsed json DATA...)))
  "
    (declare (indent defun))
    (let (json
          (json-object-type 'alist)
          (json-array-type #'list)
          (json-key-type 'symbol))
      ;; Remove request related items from params list
      (dolist (key '(:-type :-headers :-data :-params :-async? :-success :-raw))
        (cl-remf params key))

      (request
        endpoint
        :type -type
        ;; TODO Maybe roll my own plist-to-alist function
        :headers (cond
                  ((and -headers (json-alist-p -headers)) -headers)
                  ((and -headers (json-plist-p -headers)) (transient-plist-to-alist -headers))
                  (t nil))
        :parser (if -raw #'buffer-string #'json-read)
        :success (if -async?
                     -success
                   (cl-function
                    (lambda (&key data &allow-other-keys)
                      (setq json data))))
        :error (cl-function
                (lambda (&key status data &allow-other-keys)
                  (user-error "STATUS: %s, DATA: %s," status data)))
        :sync (not -async?)
        :data (cond
               ((and -data (json-alist-p -data)) -data)
               ((and -data (json-plist-p -data)) (transient-plist-to-alist -data))
               ((stringp -data) -data)
               (t nil))
        :params (cond
                 ((and -params (json-alist-p -params)) -params)
                 ((and -params (json-plist-p params)) (transient-plist-to-alist -params))
                 (t (transient-plist-to-alist params))))
      json))
#+end_src
*** URL/web utils
#+begin_src emacs-lisp
  (defun im-url-parse-title ()
    (dom-text (car (dom-by-tag (libxml-parse-html-region (point-min) (point-max)) 'title))))

  (defun im-url-get-title (url)
    "Get title of the URL."
    (with-current-buffer (url-retrieve-synchronously url :silent :inhibit-cookies)
      (im-url-parse-title)))

  (defun im-url-get-title-async (url cb)
    "Get title of the URL, async."
    (url-retrieve
     url
     (lambda (_status)
       (funcall cb (im-url-parse-title))
       (kill-buffer))
     nil :silent :inhibit-cookies))

  (defmacro with-default-browser (&rest body)
    `(let* ((browse-url-handlers nil)
            (browse-url-browser-function browse-url-secondary-browser-function))
       ,@body))

  (defun im-json-encode-and-show (obj)
    "Show given elisp OBJ as pretty printed JSON."
    (switch-to-buffer-other-window (get-buffer-create "*raw-pretty*"))
    (insert (json-encode obj))
    (json-pretty-print-buffer)
    (json-ts-mode))

  (defun im-url? (url)
    "Check if given URL is really an URL or not."
    (or (s-match "^\\(https?\\|file\\)://\\|www." url)
        (s-match "\\.\\(org\\|net\\|com\\)$" url)))
#+end_src
*** Other
#+begin_src emacs-lisp
  (defun im-kill-this-buffer ()
    "Kill current buffer.
  Function `kill-this-buffer' does not work reliably.  See
  documentation of it."
    (interactive)
    (kill-buffer (current-buffer)))

  (defmacro im-make-repeatable (name &rest rest)
    "Put given pairs in a keymap and mark them as repeatable."
    (declare (indent 1))
    (let ((pairs (-partition 2 rest))
          (map-name (intern (format "im-repeat-map-for-%s" name))))
      `(progn
         (defvar ,map-name
           (let ((map (make-sparse-keymap)))
             ,@(--map `(define-key map (kbd ,(car it)) ',(cadr it)) pairs)
             map))
         (--each ',(-map #'cadr pairs)
           (put it 'repeat-map ',map-name)))))

  (defun im-add-to-path (path)
    "Add given PATH to PATH variable.
  Useful for adding something to Emacs' PATH without restarting it."
    (interactive "sPath: ")
    (add-to-list 'exec-path (expand-file-name path))
    (setenv "PATH" (concat (getenv "PATH") ":" (expand-file-name path))))
#+end_src
*** File operations
#+begin_src emacs-lisp
  (defun im-latest-file (&optional path)
    "Get latest file in PATH."
    (car (directory-files (or path default-directory) 'full "^\\([^.]\\|\\.[^.]\\|\\.\\..\\)" #'file-newer-than-file-p)))

  (defun im-directory-files-recursively (dir regexp)
    "Faster alternative to `directory-files-recursively'."
    (->>
     (format
      "fd '%s' '%s' --type file --maxdepth 4 --absolute-path"
      regexp
      (expand-file-name dir))
     (shell-command-to-string)
     (s-trim)
     (s-split "\n")))
#+end_src
** Load path
Add =~/.emacs.d/load/= to =load-path=. I have extra configuration kept in this path.

#+begin_src emacs-lisp
  (defconst im-load-path (expand-file-name "~/.emacs.d/load/"))
  (add-to-list 'load-path im-load-path)
#+end_src

Also load ~isamert-secrets~ from =load-path=. I'll be utilizing some variables defined here throughout my configuration. It contains some api-keys, some tokens or some passwords etc. that I don't want to leak into public. Instead of doing mutations on an external hidden script, I define variables in this external hidden script and reference them in the configuration. This way the logic stays in the public configuration file so that everyone can take a look, but only the variable itself will be hidden from the public.

#+begin_src emacs-lisp
  (load "isamert-secrets")
#+end_src

* Basics
** Overriding some defaults
*** M-Backspace should delete, instead of killing
#+begin_src emacs-lisp
  ;; https://www.emacswiki.org/emacs/BackwardDeleteWord

  (defun delete-word (arg)
    "Delete characters forward until encountering the end of a word.
  With argument, do this that many times."
    (interactive "p")
    (if (use-region-p)
        (delete-region (region-beginning) (region-end))
      (delete-region (point) (progn (forward-word arg) (point)))))

  (defun backward-delete-word (arg)
    "Delete characters backward until encountering the end of a word.
  With argument, do this that many times."
    (interactive "p")
    (delete-word (- arg)))

  (global-set-key (read-kbd-macro "<M-DEL>") 'backward-delete-word)
#+end_src

** Recent files
Save recent files. Also exclude package files that appears after installing a package or after an update from recent list.

#+BEGIN_SRC emacs-lisp
  (recentf-mode t)
  (setq recentf-max-saved-items 500)
  (add-to-list 'recentf-exclude (format ".*\\.elc" (getenv "HOME")))
  (add-to-list 'recentf-exclude "/tmp/.*")
  (add-to-list 'recentf-exclude "/var/folders/.*")
#+END_SRC

** Save minibuffer, kill-ring, search-ring history
#+begin_src emacs-lisp
  (setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
  (setq savehist-file "~/.emacs.d/savehist")
  (savehist-mode 1)

  (setq save-interprogram-paste-before-kill t)
  ;; ^ Clipboard selections are copied into the kill-ring
#+end_src

** Better scrolling
*** Better settings for mouse scroll
#+BEGIN_SRC emacs-lisp
  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
  (setq mouse-wheel-progressive-speed nil)            ;; don't accelerate scrolling
  (setq mouse-wheel-follow-mouse 't)                  ;; scroll window under mouse
#+END_SRC

*** Mouse shortcuts for zooming
- Ctrl-Scroll to zoom in and out

#+BEGIN_SRC emacs-lisp
  (global-set-key [C-mouse-4] 'text-scale-increase)
  (global-set-key [C-mouse-5] 'text-scale-decrease)
  (global-set-key (kbd "C-+") 'text-scale-increase)
  (global-set-key (kbd "C-=") 'text-scale-decrease)
#+END_SRC

*** Conservative scrolling
If the cursor is at the end of the file, when you scroll emacs does a strange jump. This fixes it.

#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 100) ;; When cursor reaches end, just scroll line-by-line
  ;; (setq scroll-margin 10) ;; Start scolling earlier
#+END_SRC

** Backups
Instead of having a file that ends with ~ or '# files in same directory, save all backup files in =~/.emacs.d/backups=.

#+BEGIN_SRC emacs-lisp
  (defconst backup-dir (im-mkdir-if-not "~/.emacs.d/backups/"))

  (setq backup-directory-alist `((".*" . ,backup-dir)))
  (setq auto-save-file-name-transforms `((".*" ,backup-dir t)))

  (setq backup-by-copying t)
  ;; ^ Don't delink hardlinks
  (setq version-control t)
  ;; ^ Use version numbers on backups
  (setq delete-old-versions t)
  ;; ^ Automatically delete excess backups
  (setq kept-new-versions 20)
  ;; ^ How many of the newest versions to keep
  (setq kept-old-versions 5)
  ;; ^ How many of the old versions to keep
#+END_SRC

** Remove trailing space before save
#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

** Make script files executable automatically
#+begin_src emacs-lisp
  (add-hook 'after-save-hook #'executable-make-buffer-file-executable-if-script-p)
  (add-hook 'org-babel-post-tangle-hook #'executable-make-buffer-file-executable-if-script-p)
#+end_src

** Automatically run some commands after saving specific files
This is like =autocmd BufWritePost= of vim. When a particular file is edited, I want to make sure a command runs after the save.

#+BEGIN_SRC emacs-lisp
  (defvar im-run-after-save-alist
    '(("~/.\\(Xresources\\|Xdefaults\\)" . "xrdb %; notify-send 'xrdb updated'")
      ("~/.Xresources.d/.*"              . "xrdb ~/.Xresources; notify-send 'xrdb updated'")
      ("~/.config/sxhkd/sxhkdrc"         . "pkill -USR1 -x sxhkd; notify-send 'sxhkd updated'")
      ("~/.config/skhd/skhdrc"           . "skhd --reload; osascript -e 'display notification \"skhd updated\"'")
      ("~/.config/kmonad-linux.kbd"      . "systemctl --user restart kmonad")
      ("~/.ssh/config" . im-unison-sync)
      ("~/.emacs.d/load/isamert.*" . im-unison-sync))
    "File association list with their respective command.")

  (add-hook 'after-save-hook #'im-post-save-run-command)
  (add-hook 'org-babel-post-tangle-hook #'im-post-save-run-command)

  (defun im-post-save-run-command ()
    "Execute the specified command after saving specified file."
    (when-let* ((fname (buffer-file-name))
                (match (im-assoc-regexp fname im-run-after-save-alist #'expand-file-name)))
      (mapcar
       (-lambda ((_ . command))
         (cond
          ((stringp command)
           (shell-command (s-replace "%" fname command)))
          ((functionp command)
           (funcall command fname))
          (t
           (message ">> Wrong specification in `im-run-after-save-alist' for %s" fname))))
       match)))

  (defun im-unison-sync (file)
    (async-shell-command
     (format "DISPLAY= unison sync -ui text -batch -root ~ -root ssh://%s"
             (if (workpc?) "x220" "mac"))))
#+END_SRC

** macOS problem: too many open files
macOS is shit and I can't get rid of this error no matter what. Here is a [[https://www.blogbyben.com/2022/05/gotcha-emacs-on-mac-os-too-many-files.html][blogpost]] explaining the situation and here is the solution offered by the post:

#+begin_src emacs-lisp
  (defun file-notify-rm-all-watches ()
    "Remove all existing file notification watches from Emacs."
    (interactive)
    (maphash
     (lambda (key _value)
       (file-notify-rm-watch key))
     file-notify-descriptors))
#+end_src

Run this function (possibly after closing some buffers and killing some child processes) whenever you start getting ~too many open files~ error and hopefully emacs continues to work normally.
* Visuals
** General
#+begin_src emacs-lisp
  ;; Wrap long lines
  (global-visual-line-mode t)
  (diminish 'visual-line-mode)

  (global-hl-line-mode t) ;; Highlight current line
  ;; Disable global-hl-line-mode in eshell, ansi-term, vterm
  (mapcar
    (lambda (mode) (add-hook mode (lambda () (setq-local global-hl-line-mode nil))))
    '(eshell-mode-hook term-mode-hook vterm-mode-hook))
#+end_src

** Fix Gnome/Mutter child frame resizing problem
There is a problem under Mutter which causes child frames to not resize automatically. Following makes it better:

#+begin_src emacs-lisp
  (when (equal (getenv "XDG_SESSION_DESKTOP") "gnome")
    (setq x-gtk-resize-child-frames 'resize-mode))
#+end_src

Also see [[https://gitlab.gnome.org/GNOME/mutter/-/issues/840][this issue]].

** Fonts and theme
#+BEGIN_SRC emacs-lisp
  (menu-bar-mode 0)
  (use-package doom-themes)
  (use-package modus-themes)

  (defconst im-fonts '("Iosevka Comfy" "Iosevka Nerd Font"))
  (defconst im-font-height
    (pcase system-type
      ('gnu/linux 120)
      ('darwin 160)))

  (defun im-set-font-and-theme-config ()
    "Configure font and theme."
    (interactive)
    ;; Set the first avilable font from the `im-fonts' list
    (ignore-errors
      (let ((font (->>
                   im-fonts
                   (-filter #'im-font-exists-p)
                   car)))
        (set-face-attribute 'default nil
                            :font font
                            :weight 'normal
                            :width 'normal
                            :height im-font-height))
      ;; ...and load the theme
      (load-theme 'modus-vivendi t)))


  (defun im-set-font-and-theme-config-in-frame (frame)
    (with-selected-frame frame
      (im-set-font-and-theme-config)))

  (if (daemonp)
      ;; Following sets font/font-size for each emacsclients frame
      (add-hook
       'after-make-frame-functions
       #'im-set-font-and-theme-config-in-frame)
    ;; Not in daemon mode, set theme etc directly
    (im-set-font-and-theme-config))
#+END_SRC

** prettify-symbols-mode
I make use of this mode quite frequently throughout the configuration.

#+begin_src emacs-lisp
  (setq prettify-symbols-unprettify-at-point t)

  (defmacro im-prettify-mode (mode pairs)
    "Prettify given PAIRS in given MODE.
    Just a simple wrapper around `prettify-symbols-mode`"
    `(add-hook
      ,mode
      (lambda ()
        (mapc (lambda (pair)
                (push pair prettify-symbols-alist))
              ,pairs)
        (prettify-symbols-mode 1))))
#+end_src

** fira-code-mode (font ligatures)
This adds Fira Code ligatures into Emacs, meaning that it prettifies well-known code symbols. This mode also saves the length of the chars, so it does not break spacing.
- After the first install, you need to call =fira-code-mode-install-fonts= and then maybe restart Emacs etc.

#+begin_src emacs-lisp :tangle no
  ;; FIXME: having problems with X forwarding
  (use-package fira-code-mode
    :config
    (setq fira-code-mode-disabled-ligatures '(":" "x" "[]"))
    (add-hook 'prog-mode-hook #'fira-code-mode)
    (add-hook 'org-mode-hook  #'fira-code-mode))
#+end_src

** Pages & page-break-lines & repeat-mode
You can jump between /pages/ by using ~C-x [~ and ~C-x ]~. See [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Pages.html][this]] for more information.

#+begin_src emacs-lisp
  (define-advice forward-page (:after (&rest _) recenter-buffer)
    "Recenter the page after doing a forward-page. This is always
  what I want."
    (when (cl-find this-command '(backward-page forward-page))
      (recenter nil)))
#+end_src

Displays ~^L~ (page breaks) as full-width straight lines:

#+begin_src emacs-lisp
  (use-package page-break-lines
    :config
    ;; global-page-break-lines-mode only enables page-break-lines mode
    ;; for the major modes listed in `page-break-lines-modes'
    (add-to-list 'page-break-lines-modes 'clojure-mode)
    (add-to-list 'page-break-lines-modes 'lisp-data-mode)
    (global-page-break-lines-mode))
#+end_src

After doing ~C-x [,]~ you can continue spamming ~[~ or ~]~ to jump prev/next pages with the help of ~repeat-mode~.

#+begin_src emacs-lisp
  (use-package repeat
    :straight (:type built-in)
    :config
    (repeat-mode))
#+end_src

** Frame title
Make window title contain buffer name so it's easier to identify windows. I use ~rofi~ to switch between windows in my DE, so it helps to have buffer name in window title.

#+BEGIN_SRC emacs-lisp
  (setq frame-title-format "%b - emacs")
#+END_SRC

** Parentheses
*** Matching
Just enable parenthesis matching.

#+BEGIN_SRC emacs-lisp
  (setq show-paren-style 'parenthesis)
  (show-paren-mode 1)
#+END_SRC

*** Rainbow
Colors parentheses depending on their dept.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

** Highlight trailing spaces
- Following highlights trailing spaces. Also see: [[Remove trailing space before save]]

#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :diminish global-whitespace-mode
    :config
    (setq whitespace-style '(face empty tabs trailing))
    (setq whitespace-global-modes '(not org-mode markdown-mode vterm-mode magit-log-mode nov-mode eshell-mode dired-mode dirvish-mode w3m-mode))
    (global-whitespace-mode t))

  (defun im-whitespace-mode-toggle ()
    "Toggle between more and less agressive whitespace modes.
  Toggles between showing every whitespace (tabs, spaces, newlines
  etc.) and only showing trailing spaces and tabs.  By default I use
  the latter but sometimes I want to see everything and the
  function helps me go between these modes easily."
    (interactive)
    (if (member 'spaces whitespace-style)
        (setq whitespace-style '(face empty tabs trailing))
      (setq whitespace-style '(face tabs spaces trailing lines space-before-tab newline indentation empty space-after-tab space-mark tab-mark newline-mark)))
    (whitespace-mode 0)
    (whitespace-mode 1))
#+END_SRC

** Spaces instead of tabs
#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 2)
  (setq-default indent-tabs-mode nil)
#+END_SRC

** Shackle windows
Make some temproary windows appear at bottom. This makes buffer management so much easier. Buffers that will match given regex will appear at bottom while covering the given amount of screen.

#+BEGIN_SRC emacs-lisp
  ;; SOURCE: https://www.reddit.com/r/emacs/comments/345vtl/make_helm_window_at_the_bottom_without_using_any/
  (defun im-shackle-window (name size)
    "Make the buffer NAME appear at bottom of the window, filling
    SIZE percent of the window."
    (add-to-list 'display-buffer-alist
                 `(,name
                   (display-buffer-in-side-window)
                   (inhibit-same-window . t)
                   (window-height . ,size))))

  (defun im-clear-side-windows ()
    "Clear all side windows.
  This is sometimes required to get around the error: `Cannot make
  side window the only window'"
    (interactive)
    (when (window-with-parameter 'window-side)
      (window-toggle-side-windows)))
#+END_SRC

** Miscellaneous packages
Some small packages that enriches editing experience visually. I don't enable all of them by default, I enable most of them whenever I need the functionality. I utilize an appearance [[Hydra]] to quickly toggle the functionality I need.

#+begin_src emacs-lisp
  ;; Show column guidelines
  (use-package fill-column-indicator)

  ;; By default Emacs scales fonts with text-scale-{increase,decrease}
  ;; per buffer. This scales fonts with
  ;; default-text-scale-{increase,decrease} globally.
  (use-package default-text-scale)

  ;; Highlights changed lines in git. You need to save the buffer to see
  ;; the changes.
  (use-package diff-hl)

  ;; It helps you to find your cursor when you change buffers/windows
  ;; etc with a little animation.
  (use-package beacon
    :config
    (beacon-mode 1)
    (setq beacon-blink-duration 0.5)
    (setq beacon-push-mark 50)
    (setq beacon-color "#9F72D9")
    (add-to-list 'beacon-dont-blink-major-modes 'dirvish-mode)
    (add-to-list 'beacon-dont-blink-major-modes 'eshell-mode))

  ;; This shows some indent guides and it's highly configurable.
  (use-package highlight-indent-guides
    :config
    (set-face-background 'highlight-indent-guides-odd-face "darkgray")
    (set-face-background 'highlight-indent-guides-even-face "dimgray")
    (set-face-foreground 'highlight-indent-guides-character-face "dimgray")
    (setq highlight-indent-guides-method 'bitmap)
    (setq highlight-indent-guides-bitmap-function 'highlight-indent-guides--bitmap-line))
#+end_src

* evil-mode
** Basic configuration
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :init
    ;; Following two is required by evil-collection. It's probably wiser
    ;; to set evil-want-keybinding to t if you will not use
    ;; evil-collection
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    ;; C-i interferes with TAB key, so disable it
    (setq evil-want-C-i-jump nil)
    ;; This generally confuses me.
    (setq evil-jumps-cross-buffers nil)
    ;; Disable evil bindings in insert mode. This needs to be called
    ;; before loading evil mode...
    (setq evil-disable-insert-state-bindings t)
    (setq evil-undo-system 'undo-redo)
    :config
    ;; ...but I want some default evil bindings in insert mode, so just
    ;; remap them
    (evil-define-key 'insert 'global
      (kbd "C-d") #'evil-shift-left-line
      (kbd "C-t") #'evil-shift-right-line
      (kbd "C-n") #'evil-complete-next
      (kbd "C-p") #'evil-complete-previous
      (kbd "C-o") #'evil-execute-in-normal-state)

    ;; C-i is bound to TAB, so I use C-l for `evil-jump-forward'
    (evil-define-key 'normal 'global
      (kbd "C-l") #'evil-jump-forward)

    ;; When I paste something in visual mode, I don't want it to take
    ;; over the kill ring I also use evil-exchange, which eliminates the
    ;; need for this totally
    (setq evil-kill-on-visual-paste nil)
    ;; ^ Over the time I found myself utilizing emacs C-u more and more,
    ;; so disable this
    (setq evil-want-C-u-scroll nil)

    ;; Make horizontal movement cross lines
    (setq-default evil-cross-lines t)

    ;; Open ex-mode with `<`> text instead of '<'> by default while
    ;; visual mode is active. This way commands will work on selected
    ;; char range instead of selected line range.
    (setq evil-ex-visual-char-range t)

    ;; This is needed for being able to use *-eval-last-sexp kind of
    ;; functions in normal mode. Elisp-related ones works out of the box
    ;; but other ones (like for Racket, Clojure etc.) are not patched by
    ;; default.
    (setq evil-move-beyond-eol t)

    ;; Move between visual lines instead of real lines
    (evil-define-key 'normal 'global
      (kbd "<remap> <evil-next-line>") #'evil-next-visual-line
      (kbd "<remap> <evil-previous-line>") #'evil-previous-visual-line)
    (evil-define-key 'motion 'global
      (kbd "<remap> <evil-next-line>") #'evil-next-visual-line
      (kbd "<remap> <evil-previous-line>") #'evil-previous-visual-line)

    ;; Change cursor colors based on current mode.
    (setq evil-normal-state-cursor '("green" box)
          evil-visual-state-cursor '("orange" box)
          evil-emacs-state-cursor '("purple" box)
          evil-insert-state-cursor '("pink" bar)
          evil-replace-state-cursor '("red" bar)
          evil-operator-state-cursor '("red" hollow))

    (evil-mode 1))
#+END_SRC

** evil-collection
#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init 'ibuffer)
    (evil-collection-init 'compile)
    (evil-collection-init 'eshell)
    (evil-collection-init 'geiser)
    (evil-collection-init 'dired)
    (evil-collection-init 'grep)
    (evil-collection-init 'replace)
    (evil-collection-init 'elfeed)
    (evil-collection-init 'consult)
    (evil-collection-init 'vterm)
    (evil-collection-init 'xref)
    (evil-collection-init 'magit)
    (evil-collection-init 'magit-todos)
    (evil-collection-init 'git-timemachine)
    (evil-collection-init 'calendar)
    (evil-collection-init 'w3m)
    (evil-collection-init 'eww)
    (evil-collection-init 'vc-git)
    (evil-collection-init 'vc-dir)
    (evil-collection-init 'log-view)
    (evil-collection-init 'log-edit)
    (evil-collection-init 'vc-annotate)
    (evil-collection-init 'help)
    (evil-collection-init 'Custom)
    (evil-collection-init 'imenu-list)
    (evil-collection-init 'custom)
    (evil-collection-init 'xwidget)
    <<evil-unimpaired>>)
#+end_src
** evil-unimpaired
Apparently [[evil-collection]] has a vim-unimpaired implementation already. It contains bindings like:
  - ~[<SPC>~ ~]<SPC>~ Insert newline above/below.
  - ~[b~ ~]b~ Go to prev/next buffer.
  - ~[p~, ~]p~ Paste up/down.
  - ~[e~, ~]e~ Move line up/down.
  - ~[d~, ~]d~ Delete line above/below.
  - ~[q~ ~]q~ Go to prev/next error.
  - ~[Q~ ~]Q~ Go to first/last error.
  - ~[n~ ~]n~ Go to prev/next conflict marker.
  - ~[t~ ~]t~ Go to prev/next TODO. (This is defined in [[Dummy IDE mode]])

These also support repeat-mode. You can do ~]b~ and spam ~b~ to switch buffers.

Following are my extensions:

#+name: evil-unimpaired
#+begin_src emacs-lisp :tangle no
  (evil-collection-define-key 'normal 'evil-collection-unimpaired-mode-map
    "[d" #'im-delete-line-above
    "]d" #'im-delete-line-below)

  (defun im-delete-line-above ()
    "Delete the line above."
    (interactive)
    (save-excursion
      (previous-line 1)
      (beginning-of-line)
      (kill-line)
      (when (s-blank? (s-trim (thing-at-point 'line t)))
        (kill-line))))

  (defun im-delete-line-below ()
    "Delete the line below."
    (interactive)
    (save-excursion
      (next-line 1)
      (beginning-of-line)
      (kill-line)
      (when (s-blank? (s-trim (thing-at-point 'line t)))
        (kill-line))))

  (setq evil-collection-unimpaired-want-repeat-mode-integration t)
  (evil-collection-unimpaired-setup)
#+end_src
** evil-leader
Enable leader key and bind some keys.

#+BEGIN_SRC emacs-lisp
  (use-package evil-leader
    :after evil
    :config
    (global-evil-leader-mode)
    (evil-leader/set-leader "SPC"))
#+END_SRC

** evil-mc (multiple cursors)
Multiple cursors for evil.

- Basics
  - =C-n= / =C-p= are used for creating cursors
  - =A= and =I= creates cursors in visual selection mode as you may expect.
  - =gkk= to clear all cursors.

- To be able to create cursors at arbitrary positions:
  - =gkp= to pause all cursors. (Your main cursors moves freely while mc cursors stays still)
  - =gkr= to resume paused cursors.
  - =gkh= create a cursor at the point of main cursor. (Use after =gkp=).

#+BEGIN_SRC emacs-lisp
  (use-package evil-mc
    :after evil
    :diminish evil-mc-mode
    :config
    ;; I use "gr" (which is the default key combination that brings up evil-mc commands) for something else
    ;; So remove "gr" binding
    (evil-define-key* '(normal visual) evil-mc-key-map (kbd "gr") nil)
    (evil-define-key* '(normal visual) evil-mc-key-map (kbd "M-p") nil)

    ;; Add my bindings using "gk"
    (evil-define-key 'normal evil-mc-key-map
      (kbd "gcc") #'evil-mc-undo-all-cursors
      (kbd "gcp") #'evil-mc-pause-cursors
      (kbd "gcr") #'evil-mc-resume-cursors
      (kbd "gch") #'evil-mc-make-cursor-here)

    (evil-define-key 'visual evil-mc-key-map
      "A" #'evil-mc-make-cursor-in-visual-selection-end
      "I" #'evil-mc-make-cursor-in-visual-selection-beg)
    (global-evil-mc-mode 1))
#+END_SRC

** evil-surround
- Change surroundings. Do =cs"'= to turn ="Hello world!"= into ='Hello world!'=.
  - ='Hello world!'= ~cs'<q>~ =<q>Hello world!</q>=
  - =Hel|lo= ~ysiw"~ ="Hello"= (| is the cursor position.)
  - =Hello= ~ysw{~ ={ Hello }=  (~{[(~ adds spaces)
  - =Hello= ~ysw}~ ={Hello}=    (~}])~ does not add spaces)

- Wrap selection with ~<visual-state> S~.
- Wrap selection on new lines with ~<visual-state> gS~

#+BEGIN_SRC emacs-lisp
  (use-package evil-surround
    :after evil
    :init
    (global-evil-surround-mode 1)

    ;; Invert some default pairs
    (require 'map)
    (map-put! evil-surround-pairs-alist ?\( '("(" . ")"))
    (map-put! evil-surround-pairs-alist ?\) '("( " . " )"))
    (map-put! evil-surround-pairs-alist ?\[ '("[" . "]"))
    (map-put! evil-surround-pairs-alist ?\] '("[ " . " ]"))
    (map-put! evil-surround-pairs-alist ?\{ '("{" . "}"))
    (map-put! evil-surround-pairs-alist ?\} '("{ " . " }")))
#+END_SRC

** evil-escape
Return back to normal mode using ~jk~ from anywhere. It does not play well with multiple cursors, so use ~ESC~ to when using evil-mc related stuff.

#+BEGIN_SRC emacs-lisp
  (use-package evil-escape
    :diminish
    :after evil
    :config
    (setq evil-escape-key-sequence "jk")
    (setq evil-escape-delay 0.2)
    (setq evil-escape-excluded-major-modes '(magit-status-mode magit-log-mode magit-diff-mode))
    (evil-escape-mode 1))
#+END_SRC

** evil-matchit
Jump between matching tags using ~%~, like =<div>...</div>=, ={...}= etc. =ci%=, =da%= etc. works as expected.

#+BEGIN_SRC emacs-lisp
  (use-package evil-matchit
    :diminish
    :after evil
    :config
    (global-evil-matchit-mode 1))
#+END_SRC

** evil-goggles
~evil-goggles~ gives nice visual feedbacks while editing with evil-mode. When you do =dd=, =yw=, =ciw= or something similar, it will give a visual feedback for the selection. Feels kinda natural to have this.

#+BEGIN_SRC emacs-lisp
  (use-package evil-goggles
    :after evil
    :diminish
    :config
    (setq evil-goggles-duration 0.20
          evil-goggles-pulse nil
          evil-goggles-enable-change t
          evil-goggles-enable-delete t
          evil-goggles-enable-indent t
          evil-goggles-enable-yank t
          evil-goggles-enable-join t
          evil-goggles-enable-fill-and-move t
          evil-goggles-enable-paste t
          evil-goggles-enable-shift t
          evil-goggles-enable-surround t
          evil-goggles-enable-commentary t
          evil-goggles-enable-nerd-commenter t
          evil-goggles-enable-replace-with-register t
          evil-goggles-enable-set-marker t
          evil-goggles-enable-undo t
          evil-goggles-enable-redo t)
    (evil-goggles-mode)
    (evil-goggles-use-diff-faces))

#+END_SRC

** evil-snipe
- Overall better =f/F/t/T= and . Nice visual feedbacks.

#+BEGIN_SRC emacs-lisp
  (use-package evil-snipe
    :after evil
    :diminish evil-snipe-local-mode
    :config
    ;; (evil-snipe-mode 1) ;; This enables s/S bindings. I use those keys with avy
    (evil-snipe-override-mode 1) ;; This overrides default f/F, t/T bindings
    (setq evil-snipe-scope 'visible)
    (setq evil-snipe-skip-leading-whitespace nil)
    ;; ^ See https://github.com/hlissner/evil-snipe/issues/72
    (add-hook 'magit-mode-hook 'turn-off-evil-snipe-override-mode))
#+END_SRC

** evil-exchange
Change two parts of the text.
- Mark some text in visual mode and do =gx=.
- Mark some other text in visual mode and do =gx= again to exchange two parts.
- You can use ~gx<motion>~ instead of visual mode too.

#+begin_src emacs-lisp
  (use-package evil-exchange
    :config
    (evil-exchange-install))
#+end_src

** evil-visualstar
With this package, you can do a visual selection and ~*~, ~#~ keys will work on them.

#+begin_src emacs-lisp
  (use-package evil-visualstar
    :config
    (setq evil-visualstar/persistent t)
    (global-evil-visualstar-mode 1))
#+end_src

** evil-numbers
Pretty useful for macros. Increment or decrement number at point with ~C-c {+,-}~.

#+begin_src emacs-lisp
  (use-package evil-numbers
    :config
    (define-key evil-normal-state-map (kbd "C-c +") 'evil-numbers/inc-at-pt)
    (define-key evil-normal-state-map (kbd "C-c -") 'evil-numbers/dec-at-pt))
#+end_src

** goto-chg
- =g;= goes to the last change. (repeatable)
- There is also =gv= which selects the last selection. Not related to this package, it's a default functionality but I wanted to mention.

#+BEGIN_SRC emacs-lisp
  (use-package goto-chg
    :after evil)
#+END_SRC

* org-mode
** org-plus-contrib
#+begin_src emacs-lisp
  (use-package org
    :config
    (setq org-return-follows-link t)
    ;; ^ Open links with RET
    (setq org-src-fontify-natively t)
    ;; ^ Enable code highlighting in ~SRC~ blocks.
    (setq org-hierarchical-todo-statistics t)
    ;; ^ Show all children in todo statistics [1/5]
    (setq org-imenu-depth 7)
    ;; ^ include up to 7-depth headers in imenu search
    (setq org-image-actual-width nil)
    ;; ^ Disable showing inline images in full width. Now you can add `#+ATTR_*: :width 300` to resize inline images
    ;; (setq org-ellipsis "⤵")
    (setq org-ellipsis "…")
    ;; ^ Replace ... with … in collapsed sections
    (setq org-hide-emphasis-markers t)
    ;; Hide *...* /.../ etc.
    (setq org-pretty-entities t)
    (setq org-habit-show-habits-only-for-today t)
    ;; ^ If a TODO item has the ':STYLE: habit' property, then show it only on todays agenda, does not show recurring times.
    (setq org-log-into-drawer t)
    ;; ^ Log into LOGBOOK drawer instead of directly loging under the heading
    (setq org-extend-today-until 3)
    ;; ^ Consider the current day to end at 3AM
    (setq org-use-effective-time t)
    ;; ^ Make timestamp processing functions aware of the previous config
    (setq org-element-use-cache nil)
    ;; ^ Cache causes bunch of random errors although disabling cache
    ;; reduces the agenda performance significantly
    (setq org-tags-column 0)
    ;; Tags starts right after the heading.

    ;; TODO Remove when upstream fixes this
    ;; https://github.com/minad/consult/issues/563#issuecomment-1186612641
    (defun org-show-entry-consult-a (fn &rest args)
      (when-let ((pos (apply fn args)))
        (org-fold-show-entry)))
    (advice-add 'consult-line :around #'org-show-entry-consult-a)
    (advice-add 'consult-org-heading :around #'org-show-entry-consult-a)

    (add-to-list 'org-link-abbrev-alist '("imdb" . "https://www.imdb.com/title/%s"))
    (add-to-list 'org-link-abbrev-alist '("yt" . "https://youtu.be/%s"))
    ;; ^ More info: https://orgmode.org/manual/Link-Abbreviations.html

    (add-to-list 'org-modules 'org-habit t)
    ;; ^ Enable habit tracking

    ;; http://www.foldl.me/2012/disabling-electric-indent-mode/
    (defun im-disable-electric-indent ()
      (set (make-local-variable 'electric-indent-functions)
           (list (lambda (arg) 'no-indent))))

    (add-hook 'org-mode-hook #'im-disable-electric-indent)

    <<ob-http>>
    <<org-babel-configuration>>
    <<personal-files>>)

  (use-package org-contrib)
#+end_src

** Keybindings
#+begin_src emacs-lisp
  (use-package evil-org
    :after org
    :config
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys)
    (evil-org-set-key-theme '(textobjects insert navigation additional shift todo heading))
    (evil-define-key '(normal insert) org-mode-map
      (kbd "<RET>") #'org-return
      (kbd "S-<return>") #'im-org-link-to-indirect-buffer)
    (add-hook 'org-mode-hook #'evil-org-mode))

  (evil-leader/set-key-for-mode 'org-mode
    "d" #'org-babel-remove-result
    "D" #'im-org-babel-remove-all-results

    "op"  #'org-set-property
    "oi"  #'org-toggle-inline-images
    "oI"  #'org-redisplay-inline-images
    "or"  #'org-refile
    "oR"  #'org-mode-restart
    "oh"  #'outline-show-only-headings
    "os"  #'org-schedule
    "od"  #'org-deadline
    "ov"  #'org-babel-expand-src-block
    "oq"  #'im-org-tree-to-indirect-buffer
    "oQ"  #'im-org-link-to-indirect-buffer
    "o1"  #'im-show-outline-only

    ;; link stuff
    "oyi" #'org-copy-id
    "o#" #'org-insert-structure-template)

  (evil-leader/set-key
    "oyy" #'im-org-store-link-dwim
    "oa"  #'org-agenda
    "ow"  #'widen

    ;; org-clock
    "occ" #'org-clock-in
    "ocC" #'org-clock-cancel
    "ocl" #'org-clock-in-last
    "oco" #'org-clock-out
    "ocg" #'org-clock-goto)

  (defun im-org-tree-to-indirect-buffer ()
    "Same as `org-tree-to-indirect-buffer' but let's you open
  multiple indirect buffers."
    (interactive)
    (let ((current-prefix-arg '(4)))
      (call-interactively #'org-tree-to-indirect-buffer)))

  (defmacro im-org-focused-tree-to-indirect-buffer (&rest forms)
    "Same as `org-tree-to-indirect-buffer' but let's you open
  multiple indirect buffers."
    `(let ((current-prefix-arg '(4))
           (source-buffer (current-buffer))
           target-buffer)
       (save-excursion
         (save-restriction
           (widen)
           ,@forms
           (call-interactively #'org-tree-to-indirect-buffer)
           (setq target-buffer (current-buffer))))
       ;; If the link points to another buffer, current window will start
       ;; showing that buffer. We don't want that, so we are restoring
       ;; the current buffer here:
       (set-window-buffer nil source-buffer)
       ;; Newly opened indirect buffer is not focused automatically, we
       ;; fix that here:
       (im-select-window-with-buffer (format "%s::.*" (buffer-name target-buffer)))
       (im-show-outline-only)))

  (defun im-org-link-to-indirect-buffer ()
    "Open link at point on a new indirect buffer."
    (interactive)
    ;; Force org to open the link in current window
    (with-default-browser
     (let ((org-link-frame-setup (cons (cons 'file 'find-file) org-link-frame-setup)))
       (pcase (org-element-property :type (org-element-context))
         ((or "http" "https") (org-open-at-point))
         (_ (im-org-focused-tree-to-indirect-buffer
             (org-open-at-point)))))))

  (defun im-show-outline-only ()
    "Show all headers but hide all bodies."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (outline-next-heading)
      (outline-show-branches)
      (outline-hide-body)))
#+end_src

** Personal files
#+name: personal-files
#+BEGIN_SRC emacs-lisp :tangle no
  (defconst watchlist-org "~/Documents/notes/watchlist.org")
  (defconst readinglist-org "~/Documents/notes/readinglist.org")
  (defconst courses-org "~/Documents/notes/courses.org")
  (defconst bullet-org "~/Documents/notes/bullet.org")
  (defconst life-org "~/Documents/notes/life.org")
  (defconst reality-org "~/Documents/notes/reality.org")
  (defconst projects-org "~/Documents/notes/projects.org")
  (defconst people-org "~/Documents/notes/people.org")
  (defconst diary-org "~/Documents/notes/diary.org")
  (defconst snippets-org "~/Documents/notes/snippets.org")
  (defconst bookmarks-org "~/Documents/notes/bookmarks.org")
  (defconst work-org "~/Documents/notes/trendyol.org")
  (defconst temp-org "~/Documents/notes/temp.org")
  (defconst passwords-org "~/Documents/notes/passwords.org")
  (defconst engineering-org "~/Documents/notes/engineering.org")
  (defconst netherlands-org "~/Documents/notes/netherlands.org")

  ;; Put archive files under an archive/ directory
  ;; I don't want them to pollute my directory
  (setq org-archive-location "archive/%s_archive::")
  (setq org-directory "~/Documents/notes")
  (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)
  ;; ^ org-store-link creates an ID for header only if called interactively and if there is no custom id
  (setq org-agenda-files `(,bullet-org ,projects-org ,work-org ,people-org ,readinglist-org ,watchlist-org ,reality-org ,life-org ,netherlands-org))

  ;; With the following, I can call functions defined inside this file in other org files
  (org-babel-lob-ingest "~/Documents/notes/utils.org")
#+END_SRC

** Auto indent subsections
Automatically invoke ~org-indent-mode~ which gives nice little indentation under subsections. It makes reading easier. This does not add any spaces/tabs to the text file, the indentation is only visually apparent in Emacs.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook #'org-indent-mode t)
#+END_SRC

** Babel
*** General configuration
#+name: org-babel-configuration
#+begin_src emacs-lisp :tangle no
  ;; Typescript
  (use-package ob-typescript :after org)

  ;; Allow these languages to run in code blocks
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (shell . t)
     (scheme . t)
     (python . t)
     (haskell . t)
     (js . t)
     (sql . t)
     (http . t)
     (dot . t)
     (gnuplot . t)
     (plantuml . t)))

  ;; Don't ask permissions for evaluating code blocks
  (setq org-confirm-babel-evaluate nil)

  ;; Make certain files exacutable when tangled
  ;; Source: https://lists.gnu.org/archive/html/emacs-orgmode/2011-02/msg00465.html
  (add-hook 'org-babel-post-tangle-hook #'im-make-tangled-files-executable)

  ;; Some codeblocks produce image files as it's result (like dot
  ;; language). Re-executing these blocks removes the image
  ;; overlay. With this hook images are automatically updated after
  ;; code-block execution and not removed from screen.
  (add-hook 'org-babel-after-execute-hook #'im-org-redisplay-images-if-enabled)

  (evil-leader/set-key-for-mode 'org-mode
    "oe" #'org-edit-special
    "ot" #'im-org-babel-tangle-current-block
    "o-" #'org-babel-demarcate-block)

  (evil-define-minor-mode-key 'normal 'org-src-mode
    " oe" #'org-edit-src-exit
    " oE" #'org-edit-src-abort)

  (defalias 'im-org-babel-split-or-wrap-src-code-block #'org-babel-demarcate-block)

  (defun im-org-babel-tangle-current-block ()
    "Tangle the current source block and all other related
  blocks (the ones that tangles into the same file).

  This function also works inside `org-edit-special' buffers."
    (interactive)
    (let ((src-edit? (org-src-edit-buffer-p))
          (current-prefix-arg '(16)))
      ;;     ^ '(4) only tangles current file, '(16) tangles all code
      ;;     blocks related to current tangle file target
      (when src-edit? (org-edit-src-exit))
      (call-interactively 'org-babel-tangle)
      (when src-edit? (org-edit-special))))


  (defun im-make-tangled-files-executable ()
    (when (or (string-match-p  "\\.\\(sh\\|py\\)$" (buffer-file-name))
              (string-match-p  "\\(python\\|sh\\)$" (symbol-name major-mode)))
      (set-file-modes (buffer-file-name) #o755)))

  (defun im-org-redisplay-images-if-enabled ()
    (when org-inline-image-overlays
      (org-redisplay-inline-images)))
#+end_src

*** ob-http
#+name: ob-http
#+begin_src emacs-lisp :tangle no
  ;; Http request in org-mode babel.
  ;; You can get the generated curl command after executing the code
  ;; block, from *curl command history* buffer
  (use-package ob-http
    :straight (:host github :repo "zweifisch/ob-http"))

  (defun im-curl-to-org-http (curl-str)
    "Convert CURL-STR into an ob-http block.
  More concretely this function converts given curl command (that
  is copied from Chrome/Firefox dev tools, using the `Copy as curl'
  option) into an ob-http block to be able to use all the goodies
  that is provided by ob-http."
    (interactive
     (list
      (if (use-region-p)
          (buffer-substring-no-properties (region-beginning) (region-end))
        (read-string "Curl string: "))))
    (let* ((curl (s-trim curl-str))
           (url (cadr (s-match "['\"]\\(http.*?\\)['\"]" curl)))
           (headers (--map (format "%s: %s" (s-titleize (nth 2 it)) (nth 3 it))
                           (s-match-strings-all "-H \\('\\|\"\\)\\(.*?\\): \\(.*?\\)\\('\\|\"\\)" curl)))
           (body (-some->> (s-match "--data-\\(binary\\|raw\\) '\\(.*?\\)'" curl)
                   (nth 2)
                   (s-trim)))
           (compressed? (s-matches? "--compressed" curl))
           (method (nth 2 (s-match "-\\(X\\|-request\\) ['\"]?\\([A-Z]+\\)['\"]?" curl)))
           ;; GET https://...
           ;; Header1: Value1
           ;; ...
           ;;
           ;; body
           (result (format
                    "  %s %s\n%s%s"
                    (or method (if body "POST" "GET"))
                    url
                    (s-join "\n" (--map (format "  %s" it) headers))
                    (if body
                        (format "\n\n%s"
                                ;; if json, format the body
                                (if (or (and
                                         (s-prefix? "{" body)
                                         (s-suffix? "}" body))
                                        (and
                                         (s-prefix? "[" body)
                                         (s-suffix? "]" body)))
                                    (with-temp-buffer
                                      (insert body)
                                      (json-pretty-print-buffer)
                                      (->>
                                       (buffer-string)
                                       (s-split "\n")
                                       (--map (format "  %s" it))
                                       (s-join "\n")))
                                  (format "%s" body)))
                      ""))))
      (when (use-region-p)
        (delete-region (region-beginning) (region-end)))
      (unless (save-excursion
                (goto-char (region-beginning))
                (forward-line -1)
                (s-contains? "begin_src" (thing-at-point 'line t)))
        (insert
         (format "#+begin_src http :pretty :wrap src json%s\n\n#+end_src"
                 (if compressed? " :curl --compressed" "")))
        (forward-line -1))
      (insert result)))
#+end_src

** Exporting
*** HTML
#+BEGIN_SRC emacs-lisp
  (use-package htmlize :after org)
#+END_SRC

*** iCalendar settings
#+BEGIN_SRC emacs-lisp
  (setq org-icalendar-store-UID t)
  (setq org-icalendar-alarm-time 15)
  (setq org-icalendar-use-scheduled '(todo-start event-if-todo))
  (setq org-icalendar-use-deadline '(todo-due event-if-todo))
#+END_SRC

** Agenda
Some general settings.

#+BEGIN_SRC emacs-lisp
  (evil-set-initial-state 'org-agenda-mode 'normal)
  (evil-define-key 'normal org-agenda-mode-map
    (kbd "<RET>") 'org-agenda-switch-to
    (kbd "\t") 'org-agenda-goto
    "s" 'org-agenda-schedule
    "w" 'org-agenda-week-view
    "d" 'org-agenda-day-view
    "t" 'org-agenda-todo
    "L" 'org-agenda-log-mode
    "q" 'org-agenda-quit
    "R" 'org-agenda-clockreport-mode
    "r" 'org-agenda-redo)

  (setq org-agenda-use-time-grid t)
  (setq org-agenda-time-grid
        '((today remove-match)
          (800 900 1000 1100 1200 1300 1400 1500 1600 1700 1800 1900 2000 2100 2200 2300 2400)
          "......"
          "----------------"))
#+END_SRC

*** Making agenda buffer open faster
Here are the resources:
- https://orgmode.org/manual/Speeding-Up-Your-Agendas.html
- https://orgmode.org/worg/agenda-optimization.html

#+begin_src emacs-lisp
  (setq org-agenda-dim-blocked-tasks nil)
  (setq org-agenda-inhibit-startup t)
  (setq org-agenda-use-tag-inheritance nil)
  (setq org-agenda-ignore-drawer-properties '(effort appt category))
#+end_src

** ToDo keywords & faces
#+BEGIN_SRC emacs-lisp
  ;; Add this to org files if you need:
  ;; #+TODO: TODO PROG WAITING DONE
  ;; OR
  (setq org-todo-keywords
    '((sequence "TODO(t)" "PROG(p)" "WAIT(w)" "DONE(d)")))
  ;; Now you can do C-c C-t {t,p,w,d} to set the state directly

  (setq org-todo-keyword-faces
        '(("WAIT" . (:foreground "yellow" :weight bold))
          ("PROG" . (:foreground "magenta" :weight bold :underline t))))

  (custom-set-faces
   '(org-headline-done ((t (:strike-through t))))
   '(org-agenda-done ((t (:strike-through t))))
   '(org-column ((t (:background nil))))
   '(org-scheduled-today ((t (:foreground "light green"))))

   ;; Make some stuff small
   '(org-drawer ((t (:height 0.8))))
   '(org-special-keyword ((t (:height 0.8))))
   '(org-block-end-line ((t (:height 0.8)))))

#+END_SRC

** org-capture
:PROPERTIES:
:ID:       4e8609e8-8485-4868-a942-35b2571d46ae
:END:
See [[https://orgmode.org/manual/Template-elements.html#Template-elements][this page]] for more detail on template elements.

#+begin_src emacs-lisp
  (evil-leader/set-key "og" #'org-capture)
  (evil-leader/set-key "oG" #'org-capture-goto-last-stored)

  (setq
   org-capture-templates
   '(("g" "General todo/note")
     ("gi" "Study later" item
      (file+olp bullet-org "Life backlog" "Investigate")
      "- [ ] %U %(im-org-make-link-string (read-string \"URL: \"))"
      :prepend t)
     ("gt" "Life todo" entry
      (file+headline bullet-org "Life backlog")
      "** %?")
     ("gc" "Computer todo" entry
      (file+headline bullet-org "Computer backlog")
      "**  %?" :prepend t)
     ("gw" "Work todo" entry
      (file+headline bullet-org "Work backlog")
      "** TODO [#B] %?" :prepend t)
     ("gb" "Free time backlog" item
      (file+headline bullet-org "Free time backlog")
      "- %U %?" :prepend t)

     ("d" "Daily todo/summary/note")
     ("dt" "Daily TODO" plain
      (file+function bullet-org im-org-capture--find-daily-last-entry)
      "** TODO [#B] %?")
     ("ds" "Daily summary" item
      (file+function bullet-org im-org-capture--find-daily-summary)
      "- %U %?")
     ("dn" "Daily note" item
      (file+function bullet-org im-org-capture--find-daily-notes)
      "- %U %?"
      :prepend t)
     ("dN" "Daily note (for capturing from Signal)" item
      (file+function bullet-org im-org-capture--find-daily-notes)
      "%U %c"
      :prepend t
      :immediate-finish t)

     ("s" "Snippets")
     ("ss" "Snippet" entry
      (file+function snippets-org im-org-capture--find-snippet)
      "** ")
     ("so" "One liner snippet" item
      (file+function snippets-org im-org-capture--find-snippet-one-liner)
      "- %? :: ")

     ("D" "Diary" entry
      (file diary-org)
      "* %u\n"
      :prepend t)
     ("c" "Meeting/clock note" item
      (clock))))

  (defun im-org-capture--find-daily-notes ()
    (im-bullet-focus-today)
    (re-search-forward "^** Notes" nil t))

  (defun im-org-capture--find-daily-last-entry ()
    (im-bullet-focus-today)
    (re-search-forward "^** Notes" nil t)
    (forward-line -1)
    (end-of-line))

  (defun im-org-capture--find-daily-summary ()
    (im-bullet-focus-today)
    (re-search-forward "^** Summary" nil t))

  (defun im-org-capture--find-snippet ()
    (let* ((mode-name (with-current-buffer (org-capture-get :original-buffer)
                        (symbol-name major-mode)))
           (result (org-find-exact-headline-in-buffer mode-name)))
      (if result
          (goto-char result)
        (goto-char (point-min))
        (re-search-forward (concat "^\\(" org-outline-regexp "\\)") nil t)
        (forward-line -1)
        (insert (format "\n* %s" mode-name)))))

  (defun im-org-capture--find-snippet-one-liner ()
    (im-org-capture--find-snippet)
    (unless (re-search-forward "\\*\\* One-liners" nil t)
      (end-of-line)
      (insert "\n** One-liners")))
#+end_src
** org-refile
#+begin_src emacs-lisp
  (setq org-refile-targets '((nil . (:maxlevel . 2))))
#+end_src
** org-modern
#+begin_src emacs-lisp
  (use-package org-modern
    :config
    (add-hook 'org-mode-hook #'org-modern-mode))
#+end_src
** org-rainbow-tags
#+begin_src emacs-lisp
  (use-package org-rainbow-tags
    :custom
    (org-rainbow-tags-hash-start-index 6)
    (org-rainbow-tags-extra-face-attributes
     '(:inverse-video t :box nil :weight 'bold))
    :hook
    (org-mode . org-rainbow-tags-mode))
#+end_src
** org-clock
This prints the text that is used by polybar to show what I am clocking right now. See my [[../index.org::* Polybar][Polybar]] config where I utilize this function.

#+begin_src emacs-lisp
  (defun im-format-polybar-clock-string ()
    (if (org-clocking-p)
        (format "⏲ [%s] %s "
                (org-duration-from-minutes (org-clock-get-clocked-time))
                org-clock-heading)
      "⏸"))

  (setq org-clock-clocked-in-display nil)
  ;; ^ I show it on polybar or gnome bar, so I don't need it on modeline
#+end_src

** org-ql
#+BEGIN_SRC emacs-lisp
  (use-package org-ql
    :after org
    :config
    ;; Load org-ql-search prematurely to be able to use org-ql blocks in
    ;; org-mode
    (require 'org-ql-search))
#+END_SRC

Here are some utility functions that I use in org-ql dynamic blocks:

#+begin_src emacs-lisp
  (defun sort-by-num-prop (prop x y)
    (< (string-to-number (or (org-element-property prop y) "0"))
       (string-to-number (or (org-element-property prop x) "0"))))

  (defun sort-by-prop (prop x y)
    (string< (or (org-element-property prop y) "")
             (or (org-element-property prop x) "")))
#+end_src

You have to use ~:sort (lambda ...)~ syntax in org-ql dynamic blocks if you want to supply a function for the ~:sort~ parameter. You can't use a function that returns a lambda, hence the functions defined above should be used like this:

#+begin_example
  ,#+begin: org-ql :query ... :sort (lambda (x y) (sort-by-num-prop :RATING x y))
  ,#+end
#+end_example

** Linking improvements
Org does not provide an easy way to copy link at point. Here is a fix for that:

#+begin_src emacs-lisp
  ;; Source: https://emacs.stackexchange.com/a/60555
  (defun im-org-link-copy ()
    "Extract URL from org-mode link and add it to kill ring."
    (interactive)
    (let* ((link (org-element-lineage (org-element-context) '(link) t))
           (type (org-element-property :type link))
           (url (org-element-property :path link))
           (url (when (and type url (not (s-blank? url))) (concat type ":" url))))
      (when (called-interactively-p 'any)
        (message (concat "Copied URL: " (im-kill url))))
      url))

  (defun im-org-store-link-dwim ()
    "Like `org-store-link' but if point is on an org-link, just copy
    it to clipboard. Otherwise call `org-store-link'."
    (interactive)
    (if (org-in-regexp org-link-any-re 1)
        (call-interactively #'im-org-link-copy)
      (org-store-link nil t)))
#+end_src

This following trick (got it from [[https://www.reddit.com/r/emacs/comments/o68i0v/weekly_tips_tricks_c_thread/h2rizey?utm_source=share&utm_medium=web2x&context=3][this]] comment) simply calls =C-h .= (=display-local-help=) when idle, which shows the destination of links in the echo area (and maybe displays other helpful stuff).

#+begin_src emacs-lisp
  (defun im-help-at-point-mode ()
    "Show tooltips in the echo area automatically for current buffer."
    (interactive)
    (setq-local help-at-pt-display-when-idle t)
    (setq-local help-at-pt-timer-delay 0)
    (help-at-pt-cancel-timer)
    (help-at-pt-set-timer))

  (add-hook 'org-mode-hook #'im-help-at-point-mode)
#+end_src

Insert links/images more intelligently,
- if region is selected and there is a url in the clipboard, convert it to a link directly.
- if nothing is selected and there is a link in clipboard, just insert it as a link with the link's own title.
- if clipboard has in image in it, save that into a file that you interactively select and then insert it into the buffer.
- otherwise call ~org-insert-link~

#+begin_src emacs-lisp
  (evil-leader/set-key "oP" #'im-org-insert-dwim)

  (defun im-org-insert-dwim ()
    "Like `org-insert-link' but improved with dwim features.
      Based on: https://xenodium.com/emacs-dwim-do-what-i-mean/"
    (interactive)
    (let* ((point-in-link (org-in-regexp org-link-any-re 1))
           (clipboard-url (when (string-match-p "^http" (current-kill 0))
                            (current-kill 0)))
           (region-content (when (region-active-p)
                             (buffer-substring-no-properties (region-beginning)
                                                             (region-end)))))
      (cond
       ((im-clipboard-contains-image-p)
        (call-interactively 'im-org-attach-image-from-clipboard))
       ((and region-content clipboard-url (not point-in-link))
        (delete-region (region-beginning) (region-end))
        (insert (org-make-link-string clipboard-url region-content)))
       ((and clipboard-url (not point-in-link))
        (insert (im-org-make-link-string clipboard-url)))
       (t
        (call-interactively 'org-insert-link)))))

  (defun im-org-attach-image-from-clipboard (&optional file-path)
    "Attach the image in the clipboard into your org-buffer.
      This function saves the image file into the FILE-PATH or
      if it's not provided then it saves the image into ~/.cache."
    (interactive "FSave file to (leave empty to create a temp file): ")
    (let ((file (if (and file-path (not (string-empty-p file-path)))
                    (file-relative-name file-path)
                  (make-temp-file "~/.cache/org_temp_image_" nil ".png"))))
      (if (im-save-clipboard-image-to-file file)
          (insert (format "#+ATTR_ORG: :width 400\n[[file:%s]]" file))
        (user-error "Saving file failed!"))))

  (defun im-org-make-link-string (url)
    "Like `org-make-link-string' but fetches URL and extracts the
  title automatically. Also adds author and duration info to
  YouTube links."
    (cond
     ((im-youtube-link-extract-id url) (im-org-format-youtube-link url))
     (t (org-link-make-string url (im-url-get-title url)))))

  ;; YouTube related

  (defun im-youtube-link-extract-id (link)
    (nth 4 (s-match "https?://\\(www\\.\\)?\\(youtu\\.be\\|youtube.com\\)/\\(watch\\?v=\\)?\\([a-zA-Z0-9_-]+\\)\\(\\?\\|&\\)?/?" link)))

  (defun im-org-format-youtube-link (link)
    "Format given YouTube link as org-mode link.
  Length, author, title etc. are appended to the link."
    (let ((id (im-youtube-link-extract-id link)))
      (let-alist (im-request (format "%s/videos/%s" empv-invidious-instance id))
        (org-link-make-string
         link
         (format "%0.2f mins, by %s || %s" (/ .lengthSeconds 60.0) .author .title)))))
#+end_src

** Insert image with width
This function is especially useful when used in combination with =embark-act-all=. The workflow is as follows:
- =M-x= =im-org-insert-image-file-with-width=
- Filter the files that you want to insert to your buffer.
- Hit enter if there is only one item.
- If there are multiple items that you want to insert, do =M-a= (embark-act) and then =S= (=embark-collect-snapshot=).
- Then you can do =embark-act-all= or just hit enter on the items that you want to insert to your buffer.

#+begin_src emacs-lisp
  (defun im-org-insert-image-file-with-width ()
    "Insert interactively selected image file with fixed width information."
    (interactive)
    (let ((fname (file-relative-name (read-file-name "Select file: "))))
      (insert (format "#+ATTR_ORG: :width 400\n[[file:%s]]\n\n" fname))))
#+end_src

** Renaming files under cursor
#+begin_src emacs-lisp
  (defun im-org-rename-file-at-point ()
    "Interactively rename the file under cursor and update the link."
    (interactive)
    (let* ((link (org-element-context))
           (type (org-element-property :type link))
           (path (org-element-property :path link))
           (begin (org-element-property :begin link))
           (end (org-element-property :end link))
           (cbegin (org-element-property :contents-begin link))
           (cend (org-element-property :contents-end link))
           content)
      (unless (equal type "file")
        (user-error "Link is not a file"))
      (when (and cbegin cend)
        (setq content (format "[%s]" (buffer-substring-no-properties cbegin cend))))
      (let ((use-relative? (not (file-name-absolute-p path)))
            (fname (read-file-name "New name: "
                                   (expand-file-name
                                    (file-name-directory path))
                                   path)))
        (when use-relative?
          (setq fname (concat "./" (file-relative-name fname))))
        (save-excursion
          (rename-file path fname)
          (delete-region begin end)
          (insert (format "[[file:%s]%s]"
                          fname
                          (or content "")))))))
#+end_src

** Project management
I'm doing all of my project management in org-mode. Here you can find some supplementary functionality that makes project management within org-mode easy.

*** Do a regexp search in a project inside a org dynamic block
Here I create a dynamic block for org-mode, named ~project-grep~. You can create a block like the following:

#+begin_example
  ,#+begin: project-grep :root "~/Workspace/projects/dotfiles" :regexp "TODO"
  ,#+end
#+end_example

When you invoke =C-c C-c= on that block, it will automatically run given REGEXP in given ROOT and create a nicely formatted table containing all the results. Results are formatted into org-links you can easily jump into.

#+begin_src emacs-lisp
  (defun org-dblock-write:project-grep (params)
    "Do a regular expression search in given project.
  PARAMS may contain `:root' or `:regexp'.

  `:root' - Where to run the search. If it's skipped, it's
  `default-directory'.

  `:regexp' - Regexp to grep in given folder. If it's skipped it
  searches for TODO/FIXME items in given folder."
    (let* ((root (or (plist-get params :root) default-directory))
           (regexp (or (plist-get params :regexp) "(//|#|--|;)+ ?(TODO|FIXME)"))
           (default-directory root))
      (--map (insert (format "%s | " it)) '("" "ID" "File" "Content"))
      (insert "\n")
      (insert "|-|\n")
      (--each-indexed
          (s-split
           "\n"
           (shell-command-to-string (format "rg --line-number '%s'" regexp))
           'omit-nulls)
        (let* ((data (s-split-up-to ":" it 2))
               (file (s-join ":" (-take 2 data)))
               (file-link (concat "[[file:" default-directory "/" (s-replace ":" "::" file) "][" file "]]"))
               (content (s-replace "|" " \\vert " (-last-item data))))
          (insert "| ")
          (insert (format "%s" it-index))
          (insert " | ")
          (insert file-link)
          (insert " | ")
          (insert content)
          (insert " |\n"))))
    (delete-char 1)
    (org-table-align))
#+end_src

** Archiving URLS
#+begin_src emacs-lisp
  (defvar im-org-archive-url-path "~/Documents/notes/data/archvive/")

  (defun im-org-archive-url ()
    "Archive URL and generate an new org entry for it."
    (interactive)
    (let (url update?)
      ;; If we are on a heading and calling this function, we probably
      ;; just want to update/initialize the archive for current
      ;; heading. Otherwise we are creating a new archive.
      (if-let ((_ (org-at-heading-p))
               (old-url (org-entry-get nil "URL")))
          (progn
            (setq url old-url)
            (setq update? t))
        (progn
          (setq url (read-string "URL: "))
          (org-insert-heading)))

      ;; Precautionary call
      (org-id-get-create)

      (let* ((url-title (read-string "Title: " (im-url-get-title url)))
             (archive-path (format
                            "%s/%s_%s_%s.html"
                            im-org-archive-url-path
                            (org-id-get-create)
                            (format-time-string "%Y%m%dT%H%M%S")
                            (im-string-url-case url-title))))
        (org-set-property
         "ARCHIVED_AT"
         (format "%s[[file:./%s][%s]]"
                 (if-let ((older-archives (org-entry-get nil "ARCHIVED_AT")))
                     (format "%s, " older-archives)
                   "")
                 (f-relative archive-path)
                 (format-time-string "%Y-%m-%dT%H:%M")))
        (unless update?
          (insert (org-make-link-string url url-title)))

        (org-set-property "URL" url)
        (unless (org-entry-get nil "CREATED")
          (org-set-property "CREATED" (format-time-string "[%Y-%m-%d %a %H:%M]")))

        ;; Create the archive
        (f-mkdir im-org-archive-url-path)
        (im-archive-url
         url
         :where archive-path
         :tidy t))))

  (add-to-list
   'org-capture-templates
   `("b" "Bookmark" entry
     (file+headline ,bookmarks-org "Unsorted")
     "** (call-interactively #'im-org-archive-url)"))
#+end_src
* Other packages
** outline-mode
This is a built-in mode for providing basic outlining features. Here are a few configurations to make the navigation a bit more like what I use in org-mode:

#+begin_src emacs-lisp
  (evil-define-key 'normal outline-mode-map
    (kbd "[[") #'outline-previous-heading
    (kbd "]]") #'outline-next-heading)
#+end_src

** debugger-mode
#+begin_src emacs-lisp
  (evil-set-initial-state 'debugger-mode 'normal)
#+end_src
** eat & eshell
#+begin_src emacs-lisp
  (setq eshell-history-size 10000)

  (use-package eshell-syntax-highlighting
    :after eshell-mode
    :config
    (eshell-syntax-highlighting-global-mode +1))

  (use-package eat
    :straight (:repo "https://codeberg.org/akib/emacs-eat.git")
    :config
    (eat-eshell-mode))

  (defun im-eshell (name)
    (interactive (list (read-string "Bufffer name: " "$eshell: ")))
    (with-current-buffer (eshell t)
      (rename-buffer name t)
      (current-buffer)))

  (defun im-eshell-send-input (input)
    (eat--send-input t input))

  (defun im-eshell-send-key (key)
    (eat-self-input 1 key))

  (defun im-eshell-vertically ()
    (interactive)
    (select-window (split-window-vertically))
    (call-interactively #'im-eshell))

  (defun im-eshell-horizontally ()
    (interactive)
    (select-window (split-window-horizontally))
    (call-interactively #'im-eshell))

  (evil-define-key 'insert eshell-mode-map (kbd "C-r") #'consult-history)
  (evil-define-key 'normal 'global (kbd "M-_") #'im-eshell-vertically)
  (evil-define-key 'normal 'global (kbd "M-|") #'im-eshell-horizontally)
#+end_src

*** Reading bash/zsh aliases into Eshell
#+begin_src emacs-lisp
  (defun im-eshell-load-my-aliases ()
    "Load zsh/bash aliases into eshell.
  '$*' is appended after each alias so that they can take
  positional parameters in eshell. There is also a special syntax
  for defining eshell-specific aliases that is read verbatim:

  #eshell test='ls'
  "
    (interactive)
    (setq
     eshell-command-aliases-list
     (-filter
      #'identity
      (--map
       (-when-let ((_ eshell? name imp)
                   (s-match "^\\(alias\\|#eshell\\) \\([a-zA-Z0-9_-]+\\)='\\(.*\\)'\\( *#.*\\)*$" it))
         (list name (if (s-prefix? "#eshell" eshell?)
                        imp
                      (concat imp " $*"))))
       (--mapcat
        (s-split "\n" (with-temp-buffer (insert-file-contents it) (buffer-string)))
        (directory-files "~/.config/aliases/" t directory-files-no-dot-files-regexp))))))

  (add-hook 'eshell-alias-load-hook #'im-eshell-load-my-aliases)
#+end_src

*** Eshell-specific aliases
Look at [[id:0B508237-3BBE-416A-A6AD-31C5C78340DB][Aliases]] section in my config to see all bash/zsh aliases. These are eshell specific:

#+begin_src bash :tangle ~/.config/aliases/eshell
  #eshell clear='clear 1'
#+end_src

*** Automatically print notes for given directory
I have the file ~im-autodir-file~ which contains notes for directories, like in the following format:

#+begin_src org :tangle no
  ,* ~/a/directory
  Here are my notes for the directory...

  ,* ~/another/directory: This one contains some source code
  Use the following to compile this:
  ...
#+end_src

When I enter any of the listed directories, eshell automatically prints out my notes.

#+begin_src elisp
  (defvar im-autodir-file "~/Documents/notes/directory-notes.org")
  (defvar im-autodir-last-doc nil)

  (defun im-eshell-handle-dir-change ()
    (let ((dir (expand-file-name default-directory)))
      (setq im-autodir-last-doc
            (with-current-buffer (find-file-noselect im-autodir-file)
              (catch 'found
                (org-map-entries
                 (lambda ()
                   (when (->>
                          (org-entry-get nil "ITEM")
                          (s-split ":")
                          (car)
                          (file-name-as-directory)
                          (expand-file-name)
                          (equal dir))
                     (throw 'found (buffer-substring-no-properties
                                    (org-element-property :contents-begin (org-element-at-point))
                                    (org-element-property :contents-end (org-element-at-point))))))
                 "LEVEL=1")
                nil)))
      (when im-autodir-last-doc
        (insert "im-autodir-show-doc")
        (eshell-send-input))))

  (defun im-autodir-show-doc ()
    im-autodir-last-doc)

  (add-hook 'eshell-directory-change-hook #'im-eshell-handle-dir-change)
  ;; eshell-directory-change-hook is not get triggered when eshell is opened, hence:
  (add-hook 'eshell-mode-hook #'im-eshell-handle-dir-change)
#+end_src
** bookmark.el
You can use ~list-bookmarks~ command to view/edit/delete them but using ~consult-bookmark~ and calling ~embark-act~ on them to view/delete/edit given bookmark might be easier.

#+begin_src emacs-lisp
  (setq bookmark-save-flag 1)
  ;; ^ Save bookmarks automatically

  (evil-leader/set-key
    "bs" #'bookmark-set
    "bm" #'consult-bookmark)
#+end_src
** process-menu-mode
#+begin_src emacs-lisp
  (evil-define-key 'normal process-menu-mode
    "x" #'process-menu-delete-process)
#+end_src
** timer-list-mode
#+begin_src emacs-lisp
  (evil-define-key 'normal timer-list-mode-map
    "x" #'timer-list-cancel)
#+end_src
** tabulated-list-mode
- It's a built-in mode that shows some kind of tabulated data.
- It is used by many major modes, like [[docker]], [[prodigy]], etc. I just add these common keybindings to have a consistent way of navigating in them.
- I also try to bind following keys in their respective mode maps:
  - =a= key to a function that lists all the actions that can be taken on current column.
  - =Enter= to the default action (generally opening something etc.)

#+begin_src emacs-lisp
  (use-package tabulated-list
    :config
    (evil-define-key 'normal tabulated-list-mode-map
      (kbd "{") #'tabulated-list-narrow-current-column
      (kbd "}") #'tabulated-list-widen-current-column
      (kbd "H") #'tabulated-list-previous-column
      (kbd "L") #'tabulated-list-next-column
      (kbd "s") #'tabulated-list-sort
      (kbd "r") #'tabulated-list-revert))
#+end_src

** alert
Several packages are using this package to show system-level notifications. Here I set some defaults/fallback values.

#+begin_src emacs-lisp
  (use-package alert
    :config
    (setq alert-fade-time 15)
    (setq alert-default-style (pcase system-type
                                ('gnu/linux 'libnotify)
                                ;; osx-notifier having troubles showing
                                ;; messages with Turkish characters
                                ('darwin 'osx-notifier)
                                (_ 'message))))

  (define-advice alert (:after (msg &rest args) send-to-my-phone-if-urgent)
    "Send the notification to my phone if it's marked as urgent/high."
    (pcase (plist-get args :severity)
      ((or 'urgent 'high)
       ;; Only send notification to phone if Emacs is idle for 60 secs
       (when (and (current-idle-time)
                  (>= (time-to-seconds (current-idle-time)) 60))
         (im-send-notification-to-my-phone
          :title (or (plist-get args :title) "Emacs")
          :content msg)))))
#+end_src

** Hydra
Hydra creates a menu for quickly calling/toggling functions/modes in a visually easy way. My main use case for it right now is grouping bunch of appearance related functions/modes that I use infrequently. I believe for hydra's are not very useful for commands that you use frequently, it makes things slower than a plain keybinding but it's quite useful for the stuff that you forget or use infrequently.

#+begin_src emacs-lisp
  (use-package hydra
    :config)

  (use-package use-package-hydra
    :after hydra)

  (use-package pretty-hydra
    :after hydra
    :config
    (pretty-hydra-define appearance
      (:foreign-keys warn :title "Appearance" :quit-key "q" :color amaranth)
      ("Display"
       (("W" writeroom-mode "Writeroom mode" :toggle t)
        ("n" display-line-numbers-mode "Line numbers" :toggle t)
        ("+" default-text-scale-increase "Zoom In")
        ("-" default-text-scale-decrease "Zoom Out"))
       "Highlighting"
       (("g" diff-hl-mode "Highlight git diff" :toggle t)
        ("d" rainbow-delimiters-mode "Rainbow parens" :toggle t)
        ("=" global-hl-line-mode "Highlight current line" :toggle t)
        ("b" beacon-mode "Cursor trailer (baecon)" :toggle t)
        ("w" im-whitespace-mode-toggle "Whitespaces" :toggle t)
        ("t" highlight-thing-mode "Highlight current symbol" :toggle t))
       "Miscellaneous"
       (("l" visual-line-mode "Wrap lines" :toggle t)
        ("T" toggle-truncate-lines "Truncate lines")
        ("v" visual-fill-column-mode "Wrap lines at 72th col" :toggle t)
        ("i" highlight-indent-guides-mode "Indent Guides" :toggle t)
        ("f" fci-mode "Fill column" :toggle t)
        ("<SPC>" nil "Quit" :color blue))))

    (evil-leader/set-key
      "a" #'appearance/body))
#+end_src
** wgrep
With this package, you can make =grep= buffers editable and your edits can be applied to the files itself. Also =embark= has a feature where you can export the current completing-read results into a grep buffer, the action is called =embark-export= and it works on =consult-ripgrep= etc.
- Do ~C-c C-p~ (or =i=, enabled by evil-collection) on a =grep= buffer to make it editable.
- Do ~C-j~ or ~C-k~ (enabled by evil-collection, by default you need to use =n=) to peek at next/prev instance.

#+begin_src emacs-lisp
  (use-package wgrep)
#+end_src
** dired/dirvish
There is also ~wdired-mode~ which you can use to do bulk rename intuitively.

#+begin_src emacs-lisp
  (use-package dired
    :straight (:type built-in)
    :config
    (setq dired-dwim-target t)
    (setq dired-listing-switches "-l -A -h -v --group-directories-first")
    (setq ls-lisp-dirs-first t)
    (setq ls-lisp-use-insert-directory-program nil)
    (setq dired-kill-when-opening-new-dired-buffer t)
    (setq dired-clean-confirm-killing-deleted-buffers nil)
    (setq dired-recursive-copies 'always)
    (setq dired-recursive-deletes 'always)
    (setq dired-dwim-target t)
    (put 'dired-find-alternate-file 'disabled nil))

  (use-package dirvish
    :straight (:host github :repo "alexluigit/dirvish")
    :config
    (setq dirvish-subtree-always-show-state t)
    (setq dirvish-attributes '(vc-state subtree-state all-the-icons collapse git-msg file-size))

    ;; Other keybindings comes from dired-mode (which comes from
    ;; evil-collection)
    (evil-define-key 'normal dirvish-mode-map
      "h" #'dired-up-directory
      "l" #'dired-find-alternate-file
      (kbd "<tab>") #'dirvish-toggle-subtree)

    ;; Re-direct direct-jump calls to dirvish
    (dirvish-override-dired-mode)
    (evil-leader/set-key "ed" #'dired)

    (setq dirvish-side-width 50)
    (evil-define-key 'normal 'global
      (kbd "M-f") #'dirvish-side)

    (add-hook 'dired-mode-hook #'(lambda () (visual-line-mode -1))))
#+end_src
*** im-dired-rsync
Dired copies files sync. This function uses rsync to copy stuff async, especially useful while copying stuff over tramp/ssh.

#+begin_src emacs-lisp
  (defun im-dired-rsync (dest)
    "Copy selected files with rsync to DEST.
  This works over TRAMP (but only ssh and remote to local is
  supported).

  NOTE: Use \"rsync --version\" > 3 or something like that."
    (interactive
     (list
      (expand-file-name
       (read-file-name
        "Copy selected files to:"
        (dired-dwim-target-directory)))))
    (let* ((files (dired-get-marked-files nil current-prefix-arg))
           (ssh-regexp "/ssh:\\([a-zA-Z0-9_-]+\\):")
           (fix-remote-files (lambda (it)
                               (if-let (host (nth 1 (s-match ssh-regexp it)))
                                   (concat host ":" (shell-quote-argument (string-trim-left it ssh-regexp)))
                                 it))))
      (im-shell-command
       :command "rsync"
       :args
       `("--archive" "--recursive" "--verbose" "--human-readable" "--partial" "--xattrs" "--info=progress2"
         ,@(when (--any? (s-matches? ssh-regexp it) files)
             '("-e" "ssh"))
         ,@(mapcar fix-remote-files files)
         ,dest)
       :on-finish
       (lambda (&rest _)
         (message ">> Files copied successfully."))
       :on-fail
       (lambda (&rest _)
         (message "!! Error while copying files.")))))
#+end_src
** image-mode
I want to be able to kill image buffers with simply hitting =q=. This does that.

#+begin_src emacs-lisp
  (evil-set-initial-state 'image-mode 'normal)
  (evil-define-key 'normal image-mode-map
    "q" #'evil-delete-buffer
    "r" #'image-rotate)
#+end_src

** calendar & diary & appt
#+begin_src emacs-lisp
  (evil-leader/set-key "ec" #'calendar)
  (evil-define-key 'normal diary-fancy-display-mode-map
    "q" #'evil-delete-buffer)

  ;; Start the week from Monday
  (setq calendar-week-start-day 1)

  ;; lng and lat for my location, to get sunrise/sunset times on my
  ;; calendar (press gs)
  (setq calendar-latitude 41.0082)
  (setq calendar-longitude 28.9784)

  ;; Use 24-hour format to display times
  (setq calendar-time-display-form
        '(24-hours ":" minutes (if time-zone " (") time-zone (if time-zone ")")))

  ;; Enable including other diary entries using the #include "..." syntax
  ;; I use this to separate my work and normal diary
  (add-hook 'diary-list-entries-hook #'diary-include-other-diary-files)
  (add-hook 'diary-list-entries-hook #'diary-sort-entries t)
  (setq diary-display-function #'diary-fancy-display)

  ;; Show calendar at the bottom
  (im-shackle-window "Calendar" 0.2)
#+end_src

*** Automatically syncing with remote calendars
I'm experimenting with using default Emacs calendar as my work calendar. To do so, I import the remote calendar into my diary using the following function. Set ~im-calendar-remote-ics-file~ to the url of ICS file beforehand.

You also need to import work diary file in your main diary file, like this:

#+begin_src diary
  #include "~/.emacs.d/.cache/work-diary"
#+end_src

#+begin_src emacs-lisp
  (defconst im-work-diary-path (expand-file-name "~/.emacs.d/.cache/work-diary"))

  (defun im-update-calendar ()
    "Sync emacs calendar/diary with my remote calendar."
    (interactive)
    (message ">> Updating the calender...")
    (url-retrieve
     im-calendar-remote-ics-file
     (lambda (status)
       (delete-region (point-min) url-http-end-of-headers)
       ;; Following is required because some diary entries may contain
       ;; Turkish characters and url-retrieve does not set
       ;; buffer-multibyte to t automatically
       (set-buffer-multibyte t)
       ;; Clean the work-diary first, so that items do not get
       ;; duplicated
       (with-current-buffer (find-file-noselect im-work-diary-path)
         (delete-region (point-min) (point-max)))
       (icalendar-import-buffer im-work-diary-path t)
       (message ">> Updating the calendar... DONE"))))
#+end_src

To sync it automatically:

#+begin_src emacs-lisp
  ;; (run-with-timer 60 (* 30 60) #'im-update-calendar)
#+end_src

*** appt.el: notifications for org-agenda and diary items
~appt.el~ shows notifications for upcoming events in your diary and in your org-agenda.

- By default appt shows only the entries found in diary and the included files in ~diary-file~
- If you want to add an appt but do not want to edit ~diary-file~, you can use ~appt-add~ which adds it to the ~appt-time-msg-list~.
- You can use ~appt-delete~ to remove appts from the list.
- ~appt-time-msg-list~ updated when
  - this package is initialized, aka ~(require 'appt)~
  - at 00:01
  - manually by ~appt-check~
  - manually by ~org-agenda-to-appt~
  - whenever ~diary-file~ (and the files it includes) is edited
  - whenever one of ~org-agenda-files~ is edited. (see below)

~appt-message-warning-time~ is the minutes before appt.el starts showing warnings and it shows warnings every ~appt-display-interval~ minutes until the event starts.

#+begin_src emacs-lisp
  (require 'appt)

  ;; Use my notification function for appt notifications
  (setq appt-disp-window-function #'im-appt-notify)
  (setq appt-message-warning-time 6)
  (setq appt-display-interval 3)

  ;; Automatically update `appt-time-msg-list' after editing an
  ;; org-agenda file
  (add-hook 'org-mode-hook #'im-org-agenda-to-appt-on-save)

  (defun im-org-agenda-to-appt-on-save ()
    (add-hook
     'after-save-hook
     (lambda ()
       (when (-contains? (org-agenda-files 'unrestricted) (buffer-file-name))
         (org-agenda-to-appt)
         (appt-check)
         (message ">> appt updated.")))
     nil t))

  (defun im-appt-notify (min-to-appt new-time appt-msg)
    (if (listp min-to-appt)
        (--each (-zip min-to-appt appt-msg)
          (im-appt-notify--helper (car it) new-time (cdr it)))
      (im-appt-notify--helper min-to-appt new-time appt-msg)))

  (defun im-appt-notify--helper (min-to-appt new-time appt-msg)
    (setq min-to-appt (string-to-number min-to-appt))
    (message ">> appt :: %s, remaining %s mins" appt-msg min-to-appt)
    (let ((important? (cond
                       ((s-contains? "meeting" (s-downcase appt-msg)) t)
                       (t nil))))
      (alert
       (im-org-header-line-to-title appt-msg)
       :title (format "Reminder, %s mins left" min-to-appt new-time)
       :severity (if important? 'high 'normal)
       :persistent important?
       :category 'appt
       :id appt-msg)))

  (save-window-excursion
    (appt-activate 1))
#+end_src

*** More org-mode and diary integration and utilities
#+begin_src emacs-lisp
  (defun im-diary-kill-entry-as-bullet-task (&optional include-description)
    "Copy current diary entry as a bullet.org task."
    (interactive "P")
    (-as->
     (thing-at-point 'line) it
     (s-match "\\([0-9]+:[0-9]+-[0-9]+:[0-9]+\\) \\(.*\\)" it)
     (format
      "** TODO [#A] %s :work:\nSCHEDULED: <%s %s>\n%s"
      (if-let ((link (ignore-errors (im-diary-entry-meeting-link))))
          (format "[[%s][%s]]" link (nth 2 it))
        (nth 2 it))
      (im-today)
      (nth 1 it)
      (if include-description (im-diary-entry-description) ""))
     (im-kill it)))

  (defun im-diary-entry-meeting-link ()
    "Get meeting/zoom link of current diary entry."
    (let ((entry-details (im-diary-entry-description)))
      (with-temp-buffer
        (insert entry-details)
        (goto-char (point-min))
        (re-search-forward "https://.*zoom")
        (thing-at-point 'url))))

  (defun im-diary-entry-description ()
    "Get details/description of current diary entry."
    (interactive)
    (save-window-excursion
      (push-button)
      (let ((beg (save-excursion
                   (re-search-backward "^[^ \n].+")
                   (forward-line)
                   (point)))
            (end (save-excursion
                   (re-search-forward "^[^ \n].+")
                   (beginning-of-line)
                   (point))))
        (im-kill (buffer-substring beg end)))))
#+end_src
*** Show week numbers in the calendar
#+begin_src emacs-lisp
  ;; https://www.emacswiki.org/emacs/CalendarWeekNumbers
  (defun im-calendar-week-number-mode ()
    "Show week numbers in M-x calendar."
    (copy-face font-lock-constant-face 'calendar-iso-week-face)
    (set-face-attribute 'calendar-iso-week-face nil :height 0.7)
    (setq
     calendar-intermonth-text
     '(propertize
       (format "%2d"
               (car
                (calendar-iso-from-absolute
                 (calendar-absolute-from-gregorian (list month day year)))))
       'font-lock-face 'calendar-iso-week-face)))

  (im-calendar-week-number-mode)
#+end_src

** tramp
#+begin_src emacs-lisp
  (setq tramp-default-method "ssh")
  (setq tramp-verbose 2)
  ;; ^ Only show errors and warnings
  (setq vc-handled-backends '(Git))
  ;; ^ Only try to handle git, this speeds up things a little bit
#+end_src

** w3m
*** Installation/Keybindings
#+begin_src emacs-lisp
  (use-package w3m
    :config
    (evil-define-key 'normal w3m-mode-map
      (kbd "&") (λ-interactive (funcall browse-url-secondary-browser-function w3m-current-url))
      (kbd "^") (λ-interactive (browse-url w3m-current-url))
      (kbd "K") #'w3m-next-buffer
      (kbd "J") #'w3m-previous-buffer
      (kbd "o") #'im-w3m-open-url-dwim
      (kbd "O") #'w3m-edit-url
      (kbd "t") (λ-interactive (im-w3m-open-url-dwim (read-string "URL: ") :new-session))
      (kbd "T") (λ-interactive (im-w3m-open-url-dwim (read-string "URL: " w3m-current-url) :new-session))
      (kbd "M-j") #'w3m-tab-move-left
      (kbd "M-k") #'w3m-tab-move-right
      (kbd "x") #'w3m-delete-buffer
      (kbd "Y") #'im-w3m-yank-url
      (kbd "f") #'im-w3m-avy-link
      (kbd "F") #'im-w3m-avy-link-new-session)
    (setq w3m-fill-column 80)
    (setq w3m-use-title-buffer-name t)
    (setq w3m-default-display-inline-images t)
    (setq w3m-use-tab-line nil)
    ;; (setq w3m-display-mode 'plain)
    (add-hook 'w3m-mode-hook #'(lambda () (setq-local scroll-margin 0)))
    (w3m-display-mode 'plain))

  (defun im-w3m-open-url-dwim (url &optional new-session)
    (interactive "sURL: ")
    (if (im-url? url)
        (if new-session (w3m-goto-url-new-session url) (w3m-goto-url url))
      (if new-session (w3m-search w3m-search-default-engine url) (w3m-search-new-session w3m-search-default-engine url))))
#+end_src

*** Extras
#+begin_src emacs-lisp
  (defun im-w3m-all-anchor-points (&optional start end)
    "Return all anchor points for current w3m buffer.
  If START and/or END is given, only return anchor points between
  START and END positions of the buffer, otherwise return all
  anchor points in the buffer."
    (let ((points (list))
          (start (or start (point-min)))
          (end (or end (point-max)))
          (prev 0))
      (save-excursion
        (goto-char start)
        (while (and (w3m-next-anchor)
                    (> (point) prev)
                    (<= (point) end))
          (setq prev (point))
          (when-let* ((url (w3m-url-valid (w3m-anchor)))
                      (_ (string-match "\\`https?:" url)))
            (push (point) points))))
      points))

  (defun im-w3m-avy-link ()
    "Jump to a link and open it automatically."
    (interactive)
    (avy-process (im-w3m-all-anchor-points (window-start) (window-end)))
    (w3m-goto-url (w3m-anchor)))

  (defun im-w3m-avy-link-new-session ()
    "Jump to a link and open it automatically."
    (interactive)
    (avy-process (im-w3m-all-anchor-points (window-start) (window-end)))
    (w3m-goto-url-new-session (w3m-anchor)))

  (defun im-w3m-yank-url ()
    "Copy current URL to clipboard."
    (interactive nil 'w3m-mode)
    (im-kill w3m-current-url))

  ;; Rename w3m buffer names in a way that works with my
  ;; `im-tab-line-buffers' implementation
  (define-advice w3m-buffer-name-add-title (:after (&rest _) rename-w3m-buffer-name)
    (when w3m-use-title-buffer-name
      (rename-buffer
       (format
        "*w3m: %s *w3m*<%d>" (w3m-current-title)
        ;; Lot's of functions on w3m depend on this number. Hence I left
        ;; it here. Ugly but not worth dealing with
        (w3m-buffer-number (current-buffer))))))
#+end_src

** eww
#+begin_src emacs-lisp
  (use-package eww
    :config
    ;; (setq shr-image-animate nil)
    ;; ^ Gifs make my computer suffer, so I just disable them
    (setq shr-max-image-proportion 0.6)
    (setq shr-discard-aria-hidden t)
    (setq shr-use-xwidgets-for-media t)
    (setq eww-auto-rename-buffer
          (lambda () (format "*eww: %s*" (or (plist-get eww-data :title) "..."))))

    (evil-define-key 'normal eww-mode-map
      "Y" #'eww-copy-page-url
      "d" #'im-eww-save-image
      "O" (λ-interactive (eww (read-string "URL: " (eww-current-url))))
      "t" (λ-interactive (eww (read-string "URL: ") :new-session))
      "T" (λ-interactive (eww (read-string "URL: " (eww-current-url)) :new-session))
      "f" #'im-eww-avy-follow
      "F" (λ-interactive (im-eww-avy-follow :new-session))
      "r" #'eww-reload
      "R" #'eww-readable
      "^" (λ-interactive (browse-url (eww-current-url)))
      "&" (λ-interactive (funcall browse-url-secondary-browser-function (eww-current-url))))
    (setq browse-url-secondary-browser-function #'browse-url-firefox)
    (setq browse-url-handlers
          '((".*jtracker.trendyol.*/browse/.*" . (lambda (link &rest _) (im-jira-view-ticket link)))
            (".*slack.com/archives/.*" . (lambda (link &rest _) (im-slack-open-link link)))
            (".*reddit.com/r/[a-zA-Z0-9_-]+/comments/[a-zA-Z0-9_-]+/\\([a-zA-Z0-9_-]+/?\\)?$" . (lambda (link &rest _) (reddigg-view-comments link)))
            (".*\\(stackoverflow.com\\|stackexchange.com\\).*" . (lambda (link &rest _) (im-open-stackexchange-link link)))
            (".*\\(youtube.com\\|youtu.be\\)/watch.*" . (lambda (link &rest _) (empv-play link)))
            (".*zoom.us/j/.*" . (lambda (link &rest _) (im-open-zoom-meeting-dwim link)))
            (".*\\(trendyol\\|gitlab\\|github\\|slack\\|docs.google\\).*" . (lambda (link &rest _) (xwidget-webkit-browse-url link)))
            ("." . w3m-goto-url)))

    (defun im-eww-avy-follow (&optional follow-type)
      (interactive)
      (let ((wend (window-end))
            (urls '()))
        (save-excursion
          (goto-char (window-start))
          (while-let ((match (text-property-search-forward 'shr-tab-stop nil nil t))
                      ((< (point) wend)))
            (goto-char (prop-match-beginning match))
            ;; (push (get-text-property (point) 'shr-url) urls)
            (push (point) urls)))
        (avy-process (nreverse urls))
        (pcase follow-type
          (:new-session
           (eww (get-text-property (point) 'shr-url) :new-session))
          (:external (eww-browse-with-external-browser  t))
          (_ (eww-follow-link)))))

    (evil-leader/set-key
      "ew" #'eww
      "eW" #'im-xwidget-webkit-open))

  (defun im-eww-save-image ()
    "Save the image at point."
    (interactive)
    (let ((image (get-text-property (point) 'display))
          ;; Disable all save hooks as they might damage the file
          (before-save-hook '())
          (after-save-hook '()))
      (unless (and image
                   (eq (car image) 'image))
        (user-error "No images at point!"))
      (with-temp-buffer
        (setq buffer-file-name
              (read-file-name "Save to: "  nil default-directory nil))
        (insert (plist-get (cdr image) :data))
        (save-buffer))))
#+end_src
** shell-mode
#+begin_src emacs-lisp
  (use-package shell
    :straight (:type built-in)
    :config
    (evil-define-key 'insert 'shell-mode-map (kbd "C-l") #'comint-clear-buffer))
#+end_src

** which-key
A package that shows key combinations. (for example press C-x and wait) It also works with ~evil-leader~, just press leader key and wait to see your options. I made a few adjustment so that it's more compact and you can see full function names (most of the time) and it shows up at the top center instead of bottom left corner. This mostly eliminates the need for creating a [[Hydra]].

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :diminish which-key-mode
    :config
    (setq which-key-min-display-lines 1)
    (setq which-key-max-display-columns 1)
    (setq which-key-max-description-length 70)
    (setq which-key-show-docstrings t)
    (setq which-key-idle-delay 0.5)
    (setq which-key-sort-order #'which-key-prefix-then-key-order)
    (which-key-mode))
#+END_SRC

** magit & vc
While I mainly use magit for version control stuff, ~vc~ has some nicer parts that I make use of. Like
- =vc-annotate= :: Faster and simpler alternative to =magit-blame=. (Bound to ~SPC gB~). Use =L= on line to show commit message.

Sometimes I use =vc= for pure speed. Because it supports multiple backends, the terminology is a bit different but here is how you stage and commit (keybindings are coming from [[evil-collection]]):
- =C-x v d= to open magit-status like status buffer.
- =TAB= to show diff of the file at point.
- =m/u= (vc-dir-mark) to mark/unmark files to take an action on them. You can also think this as staging if your next action is going to be committing.
- =c= (vc-next-action) to commit /staged/ files.

Note that it's not possible to stage hunks with =vc=.

*** Installation
- Read this for some useful status mode keymaps: https://endlessparentheses.com/it-s-magit-and-you-re-the-magician.html
  - y :: Branch viewer (delete branches with ~k~)
  - ll :: Log current
  - bs :: Branch spin-off; create and checkout to a new branch, carry over the ongoing changes. It also undoes the changes in the current branch
  - bc :: Branch create; you can directly create new branch from *origin/develop* for instance

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :config
    (define-advice magit-checkout (:after (&rest _) refresh-vc-state) (vc-refresh-state))
    (define-advice magit-branch-and-checkout (:after (&rest _) refresh-vc-state) (vc-refresh-state))
    (define-advice vc-create-branch (:after (&rest _) refresh-vc-state) (vc-refresh-state))
    (define-advice vc-switch-branch (:after (&rest _) refresh-vc-state) (vc-refresh-state))

    (evil-leader/set-key
      "gv" 'project-vc-dir
      "gd" 'vc-diff
      "gD" 'vc-root-diff
      "gn" 'vc-next-action
      "gs" 'magit-status
      "gS" 'magit-stash
      "gf" 'magit-file-dispatch
      "gp" 'vc-pull
      "gP" 'vc-push
      "gr" 'magit-reset
      "gcc" 'vc-switch-branch
      "gB" 'vc-annotate ;; Git Blame
      "gR" 'vc-refresh-state
      "gbc" 'vc-create-branch
      "gL" 'vc-print-root-log
      "gbb" 'magit-branch))
#+END_SRC

*** vc configuration
#+begin_src emacs-lisp
  (evil-define-key 'normal vc-dir-mode-map "r" #'vc-dir-refresh)

  ;; Magit like commit interface:
  ;; - Open commit window
  ;; - Clear all other windows
  ;; - Open diff
  ;; - When committed, kill diff buffer and window.
  ;; TODO Also kill diff buffer when C-c C-k is called on commit window

  (remove-hook 'log-edit-hook #'log-edit-show-files)
  (add-hook 'log-edit-hook #'im-vc-show-diff)

  (defvar im--last-log-diff-buffer nil)
  (defun im-vc-show-diff ()
    "Same as log-edit-show-diff but do not focus to the diff window."
    (let ((bname (buffer-name (current-buffer))))
      (delete-other-windows)
      (log-edit-show-diff)
      (setq im--last-log-diff-buffer (current-buffer))
      (im-select-window-with-buffer bname)))

  (add-hook
   'log-edit-done-hook
   #'(lambda ()
       (im-select-window-with-buffer (buffer-name im--last-log-diff-buffer))
       (when (equal (window-buffer) im--last-log-diff-buffer)
         (im-quit))
       (kill-buffer im--last-log-diff-buffer)))
#+end_src
*** git-timemachine
- Toggle with ~git-timemachine~ (SPC gt).
- When in timemachine mode,
  - use =gt<SOMETHING>= to do timemachine specific operations. Some useful ones are:
    - t -> =git-timemachine-show-revision-fuzzy=, selects a revision through completing-read interface.
    - y/Y -> Yank (abbreviated) revision hash.
  - ~C-j/k~ to go to prev/next revision of the file.

#+begin_src emacs-lisp
  (use-package git-timemachine
    :after magit
    :config

    (evil-leader/set-key  "gt" #'git-timemachine-toggle)

    ;; Override completing-read function to make it use
    ;; `completing-read' no matter what
    (defun git-timemachine-completing-read-fn (&rest args)
      (with-completing-read-exact-order
       (apply 'completing-read args))))
#+end_src

*** magit-delta (for diff syntax highlighting)
You need to install ~delta~ (or ~git-delta~) before to get this working. See [[https://github.com/dandavison/delta][here]].

#+begin_src emacs-lisp
  (use-package magit-delta
    :after magit
    :config
    (setq magit-delta-default-light-theme "GitHub")
    (setq magit-delta-default-dark-theme "Monokai Extended Bright")
    (setq magit-delta-hide-plus-minus-markers nil)

    ;; Apply diff colors to whole visual line
    ;; See https://github.com/dandavison/magit-delta/issues/6
    (set-face-attribute 'magit-diff-added-highlight nil :background "#002800")
    (set-face-attribute 'magit-diff-added nil :background "#002800")
    (set-face-attribute 'magit-diff-removed-highlight nil :background "#3f0001")
    (set-face-attribute 'magit-diff-removed nil :background "#3f0001")

    (add-hook 'magit-mode-hook (lambda () (magit-delta-mode +1)))
    (add-hook 'magit-delta-mode-hook #'im-delta-fix-bg-colors))

  (defun im-delta-fix-bg-colors ()
    (setq face-remapping-alist
          (seq-difference face-remapping-alist
                          '((magit-diff-removed . default)
                            (magit-diff-removed-highlight . default)
                            (magit-diff-added . default)
                            (magit-diff-added-highlight . default)))))
#+end_src

** diff-mode
Some small enhancments to diff mode:
- Cycle hunks with TAB, SHIFTTAB.
- Reverse hunks with "x" (like magit diff).
- Split hunks with "-", which enables you to split and then reverse so that you can reverse individual lines/portions etc.
- TODO: maybe add ability to stage hunks

#+begin_src emacs-lisp
  (add-hook 'diff-mode-hook #'outline-minor-mode)

  (evil-define-key 'normal diff-mode-map
    "r" #'vc-diff
    "x" #'im-diff-reverse-hunk
    "-" #'diff-split-hunk
    (kbd "RET") #'diff-goto-source
    (kbd "<tab>") #'outline-cycle
    (kbd "<backtab>") #'outline-cycle-buffer)

  (defun im-diff-reverse-hunk ()
    "Reverse hunk at point."
    (interactive)
    (pcase-let ((`(,buf ,_line-offset ,_pos ,_src ,_dst ,_switched)
                 (diff-find-source-location nil nil)))
      (when (y-or-n-p "Really want to revert?")
        (save-excursion
          (diff-apply-hunk :reverse)
          (with-current-buffer buf
            (save-buffer)))
        (diff-hunk-kill))))
#+end_src
** avy
avy is very similar to ~vim-easymotion~. It simply jumps to a visible text using a given char.
- =s= for jumping to beginning of a word
- =S= for jumping any part of the text
- =gl= for going into beginning of a line

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :config
    (setq avy-keys '(?q ?w ?e ?r ?t ?a ?s ?d ?f ?j ?k ?l ?u ?i ?o ?p)
          avy-case-fold-search nil
          avy-all-windows t)
    (evil-define-key 'normal 'global
      (kbd "S") #'avy-goto-subword-1
      (kbd "s") #'avy-goto-word-1))
#+END_SRC

** vertico & marginalia & orderless & mini-frame
A nice, fast minibuffer narrowing framework. It works well with quite a lot of package.
- =marginalia.el= brings annotations to completing-read, ie. it adds current keybinding of a command, summary of command to M-x.
- =miniframe.el= shows all completing-read prompts in a nice mini popup frame.
- Also see [[embark]].

Keybindings:
- =SPC 0= to repeat/open last vertico window you closed.

Some shortcuts you can use on any vertico window:
- =M-{n,p}= goes {back,forward} in minibuffer history.
- =M-{[,]}= goes {previous,next} group.
- =M-m= cycles the marginalia detail level.
- =M-a= brings up embark-act menu. See [[embark]].
- =M-w= copy the current candidate.
- =TAB= inserts the current candidate (into minibuffer).

#+begin_src emacs-lisp
  (use-package vertico
    :config
    ;; Grow and shrink the Vertico minibuffer
    ;; (setq vertico-resize t)

    ;; Show more candidates
    (setq vertico-count 15)
    ;; Enable cycling for `vertico-next' and `vertico-previous'.
    (setq vertico-cycle t)
    ;; Hide commands in M-x which do not work in the current mode.
    (setq read-extended-command-predicate #'command-completion-default-include-p)

    ;; Add prompt indicator to `completing-read-multiple'.
    (defun crm-indicator (args)
      (cons (concat "[CRM] " (car args)) (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

    ;; Enable recursive minibuffers
    (setq enable-recursive-minibuffers t)
    (define-key vertico-map (kbd "M-[") #'vertico-previous-group)
    (define-key vertico-map (kbd "M-]") #'vertico-next-group)

    ;; Use `consult-completion-in-region' which works with vertico
    (setq completion-in-region-function #'consult-completion-in-region)

    (vertico-mode))
#+end_src

Here I enable a few extensions for vertico:

#+begin_src emacs-lisp
  ;; Load vertico extensions
  (add-to-list 'load-path (expand-file-name (format "%sstraight/build/vertico/extensions" straight-base-dir)))

  ;; Enable avy style candidate selection
  (use-package vertico-quick
    :ensure nil
    :straight nil
    :after vertico
    :config
    (setq vertico-quick1 "asdfgqwe")
    (setq vertico-quick2 "hjklui")
    (define-key vertico-map "\M-q" #'vertico-quick-exit))

  (use-package vertico-repeat
    :ensure nil
    :straight nil
    :after vertico
    :config
    (add-hook 'minibuffer-setup-hook #'vertico-repeat-save)
    (evil-leader/set-key "0" #'vertico-repeat))

  ;; Enable showing vertico in a buffer instead of minibuffer
  (use-package vertico-buffer
    :ensure nil
    :straight nil
    :after vertico)

  ;; Switch between different vertico display forms for different commands
  (use-package vertico-multiform
    :ensure nil
    :straight nil
    :after vertico
    :config
    ;; Toggle grid mode by hitting M-G while in vertico
    ;; Toggling grid mode does not work well with mini-frame.
    (define-key vertico-map "\M-G" #'vertico-multiform-grid)

    ;; '(command display-type... (buffer-local-variable . value))
    ;; vertico README explains this very well
    (setq vertico-multiform-commands
          '((consult-org-heading
             buffer
             (vertico-buffer-display-action . (display-buffer-in-side-window
                                               (side . right)
                                               (window-width . 0.4))))
            (consult-imenu
             buffer
             (vertico-buffer-display-action . (display-buffer-in-side-window
                                               (side . right)
                                               (window-width . 0.4))))))
    (vertico-multiform-mode))

  ;; Enable displaying candidates in a grid.
  (use-package vertico-grid
    :ensure nil
    :straight nil
    :after vertico)
#+end_src

Other complementary packages:

#+begin_src emacs-lisp
  (use-package orderless
    :config
    (setq completion-styles '(orderless partial-completion basic))
    (setq completion-category-defaults nil)
    (setq completion-category-overrides '((file (styles partial-completion)))))

  (use-package marginalia
    :config
    (define-key minibuffer-local-map (kbd "M-m") #'marginalia-cycle)
    (marginalia-mode))

  (use-package mini-frame
    :config
    (setq mini-frame-show-parameters
          '((top . 0.15)
            (width . 0.70)
            (left . 0.5)
            ;; https://github.com/minad/vertico/issues/115#issuecomment-973753577
            ;; Not needed on emacs 29
            (no-accept-focus . t)))
    (setq mini-frame-color-shift-step 15)

    ;; Disable mini-frame while using some functions either that does
    ;; not work well with mini-frame or it doesn't make sense to use it
    ;; with mini-frame
    (setq mini-frame-ignore-commands
          '(completion-at-point
            evil-ex
            ctrlf-forward-default
            tab-jump-out
            consult-line
            consult-ripgrep
            consult-bookmark
            jq-interactively
            im-consult-ripgrep
            consult-org-heading
            consult-imenu))
    ;; (mini-frame-mode +1)
    )
#+end_src
** ~project.el~ and project management
~(project-remember-projects-under im-projects-root t)~ does not work as I expect, so I add all of my projects using a custom function that returns all of my projects' paths.

#+begin_src emacs-lisp
  (defconst im-projects-root "~/Workspace/projects")

  (defun im-current-project-root ()
    "Return the root path of current project."
    (interactive)
    (ignore-errors
      (expand-file-name (project-root (project-current)))))

  (defun im-current-project-name ()
    "Return current projects name."
    (if-let ((curr-proj (im-current-project-root))
             (projects-root (expand-file-name im-projects-root)))
        (if (string-prefix-p projects-root curr-proj)
            (string-trim (string-remove-prefix projects-root curr-proj) "/" "/")
          (file-name-nondirectory (directory-file-name curr-proj)))
      (file-name-nondirectory (directory-file-name default-directory))))

  (defun im-is-git-dir (dir)
    (file-directory-p (concat dir "/.git")))

  (defun im-all-project-roots ()
    "Find every project dir under `im-projects-root'.
  It simply checks for folders with `.git' under them."
    (->>
     (expand-file-name im-projects-root)
     (format "fd . '%s' --type directory --maxdepth 4 --absolute-path")
     (shell-command-to-string)
     (s-trim)
     (s-split "\n")
     (--filter (im-is-git-dir it))
     (--map (abbreviate-file-name (f-full it)))))

  (defalias 'im-import-projects #'im-load-projects-list)
  (defun im-load-projects-list ()
    (interactive)
    ;; Ensure all projects are known by project.el
    ;; The following does not recurse as I like it to be
    ;; (project-remember-projects-under im-projects-root t)
    (setq project--list '())
    (--each (--map (project-try-vc it) (im-all-project-roots))
      (project-remember-project it t)))

  (run-with-timer 10 nil #'im-load-projects-list)
#+end_src

- project.el offers ~C-x p~ keymap with very useful bindings. I also keep my project related bindings under ~SPC p~.
- After doing ~project-switch-project~, you are expected to hit a key to trigger a project action, like finding a file in the project or doing a project grep. You need to add these actions into ~project-switch-commands~ list and you need to define a key in ~project-prefix-map~ (that is ~C-x p~) to make it triggerable by given key.

#+begin_src emacs-lisp
  (evil-leader/set-key "p" (λ-interactive
                            (if-let (root (im-current-project-root))
                                (project-switch-project root)
                              (call-interactively #'project-switch-project))))

  (setq project-switch-commands
        '((project-find-file "Find file")
          (project-find-dir "Find directory")
          (project-eshell "Eshell")))

  (define-key project-prefix-map "s" #'project-switch-project)
  (add-to-list 'project-switch-commands `(project-switch-project "Switch"))

  (define-key project-prefix-map "g" #'im-consult-ripgrep)
  (add-to-list 'project-switch-commands `(im-consult-ripgrep "Grep"))

  (define-key project-prefix-map "f" #'im-find-file-in-current-project)
  (add-to-list 'project-switch-commands `(im-find-file-in-current-project "Files"))

  (define-key project-prefix-map "D" #'dired-jump)
  (add-to-list 'project-switch-commands `(dired-jump "Open in dired"))

  (define-key project-prefix-map "m" #'magit-status)
  (add-to-list 'project-switch-commands `(magit-status "Magit"))

  (define-key project-prefix-map "v" #'project-vc-dir)
  (add-to-list 'project-switch-commands `(project-vc-dir "vc-dir"))

  (define-key project-prefix-map "M" #'lab-list-project-merge-requests)
  (add-to-list 'project-switch-commands `(lab-list-project-merge-requests "Merge Requests"))

  (define-key project-prefix-map "P" #'lab-list-project-pipelines)
  (add-to-list 'project-switch-commands `(lab-list-project-pipelines "Pipelines"))

  (define-key project-prefix-map "!" #'im-project-shell-command)
  (add-to-list 'project-switch-commands `(im-project-shell-command "Run shell command"))

  (define-key project-prefix-map "t" #'multi-vterm-project)
  (add-to-list 'project-switch-commands `(multi-vterm-project "terminal"))

  (define-key project-prefix-map "F" #'im-select-any-project-file)
  (add-to-list 'project-switch-commands `(im-select-any-project-file "All project files"))

  (defun im-select-any-project-file ()
    (interactive)
    (im-find-file-in im-projects-root))

  (defun im-project-shell-command ()
    "Run `async-shell-command' in the current project's root directory."
    (interactive)
    (let ((default-directory (project-root (project-current t))))
      (call-interactively #'im-shell-command)))

  (defvar im-project-shell-last-height 15)
  (defvar im-project-shell-last-window nil)

  (defun im-shell-for (&optional type)
    (interactive)
    (require 'eshell)
    (setq type (or type 'project))
    (let* ((proj-dir (or (ignore-errors
                           (project-root (project-current)))
                         default-directory))
           (default-directory (if (eq type 'project) proj-dir default-directory))
           (proj-name (f-base default-directory))
           (name (format "$eshell: %s" proj-name)))
      (if-let* ((window (--find (s-prefix? "\$eshell: " (buffer-name (window-buffer it))) (window-list)))
                (focused? (equal window (selected-window))))
          (progn
            (setq im-project-shell-last-height (window-height window))
            (delete-window window)
            (when im-project-shell-last-window
              (select-window im-project-shell-last-window)))
        (let* ((term (or (get-buffer name)
                         (save-window-excursion
                           (let ((eshell-buffer-name name))
                             (eshell t))))))
          (with-current-buffer term
            (tab-line-mode -1))
          (display-buffer-in-side-window
           term
           (append
            `((window-height . ,im-project-shell-last-height)
              (side . top)
              (slot . 1))))
          (setq im-project-shell-last-window (get-buffer-window))
          (select-window (get-buffer-window term))))))

  (bind-key "M-`" #'im-shell-for)
  (bind-key "M-~" (λ-interactive (im-shell-for 'dir)))
#+end_src

** consult
Some key points:
- =SPC RET= brings up =consult-buffer=.
  - Typing =SPC {p,f,b,m}= narrows the list into {project files, files, buffers, bookmarks}.
  - Also see: [[id:90769b1b-7baf-4285-80f9-153ae07d73ab][frequently used files]]
- =M-y= brings up =consult-yank=, where you can select from clipboard history and paste.
- =C-f= does fuzzy search on current file lines.
- Do =M-,= on a candidate to preview it.
- Also don't forget to utilize =M-a= (=embark-act=) in consult windows.
- Use =M-n= (future-history) to insert current symbol after running a consult command. Normally you would use =M-{p,n}= to cycle between history items but when you open minibuffer, typing =M-n= directly tries to guess what the user input would be.

#+begin_src emacs-lisp
  (use-package consult
    :config
    (advice-add #'register-preview :override #'consult-register-window)

    (setq consult-preview-key "M-,")
    ;; ^ When you do M-, on a candidate, it previews it

    (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)
    ;; ^ Shows all narrowing possibilities when you hit "?"

    ;; TODO move bindings
    (evil-leader/set-key "RET" #'consult-buffer)
    (evil-define-key 'normal 'global (kbd "M-i") (λ-interactive (condition-case nil
                                                                    (consult-imenu)
                                                                  (error (consult-outline)))))
    (evil-define-key 'normal org-mode-map (kbd "M-i") 'consult-org-heading)
    (evil-leader/set-key "fo" #'find-file)
    (evil-leader/set-key "fs" #'save-buffer)
    (evil-leader/set-key "fd" #'consult-dir)
    (evil-leader/set-key "fl" #'consult-line)
    (evil-leader/set-key "cr" #'consult-history)

    ;; Hide some buffers from consult-buffer window. If you want to jump
    ;; on one of these buffers, start with a space after opening
    ;; `consult-buffer'.
    (add-to-list
     'consult-buffer-filter
     "\\`\\*\\(Help\\|Backtrace\\|Messages\\|Buffer List\\|Flycheck.*\\|scratch.*\\)\\'")

    ;; This also supports previews. Use the `consult-preview-key'.
    (defalias 'im-switch-theme #'consult-theme)

    <<consult-project-management>>
    <<consult-buffer-source-files>>
    <<consult-buffer-source-projects>>)
#+end_src

*** Project & file management
Some functionality for project management. I do some fine-tuning for =find= and =ripgrep= commands that consult uses.

#+name: consult-project-management
#+begin_src emacs-lisp :tangle no
  (evil-leader/set-key
    "cf"  #'im-find-file-in
    "cG"  #'im-consult-ripgrep-in-given-directory
    "cg"  #'im-consult-ripgrep-current-directory)

  ;; TODO fix search
  (setq
   consult-find-command "fd  --hidden --full-path ARG OPTS"
   consult-ripgrep-command "rg  --hidden --null --line-buffered --color=always --max-columns=500 --no-heading --smart-case --line-number . -e ARG OPTS"
   consult-project-root-function #'im-current-project-root)

  (defun im-consult-ripgrep (&optional path)
    "`consult-ripgrep' in current project.
  `consult-ripgrep' with `consult-project-root-function' shows full path of the
  file in the results.  I don't want that."
    (interactive)
    (consult-ripgrep (or path (im-current-project-root))))

  (defun im-consult-ripgrep-current-directory ()
    "Do ripgrep in `default-directory'."
    (interactive)
    (consult-ripgrep default-directory))

  (defun im-consult-ripgrep-in-given-directory (dir)
    (interactive "DSelect directory: ")
    (consult-ripgrep dir))

  (defun im-find-file-in (&optional dir)
    "Find file in DIR. `fd' is already fast enough, no need for
  `consult-find's async approach."
    (interactive "DFind files in: ")
    (let ((default-directory dir))
      (im-output-select
       :cmd "fd --exclude '.git' --exclude 'node_modules' --hidden ."
       :prompt "Open file: "
       :category 'file
       :map (s-chop-prefix "./" it)
       :do (find-file it))))

  (defun im-find-file-in-current-project ()
    (interactive)
    (im-find-file-in (im-current-project-root)))
#+end_src

*** consult-buffer and some extensions
:PROPERTIES:
:ID:       90769b1b-7baf-4285-80f9-153ae07d73ab
:END:
I use =(consult-buffer)= function for switching between buffers/files/marks etc. Here I add a source for my frequently used files. This is handy in a way that =(consult-buffer)= becomes my go-to place for switching to anything.

#+name: consult-buffer-source-files
#+begin_src emacs-lisp :tangle no
  (defvar im-consult-source-files
    (list
     :name     "My files"
     :narrow   ?f
     :category 'file
     :face     'consult-file
     :history  'file-name-history
     :state    #'consult--file-state
     :default  t
     :hidden   nil
     :items    #'im-my-files)
    "My frequently accessed files source for `consult-buffer'.")

  (defun im-my-files ()
    "Return list of all files I frequently use."
    `(,@(directory-files org-directory t "^\\w+.*.org$")
      ,@(directory-files im-load-path t "\\.el$")))

  (im-append! consult-buffer-sources 'im-consult-source-files)
#+end_src

I also add a source for listing all of my projects:

#+name: consult-buffer-source-projects
#+begin_src emacs-lisp :tangle no
  (defvar im-consult-source-projects
    (list
     :name     "Projects"
     :narrow   ?a
     :hidden   nil
     :category 'file
     :action  (lambda (it &rest _) (project-switch-project it))
     :items   (lambda () (mapcar #'car project--list)))
    "Projects source for consult-buffer.")

  (im-append! consult-buffer-sources 'im-consult-source-projects)
#+end_src

*** consult-dir: Jump to different places easily in minibuffer
Here is a nice description of the package from it's README:
: Avoid "navigating" long distances when picking a file or directory in any Emacs command that requires one. Think of it like the shell tools autojump, fasd or z but for Emacs.

#+begin_src emacs-lisp
  (defvar consult-dir--my-dirs
    (list
     :name "My favorites"
     :narrow ?m
     :category 'file
     :face 'consult-file
     :items
     (lambda ()
       `("~/Downloads/"
         "~/Documents/"
         "~/Pictures/f3/Camera/"
         "~/Music/"
         "~/Music/mix/"
         "~/Videos/Shows/"
         "~/Videos/Movies/"
         "~/Documents/notes/"
         "~/Documents/notes/img/"
         "~/Workspace/projects/"
         "~/Workspace/temp/"
         "~/Workspace/temp/git/"
         "~/.emacs.d/"
         "~/.local/share/"
         "~/.local/bin/"
         "~/.config/"
         ,(format "/run/media/%s/" (getenv "USERNAME"))
         ,(format "/run/media/%s/BINGUS/" (getenv "USERNAME"))))))

  (use-package consult-dir
    :bind (("C-x C-d" . consult-dir)
           :map vertico-map
           ("M-d" . consult-dir))
    :config
    (setq consult-dir-sources '(consult-dir--my-dirs
                                consult-dir--source-bookmark
                                consult-dir--source-recentf
                                consult-dir--source-tramp-local
                                consult-dir--source-default
                                consult-dir--source-project)))
#+end_src

** embark
=embark.el= provides contextual command maps.
  - =M-a= activates command mode. Next key should be command. Do =C-h= to list all commands with their keybindings.
  - Commands are context specific, ie. the commands is based on if currently selected item is a file, folder, buffer etc.
  - It's mostly used within the minnibuffer, some example functions:
    - =M-a w= (~embark-save~) saves the current candidate's text into kill-ring.
    - =M-a i= (~embark-insert~) like the one above but instead of saving to the kill-ring, it directly inserts it to the buffer.
    - =M-a S= (~embark-collect-snapshot~) creates a buffer containing all the candidates.

- To apply an action to multiple items, filter the items first and then do =embark-collect-snapshot=. A buffer will open and you can apply the main action or other actions on the items.

#+begin_src emacs-lisp
  (use-package embark-consult)

  (use-package embark
    :config
    (bind-key (kbd "M-a") #'embark-act)
    (bind-key (kbd "M-A") #'embark-act-all)
    (setq embark-prompter #'embark-completing-read-prompter)
    ;; ^ This directly shows the actions in a completing read window.
    ;; By default, it is set to `embark-keymap-prompter' and you need to
    ;; hit `C-h' to bring this menu up.
    (setq embark-indicators '(embark-highlight-indicator embark-isearch-highlight-indicator))
    ;; ^ I removed embark-mixed-indicator from the list because I'm
    ;; using embark-completing-read-prompter by default which already
    ;; provides same functionality

    ;; Replace describe-symbol with helpful-symbol
    (define-key embark-symbol-map "h" #'helpful-symbol))
#+end_src

*** sudo-file-edit action
Nice little embark action that let's you open files with sudo.

Source: https://karthinks.com/software/fifteen-ways-to-use-embark/
#+begin_src emacs-lisp
  (defun im-sudo-find-file (file)
    "Open FILE as root."
    (interactive "FOpen file as root: ")
    (when (file-writable-p file)
      (user-error "File is user writeable, aborting sudo"))
    (find-file (if (file-remote-p file)
                   (concat "/" (file-remote-p file 'method) ":"
                           (file-remote-p file 'user) "@" (file-remote-p file 'host)
                           "|sudo:root@"
                           (file-remote-p file 'host) ":" (file-remote-p file 'localname))
                 (concat "/sudo:root@localhost:" file))))

  (define-key embark-file-map (kbd "#") 'im-sudo-find-file)
#+end_src

** flycheck
- Use =ge= (=consult-flycheck=) to list and jump any of the errors/warnings in the buffer.
  - Write ~i SPC~, ~w SPC~, ~e SPC~ to show infos, warnings, errors only in the =consult-flycheck=

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :diminish
    :config
    (setq flycheck-idle-change-delay 1)
    (setq flycheck-display-errors-delay 0.3)
    (setq flycheck-emacs-lisp-load-path 'inherit)
    (setq flycheck-emacs-lisp-initialize-packages t)
    (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
    (setq flycheck-global-modes '(not org-mode jira-view-mode))

    (global-flycheck-mode))

  (use-package consult-flycheck
    :after flycheck
    :config
    (evil-define-minor-mode-key 'normal 'flycheck-mode
      (kbd "ge") #'im-show-error-list))

  (use-package flycheck-posframe
    :straight (:host github :repo "alexmurray/flycheck-posframe")
    :config
    (setq flycheck-posframe-border-width 2)
    (setq flycheck-posframe-border-use-error-face t)
    (setq flycheck-posframe-position 'window-bottom-center)
    (add-hook 'flycheck-mode-hook #'flycheck-posframe-mode)
    (flycheck-posframe-configure-pretty-defaults))

  (defun im-show-error-list (arg)
    "Show all lsp errors or flycheck erros, depending on which is available."
    (interactive "P")
    (if (bound-and-true-p lsp-mode)
        (consult-lsp-diagnostics arg)
      (consult-flycheck)))
#+END_SRC

** corfu & corfu-doc & kind-icon & pcmpl-args & cape
- When corfu popup is open
  - M-SPC to insert a space to be able to filter with orderless.
  - M-q to show an avy like quick selection keys.
  - M-m to move completion items to mini-buffer (completing-read).
#+BEGIN_SRC emacs-lisp
  (use-package corfu
    :straight (:files (:defaults "extensions/*.el"))
    :config
    (set-face-background 'corfu-current "dim gray")
    (setq corfu-cycle t)
    (setq corfu-auto t)
    (setq corfu-auto-prefix 2)
    (global-corfu-mode))

  ;; This is useful because sometimes I just want to collect list of
  ;; completions. With this I can use embark's collect functionality.
  (defun corfu-move-to-minibuffer ()
    (interactive)
    (let ((completion-extra-properties corfu--extra)
          completion-cycle-threshold completion-cycling)
      (apply #'consult-completion-in-region completion-in-region--data)))
  (define-key corfu-map "\M-m" #'corfu-move-to-minibuffer)

  (use-package corfu-quick
    :ensure nil
    :straight nil
    :after corfu
    :config
    (setq corfu-quick1 "asdfgqwe")
    (setq corfu-quick2 "hjklui")
    (define-key corfu-map "\M-q" #'corfu-quick-insert))

  (use-package kind-icon
    :after corfu
    :config
    (setq kind-icon-default-face 'corfu-default)
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))

  (use-package corfu-popupinfo
    :ensure nil
    :straight nil
    :after corfu
    :config
    (setq corfu-popupinfo-delay 0)
    (corfu-popupinfo-mode)
    ;; Toggle doc on/off while in corfu
    (define-key corfu-map (kbd "M-d") #'corfu-popupinfo-toggle)
    (define-key corfu-map (kbd "M-p") #'corfu-popupinfo-scroll-down)
    (define-key corfu-map (kbd "M-n") #'corfu-popupinfo-scroll-up))

  ;; add extensions
  (use-package cape
    ;; Bind dedicated completion commands
    ;; Alternative prefix keys: C-c p, M-p, M-+, ...
    :bind (("M-o p" . completion-at-point) ;; capf
           ("M-o t" . complete-tag)        ;; etags
           ("M-o d" . cape-dabbrev)        ;; or dabbrev-completion
           ("M-o h" . cape-history)
           ("M-o f" . cape-file)
           ("M-o k" . cape-keyword)
           ("M-o s" . cape-symbol)
           ("M-o a" . cape-abbrev)
           ("M-o i" . cape-ispell)
           ("M-o l" . cape-line)
           ("M-o w" . cape-dict)
           ("M-o \\" . cape-tex)
           ("M-o _" . cape-tex)
           ("M-o ^" . cape-tex)
           ("M-o &" . cape-sgml)
           ("M-o r" . cape-rfc1345))
    :init
    ;; Add `completion-at-point-functions', used by `completion-at-point'.
    ;;(add-to-list 'completion-at-point-functions #'cape-dabbrev)
    ;;(add-to-list 'completion-at-point-functions #'cape-file)
    ;;(add-to-list 'completion-at-point-functions #'cape-history)
    ;;(add-to-list 'completion-at-point-functions #'cape-keyword)
    ;;(add-to-list 'completion-at-point-functions #'cape-tex)
    ;;(add-to-list 'completion-at-point-functions #'cape-sgml)
    ;;(add-to-list 'completion-at-point-functions #'cape-rfc1345)
    ;;(add-to-list 'completion-at-point-functions #'cape-abbrev)
    ;;(add-to-list 'completion-at-point-functions #'cape-ispell)
    ;;(add-to-list 'completion-at-point-functions #'cape-dict)
    ;;(add-to-list 'completion-at-point-functions #'cape-symbol)
    ;;(add-to-list 'completion-at-point-functions #'cape-line)
    )

  ;; For shell-mode completion
  (use-package pcmpl-args
    :config
    ;; Silence the pcomplete capf, no errors or messages!
    (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-silent)

    ;; Ensure that pcomplete does not write to the buffer
    ;; and behaves as a pure `completion-at-point-function'.
    (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-purify))
#+END_SRC

** lsp-mode
- See: https://emacs-lsp.github.io/lsp-mode/tutorials/how-to-turn-off/

#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :commands lsp
    :hook ((web-mode . lsp)
           (js-mode . lsp)
           (tsx-ts-mode . lsp)
           (typescript-ts-mode . lsp)
           (dhall-mode . lsp)
           (haskell-mode . lsp)
           (kotlin-mode . lsp)
           (rust-mode . lsp)
           (go-mode . lsp)
           (java-mode . lsp)
           (java-ts-mode . lsp))
    :init
    (setq lsp-use-plists t)
    :config
    (setq lsp-completion-provider :none) ;; for corfu
    (setq lsp-enable-xref t)
    (setq lsp-enable-links t)
    (setq lsp-enable-folding t)
    (setq lsp-enable-symbol-highlighting nil)
    ;; ^ I use highlight-thing instead and it works pretty well.
    (setq lsp-enable-indentation nil)
    (setq lsp-enable-on-type-formatting nil)
    (setq lsp-before-save-edits nil)
    (setq lsp-eldoc-render-all nil)
    (setq lsp-headerline-breadcrumb-enable nil)
    (setq lsp-enable-snippet nil)
    ;; ^ I handle snippets myself with yasnippet
    (setq lsp-ui-doc-include-signature t)
    ;; ^ Show the signature in the doc posframe. This shows the
    ;; posframe even if there is no documentation for the function
    ;; etc.
    (setq lsp-ui-sideline-show-diagnostics nil)
    ;; ^ Disable showing errors on sideline, because I use
    ;; flycheck-inline already and it does a better job showing
    ;; errors inline

    (setq
     lsp-imenu-index-symbol-kinds
     '(Module
       File
       Namespace
       Package
       Class
       Method
       Constructor
       Property
       Enum
       Struct
       Field
       Interface
       Function))
    ;; ^ Local variables etc. pollute imenu, so just show these in imenu
    ;; Following are the what's left out: Variable Constant String
    ;; Number Boolean Array Object Key Null Struct Event Operator
    ;; TypeParameter

    (evil-define-minor-mode-key 'normal 'lsp-mode
      "gr" #'lsp-ui-peek-find-references
      "gd" #'lsp-ui-peek-find-definitions
      "gi" #'lsp-ui-peek-find-implementation
      "ga" #'lsp-execute-code-action
      "K"  #'im-lsp-ui-doc-focus-frame))

  (defun im-lsp-ui-doc-focus-frame ()
    "Show and focus to the documentation."
    (interactive)
    (unless (lsp-ui-doc-focus-frame)
      (lsp-ui-doc-show)))

  (use-package lsp-ui
    :after (lsp-mode)
    :commands lsp-ui-mode
    :config
    (setq lsp-ui-sideline-show-code-actions nil))

  ;; consult-lsp-diagnostics and consult-lsp-symbols
  (use-package consult-lsp
    :config
    (evil-define-key 'normal lsp-mode-map
      (kbd "M-I") 'consult-lsp-symbols))
#+END_SRC

** dap-mode
Basic workflow is as follows:
- ~dap-breakpoint-add~
- ~dap-debug~
  - You may need to run this on root of your project (like in README etc.) otherwise it may fail.
- When debugger kicks-in, ~dap-hydra~ will be displayed, or you can call it manually anytime you want.
- ~dap-ui-repl~ → This drops you in a REPL where you can run code in the debug context, which is better than the hydra provided eval functionality.

#+begin_src emacs-lisp
  (use-package dap-mode
    :after (lsp-mode)
    :config
    ;; When debugger kicks-in, run dap-hydra
    (add-hook 'dap-stopped-hook (lambda (arg) (call-interactively #'dap-hydra))))
#+end_src

** vterm
Also check out =~/.zshrc= and =~/.config/zsh/emacs.sh=. These files contains some helpful commands that enriches ~vterm~ usage.

- Use =C-z= to go in/out (you can also use =jk= to go back into normal mode from emacs mode) emacs state so that you can make use of use vi-mode in zsh.

#+BEGIN_SRC emacs-lisp
  (defun evil-collection-vterm-escape-stay ()
    "Go back to normal state but don't move cursor backwards.
    Moving cursor backwards is the default vim behavior but
    it is not appropriate in some cases like terminals."
    (setq-local evil-move-cursor-back nil))

  (use-package vterm
    :config
    (evil-define-key 'insert vterm-mode-map
      (kbd "C-r") #'vterm--self-insert
      (kbd "M-\\") #'vterm--self-insert
      (kbd "M--") #'vterm--self-insert
      (kbd "C-c") #'vterm--self-insert
      (kbd "C-x") #'vterm--self-insert)

    (evil-leader/set-key
      "tj" 'im-jump-to-visible-term
      "tl" 'im-run-last-command-on-visible-term
      "ty" 'im-send-selected-text-to-visible-term
      "tr" 'im-run-command-on-visible-term-with-history)
    (setq vterm-kill-buffer-on-exit t)
    (add-hook 'vterm-mode-hook #'evil-collection-vterm-escape-stay)
    (add-hook 'vterm-mode-hook #'evil-emacs-state))

  (use-package multi-vterm
    :config
    (evil-leader/set-key
      "tt" #'multi-vterm-dedicated-toggle
      "tn" #'multi-vterm-project
      "td" #'multi-vterm))
#+END_SRC

*** Utility functions
#+begin_src emacs-lisp
  (defun im-run-last-command-on-visible-term ()
    (interactive)
    (save-buffer)
    (or
     (im-with-visible-buffer
      ".*vterm.*"
      (vterm-send-up)
      (vterm-send-return)
      t)
     (im-with-visible-buffer
      ".*eshell.*"
      (eshell-previous-matching-input "" 0)
      (eshell-send-input))))

  (defun im-run-command-on-visible-term (cmd)
    (or
     (im-with-visible-buffer ".*vterm.*"
       (vterm-send-string cmd)
       (vterm-send-return)
      t)
     (im-with-visible-buffer ".*eshell.*"
       (insert cmd)
       (eshell-send-input)))
    cmd)

  (defun im-send-selected-text-to-visible-term (start end)
    (interactive "r")
    (if (use-region-p)
        (im-run-command-on-visible-term (buffer-substring-no-properties start end))
      (im-run-command-on-visible-term (s-trim (buffer-substring-no-properties (line-beginning-position) (line-end-position))))))

  (defvar im-term-run-history '())
  (defvar im-jump-to-term-last-window nil)

  (defun im-jump-to-visible-term ()
    "Jump to the visible term window.
  When invoked in a term window, return back to last window that
  this command is invoked from."
    (interactive)
    (cond
     ((string-match ".*\\(vterm\\|eshell\\).*" (buffer-name (window-buffer (selected-window))))
      (select-window im-jump-to-term-last-window))
     (t
      (setq im-jump-to-term-last-window (selected-window))
      (im-select-window-with-buffer ".*\\(vterm\\|eshell\\).*"))))

  (defun im-run-command-on-visible-term-with-history ()
    (interactive)
    (let ((cmd (im-run-command-on-visible-term
                (completing-read "Run new command: " im-term-run-history))))
      (when cmd
        (setq im-term-run-history (cons cmd (delete cmd im-term-run-history))))))
#+end_src

** moodline modeline
Light weight and nice modeline.

#+begin_src emacs-lisp
  (use-package mood-line
    :diminish
    :straight (:host gitlab :repo "jessieh/mood-line")
    :config
    (mood-line-mode)

    (set-face-attribute
     'mood-line-unimportant nil
     :foreground "Sky Blue")
    (set-face-attribute
     'mood-line-status-neutral nil
     :foreground "Sky Blue"))
#+end_src

** howdoyou
When you search for something, it opens the results in an org-mode buffer. Results are fetched from SX (stack-exchange, stackoverflow etc) sites.
- =SPC hs= or =howdoyou-query= :: search function
- =C-M-Left= :: prev answer
- =C-M-Right= :: next answer

#+BEGIN_SRC emacs-lisp
  (use-package howdoyou
    :config
    (setq howdoyou-switch-to-answer-buffer t)
    (setq howdoyou-number-of-answers 5)
    (evil-define-minor-mode-key '(normal motion) 'howdoyou-mode
      "gn" #'howdoyou-next-link
      "gp" #'howdoyou-previous-link)
    (evil-leader/set-key
      "is" 'howdoyou-query))

  (defun im-open-stackexchange-link (link)
    "Open stackexchange LINK in a nicely formatted org buffer."
    (interactive "sLink: ")
    (switch-to-buffer (howdoyou--get-buffer))
    (insert "Loading...")
    (let ((buffer (current-buffer)))
      (promise-chain (howdoyou-read-so-link link)
        (then #'(lambda (_)
                  (im-url-get-title-async
                   link
                   (lambda (title)
                     (with-current-buffer buffer (rename-buffer (format "*se: %s*" title) :unique)))))))))
#+END_SRC

** tldr
tldr client for Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package tldr
    :config
    (evil-leader/set-key
      "it" #'tldr))
#+END_SRC

** yasnippet & yankpad: template manager
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :config
    (yas-global-mode))

  (use-package yankpad
    :after yasnippet
    :config
    (setq yankpad-file snippets-org)
    (add-to-list 'hippie-expand-try-functions-list #'yankpad-expand)
    (evil-leader/set-key
      "sr" #'yankpad-reload
      "sc" #'yankpad-set-category
      "se" #'yankpad-edit
      "ss" #'yankpad-map
      "sm" #'yankpad-map)

    (evil-define-key 'insert 'global
      (kbd "M-s") #'yankpad-insert
      (kbd "M-e") #'hippie-expand)

    ;; Enable expanding in minibuffer
    (add-hook 'minibuffer-setup-hook 'yas-minor-mode)
    (define-key minibuffer-local-map (kbd "M-e") #'hippie-expand)

    ;; Categories returned by the following functions will be used to
    ;; expand snippets
    (setq
     yankpad-auto-category-functions
     '(yankpad-major-mode-category im-current-project-name)))
#+END_SRC

I also like to use these snippets outside of Emacs. For this, I defined =im-select-any-snippet=. It let's you select any snippet from the yankpad file (no mode restriction, shows all snippets prefixed with mode name they are defined for) through =completing-read=. Combined with [[id:30465D2E-AB40-4E53-B6EA-9D72F7242700][im-globally]], you can use this outside of Emacs.

#+begin_src emacs-lisp
  (defvar im--all-snippets-cache nil)

  (defun im-load-snippets-list ()
    (interactive)
    (message ">> Loading snippets...")
    (setq im--all-snippets-cache
          (-mapcat
           (lambda (category)
             (--map (cons (format "%s :: %s" category (car it)) it)
                    (ignore-errors (yankpad--snippets category))))
           (yankpad--categories)))
    (message ">> Loading snippets... Done"))

  ;; Load snippets for the first time, after the startup
  ;; This may take a bit of time
  (run-with-timer 30 nil #'im-load-snippets-list)

  (defun im-select-any-snippet ()
    "List all templates for all modes and return the applied template
  as string."
    (interactive)
    (-let* ((selected (completing-read "Select snippet: " im--all-snippets-cache))
            (snippet (alist-get selected im--all-snippets-cache nil nil #'equal))
            ((_ category _) (s-match "\\(.*\\) :: \\(.*\\)" selected)))
      (with-temp-buffer
        (setq yankpad-category category)
        ;; Activate yas snippet on the temp buffer
        (let ((yas-dont-activate-functions '()))
          (yas-minor-mode-on))
        (yankpad--run-snippet snippet)
        (im-kill (buffer-string)))))

#+end_src

** git-link
#+begin_src emacs-lisp
  (use-package git-link
    :config
    (setq git-link-open-in-browser t)
    (evil-leader/set-key
      "glm" 'im-git-link-merge-requests
      "gll" 'im-git-link-on-branch
      "glL" 'im-git-link-commit
      "glc" 'im-git-link-commit
      "glh" 'git-link-homepage))

  (defun im-git-link-homepage ()
    "Like git-link-homepage itself but it does not open in browser, simply returns the address as string."
    (interactive)
    (let ((git-link-open-in-browser nil))
      (call-interactively 'git-link-homepage)
      (car kill-ring)))

  (defun im-git-link-on-branch (branch)
    "Like `git-link' but let's you select the branch first when called interactively."
    (interactive
     (list
      (completing-read
       "Select a branch: "
       (vc-git-branches)
       nil nil (lab-git-current-branch))))
    (let ((git-link-default-branch branch))
      (call-interactively 'git-link)))

  (defun im-git-link-commit ()
    "Like `git-link' but use commit hash in url."
    (interactive)
    (let ((git-link-use-commit t))
      (call-interactively 'git-link)))

  (defun im-git-link-merge-requests ()
    "Open MR page."
    (interactive)
    (browse-url
     (let ((homepage (im-git-link-homepage)))
       (cond
        ((s-contains? "gitlab" homepage) (concat homepage "/-/merge_requests"))
        ((s-contains? "github" homepage) (concat homepage "/pulls"))
        (t (user-error "Forge undefined."))))))
#+end_src

** tab-out
When you press tab, jump out from the current enclosing parens/quotes etc. When there is no enclosing stuff, TAB key automatically fallbacks to it's default behavior.

#+begin_src emacs-lisp
  (use-package tab-jump-out
    :diminish
    :straight (:host github :repo "zhangkaiyulw/tab-jump-out")
    :config
    ;; This is not defined as a global minor mode, so define one and enable it
    (define-globalized-minor-mode global-tab-jump-out-mode tab-jump-out-mode
      (lambda ()
        (tab-jump-out-mode)
        (push "/" tab-jump-out-delimiters)
        (push "=" tab-jump-out-delimiters)))
    (global-tab-jump-out-mode 1))
#+end_src

** completing-read-xref
Provides an interface to xref based on completing-read.

#+begin_src emacs-lisp
  (use-package completing-read-xref
    :diminish
    :straight (:host github :repo "travitch/completing-read-xref.el")
    :config
    (setq xref-show-definitions-function #'completing-read-xref-show-defs))
#+end_src
** helpful and elisp-demos
- helpful :: Better help dialogs with syntax highlighting, references, source etc.
- elisp-demos :: Adds code examples into function help buffers.
  - Code examples are maintained [[https://github.com/xuchunyang/elisp-demos/blob/master/elisp-demos.org][here]], don't forget to contribute!
  - Call ~elisp-demos-add-demo~ to add a demo locally.

#+begin_src emacs-lisp
  (use-package helpful
    :config
    ;; Override default help bindings
    (global-set-key (kbd "C-h f") #'helpful-callable)
    (global-set-key (kbd "C-h v") #'helpful-variable)
    (global-set-key (kbd "C-h k") #'helpful-key)
    (global-set-key (kbd "C-h p") #'helpful-at-point)

    (evil-define-key 'normal helpful-mode-map
          "q" 'evil-delete-buffer))

  (use-package elisp-demos
    :after helpful
    :config
    (advice-add 'helpful-update :after #'elisp-demos-advice-helpful-update))
#+end_src

** expand-region
#+begin_src emacs-lisp
  (use-package expand-region
    :config
    (evil-define-key 'normal 'global
      (kbd "M-w") #'er/expand-region))
#+end_src
** aggressive-indent
It keeps your indentation working all the time. Seems like a good idea but I have some concerns about it, so I just use it with elisp for the time being.

#+begin_src emacs-lisp
  (use-package aggressive-indent
    :config
    (add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode)
    ;; (add-hook 'typescript-mode-hook #'aggressive-indent-mode)
    (add-to-list 'aggressive-indent-protected-commands 'evil-undo)
    (add-to-list 'aggressive-indent-protected-commands 'format-all-buffer))
#+end_src
** xmodmap-mode
Simple mode for editing =~/.Xmodmap= file.
- [[https://www.emacswiki.org/emacs/XModMapMode][Source]]

#+begin_src emacs-lisp
  (define-generic-mode 'xmodmap-mode
    '(?!)
    '("add" "clear" "keycode" "keysym" "pointer" "remove")
    nil
    '("[xX]modmap\\(rc\\)?\\'")
    nil
    "Simple mode for xmodmap files.")
#+end_src
** slack
#+begin_src emacs-lisp
  (use-package slack
    :straight (:host github :repo "isamert/emacs-slack")
    :config
    (setq slack-log-level 'error)
    ;; ^ info level shows unnecessary stuff that distracts me
    (setq slack-buffer-emojify nil)
    (setq slack-render-image-p t)
    (setq slack-image-max-height nil)
    (setq slack-prefer-current-team t)
    ;; ^ Set current team with `slack-change-current-team'
    (setq slack-buffer-function #'switch-to-buffer-other-window)
    ;; ^ Open slack windows on the right side of the screen

    ;; Disable filling as it fucks with copying stuff
    (setq lui-fill-type nil)
    (setq slack-buffer-function 'switch-to-buffer)
    (setq slack-message-custom-notifier #'im-slack-notify)
    (setq slack-message-custom-delete-notifier #'im-slack-notify)

    (evil-leader/set-key
      "ess" #'slack-select-rooms
      "esS" #'slack-select-unread-rooms
      "esm" #'im-slack-send-message
      "esr" #'im-slack-recent-messages
      "esl" #'im-slack-open-last-message
      "esy" #'im-slack-yank-last-message)

    (defun im-slack--add-reaction-to-message (reaction)
      (defalias (intern (concat "react-" reaction))
        `(lambda ()
           (interactive)
           (slack-buffer-add-reaction-to-message
            slack-current-buffer
            ,reaction
            (slack-get-ts)))))

    (evil-set-initial-state 'slack-mode-map 'normal)

    (evil-define-key 'normal slack-message-edit-buffer-mode-map
      "@"  #'slack-message-embed-mention
      "mc" #'slack-message-embed-channel)
    (evil-define-key 'normal slack-message-compose-buffer-mode-map
      "@"  #'slack-message-embed-mention
      "mc" #'slack-message-embed-channel))

  (defun im-slack-initialize ()
    (interactive)
    (ignore-errors (slack-ws-close))
    (ignore-errors (slack-team-delete))
    (slack-register-team
     :name ty-slack-name
     :token ty-slack-token
     :cookie ty-slack-cookie
     :subscribed-channels ty-slack-channels)
    (slack-start)
    (slack-change-current-team)
    (im-slack-initialize-keymaps))

  (defvar im-slack--last-messages '())

  (defun im-slack-notify (message room team)
    (when (or
           (slack-message-minep message team)
           (slack-mpim-p room)
           (slack-message-notify-p message room team))
      (let* ((sender-name (slack-message-sender-name message team))
             (room-name (slack-room-name room team))
             (title (format "%s - %s" room-name sender-name))
             (msg-str (im-slack--stringify-message
                       (list :message message :team team))))
        (push
         (list :room room
               :team team
               :message message
               :sender-name sender-name
               :room-name room-name
               :title title
               :message-string msg-str)
         im-slack--last-messages)
        (unless (or (slack-message-minep message team)
                    (s-contains? "message deleted" msg-str)
                    (s-contains? "has joined the" msg-str)
                    (s-contains? "has left the" msg-str)
                    ;; Dont show notifications for visible slack windows if emacs is not idle
                    (and
                     (< (time-to-seconds (or (current-idle-time) 0)) 15)
                     (--some
                      (s-contains? room-name it)
                      (--map (buffer-name (window-buffer it)) (window-list)))))
          ;; Only send desktop notifications for the things I'im interested
          ;; mpim || group || in subscribed channels
          (when (slack-message-notify-p message room team)
            ;; msg-str sometimes causes errors with `alert'. Thats why I
            ;; used `ignore-errors'.
            (ignore-errors
              (alert
               msg-str
               :title title
               :category "slack")))
          (message
           ">> Slack: %s // %s"
           title
           (car (s-split "\n" msg-str)))))))

  (defun im-slack-yank-last-message ()
    "Yank the contents of the last received message as text."
    (interactive)
    (im-kill
     (im-slack--stringify-message
      (im-slack--last-message))))

  (defun im-slack-open-last-message ()
    "Open last room that got new message."
    (interactive)
    (im-slack--open-message-or-thread (im-slack--last-message)))

  (defun im-slack--open-message-or-thread (msg)
    (let-plist msg
      (if (ignore-errors (slack-thread-message-p .message))
          (slack-thread-show-messages .message .room .team)
        (slack-room-display
         .room
         .team))
      ;; Focus the message on buffer
      (run-with-timer
       1.3 nil
       (lambda () (slack-buffer-goto (slack-ts .message))))))

  (defalias 'im-slack-recent-messages #'im-slack-last-messages)

  (defun im-slack-last-messages ()
    "List and open rooms that had new messages in them recently."
    (interactive)
    (with-completing-read-exact-order
     (let* ((rooms
             (-uniq
              (--map
               (cons
                (let-plist it
                  (format "%s (%s: %s)" .room-name .sender-name .message-string))
                it)
               im-slack--last-messages)))
            (selected (im-alist-completing-read "Select message: " rooms)))
       (im-slack--open-message-or-thread selected))))

  (defun im-slack-send-message (msg)
    "Send given MSG or selected region as message to interactively
    selected user."
    (interactive
     (list
      (if (use-region-p)
          (let ((text (buffer-substring-no-properties (region-beginning) (region-end))))
            (if (y-or-n-p "Wrap with backticks? ")
                (format "```\n%s\n```" text)
              text))
        (read-string "Enter message: "))))
    "Send MSG to interactively selected room."
    (-let* (((room team) (im-slack--select-room)))
      (slack-message-send-internal
       msg room team)))

  (defun im-slack-clipboard-image-upload ()
    "Uploads png image from clipboard.

    The default `slack-clipboard-image-upload' was not working
    properly in MacOS."
    (interactive)
    (unless (im-clipboard-contains-image-p)
      (user-error "No image in clipboard."))
    (let* ((file (make-temp-file "clip" nil ".png")))
      (im-save-clipboard-image-to-file file)
      (slack-file-upload file "png" "image.png")))

  ;; TODO multiple message quote
  (defun im-slack-quote-message ()
    (interactive)
    (let ((quote-text (->>
                       (im-slack-current-message-content)
                       (substring-no-properties)
                       (s-trim)
                       (s-split "\n")
                       (-drop 1)
                       (--map (concat "> " it))
                       (s-join "\n")
                       (s-append "\n"))))
      (slack-message-write-another-buffer)
      (insert quote-text)))

  (defun im-slack-current-message-content ()
    (slack-if-let* ((buf slack-current-buffer)
                    (team (slack-buffer-team buf))
                    (room (slack-buffer-room buf))
                    (message (slack-room-find-message room (slack-get-ts))))
        (slack-message-to-string message team)))

  (defun im-slack-open-link (link)
    (interactive
     (list
      (read-string "Link: " (thing-at-point 'url))))
    (let* ((m (s-match
               "https://\\(\\w+\\).slack.com/archives/\\(\\w+\\)/p\\(\\w+\\).*\\(\\?thread_ts=\\(\\w+\\)\\)?"
               link))
           (team (--find (string= (oref it domain) (nth 1 m))
                         (hash-table-values slack-teams-by-token)))
           (room (slack-room-find (nth 2 m) team))
           (message-ts (number-to-string (/ (string-to-number (nth 3 m)) 1000000.0)))
           (message (slack-room-find-message room message-ts))
           (thread (nth 4 m)))
      (im-slack--open-message-or-thread (list :message message :room room :team team))
      thread))

  ;;
  ;; Utils/internals
  ;;

  (defun im-slack--last-message ()
    (--find (not (s-matches? ".*\\(alert\\|practice\\).*" (plist-get it :room-name))) im-slack--last-messages))

  (defun im-slack--stringify-message (msg)
    (let ((message (plist-get msg :message))
          (team (plist-get msg :team)))
      (slack-message-to-alert message team)))

  (defun im-slack--select-room ()
    "Select interactively and return (room team) pair."
    (let* ((team (slack-team-select))
           (room (slack-room-select
                  (cl-loop for team in (list team)
                           append (append (slack-team-ims team)
                                          (slack-team-groups team)
                                          (slack-team-channels team)))
                  team)))
      (list room team)))

  (defun im-slack-initialize-keymaps ()
    (interactive)
    (dolist (mode-map (list slack-message-buffer-mode-map slack-thread-message-buffer-mode-map))
      (evil-define-key* '(normal motion) mode-map
        "q" #'im-quit

        "@" 'slack-message-embed-mention
        "mc" 'slack-message-embed-channel ;
        "mm" 'slack-message-write-another-buffer
        "md" 'slack-message-delete
        "ml" 'slack-message-copy-link
        "me" 'slack-message-edit
        "mt" 'slack-thread-show-or-create
        "mq" 'im-slack-quote-message

        "mrr" 'slack-message-add-reaction
        "mR" 'slack-message-remove-reaction
        "mrs" (im-slack--add-reaction-to-message "seen")
        "mr1" (im-slack--add-reaction-to-message "+1")
        "mr2" (im-slack--add-reaction-to-message "ok_hand")
        "mr3" (im-slack--add-reaction-to-message "eyes")
        "mr4" (im-slack--add-reaction-to-message "ultrafastparrot")
        "mr5" (im-slack--add-reaction-to-message "pepedance")
        "mrp" (im-slack--add-reaction-to-message "pray")

        "[[" 'slack-buffer-goto-prev-message
        "]]" 'slack-buffer-goto-next-message)))
#+end_src

** prodigy
#+begin_src emacs-lisp
  (use-package prodigy
    :diminish
    :straight (:host github :repo "rejeep/prodigy.el")
    :config
    (evil-define-key 'normal prodigy-mode-map
      "m" #'prodigy-mark
      "u" #'prodigy-unmark
      "x" #'prodigy-stop
      "S" #'prodigy-start
      "r" #'prodigy-restart
      "R" #'prodigy-refresh
      "f" #'prodigy-jump-file-manager
      "M" #'prodigy-jump-magit
      "t" #'prodigy-add-tag-filter
      "T" #'prodigy-clear-filters
      (kbd "RET") #'prodigy-display-process)

    (evil-leader/set-key
      "et" #'prodigy)

    (defun im-prodigy-autostart ()
      "Start all services with the `:auto-start' set to non-nil if they
  are not already started."
      (interactive)
      (prodigy-with-refresh
       (--each
           prodigy-services
         (when (and (plist-get it :auto-start)
                    (not (prodigy-service-started-p it)))
           (prodigy-start-service it)))))

    (add-hook
     'after-init-hook
     #'im-prodigy-autostart))
#+end_src
** poporg
Pop current comment section into an org (or markdown, as it's more widely used for comments) buffer and edit it there. Pretty useful for writing long comments. Use ~poporg-dwim~ on a comment/comment block.

#+begin_src emacs-lisp
  (use-package poporg
    :config
    (remove-hook 'poporg-edit-hook 'org-mode)
    (add-hook 'poporg-edit-hook 'markdown-mode))
#+end_src
** nov.el
For reading epub files.

#+begin_src emacs-lisp
  (use-package justify-kp
    :diminish
    :straight (:host github :repo "Fuco1/justify-kp"))

  (use-package nov
    :config
    ;; Just copied the configuration below from
    ;; https://depp.brause.cc/nov.el/

    (require 'justify-kp)
    (setq nov-text-width t)
    (setq nov-text-width 120)
    (setq visual-fill-column-center-text t)

    (add-hook 'nov-mode-hook 'visual-line-mode)
    (add-hook 'nov-mode-hook 'visual-fill-column-mode)
    (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))

    (defun im-nov-window-configuration-change-hook ()
      (im-nov-post-html-render-hook)
      (remove-hook 'window-configuration-change-hook
                   'im-nov-window-configuration-change-hook
                   t))

    (defun im-nov-post-html-render-hook ()
      (if (get-buffer-window)
          (let ((max-width (pj-line-width))
                buffer-read-only)
            (save-excursion
              (goto-char (point-min))
              (while (not (eobp))
                (when (not (looking-at "^[[:space:]]*$"))
                  (goto-char (line-end-position))
                  (when (> (shr-pixel-column) max-width)
                    (goto-char (line-beginning-position))
                    (pj-justify)))
                (forward-line 1))))
        (add-hook 'window-configuration-change-hook
                  'im-nov-window-configuration-change-hook
                  nil t)))

    (add-hook 'nov-post-html-render-hook 'im-nov-post-html-render-hook))
#+end_src
** all-the-icons
- You should run =all-the-icons-install-fonts= command after this. Also run =fc-cache -f -v= afterwards (=all-the-icons-install-fonts= already does that but it may fail).
- =all-the-icons-completion= gives you icons in completion UI, like in =completing-read= etc.

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)
  (use-package all-the-icons-completion
    :after (all-the-icons vertico)
    :config
    (all-the-icons-completion-mode +1))
#+END_SRC
** reddigg
It lets me display comments of given reddit thread in an org buffer using the =reddigg-view-comments= function.

#+begin_src emacs-lisp
  (use-package reddigg
    :config
    (setq reddigg-convert-md-to-org t))
#+end_src

** jq-mode
A mode for editing ~jq~ scripts. Mostly using it for ~jq-interactively~ function which enables you to write a jq query and update the buffer accordingly in real time.

#+begin_src emacs-lisp
  (use-package jq-mode)
#+end_src
** imenu-list
You can also do ~consult-imenu~ and ~embark-collect~ but it does not have a refresh feature.

#+begin_src emacs-lisp
  (use-package imenu-list
    :config
    (evil-leader/set-key "il" #'imenu-list))
#+end_src
** webpaste
#+begin_src emacs-lisp
  (use-package webpaste
    :config
    (setq webpaste-open-in-browser t))
#+end_src
** wolfram
Easy way to interact with WolframAlpha. I generally use it for unit conversions or stuff like that.

#+begin_src emacs-lisp
  (use-package wolfram
    :straight (:host github :repo "hsjunnesson/wolfram.el")
    :config
    (setq wolfram-alpha-app-id im-wolfram-alpha-app-id)
    (evil-leader/set-key "iw" #'wolfram-alpha))
#+end_src
** xwidget-webkit & xwwp
#+begin_src emacs-lisp
  (use-package ctable)

  (use-package xwwp
    :straight (:host github :repo "BlueFlo0d/xwwp" :files (:defaults "*.el"))
    :config
    (require 'xwwp-ace)
    (evil-define-key '(normal) xwidget-webkit-mode-map
      ;; TODO: F → xwwp-ace-new-tab-toggle?
      (kbd "f") #'xwwp-ace-toggle
      (kbd "^") (λ-interactive (browse-url (xwidget-webkit-uri (xwidget-webkit-current-session))))
      (kbd "&") (λ-interactive (funcall browse-url-secondary-browser-function (xwidget-webkit-uri (xwidget-webkit-current-session))))
      (kbd "o") #'im-xwidget-webkit-open
      (kbd "O") (λ-interactive (im-xwidget-webkit-open (read-string "URL: " (xwidget-webkit-uri (xwidget-webkit-current-session)))))
      (kbd "t") (λ-interactive (im-xwidget-webkit-open (read-string "URL: ") :new-session))
      (kbd "T") (λ-interactive (im-xwidget-webkit-open (read-string "URL: " (xwidget-webkit-uri (xwidget-webkit-current-session))) :new-session))))

  (defun im-w3m-open-in-xwidget-webkit ()
    (interactive nil w3m-mode)
    (xwidget-webkit-browse-url w3m-current-url :new-session))

  (defun im-xwidget-webkit-open (url &optional new-session)
    (interactive "sURL: ")
    (xwidget-webkit-browse-url
     (if (im-url? url)
         url
       (concat eww-search-prefix (url-hexify-string url)))
     new-session))
#+end_src
* Editing
** Breaking long texts/comments into multiple lines
I use =M-q= (=fill-paragraph=) to break long texts into multiple
lines. It also works well within comment sections. 80 col length is
quite readable. See how this item is formatted, it's done
automatically by the usage of =M-q=.

  #+begin_src emacs-lisp
    (setq fill-column 80)
  #+end_src

** Spell checking (flyspell) & dictionaries & translation
- Use =flyspell-mode= to start spell checking.
- Use =ispell-change-dictonary= to change dictionaries.
- ~z=~ or ~zw~ to correct current spelling mistake.
  - ~C-u zw~ to correct all mistakes in order.

*** Configuration
See [[https://isamert.net/2021/01/31/emacs-te-turkce-imla-denetimi.html][this]] for rationale behind the following configuration.

#+BEGIN_SRC emacs-lisp
  (setq ispell-program-name "hunspell"
        ispell-local-dictionary "en_US"
        ispell-local-dictionary-alist
        '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)
          ("tr_TR" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "tr_TR") nil utf-8)))

  (add-hook 'org-mode-hook 'flyspell-mode)
  (add-hook 'markdown-mode-hook 'flyspell-mode)
  (add-hook 'text-mode-hook 'flyspell-mode)
#+END_SRC

*** flyspell-correct
Better way to correct spelling mistakes. By default it uses completing-read. This also makes it easy to save words into personal dictonary or silence warnings for session because it shows these options in the correction menu.
#+begin_src emacs-lisp
  (use-package flyspell-correct
    :config
    ;; Rebind default evil ispell keys to flyspell-correct ones
    (evil-define-key 'normal 'global
      (kbd "z=") #'flyspell-correct-at-point
      (kbd "zw") #'flyspell-correct-wrapper))
      ;; ^ This goes to nearest spelling mistake.
      ;; If called with C-u, it goes into rapid mode where you correct all mistakes in order.
#+end_src

*** synosaurus & wordnut
Both synosaurus and wordnut uses ~wordnet~ to work.
- Use ~synosaurus-choose-and-replace~ to replace the current word with one of it's synonyms.

#+begin_src emacs-lisp
  (use-package synosaurus
    :config
    (setq synosaurus-choose-method nil)
    (evil-leader/set-key
      "/s" #'synosaurus-choose-and-replace))

  (use-package wordnut
    :config
    (evil-define-key 'normal 'global (kbd "K") #'wordnut-lookup-current-word))
#+end_src

*** sozluk.el
Turkish dictionary.

#+begin_src emacs-lisp
  ;; This is an optional dependency for sozluk.
  (use-package turkish)

  (use-package sozluk
    :straight (:host github :repo "isamert/sozluk.el")
    :config
    (setq sozluk-include-etymology-on-sozluk t)
    (setq sozluk-deasciify-if-not-found t))
#+end_src

*** Etymology lookup inside Emacs
#+begin_src emacs-lisp
  (evil-leader/set-key
    "/e" #'im-etymology-en)

  (defun im-etymology-en (input)
    "Find and retrieve the given word etymology from etymonline.
  Adapted from: https://babbagefiles.xyz/emacs_etymologies/"
    (interactive
     (list (read-string "Word: " (im-region-or 'word))))
    (let* ((buffer (generate-new-buffer (format "*etymology: %s*" input))))
      (switch-to-buffer buffer)
      (insert (shell-command-to-string (concat "links -dump http://www.etymonline.com/word/" input)))
      (goto-char (point-min))
      (if (re-search-forward "Error 404 (Not Found)" nil t)
          (progn
            (kill-buffer)
            (user-error "Word not found: %s" input))
        (progn
          (delete-region (point-min) (progn
                                       (goto-char (point-min))
                                       (search-forward "[\s\s]")))
          (delete-region (progn
                           (goto-char (point-max))
                           (search-backward-regexp "See all related words"))
                         (point-max))))
      (goto-char (point-min))))
#+end_src
*** Google translate
#+begin_src emacs-lisp
  (use-package go-translate
    :config
    (setq gts-translate-list '(("en" "tr") ("tr" "en")))
    (setq gts-buffer-follow-p t)
    (setq gts-default-translator
          (gts-translator
           :picker (gts-prompt-picker)
           :engines (list (gts-bing-engine) (gts-google-engine) (gts-stardict-engine))
           :render (gts-buffer-render))))

  (evil-leader/set-key "T" #'gts-do-translate)
#+end_src

** string-inflection
- In the case of =string-inflection-ruby-style-cycle=   : ~emacs_lisp => EMACS_LISP => EmacsLisp => emacs_lisp~
- In the case of =string-inflection-python-style-cycle= : ~emacs_lisp => EMACS_LISP => EmacsLisp => emacs_lisp~
- In the case of =string-inflection-java-style-cycle=   : ~emacsLisp => EMACS_LISP => EmacsLisp => emacsLisp~
- In the case of =string-inflection-all-cycle=          : ~emacs_lisp => EMACS_LISP => EmacsLisp => emacsLisp => emacs-lisp => Emacs_Lisp => emacs_lisp~

#+begin_src emacs-lisp
  (use-package string-inflection
    :config
    (evil-define-key 'normal 'global (kbd "M-c") #'string-inflection-all-cycle))
#+end_src

** smartparens
#+begin_src emacs-lisp
  (use-package smartparens
    :config
    (require 'smartparens-config)

    (evil-define-key*
      '(normal insert) sp-keymap
      (kbd "M-[") #'sp-forward-barf-sexp
      (kbd "M-]") #'sp-forward-slurp-sexp
      (kbd "M-{") #'sp-backward-slurp-sexp
      (kbd "M-}") #'sp-backward-barf-sexp)
    (smartparens-global-mode))
#+end_src

** writeroom-mode
Gives you a nice, uncluttered editing experience by removing all unneeded visual clutter and by justifying the text in the middle.

#+begin_src emacs-lisp
  (use-package writeroom-mode
    :config
    (setq writeroom-fullscreen-effect 'maximized)
    (setq writeroom-global-effects nil)
    (setq writeroom-mode-line-toggle-position 'header-line-format)
    (setq writeroom-width 81))
#+end_src

* Dummy IDE mode
I try to use ~lsp-mode~ and other language-specific packages for the languages I use (see [[Language specific]]), but sometimes either they are too slow or the computer I'm currently working on requires some extra setup or I just don't want to use them for some reason. For those cases, I use a collection of packages that gives you the power of IDEs but in some dummy/restricted way.

- <<highlight-thing>> :: Automatically highlights the all instances of the symbol under the cursor in the buffer. Simply use evils ~*~ and ~#~ to jump between them.
- <<dumb-jump>> :: Jumps to definition by using predefined-regexps, generally works fine. Use =gd=.
  - To debug why it's not working: M-x ~set-variable dumb-jump-debug t~, then go to *Messages* buffer.
- <<treesit>> :: This is a generic parser for bunch of languages. You can also inspect the syntax tree on the fly and do whatever you want to do with it. Best feature so far is just better (like, miles ahead better) syntax highlighting for some languages. Especially for JS/TS and Rust.
- <<hl-todo>> :: Highlight TODO/FIXME etc.
  - Use ~]t~ and ~[t~ to go next/prev TODO/FIXME item.

#+begin_src emacs-lisp
  (use-package dumb-jump
    :config
    ;; ag is supported by nearly every rule but rg is not.
    ;; also see: https://github.com/jacktasia/dumb-jump/issues/376
    (setq dumb-jump-force-searcher 'ag)
    (setq dumb-jump-ignore-context t)
    (setq dumb-jump-fallback-search nil)
    (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))

  ;; Call treesit-auto-install-all
  (use-package  treesit-auto
    :straight (:host github :repo "renzmann/treesit-auto")
    :config
    (global-treesit-auto-mode))

  (use-package hl-todo
    :hook (prog-mode . hl-todo-mode)
    :config
    (setq hl-todo-keyword-faces
          '(("TODO"   . "#FF0000")
            ("FIXME"  . "#FF0000")
            ("DEBUG"  . "#A020F0")
            ("GOTCHA" . "#FF4500")
            ("STUB"   . "#1E90FF")))

    (evil-define-key 'normal 'global
      (kbd "]t") #'hl-todo-next
      (kbd "[t") #'hl-todo-previous))
#+end_src

** highlight-thing
#+begin_src emacs-lisp
  (use-package highlight-thing
    :after evil
    :config
    (setq-default evil-symbol-word-search t)
    ;; ^ highlight-thing highlights symbols, not words. # and * searches for
    ;; symbols if you set this to true, otherwise they search for words.

    (add-hook
     'highlight-thing-mode-hook
     #'(lambda () (set-face-attribute 'highlight-thing nil :background "dark violet" :foreground "white")))
    ;; ^ Default one with my theme makes some text quite unreadable

    (setq highlight-thing-prefer-active-region nil
          ;; ^ Don't highlight the selected text in visual mode
          highlight-thing-ignore-list '("False" "True" "->" "::" "defun" "def"))
    ;; I'm experimenting with manual highlighting
    ;; (global-highlight-thing-mode)
    )

  (setq
   hi-lock-face-defaults
   '("hi-salmon" "hi-aquamarine" "hi-blue" "hi-yellow" "hi-pink" "hi-green" "hi-black-b" "hi-blue-b" "hi-red-b" "hi-green-b" "hi-black-hb"))

  (defun im-highlight-thing-at-point-dwim ()
    "Hightlight or unhighlight current symbol or selection."
    (interactive)
    (cond
     ((--any?
       (-contains? hi-lock-face-defaults
                   (symbol-name it))
       (-flatten (list (plist-get (text-properties-at (point)) 'face))))
      (unhighlight-regexp
       (if (use-region-p)
           (regexp-quote (buffer-substring-no-properties (region-beginning) (region-end)))
         (hi-lock-regexp-okay (find-tag-default-as-symbol-regexp)))))
     ((use-region-p)
      (highlight-regexp
       (regexp-quote (buffer-substring-no-properties (region-beginning) (region-end))))
      (deactivate-mark))
     ((thing-at-point 'symbol)
      (hi-lock-face-symbol-at-point))
     (t (unhighlight-regexp t))))

  (evil-define-key 'normal 'global
    (kbd "M-h") #'im-highlight-thing-at-point-dwim
    (kbd "M-H") (λ-interactive (unhighlight-regexp t)))
#+end_src

* Media/feed/IRC
I try to maximize my Emacs usage which brings it's own benefits and downsides which I will not go over here. Here are some packages and configurations that are not related to programming/editing.

** elfeed (RSS feeds)
Feed reader.

- Filter examples (after hitting ~s~)
  - +tag OR -tag (unread is also a tag)
  - #number-of-entries-limit (like #20)
  - !inverse-regex (!x?emacs will filter out titles containing x?emacs regex)
  - =regex (entries that contains the regex will be shown)
  - +unread +youtube =emacs #10 @5-months-ago
#+begin_src emacs-lisp
  ;; TODO: experiment with custom faces
  ;; (defface elfeed-comic
  ;;   '((t :foreground "#BFF"))
  ;;   "Marks comics in Elfeed."
  ;;   :group 'elfeed)
  ;;
  ;; (push '(comic elfeed-comic)
  ;;       elfeed-search-face-alist)

  (defun im-elfeed-search-browse-url-in-default-browser ()
    "Open URL in the default browser."
    (interactive)
    (with-default-browser
     (elfeed-search-browse-url)))

  (defun im-elfeed-auto-tag-url (pairs)
    "Takes a list of url-regex and tag-list pairs and adds a new entry hook for each of them."
    (--map
     (add-hook 'elfeed-new-entry-hook
               (elfeed-make-tagger :feed-url (car it)
                                   :add (cdr it)))
     pairs))

  (defun im-elfeed-auto-tag-title (pairs)
    "Takes a list of title-regex and tag-list pairs and adds a new entry hook for each of them."
    (--map
     (add-hook 'elfeed-new-entry-hook
               (elfeed-make-tagger :entry-title (car it)
                                   :add (cdr it)))
     pairs))

  ;; https://github.com/skeeto/.emacs.d/blob/master/etc/feed-setup.el
  (defvar youtube-feed-format
    '(("^UC" . "https://www.youtube.com/feeds/videos.xml?channel_id=%s")
      ("^PL" . "https://www.youtube.com/feeds/videos.xml?playlist_id=%s")
      (""    . "https://www.youtube.com/feeds/videos.xml?user=%s")))

  (defun im-elfeed--expand (listing)
    "Expand feed URLs depending on their tags."
    (cl-destructuring-bind (url . tags) listing
      (cond
       ((member 'youtube tags)
        (let* ((case-fold-search nil)
               (test (lambda (s r) (string-match-p r s)))
               (format (cl-assoc url youtube-feed-format :test test)))
          (cons (format (cdr format) url) tags)))
       ((member 'reddit tags)
        (cons (format "https://www.reddit.com/r/%s/.rss" url) tags))
       ((member 'gh-release tags)
        (cons (format "https://github.com/%s/releases.atom" url) tags))
       (listing))))

  (use-package elfeed
    :config
    ;; When adding tags, don't add any hierarchical tags like (blog blog-software), or (metal metal-black)
    ;; Just use something like: (blog software) and (metal black)

    (load "feeds")
    (setq elfeed-search-title-max-width 100)
    (setq elfeed-curl-extra-arguments '("--netrc"))
    (setq elfeed-feeds (mapcar #'im-elfeed--expand im-feeds))
    (im-elfeed-auto-tag-url '(("youtube\\.com" youtube)))
    (im-elfeed-auto-tag-title '(("youtube\\.com" youtube)
                                     ("c\\+\\+"  (programming c++))
                                     ("python"   (programming python))
                                     ("haskell"  (programming haskell))))

    ;; To apply hooks to all existing entries, use: elfeed-apply-hooks-now

    (evil-define-key 'normal elfeed-search-mode-map
      "o" #'elfeed-search-browse-url
      "O" #'im-elfeed-search-browse-url-in-default-browser)

    (evil-leader/set-key "ee" #'im-elfeed-reload-and-open))

  (defun im-elfeed-reload-and-open ()
    "Reload and open elfeed.
  Useful if .elfeed directory is freshly syncned."
    (interactive)
    (elfeed-db-load)
    (elfeed)
    (elfeed-search-update--force))
#+end_src

** empv (music/media/radio/youtube management)
Manage media and streams through =completing-read=.

#+begin_src emacs-lisp
  (use-package empv
    :straight (:host github :repo "isamert/empv.el")
    :config
    (load "radio-channels")
    (setq empv-radio-channels im-radio-channels)
    (setq empv-radio-log-file "~/Documents/notes/songs.org")
    (setq empv-base-directory "~/Music/")
    (setq empv-video-dir `("~/Videos" ,(format "/run/media/%s/BINGUS/Videos" (user-login-name)) ,(format "/run/media/%s/FLOPPA/Videos" (user-login-name))))
    (setq empv-audio-dir `("~/Music" ,(format "/run/media/%s/BINGUS/Music" (user-login-name)) ,(format "/run/media/%s/FLOPPA/Music" (user-login-name))))
    (setq empv-allow-insecure-connections t)
    (setq empv-invidious-instance "https://inv.riverside.rocks/api/v1")
    ;; ^ see https://api.invidious.io/
    (add-to-list 'empv-mpv-args "--ytdl-format=best")
    (add-to-list 'empv-mpv-args "--save-position-on-quit")
    (add-hook 'empv-init-hook #'empv-override-quit-key)

    (evil-leader/set-key "r" empv-map)
    (evil-make-overriding-map empv-youtube-results-mode-map 'normal)
    (with-eval-after-load 'embark (empv-embark-initialize-extra-actions)))

  (defun im-export-radio-channels-as-m3u (file)
    "Export radio list into an M3U FILE."
    (interactive
     (list
      (read-file-name
       "Where to save the .m3u file?"
       "~/Documents/sync/"
       "radiolist.m3u")))
    (with-temp-file file
      (->>
       im-radio-channels
       (--map
        (format
         "#EXTINF:0, %s\n%s"
         (car it)
         ;; Replace http:// with icyx://, because VLC on Android can't
         ;; retrieve song name if the stream is on http://
         (if (s-contains? "radcap.ru" (car it))
             (s-replace "http://" "icyx://" (cdr it))
           (cdr it))))
       (--reduce (format "%s\n%s" acc it))
       (s-prepend "#EXTM3U\n")
       (insert))))
#+end_src

** orgmdb (movies & shows)
I have a file called ~watchlist.org~ where I keep list of movies and shows that I watched and going to watch. Here are some packages and functions to deal with them.

#+begin_src emacs-lisp
  (use-package orgmdb
    :diminish
    :straight (:host github :repo "isamert/orgmdb.el")
    :config
    (setq orgmdb-omdb-apikey im-orgmdb-omdb-apikey)
    (setq orgmdb-poster-folder "~/Documents/notes/data/posters")
    (setq orgmdb-fill-property-list '(genre runtime director country imdb-id imdb-link imdb-rating metascore actors poster))
    (evil-define-key 'normal 'global (kbd "go") #'orgmdb-act))
#+end_src
** erc (IRC client)
IRC client for Emacs.

- Some shortcuts:
  - C-c C-b :: switch between channels
  - C-c C-j :: join channel

- TODO items:
  - Autologin
  - Autojoin channels
  - Notifications
  - Add registration notes here
  - Colors?

#+begin_src elisp
  (use-package erc
    :config

    ;; More compact and cleaner look, nicks and messages are in seperate
    ;; column and total length for nicks are 15 cols
    (setq erc-fill-function 'erc-fill-static)
    (setq erc-fill-static-center 15)

    ;; The rest is from https://www.emacswiki.org/emacs/ErcNickColors
    ;; It's the Option 5

    (defmacro unpack-color (color red green blue &rest body)
      `(let ((,red   (car ,color))
             (,green (car (cdr ,color)))
             (,blue  (car (cdr (cdr ,color)))))
         ,@body))

    (defun rgb-to-html (color)
      (unpack-color color red green blue
                    (concat "#" (format "%02x%02x%02x" red green blue))))

    (defun hexcolor-luminance (color)
      (unpack-color color red green blue
                    (floor (+ (* 0.299 red) (* 0.587 green) (* 0.114 blue)))))

    (defun invert-color (color)
      (unpack-color color red green blue
                    `(,(- 255 red) ,(- 255 green) ,(- 255 blue))))

    (defun erc-get-color-for-nick (nick dark)
      (let* ((hash     (md5 (downcase nick)))
             (red      (mod (string-to-number (substring hash 0 10) 16) 256))
             (blue     (mod (string-to-number (substring hash 10 20) 16) 256))
             (green    (mod (string-to-number (substring hash 20 30) 16) 256))
             (color    `(,red ,green ,blue)))
        (rgb-to-html (if (if dark (< (hexcolor-luminance color) 85)
                           (> (hexcolor-luminance color) 170))
                         (invert-color color)
                       color))))

    (defun erc-highlight-nicknames ()
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward "\\w+" nil t)
          (let* ((bounds (bounds-of-thing-at-point 'symbol))
                 (nick   (buffer-substring-no-properties (car bounds) (cdr bounds))))
            (when (erc-get-server-user nick)
              (put-text-property
               (car bounds) (cdr bounds) 'face
               (cons 'foreground-color (erc-get-color-for-nick nick 't))))))))

    (add-hook 'erc-insert-modify-hook 'erc-highlight-nicknames))
#+end_src
* Keybindings
Keybindings are generally set in-place, following have no context, so they are here.

** macOS
#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    ;; I set the following in Linux using xmodmap but it's kinda
    ;; impossible to do it in OSX I guess.

    ;; I use an external keyboard, this makes AltGr and Meta (Alt) work as expected
    ;; I have also inverted Meta and Control keys system-wide or something, so
    ;; this setting is done according to that.
    (setq ns-option-modifier 'meta
          ns-right-alternate-modifier 'none)

    ;; (define-key key-translition-map ...) is better than (global-define-key ...)
    ;; because this just remaps key everywhere to given key so that the mappings
    ;; works in command mode, isearch etc.
    ;; AltGr + k -> Up
    ;; AltGr + j -> Down
    ;; AltGr + l -> Right
    ;; AltGr + h -> Left
    (define-key key-translation-map (kbd "˚") (kbd "<up>"))
    (define-key key-translation-map (kbd "∆") (kbd "<down>"))
    (define-key key-translation-map (kbd "¬") (kbd "<right>"))
    (define-key key-translation-map (kbd "˙") (kbd "<left>"))

    (define-key key-translation-map (kbd "") (kbd "S-<up>"))
    (define-key key-translation-map (kbd "Ô") (kbd "S-<down>"))
    (define-key key-translation-map (kbd "Ò") (kbd "S-<right>"))
    (define-key key-translation-map (kbd "Ó") (kbd "S-<left>"))

    ;; AltGr + [ -> (
    ;; AltGr + ] -> )
    (define-key key-translation-map (kbd "“") (kbd "("))
    (define-key key-translation-map (kbd "‘") (kbd ")")))
#+end_src

** Some general keybindings

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
  (global-set-key (kbd "C-x <escape>") 'keyboard-escape-quit)
  (global-set-key (kbd "C-c <escape>") 'keyboard-escape-quit)

  (evil-define-key 'normal prog-mode-map
    "gd" 'xref-find-definitions
    "gr" 'xref-find-references)

  (evil-define-key 'normal prog-mode-map (kbd "M-;") 'comment-line)
  (evil-define-key 'visual prog-mode-map (kbd "M-;") 'comment-dwim)

  (evil-define-key 'normal 'global (kbd "M-d") #'im-kill-this-buffer)

  (evil-leader/set-key "1" (λ-interactive (call-interactively (local-key-binding (kbd "C-c C-c")))))
#+END_SRC

* Language specific
** General/language-agnostic functionality
- Use =format-all-buffer= function to format current buffer. Works for any language.

#+begin_src emacs-lisp
  ;; Automatically format file with `format-all-buffer'. It recognizes
  ;; most language formatters/linters.
  (use-package format-all)

  ;; Like `format-all` but works async and automatically formats on
  ;; buffer save.  I keep both of them because somethimes I need
  ;; `format-all-buffer' and it works with more formatters.
  (use-package apheleia
    :config
    (apheleia-global-mode +1)
    (defalias 'im-toggle-auto-code-format #'apheleia-mode))

  ;; Pick up .editorconfig settings for current project automatically
  (use-package editorconfig
    :config
    (editorconfig-mode 1))
#+end_src

*** TODO Get currently focused function name
Needs to be fixed for new treesitter.

#+begin_src emacs-lisp
  (defun im-refactor-debug-log-text ()
    "Return a string in the following format: 'BufferName:FunctionName:LineNumber'.
    This is used in my snippets."
    (format "%s:%s:%s" (buffer-name) (im-current-func-name) (line-number-at-pos)))

  (defun im-current-func-name ()
    (if-let ((fn-node (im-get-current-func-node)))
        (treesit-node-text (treesit-node-child-by-field-name fn-node :name))
      (which-function)))

  (defun im-get-current-func-node ()
    "Return currently focused function node."
    (let ((curr-func nil)
          (curr-node (ignore-errors
                       (treesit-node-at (point)))))
      ;; Find first function declaration or definition
      (while (and curr-node
                  (not (-contains? '(method_definition ;; JS
                                     function_declaration ;; JS
                                     arrow_function ;; JS
                                     function_item ;; Rust
                                     )
                                   (treesit-node-type curr-node))))
        (setq curr-node (treesit-node-parent curr-node)))

      ;; Find first named object of the found function definition
      (while (and curr-node
                  (not (ignore-errors
                         (treesit-node-child-by-field-name curr-node :name))))
        (setq curr-node (treesit-node-parent curr-node)))
      curr-node))
#+end_src
** Refactoring (emr)
#+begin_src emacs-lisp
  (use-package emr
    :config
    (evil-define-key 'normal prog-mode-map (kbd "gR") #'emr-show-refactor-menu)
    (define-key popup-menu-keymap [escape] 'keyboard-quit))
#+end_src

** markdown
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :mode
    (("README\\.md\\'" . gfm-mode)
     ("\\.md\\'" . markdown-mode)
     ("\\.markdown\\'" . markdown-mode)
     ("\\.txt\\'" . markdown-mode)
     ("qutebrowser-editor-" . markdown-mode))
    :config
    (setq markdown-command "multimarkdown")
    (setq markdown-fontify-code-blocks-natively t)

    (evil-leader/set-key-for-mode 'markdown-mode
      "oi" #'markdown-toggle-inline-images)

    (evil-define-key 'normal markdown-mode-map
      (kbd "TAB") 'markdown-cycle
      (kbd "]]") 'markdown-outline-next
      (kbd "[[") 'markdown-outline-previous))
#+END_SRC

** haskell
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode)

  (use-package lsp-haskell
    :config
    (setq lsp-haskell-process-path-hie "ghcide"
          lsp-haskell-process-args-hie '()))

  (use-package ormolu
    :hook (haskell-mode . ormolu-format-on-save-mode)
    :bind
    (:map haskell-mode-map
          ("C-c r" . ormolu-format-buffer)))
#+END_SRC

** rust
#+BEGIN_SRC emacs-lisp
(use-package rust-mode
  :after (lsp-mode)
  (setq lsp-rust-server 'rust-analyzer
        lsp-rust-clippy-preference 'on))
;; (setq lsp-rust-server 'rls)
#+END_SRC

** javascript
*** jsdoc.el
This is a package I wrote for inserting JSDoc comments easily. Check out the [[https://github.com/im-jsdoc.el][README]].

#+begin_src emacs-lisp
  (use-package jsdoc
    :diminish
    :straight (:host github :repo "isamert/jsdoc.el"))
#+end_src

*** subword-mode
The following enables =CamelCase= aware editing operations.
#+begin_src emacs-lisp
(add-hook 'js-mode-hook 'subword-mode)
#+end_src

*** Helper functions
#+begin_src emacs-lisp
  ;; TODO make this idempotent, it breaks absolute imports
  ;; TODO make it work on a line instead of between quotes
  (defun im-js-relative-import-to-abs ()
    "Convert a relative import to an absolute import.
  For example, if you are on the line:
    import Test from '../../test'
  This function transforms the line into:
    import Test from 'src/a/b/test'"
    (interactive)
    (let ((fname (substring-no-properties (thing-at-point 'filename)))
          (bounds (bounds-of-thing-at-point 'filename)))
      (delete-region (car bounds) (cdr bounds))
      (insert (s-chop-prefix (im-current-project-root) (expand-file-name fname)))))


  (defun im-convert-js-object-to-json ()
    "Convert selected JS object into JSON object.
  Example:
    {a: 3, b: 5}
  is converted into
    {
      \"a\": 3,
      \"b\": 5
    }"
    (interactive)
    (if (use-region-p)
        (shell-command-on-region
         (region-beginning)
         (region-end)
         "node -e 'console.log(JSON.stringify(eval(\"(\" + require(\"fs\").readFileSync(0, \"utf-8\") + \")\"), null, 2))'"
         (current-buffer)
         t)
      (user-error "Select something first")))

  (defun im-convert-json-to-js-object ()
    "Convert selected JS object into JSON object.
  Example:
    {
      \"a\": 3,
      \"b\": 5
    }
  is converted into
    {
      a: 3,
      b: 5,
    }"
    (interactive)
    (if (use-region-p)
        (shell-command-on-region
         (region-beginning)
         (region-end)
         "node -e 'console.log(require(\"util\").inspect(JSON.parse(require(\"fs\").readFileSync(0, \"utf-8\")), false, null))'"
         (current-buffer)
         t)
      (user-error "Select something first")))
#+end_src
*** Add node_modules/.bin to PATH automatically
#+begin_src emacs-lisp
  (defun im-add-node-modules-to-path ()
    "Add node_modules/.bin to `exec-path'."
    (interactive)
    (-some--> (locate-dominating-file "." "node_modules")
      (expand-file-name it)
      (f-join it "node_modules/.bin")
      (setq-local exec-path `(,it ,@exec-path))
      (message "%s added to buffer-local path." it)))

  (add-hook 'js-mode-hook #'im-add-node-modules-to-path)
  (add-hook 'js2-mode-hook #'im-add-node-modules-to-path)
  (add-hook 'eshell-mode-hook #'im-add-node-modules-to-path)
#+end_src
*** Debug helpers
#+begin_src emacs-lisp
  (defun im-js-insert-debug-log-for-current-variable ()
    "Insert a `console.log' line for currently focused variable."
    (interactive)
    (let ((curr-indent)
          (node (treesit-node-child-by-field-name
                 (car (jsdoc--tsc-find-descendants-with-type
                       (treesit-node-parent (treesit-node-at (point)))
                       "variable_declarator"))
                 "name")))
      (goto-char (treesit-node-end node))
      (end-of-line)
      (setq curr-indent (current-indentation))
      (insert "\n")
      (insert (make-string curr-indent ? ))
      (insert
       (format
        "console.log(\"%s\", %s) // FIXME remove log"
        (im-refactor-debug-log-text)
        (->>
         node
         (treesit-node-text)
         (s-split "\n")
         (-map #'s-trim)
         (s-join " "))))))
#+end_src
** typescript
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.ts\\'" . typescript-ts-mode))
  (add-hook 'typescript-ts-mode-hook #'im-add-node-modules-to-path)
  (add-hook 'tsx-ts-mode-hook #'im-add-node-modules-to-path)
#+end_src

*** REPL interaction
#+begin_src emacs-lisp
  (evil-leader/set-key-for-mode 'typescript-ts-mode
    ";" #'im-ts-send-expression-to-repl)
  (evil-leader/set-key-for-mode 'js-mode
    ";" #'im-ts-send-expression-to-repl)

  (defun im-treesit-find-parent-with-type (node wanted-type)
    "Get first parent of NODE where parents type is WANTED-TYPE."
    (let ((curr-node node)
          (curr-type nil))
      (while (and curr-node (not (equal curr-type wanted-type)))
        (setq curr-node (treesit-node-parent curr-node))
        (setq curr-type (when curr-node (treesit-node-type curr-node))))
      curr-node))

  (defun im-ts-current-expression ()
    "Get smallest meaningful expression (as something that can be
  sent to REPL)."
    (let* ((current-node (treesit-node-at (point)))
           (getter (lambda (it)
                     (when-let (node (im-treesit-find-parent-with-type current-node (car it)))
                       (if (numberp (cdr it))
                           (treesit-node-child node (cdr it))
                         node)))))
      (->>
       '(("variable_declarator" . 2)
         ("expression_statement" . 0)
         ("function_declaration")
         ("interface_declaration")
         ("enum_declaration")
         ("import_statement")
         ("class_declaration"))
       (-find getter)
       (funcall getter)
       (treesit-node-text))))

  (defun im-ts--import-absolute (expr)
    (if-let ((matches (s-match "^\\(import .* \\)'\\.\\(.*\\)'\\(;\\)?$" expr)))
        (format "%s'%s'"
                (nth 1 matches)
                (s-chop-prefix
                 (im-current-project-root)
                 (expand-file-name (format ".%s" (nth 2 matches)))))
      expr))

  (defun im-ts-send-expression-to-repl (&optional redefine)
    "Send current meaningful expression to node REPL."
    (interactive "P")
    (if-let (expression
             (->>
              (if (use-region-p)
                  (buffer-substring-no-properties (region-beginning)
                                                  (region-end))
                (im-ts-current-expression))
              ;; Replace const with let so that we can redefine this
              ;; thing later if we need to
              (s-replace-regexp "^[\n\t ]*\\(let\\|const\\)" (if redefine "" "let"))
              (s-replace-regexp "^[\n\t ]*export" "")
              ;; Replace relative imports with absolute ones
              im-ts--import-absolute))
        (im-with-visible-buffer
         ".*eshell.*"
         (im-eshell-send-input ".editor\n")
         (im-eshell-send-input expression)
         (im-eshell-send-key ?\C-d))
      (user-error "No expression is found")))
#+end_src

** json
#+begin_src emacs-lisp
  (defun im-jsons-print-path-python ()
    (interactive)
    (let ((jsons-path-printer 'jsons-print-path-python))
      (jsons-print-path)))

  (defun im-jsons-print-path-javascript-js-jq ()
    (interactive)
    (let ((jsons-path-printer 'jsons-print-path-jq))
      (jsons-print-path)))

  ;;  Provides jsons-print-path function, it simply kills the path to the key under point
  (use-package json-snatcher
    :config
    ;; Copies paths like:.definition.summary.pastGroup.trackingResults[0].trackingItemReferenceId
    ;; I've created two functions above for the variations
    (setq jsons-path-printer 'jsons-print-path-jq))

  (defvar im-nodejs-runner-preface
    "const R = require(\"ramda\");")

  (defun im--run-x-on-json (result interactive? &optional replace)
    "Run given EXPRESSION with nodejs on JSON and return the result.
  If REPLACE is non-nil, then clear the buffer or current
  selection and insert the result.

  When called with prefix argument, REPLACE becomes non-nil."
    (when (and interactive?
               (not replace))
      (if (>= (max-mini-window-lines) (length (s-lines result)))
          (message ">> %s" (s-trim result))
        (with-current-buffer (get-buffer-create "*nodejs-result*")
          (switch-to-buffer-other-window (current-buffer))
          (insert result))))
    (cond
     ((and replace (use-region-p))
      (delete-region (region-beginning) (region-end))
      (insert result))
     (replace
      (erase-buffer)
      (insert result)))
    result)

  (defun im--read-json-and-expression ()
    (list
     (if (use-region-p)
         (buffer-substring-no-properties (region-beginning) (region-end))
       (read-string "JSON: "))
     (read-string "Expression: ")
     current-prefix-arg))

  (defun im-run-jq-on-json (json expression &optional replace)
    "Run given EXPRESSION with jq on JSON and return the result.
  If REPLACE is non-nil, then clear the buffer or current
  selection and insert the result.

  When called with prefix argument, REPLACE becomes non-nil."
    (interactive (im--read-json-and-expression))
    (im--run-x-on-json
     (with-temp-buffer
       (insert json)
       (shell-command-on-region (point-min) (point-max) (format "jq -r \"%s\"" expression) nil 't)
       (buffer-string))
     (called-interactively-p 'interactive)
     replace))

  (defun im-run-nodejs-on-json (json expression &optional replace)
    "Run given EXPRESSION with nodejs on JSON and return the result.
  If REPLACE is non-nil, then clear the buffer or current
  selection and insert the result.

  When called with prefix argument, REPLACE becomes non-nil."
    (interactive (im--read-json-and-expression))
    (im--run-x-on-json
     (with-temp-buffer
       (insert im-nodejs-runner-preface)
       (insert "\n")
       (insert (format "const it = %s;" json))
       (insert (format "JSON.stringify(%s, null, 2)" expression))
       (shell-command-on-region (point-min) (point-max) "node -p" nil 't)
       (buffer-string))
     (called-interactively-p 'interactive)
     replace))

  ;; Add execution ability to json blocks inside org-mode. Either add
  ;; `:jq some-jq-query' or `:node it.accessor' to code block's header
  ;; to filter the json
  (defun org-babel-execute:json (body params)
    (let ((jq (cdr (assoc :jq params)))
          (node (cdr (assoc :node params))))
      (cond
       (jq (im-run-jq-on-json body jq))
       (node (im-run-nodejs-on-json body node)))))
#+end_src

** java
=lsp-java= automatically installs =eclipse.jdt.ls= to get lsp.
#+BEGIN_SRC emacs-lisp
  (use-package lsp-java
    :after lsp
    :config
    (setq-default c-basic-offset 4)
    ;; ^ This is required for java-ts-mode, otherwise it fails for some reason.
    ;; https://github.com/emacs-lsp/lsp-mode/issues/3135#issuecomment-933539371
    )

  (defun im-lsp-java-find-lombok-jar ()
    (car (sort (file-expand-wildcards "~/.m2/repository/org/projectlombok/lombok/*/lombok-*.jar") #'string>)))

  (when-let (lombok (im-lsp-java-find-lombok-jar))
    (add-to-list 'lsp-java-vmargs (concat "-javaagent:" (expand-file-name lombok))))
#+END_SRC

*** maven helpers
#+begin_src emacs-lisp
  (defun im-maven-goal-run (&optional invalidate)
    "Select a maven goal and run it.
  This function caches the goal list in the firt run. If you want
  to invalidate the cache, pass a non-nil value for INVALIDATE."
    (interactive "P")
    (let* ((cache-dir (expand-file-name "~/.cache/im-maven/"))
           (cache-file (f-join cache-dir (concat (s-replace "/" "!" (im-current-project-root)) "maven-goals")))
           goals)
      (if (and (not invalidate) (f-exists? cache-file))
          (setq goals (im-deserialize-from-file cache-file))
        (progn
          (message "Generating maven goal list, please wait...")
          (f-mkdir-full-path cache-dir)
          (setq goals (im-maven-goals-read))
          (im-serialize-into-file cache-file goals)
          (message "Generating maven goal list, please wait...Done")))
      (let ((selected (lab--completing-read-object
                       "Select maven goal: "
                       goals
                       :formatter #'(lambda (x) (format "%s - %s"
                                                   (propertize (car x) 'face '(:weight bold))
                                                   (propertize (cadr x) 'face '(:weight thin :slant italic))))
                       :category 'maven-goal)))
        (let ((default-directory (im-current-project-root)))
          (im-shell-command
           :command (format "./mvnw %s" (car selected))
           :buffer-name (format "*%s: %s*" (f-filename (im-current-project-name)) (car selected)))))))

  (defun im-maven-goals-read ()
    "Find all maven goals and their descriptions in current project."
    (let ((default-directory (im-current-project-root)))
      (->>
       (shell-command-to-string "mvn help:effective-pom | grep -E -A 1 '<groupId>'")
       (s-split "\n")
       (--filter (not (equal it "--")))
       (-partition 2)
       (--filter (s-contains? "plugin" (nth 1 it)))
       (--map (let ((group-id (nth 1 (s-match ">\\(.*\\)<" (car it))))
                    (artifact-id (nth 1 (s-match ">\\(.*\\)<" (nth 1 it)))))
                (format "-DgroupId=%s -DartifactId=%s" group-id artifact-id)))
       (-uniq)
       (--mapcat
        (--map
         (let ((xd (s-split "\n" (s-trim it))))
           (list (car xd)
                 (s-join " " (mapcar #'s-trim (-drop 1 xd)))))
         (s-split
          "\n\n"
          (let ((x
                 (->
                  (im-tap (format "mvn help:describe %s" it) )
                  shell-command-to-string
                  (string-trim-left "\\(\n\\|.\\)*This plugin has [0-9]+ goals:\n\n")
                  (string-trim-right "\n\nFor more information\\(\n\\|.\\)*"))))
            (if (s-contains? "[ERROR]" x) "" x))))))))
#+end_src

** clojure
Here is the current workflow I use:
- =lein new app project-name=
- =cider-jack-in=

#+begin_src emacs-lisp
  (use-package cider
    :after clojure-mode
    :config
    (setq cider-inspector-page-size 50)
    (setq cider-show-error-buffer nil)

    (evil-define-key 'normal clojure-mode-map (kbd "K") #'cider-doc)
    (evil-define-key 'normal cider-inspector-mode-map
      (kbd "RET") #'cider-inspector-operate-on-point
      (kbd "DEL") #'cider-inspector-pop)
    (evil-leader/set-key-for-mode 'clojure-mode
      ";" (im-eval-dwim #'cider-eval-last-sexp #'cider-eval-region #'cider-eval-defun-at-point))

    ;; `compojure' indent
    (define-clojure-indent
      (defroutes 'defun)
      (GET 2)
      (POST 2)
      (PUT 2)
      (DELETE 2)
      (HEAD 2)
      (ANY 2)
      (OPTIONS 2)
      (PATCH 2)
      (rfn 2)
      (let-routes 1)
      (context 2)))

  ;; TODO use this for all lispy langs
  (defun im-eval-dwim (lastf regionf defunf)
    "Generate an interactive function that you can bind to a key
  which calls LASTF, REGIONF or DEFUNF."
    (lambda ()
      (interactive)
      (cond
       ((use-region-p)
        (call-interactively regionf))
       ((or (-contains? '(?\) ?\") (char-before))
            (-contains? '(?\ ?\)) (char-after)))
        (call-interactively lastf))
       (t
        (call-interactively defunf)))))
#+end_src

** common-lisp
#+begin_src emacs-lisp
  (use-package slime
    :config
    (setq inferior-lisp-program "sbcl"))

  (evil-define-key 'normal lisp-mode-map (kbd "K") #'slime-documentation)
  (evil-leader/set-key-for-mode 'lisp-mode
    ";" (im-eval-dwim #'slime-eval-last-expression #'slime-eval-region #'slime-eval-region))
#+end_src
** emmet-mode
Hit <C-j> after these and get:
- =a= ~<a href="|">|</a>~
- =.x= ~<div class="x"></div>~
- =br/= ~<br />~
- =p.x.y.z= ~<p className="x y z"></p>~ (Works well with JSX)
- ~input[type=text]~ ~<input type="text" name="" value=""/>~
- =a>b>c= ~<a href=""><b><c></c></b></a>~
- =b*3= ~<b></b><b></b><b></b>~
#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :hook (js-mode css-mode sgml-mode web-mode tsx-mode)
  :init
  (setq emmet-expand-jsx-className? t
        emmet-self-closing-tag-style " /"))
#+END_SRC

** r
#+BEGIN_SRC emacs-lisp
(use-package ess)
#+END_SRC

** kotlin
#+BEGIN_SRC emacs-lisp
  (use-package kotlin-mode
    :config
    (evil-leader/set-key-for-mode 'kotlin-mode
      ";" (im-eval-dwim #'kotlin-send-line #'kotlin-send-region #'kotlin-send-line)
      "'" #'kotlin-repl)

    ;; ki is a better REPL for Kotlin. You can save and reload your session.
    (setq kotlin-command "ki"))
#+END_SRC

** gradle/groovy
#+BEGIN_SRC emacs-lisp
(use-package groovy-mode
  :config
  (add-to-list 'auto-mode-alist '("\\.gradle\\'" . groovy-mode)))
#+END_SRC

** yaml
#+begin_src emacs-lisp
(use-package yaml-mode)
#+end_src

** elisp
*** Inspector/debugging/pretty-printing
There is a built-in function (~data-debug-eval-expression~) to inspect objects (not good as CIDERs inspector but it works). I made a helper function to evaluate last expression and open data-debug window of it.

#+begin_src emacs-lisp
  (defun im-eval-and-inspect-last-sexp ()
    (interactive)
    (require 'data-debug)
    (data-debug-show-stuff (eval-last-sexp nil) "last sexp"))
#+end_src

There is also ~pp-eval-last-sexp~ which evaluates and pretty-prints the result of last expression in a separate buffer, which can be better for inspection sometimes.

*** eros
Like CIDER, it shows the results of ~eval-last-sexp~ etc. in an overlay, right next to the expression itself. There is also ~eros-inspect-last-result~ which essentially shows the result of last evaluation in a pretty printed format in a different buffer.

#+begin_src emacs-lisp
  (use-package eros
    :diminish
    :straight (:host github :repo "isamert/eros")
    :config
    (eros-mode 1)
    (add-hook 'eros-inspect-hooks (lambda () (flycheck-mode -1)))
    (evil-leader/set-key
      ";"  (im-eval-dwim #'eros-eval-last-sexp #'eval-region #'eros-eval-defun)
      "'" #'eros-inspect-last-result))
#+end_src
*** Inline/popup documentation
#+begin_src emacs-lisp
  (evil-define-key 'normal emacs-lisp-mode-map (kbd "K") #'im-describe-thing-in-popup)
  (evil-define-key 'normal lisp-interaction-mode-map (kbd "K") #'im-describe-thing-in-popup)

  (defvar im-describe-thing-posframe-point nil)
  (defun im-describe-thing--remove-posframe (&rest _)
    (unless (eq (point) im-describe-thing-posframe-point)
      (posframe-hide "*im-describe*")
      (remove-hook 'post-command-hook #'im-describe-thing--remove-posframe)))

  (defun im-describe-thing-in-popup ()
    (interactive)
    (let* ((thing (symbol-at-point))
           (help-xref-following t)
           (description (save-window-excursion
                          (helpful-symbol thing)
                          (buffer-string))))
      (posframe-hide-all)
      (posframe-show
       "*im-describe*"
       :string description
       :poshandler #'posframe-poshandler-frame-top-right-corner
       :border-width 10
       :max-width 80
       :background-color (mini-frame-get-background-color))
      (setq im-describe-thing-posframe-point (point))
      (add-hook 'post-command-hook #'im-describe-thing--remove-posframe)))
#+end_src

*** Pretty stuff
#+begin_src emacs-lisp
  (im-prettify-mode 'emacs-lisp-mode-hook
                         '((">="     . ?≥)
                           ("<="     . ?≤)
                           ("defun"  . ?ƒ)
                           ("lambda" . ?λ)))
#+end_src

For linting packages, use  ~(flycheck-package-setup)~ to initialize it.

#+begin_src emacs-lisp
  (use-package package-lint)
  (use-package flycheck-package)
#+end_src

** Racket
- Open a racket buffer.
- Do C-c C-c (racket-run)
- It'll drop you on a REPL within the scope of the file.

#+begin_src emacs-lisp
  (use-package racket-mode
    :config
    (evil-leader/set-key-for-mode 'racket-mode
      ";" #'racket-eval-last-sexp
      "'" #'racket-send-definition
      "\\" #'racket-send-region))
#+end_src
** dhall
#+begin_src emacs-lisp
  (use-package dhall-mode
    :diminish dhall-format-on-save-mode
    :mode "\\.dhall\\'"
    :config
    ;; I use dhall-lsp-server, so I don't need this
    (setq dhall-use-header-line nil))
#+end_src

** nix
#+begin_src emacs-lisp
  (use-package nix-mode
    :mode "\\.nix\\'")

  (defun im-import-env-from-nix-shell ()
    (interactive)
    (let ((default-directory (im-current-project-root)))
      (when (not (and (file-exists-p "shell.nix") (executable-find "nix-shell")))
        (error "Failed to find shell.nix or nix-shell"))
      (--> (shell-command-to-string "nix-shell --quiet --run 'env'")
        (split-string it "\n")
        (--map (-let (((name val) (s-split-up-to "=" it 1)))
                 (setenv name val)
                 (when (string-equal name "PATH")
                   (setq exec-path (split-string val path-separator)))
                 `(,name ,val))
               it))
      (message "Done.")))
#+end_src

** swift
#+begin_src emacs-lisp
  (use-package swift-mode)
#+end_src

** scheme
#+begin_src emacs-lisp
  ;; Scheme
  (use-package geiser
    :config
    (setq geiser-debug-jump-to-debug-p nil)
    (setq geiser-default-implementation 'guile)
    (evil-leader/set-key-for-mode 'scheme-mode
      ";" #'geiser-eval-last-sexp
      "'" #'geiser-eval-definition
      "\\" #'geiser-eval-region))

  (use-package geiser-guile
    :after geiser)
#+end_src

** Docker stuff
Some major modes for editing files.
#+begin_src emacs-lisp
  (use-package dockerfile-mode
    :mode "Dockerfile\\'")
  (use-package docker-compose-mode
    :mode "docker-compose\\'")
#+end_src

A package for  managing docker.

#+begin_src emacs-lisp
  (use-package docker
    :config
    (evil-define-key 'normal docker-container-mode-map (kbd "a") #'docker-container-help)
    (evil-define-key 'normal docker-image-mode-map     (kbd "a") #'docker-image-help)
    (evil-define-key 'normal docker-machine-mode-map   (kbd "a") #'docker-machine-help)
    (evil-define-key 'normal docker-network-mode-map   (kbd "a") #'docker-network-help)
    (evil-define-key 'normal docker-volume-mode-map    (kbd "a") #'docker-volume-help))
#+end_src
** Kubernetes
- Use ~kubernetes-overview~ to get an overview.
- Use ~kubernetes-contexts-use-context~ to switch between contexts.
- Use ~kubernetes-set-namespace~ to set a namespace.

#+begin_src emacs-lisp
  (use-package kubernetes
    :config
    (setq kubernetes-poll-frequency 3600)
    (setq kubernetes-redraw-frequency 3600)

    (evil-define-key 'normal kubernetes-overview-mode-map
      (kbd "r") #'kubernetes-refresh
      (kbd "a") #'kubernetes-dispatch))

  (use-package kubernetes-evil
    :after kubernetes)
#+end_src
** vimrc
Mostly for editing tridactyl and sometimes real vimrc.

#+begin_src emacs-lisp
  (use-package vimrc-mode)
#+end_src

** Graphviz/dot
#+begin_src emacs-lisp
  (use-package graphviz-dot-mode)
#+end_src
** PlantUML
#+begin_src emacs-lisp
  (use-package plantuml-mode
    :config
    (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
    (setq plantuml-default-exec-mode 'jar)
    (setq plantuml-jar-path "/nix/store/q0v5nv70zc23fx4hjgghnqf7lvydr6fq-plantuml-1.2021.3/lib/plantuml.jar")
    (setq org-plantuml-jar-path plantuml-jar-path))
#+end_src
** Couchbase
Install couchbase-query package for running interactive queries inside emacs.
#+begin_src emacs-lisp
  (use-package couchbase-query
    :diminish
    :straight (:host github :repo "isamert/couchbase-query.el")
    :config
    (setq couchbase-query-command "/Applications/Couchbase Server.app/Contents/Resources/couchbase-core/bin/cbq"))
#+end_src

Create a mode for n1ql and make n1ql code blocks inside org-mode runnable.

#+begin_src emacs-lisp
  ;; Create a dummy derived mode based on sql-mode for n1ql, so that we
  ;; get some syntax highlighting for free
  (define-derived-mode n1ql-mode sql-mode "n1ql-mode")
  (add-to-list 'auto-mode-alist (cons (rx ".n1ql" string-end) #'n1ql-mode))

  ;; Add a function to execute n1ql code blocks in org-mode. It works
  ;; just like how sql-mode code blocks is executed
  (defun org-babel-execute:n1ql (body params)
    (im-cbq
     body
     :host (alist-get :host params)
     :username (alist-get :username params)
     :password (alist-get :password params)
     :select (or (alist-get :select params) ".")))


  (cl-defun im-cbq (query &key host username password (select "."))
    "Run a couchbase query and return the result."
    (with-temp-buffer
      (insert query)
      (shell-command-on-region
       (point-min)
       (point-max)
       (format "cbq -quiet -engine '%s' -credentials '%s'"
               host
               (format "%s:%s" username password))
       nil t)
      (replace-regexp-in-region "^cbq> " "" (point-min) (point-max))
      (shell-command-on-region (point-min) (point-max) (format "jq -r '%s'" select) nil t)
      (buffer-string)))
#+end_src

Create a mode for cbc binary and make cbc-mode code blocks runnable inside emacs. cbc is not able to read commands from a file, so it does not really makes sense to create a mode for it but I do this to be able to create code blocks in org mode for cbc commands so that I can save some commands in an org file and re-run them whenever I want.

#+begin_src emacs-lisp
  (define-generic-mode 'cbc-mode
    '(?!)
    '("help" "version" "cat" "create" "create" "cp" "incr" "decr" "touch" "rm" "hash" "stats" "observe" "view" "lock" "unlock" "admin" "bucket" "bucket" "bucket" "role" "user" "user" "user" "connstr" "query" "write" "strerror" "ping" "watch" "keygen")
    nil
    '("cbc\\'")
    nil
    "Simple mode for couchbase cbc commandline utility.")

  (defun org-babel-execute:cbc (body params)
    (im-cbc
     body
     :host (alist-get :host params)
     :username (alist-get :username params)
     :password (alist-get :password params)
     :bucket (alist-get :bucket params)
     :select (or (alist-get :select params) ".")))

  (cl-defun im-cbc (cbc-command &key host username password bucket raw (select "."))
    "Run given cbc command."
    (let* ((cmd (format "cbc %s --spec=%s/%s --username='%s' --password='%s'"
                        cbc-command
                        host
                        bucket
                        username
                        password)))
      (message "im-cbc :: %s" cmd)
      (with-temp-buffer
        (insert (im-shell-command-to-string cmd))
        (shell-command-on-region
         (point-min)
         (point-max)
         (format "jq %s '%s'" (if raw "-r" "") select)
         nil
         t)
        (buffer-string))))
#+end_src

** BigQuery
#+begin_src emacs-lisp
  (define-derived-mode bqsql-mode sql-mode "bqsql-mode")
  (add-to-list 'auto-mode-alist (cons (rx ".bqsql" string-end) #'bqsql-mode))

  (defun org-babel-execute:bqsql (query params)
    "Execute bqsql (BigQuery) scripts.
  `:var' syntax is ${var_name}."
    (let* ((job-id (im-uuid))
           (format (or (alist-get :format params) "pretty"))
           (json-out? (s-matches? "json" format))
           (buf (get-buffer-create "*im-bqsql*"))
           (org-buffer (current-buffer))
           (start-time (float-time))
           process
           (vars (org-babel--get-vars params)))
      (setq query
            (replace-regexp-in-string
             "${[a-zA-Z_]+}"
             (lambda (substr)
               (let ((var (intern (replace-regexp-in-string "${\\([a-zA-Z_]+\\)}" "\\1" substr))))
                 (or (alist-get var vars) substr)))
             query))
      (with-current-buffer buf (erase-buffer))
      (setq process (start-process "query" buf "bq" "query" "--quiet" "--nouse_legacy_sql" "--format" format "--job_id" job-id query))
      (set-process-sentinel
       process
       (lambda (p m)
         (let ((end-time (float-time))
               (result (with-current-buffer buf
                         (string-trim (buffer-string)))))
           (message "=> Query finished, time elapsed: %s" (format-seconds "%Y %D %H %M %z%S" (- end-time start-time)))
           (with-current-buffer org-buffer
             (save-excursion
               (goto-char (point-max))
               (unless (re-search-backward job-id nil t)
                 (let ((bname (format "*bqsql:%s" job-id)))
                   (with-current-buffer (get-buffer-create bname)
                     (insert result)
                     (org-mode))
                   (user-error "org-block is gone. Result inserted to the buffer %s" bname)))
               (forward-line -4)
               (org-babel-insert-result
                result
                (list "replace" (cond
                                 ((s-prefix? "Error" result) "drawer")
                                 (json-out? "lang")
                                 (t "raw")))
                nil
                nil
                (when json-out? "json")))))))
      job-id))

  (defun im-big-query-job-status (job-id)
    "Get status for given job id."
    (interactive
     (list (read-string "Job ID: " (im-region-or 'symbol))))
    (let ((buf (get-buffer-create (format "*im-bigquery: %s*" job-id))))
      (switch-to-buffer buf)
      (insert (shell-command-to-string (format "bq show %s -j '%s'" (if current-prefix-arg "--format=prettyjson" "") job-id)))))

  (defun im-big-query-table-info (table-name)
    "Get summary information for TABLE-NAME.
  This information includes schema summary, last modified date,
  total {rows,bytes} etc. and first 10 rows of the table."
    (interactive
     (list (read-string
            "Table: "
            ;; Replace first `.' with `:'
            (s-replace-regexp
             "^\\([A-Za-z0-9_-]+\\)\\." "\\1:"
             (im-region-or
              (lambda () (im-inner-back-quote-at-point)))))))
    (let ((buffer-name (format "*bq table info: %s*" table-name)))
      (im-shell-command
       :buffer-name buffer-name
       :command (format "bq show '%s'" table-name)
       :on-start
       (lambda (&rest _)
         (toggle-truncate-lines +1)
         (im-shell-command
          :buffer-name buffer-name
          :command (format "bq head -n 200 '%s'" table-name))))))
#+end_src

** kbd-mode
For working with [[id:DF9E83D5-CA3E-4E3A-990A-ED2AEBA00983][KMonad]] kbd files. Do ~C-c C-c~ (~kbd-start-demo~) to apply your config and try it in a buffer.

#+begin_src emacs-lisp
  (use-package kbd-mode
    :diminish
    :straight (:host github :repo "kmonad/kbd-mode")
    :config
    (setq kbd-mode-kill-kmonad "pkill -9 kmonad")
    (setq kbd-mode-start-kmonad "kmonad ~/.config/kmonad.kbd"))
#+end_src

** lua-mode
#+begin_src emacs-lisp
  (use-package lua-mode)
#+end_src
** jsonnet-mode
#+begin_src emacs-lisp
  (use-package jsonnet-mode
    :config
    ;; Apheleia config, so that it automatically formats on save
    (setf (alist-get 'jsonnet apheleia-formatters) '("jsonnetfmt" "-"))
    (setf (alist-get 'jsonnet-mode apheleia-mode-alist) 'jsonnet))
#+end_src
* Window and buffer management
** tab-bar-mode
It's a great workspace manager that comes bundled with Emacs. I was using an abomination where ~persp.el~ and ~eyebrowse~ was glued together but I guess this is a simpler and more sane alternative to them.

~tab-history-mode~ is just like ~winner-mode~ but tab-local which saves you from a lot of trouble.

#+begin_src emacs-lisp
  (tab-bar-mode)
  (tab-bar-history-mode)

  (setq tab-bar-new-tab-to 'rightmost)
  (setq tab-bar-new-tab-choice im-init-file)
  (setq
   tab-bar-format
   '(tab-bar-format-tabs
     tab-bar-separator
     tab-bar-format-add-tab
     tab-bar-format-align-right
     ;;tab-bar-format-global
     ))
#+end_src

Use a slightly modified version of ~tab-bar-tab-name-format~.

#+begin_src emacs-lisp
  (setq tab-bar-tab-hints t)
  ;; ^ Show numbers before tab names
  (setq tab-bar-auto-width nil)
  (setq tab-bar-auto-width-max nil)
  ;; ^ Hmmm
  (setq tab-bar-tab-name-format-function #'tab-bar-tab-name-format-default)
  (setq tab-bar-tab-name-function #'im-current-project-name)
#+end_src

Evil has a default binding for switching between tabs with ~gt~ and ~gT~, switching forward and backward respectively. I just make them repeatable so that after first ~gt~ (~gT~) I can hammer down ~t~ (or ~T~) to switch next/prev tab quickly instead of doing ~gt~ (or ~gT~) again and again.

#+begin_src emacs-lisp
  (im-make-repeatable tab-bar-switch
    "t" tab-bar-switch-to-next-tab
    "T" tab-bar-switch-to-prev-tab)
#+end_src

I want to show ~consult-buffer~ when I open a new tab to be able to quickly jump a file. I also want to show it in a buffer, not in mini-buffer.

#+begin_src emacs-lisp
  (define-advice tab-bar-new-tab (:after (&rest _) show-consult-buffer-in-buffer)
    (when (eq this-command 'tab-bar-new-tab)
      ;; Display consult-buffer in current window (in newly opened tab)
      ;; so that I can start typing direclty to jump another
      ;; file/project etc.
      (let ((vertico-multiform-commands '((consult-buffer buffer (vertico-buffer-display-action . (display-buffer-same-window)))))
            (mini-frame-ignore-commands `(,@mini-frame-ignore-commands consult-buffer))
            (this-command 'consult-buffer))
        (consult-buffer))))
#+end_src

** tab-line-mode
:PROPERTIES:
:ID:       163981c6-a121-4841-be08-54e359233450
:END:
#+begin_src emacs-lisp
  (setq tab-line-close-button-show 'selected)
  (setq tab-line-tabs-function #'im-tab-line-buffers)
  (setq tab-line-tab-name-function #'tab-line-tab-name-truncated-buffer)
  (setq tab-line-tab-name-truncated-max 25)
  (global-tab-line-mode)

  (defvar im-tab-line-hidden-buffer-name-regexp
    (concat
     "\\*\\(Calc.*\\|Calendar\\|elfeed-log\\|helpful.*\\|Compile-Log\\|Help\\|lsp-log\\)\\*"
     "\\|magit.*"
     "\\|slack-curl-downloader"
     "\\|slack-log"
     "\\|slack-event-log"
     "\\|dir-data"
     "\\|.*-ls\\*"
     "\\|.*stderr\\*"
     "")
    "Regexp to filter out buffer names on tab line.")

  (defun im-tab-line-buffers ()
    "Return releated project buffers (not limited to files, shells
  etc.) to display in tab-line."
    (let* ((proj (or (im-current-project-root)
                     (expand-file-name default-directory)))
           (buffer-name (buffer-name))
           (buffer-filter (if (s-matches? "^\\*\\|\\$" buffer-name)
                              (apply-partially #'im-tab-line--buffer-same-group? buffer-name)
                            (apply-partially #'im-tab-line--buffer-same-project? proj))))
      (seq-sort-by
       #'buffer-name #'string<
       (seq-filter (lambda (b)
                     (with-current-buffer b
                       (and (im-tab-line--buffer-valid?)
                            (funcall buffer-filter))))
                   (funcall tab-line-tabs-buffer-list-function)))))

  (defun im-tab-line--buffer-valid? ()
    (not (s-matches? im-tab-line-hidden-buffer-name-regexp (buffer-name))))

  (defun im-tab-line--buffer-same-project? (project-dir)
    (and
     (s-prefix? project-dir (expand-file-name default-directory))
     (not (s-matches? "^\\*\\|\\$" (buffer-name)))))

  (defun im-tab-line--buffer-same-group? (orig-buffer-name)
    (s-prefix? (substring orig-buffer-name 0 4) (buffer-name)))
#+end_src

** tabgo.el
#+begin_src emacs-lisp
  (use-package tabgo :straight (:host github :repo "isamert/tabgo.el"))
  (evil-define-key 'normal 'global (kbd "M-t") #'tabgo)
  (evil-define-key 'normal 'evil-org-mode (kbd "M-t") #'tabgo)
#+end_src
** bufler
Good for buffer management, especially for groupped killings.

#+begin_src emacs-lisp
  (use-package bufler
    :config
    (evil-define-key 'normal bufler-list-mode-map
      (kbd "q") 'quit-window
      (kbd "x") 'bufler-list-buffer-kill
      (kbd "<return>") 'bufler-list-buffer-switch
      (kbd "M-,") 'bufler-list-buffer-peek
      (kbd "p") 'bufler-list-buffer-peek))
#+end_src

** Functions
#+begin_src emacs-lisp
  (defun im-quit ()
    "Quit current window or buffer. Source: meow-quit"
    (interactive)
    (if (> (seq-length (window-list (selected-frame))) 1)
        (delete-window)
      (previous-buffer)))

  (defun im-split-window-below ()
    "Split window below and focus."
    (interactive)
    (split-window-below)
    (other-window 1))

  (defun im-split-window-right ()
    "Split window right and focus."
    (interactive)
    (split-window-right)
    (other-window 1))

  (defun im-print-buffer-file-info (&optional kill-file-path)
    (interactive "P")
    (let* ((proj-name (im-current-project-name))
           (proj-path (or (im-current-project-root) (expand-file-name "~/")))
           (fpath (or (buffer-file-name) (buffer-name)))
           (fpath-pretty (string-replace (expand-file-name "~") "~" fpath)))
      (message "[%s] %s\n%s\n%s\n%s"
               (propertize proj-name 'face 'bold)
               (propertize (string-remove-prefix proj-path fpath) 'face '(:foreground "plum"  :slant italic))
               (format "%s%s" (if kill-file-path (propertize "Copied: " 'face 'bold) "") fpath-pretty)
               (format "Size: %s" (im-human-readable-size (buffer-size)))
               (format "Current branch: %s" (lab-git-current-branch)))
      (when kill-file-path
        (im-kill fpath-pretty))))
#+end_src
** Keybindings
#+begin_src emacs-lisp
  (evil-define-key 'normal 'global
    "Q" #'im-quit
    (kbd "M-\\") #'im-split-window-right
    (kbd "M--")  #'im-split-window-below
    (kbd "[2") #'tab-line-switch-to-prev-tab
    (kbd "]2") #'tab-line-switch-to-next-tab
    (kbd "[1") #'tab-bar-switch-to-prev-tab
    (kbd "]1") #'tab-bar-switch-to-next-tab)

  (evil-leader/set-key
    "l" #'evil-window-right
    "h" #'evil-window-left
    "j" #'evil-window-down
    "k" #'evil-window-up)

  (evil-leader/set-key
    ;; misc window operations
    "wo" #'other-window
    "w1" #'delete-other-windows
    "w=" #'balance-windows
    ;; window-move
    "wL" #'evil-window-move-far-right
    "wH" #'evil-window-move-far-left
    "wJ" #'evil-window-move-very-bottom
    "wK" #'evil-window-move-very-top
    ;; window-size
    "w+" #'enlarge-window
    "w-" #'shrink-window
    "w>" #'enlarge-window-horizontally
    "w<" #'shrink-window-horizontally
    ;; workspace (tab-bar-mode)
    "wu" #'tab-bar-history-back ;; undo
    "wr" #'tab-bar-history-forward ;; redo
    "wt" #'tab-bar-new-tab ;; tab
    "wn" #'tab-bar-rename-tab ;; name
    "wm" #'tab-move ;; move
    "ws" #'tab-bar-switch-to-tab ;; switch
    "wl" #'tab-bar-switch-to-recent-tab ;; last
    "wk" #'tab-close ;; kill
    ;; extra
    "wi" #'im-print-buffer-file-info
    ;; buffer
    "wb" #'bufler)

  (evil-define-key '(normal insert motion) 'global
    (kbd "M-1") (λ-interactive (tab-bar-select-tab 1))
    (kbd "M-2") (λ-interactive (tab-bar-select-tab 2))
    (kbd "M-3") (λ-interactive (tab-bar-select-tab 3))
    (kbd "M-4") (λ-interactive (tab-bar-select-tab 4))
    (kbd "M-5") (λ-interactive (tab-bar-select-tab 5)))

  (im-make-repeatable winner
    "u" tab-bar-history-back
    "r" tab-bar-history-forward)

  (im-make-repeatable window-resize
    "+" enlarge-window
    "-" shrink-window
    ">" enlarge-window-horizontally
    "<" shrink-window-horizontally)
#+end_src
* Misc functions
** marks integration
[[https://github.com/im-marks][marks]] is a grep-like tool for searching org-mode and markdown files. The following snippet provides a ~consult~ support for marks.

#+begin_src emacs-lisp
  (evil-leader/set-key "cm" #'im-marks-my-docs)

  (defun im-consult--marks-builder (input)
    (cons
     (list "marks" "--no-color" "--null" "--path" default-directory "--query" input)
     nil))

  (defun im-marks (&optional directory)
    "Run `marks'."
    (interactive)
    (let ((default-directory (or directory default-directory)))
      (consult--grep "marks" #'im-consult--marks-builder default-directory "")))

  (defun im-marks-my-docs ()
    "Run marks inside `~/Documents/notes'."
    (interactive)
    (im-marks (expand-file-name "~/Documents/notes")))
#+end_src
** Jira
#+begin_src emacs-lisp :lexical yes
  (evil-leader/set-key "ejo" #'im-open-jira-issue-at-point)
  (evil-leader/set-key "eji" #'im-jira-list-issues)
  (evil-leader/set-key "ejc" #'im-jira-create-ticket)

  ;;
  ;; Install required JIRA client
  ;;

  (use-package jiralib2
    :config
    (setq jiralib2-url ty-jira-url)
    (setq jiralib2-auth 'basic)
    (setq jiralib2-user-login-name ty-jira-login)
    (setq jiralib2-token nil))

  ;;
  ;; My completing-read based JIRA utilities
  ;;

  (defvar im-git-worktrees-root "~/Workspace/projects/worktrees"
    "Directory to create worktrees in.")

  (defvar im-git-main-branch "master"
    "Main branch name.")

  (defvar im-jira-projects '(("AI"))
    "List of projects that I enrolled in JIRA.")

  (defvar im-jira-base-branch "origin/master"
    "Brach to create feature branches from.
  Consider using origin/something to create the branch from latest
  something.")

  (defvar im-jira-feature-branch-prefix "feature/"
    "Prefix to prepend feature branch names.")

  (defvar im-jira-my-issues-query "Pair-programmer = currentUser() OR assignee = currentUser() OR creator = currentUser() ORDER BY createdDate DESC"
    "Query to find out issues that are assigned to me.")

  (defvar im-jira-kanban-board-query
    "project = AI AND (fixVersion in unreleasedVersions() OR fixVersion is EMPTY) AND createdDate >= -2w ORDER BY Rank ASC"
    "Query to get kanban board issues.")

  (defvar im-jira-board-id
    "1066"
    "Interested board id. TODO: make this a list so that I can access to multiple boards by `im-jira-list-issues'.")

  (defun im-open-jira-issue (issue-number)
    "Open given Jira ISSUE-NUMBER."
    (interactive "sIssue: ")
    (let ((url (format "%s/browse/%s" jiralib2-url (car (s-split " " issue-number)))))
      (kill-new url)
      (browse-url url)))

  (defun im-jira-issue-at-point ()
    (let ((sym (or (thing-at-point 'symbol) "")))
      (when (s-matches? "[a-zA-Z]+-[0-9]+" sym)
        sym)))

  (defun im-open-jira-issue-at-point ()
    "Open issue at point."
    (interactive)
    (im-open-jira-issue
     (or (im-jira-issue-at-point)
         (read-string "Enter issue number: "))))

  (defmemoize im-jira-get-my-issues ()
    (jiralib2-jql-search im-jira-my-issues-query))

  (defun im-jira-get-kanban-issues ()
    (jiralib2-jql-search im-jira-kanban-board-query))

  (defun im-jira-get-board-issues ()
    (jiralib2-board-issues im-jira-board-id nil))

  (defun im-jira-jql (jql)
    (interactive "sEnter JQL: ")
    (jiralib2-jql-search jql))

  (defmemoize im-jira-get-current-sprint-issues ()
    (let ((issues '()))
      (mapc
       (lambda (project)
         (setq
          issues
          (thread-last (format "project = \"%s\" AND Sprint in openSprints()"
                               (car project) (car project) (cdr project))
                       (jiralib2-jql-search)
                       (append issues))))
       im-jira-projects)
      issues))

  (defun im-jira-get-new-issues ()
    (let ((issues '()))
      (mapcar
       (lambda (project)
         (setq
          issues
          (thread-last (format "project = \"%s\" AND created > -7d"
                               (car project))
                       (jiralib2-jql-search)
                       (append issues))))
       im-jira-projects)
      issues))

  (defun im-jira-list-issues (&optional arg)
    (interactive "P")
    (thread-last (pcase (completing-read "Issue list: " '("My issues" "Current Sprint" "New issues" "Kanban" "Board" "JQL"))
                   ("My issues" (im-jira-get-my-issues))
                   ("New issues" (im-jira-get-new-issues))
                   ("Current Sprint" (im-jira-get-current-sprint-issues))
                   ("Board" (im-jira-get-board-issues))
                   ("Kanban" (im-jira-get-kanban-issues))
                   ("JQL" (call-interactively #'im-jira-jql)))
                 (--map (cons (im-jira--format-ticket-name it) it))
                 (im-alist-completing-read "Select ticket: ")
                 (im-jira-issue-actions)))

  (defun im-jira-ticket-to-branch (key summary)
    "Create a new branch from given ISSUE-NAME and switch to it."
    (interactive "sIssue name: ")
    (let ((branch-name (im-jira--create-branch-name-from-ticket (concat key summary))))
      (unless (equal im-git-main-branch (lab-git-current-branch))
        (user-error "Please switch to `%s' branch first." im-git-main-branch))
      (message "Updating...")
      (magit-fetch-all nil)
      (message "Creating branch...")
      (magit-branch-and-checkout branch-name im-jira-base-branch)
      (vc-refresh-state)
      (im-jira-change-issue-status-to-status key "In Progress")
      (message "Currently on %s." (magit-get-current-branch))))

  (defun im-jira-ticket-to-worktree (key summary)
    (interactive "sIssue name: ")
    (let* ((branch-name (im-jira--create-branch-name-from-ticket (concat key summary)))
           (worktree (expand-file-name (format "%s/%s" im-git-worktrees-root (s-replace "/" "-" branch-name)))))
      (message "Updating...")
      (magit-fetch-all nil)
      (message "Creating worktree...")
      (if (-contains? (vc-git-branches) branch-name)
          (magit-worktree-checkout worktree branch-name)
        (magit-worktree-branch worktree branch-name im-jira-base-branch))
      (persp-add-new branch-name)
      (persp-switch branch-name)
      (cd worktree)
      (find-file)
      (vc-refresh-state)
      (im-jira-change-issue-status-to-status key "In Progress")
      (message "Currently on %s." (magit-get-current-branch))))

  (defun im-jira-create-ticket ()
    (interactive)
    (let ((project (im-jira--select-project))
          (issue-type (im-jira--select-issue-type))
          (summary (read-string "Issue summary: ")))
      (im-get-input
       :init
       (format (concat
                "* %s\n"
                ":PROPERTIES:\n"
                ":PROJECT-ID: %s\n"
                ":ISSUE-TYPE: %s\n"
                ":SPRINT: active|future\n"
                ":END:\n\n"
                (im-jira--get-issue-template issue-type))
               summary project issue-type)
       :pre-process
       (lambda ()
         (goto-char (point-min))
         (list
          :summary (org-entry-get nil "ITEM")
          :project-id (org-entry-get nil "PROJECT-ID")
          :type (org-entry-get nil "ISSUE-TYPE")
          :rest `((,(im-jira-get-issue-field-id-for "Sprint") .
                   ,(alist-get 'id (im-jira-find-sprint (org-entry-get nil "SPRINT")))))))
       :on-accept
       (lambda (description props)
         (setq description
               (->>
                (org-export-string-as description 'confluence t)
                (s-split "\n")
                (-drop 1)
                (s-join "\n")))
         (message ">> (im-jira-create-ticket %s :description %s)" props description)
         (thread-last
           (apply #'jiralib2-create-issue
                  `(,(plist-get props :project-id)
                    ,(plist-get props :type)
                    ,(plist-get props :summary)
                    ,description
                    ,@(plist-get props :rest)))
           (im-jira-issue-actions))))))

  (defun im-jira-get-issue-fields ()
    (jiralib2-session-call "/rest/api/2/field"))

  ;; TODO support pagination
  (defun im-jira-get-sprints ()
    (alist-get 'values (jiralib2-session-call "/rest/agile/1.0/board/868/sprint")))

  (defun im-jira-find-sprint (sprint)
    "Find a sprint. SPRINT can be a full sprint name or one \"active\"|\"future\"."
    (let ((sprints (im-jira-get-sprints)))
      (or
       (--find (string-equal sprint (alist-get 'name it)) sprints)
       (--find (string-equal sprint (alist-get 'state it)) sprints))))

  (defun im-jira-get-issue-field-id-for (field-name)
    (alist-get
     'id
     (--find
      (string-equal field-name (alist-get 'name it))
      (im-jira-get-issue-fields))))

  (defun im-jira-get-issue-transitions (issue)
    (alist-get
     'transitions
     (jiralib2-session-call (format "/rest/api/2/issue/%s/transitions?expand=transition.fields" issue))))

  (defun im-jira-change-issue-status-to (issue status-id)
    (jiralib2-session-call
     (format "/rest/api/2/issue/%s/transitions?expand=transition.fields" issue)
     :type "POST"
     :data (json-encode
            `((transition (id . ,status-id))))))

  (defun im-jira-change-issue-status (key)
    (interactive "sIssue number: ")
    (->>
     (lab--completing-read-object
      "Select status: "
      (im-jira-get-issue-transitions key)
      :formatter (lambda (it) (let-alist it (format "%s [%s]" .name .to.name))))
     (alist-get 'id)
     (im-jira-change-issue-status-to key)))

  (defun im-jira-change-issue-status-to-status (issue-id status)
    "Same as `im-jira-change-issue-status-to' but uses the
  status name as shown in Jira UI instead of status id."
    (im-jira-change-issue-status-to
     issue-id
     (alist-get
      'id
      (--find
       (string-equal (alist-get 'name it) status)
       (im-jira-get-issue-transitions issue-id)))))

  ;;
  ;; Utility
  ;;

  (defmemoizefile im-jira-get-users () "~/.emacs.d/jira-user-cache"
    (mapcar
     (lambda (project) (cons project (jiralib2-get-users project)))
     (mapcar #'car im-jira-projects)))

  (defun im-jira--select-user ()
    (thread-last
      (im-jira-get-users)
      (assoc-string (im-jira--select-project))
      (cdr)
      (--map (cons (alist-get 'name it) it))
      (im-alist-completing-read "Select a user: ")))

  (defun im-jira--select-project ()
    "Interactively select one of enrolled projects."
    (if (eq (length im-jira-projects) 1)
        (caar im-jira-projects)
      (completing-read "Select project: " im-jira-projects)))

  (defun im-jira--select-issue-type ()
    (completing-read
     "Issue type: "
     (--map
      (let-alist it (cons .name .id))
      (jiralib2-get-issuetypes))))

  (defun im-jira--get-issue-template (issue-type)
    (pcase issue-type
      ("Story" "** Motivation\n\n\n** Description\n\n\n** Acceptance Criteria\n\n\n** Projects\n\n\n** Has Automation Test?\n\n\n** Links (UI/UX, Analysis etc.)\n\n")
      ("Sprint Development Bug" "** Description\n\n\n**Case\n\n\n** Projects\n\n")
      ("Production Bug" "** Description\n\n\n** Steps\n\n\n** Projects\n\n\n** Incident Excel\n\n\n** Links - SS - Video\n\n")))

  (defun im-jira--create-branch-name-from-ticket (issue-name)
    "Create a branch name from given Jira ISSUE-NAME"
    (thread-last
      issue-name
      (s-replace-all '((" " . "-") (":" . "-") ("\"" . "") ("/" . "-") ("&" . "") ("(" . "-") (")" . "-")))
      (s-replace "---" "-")
      (s-replace "--" "-")
      (s-downcase)
      (im-s-upcase-until "-")
      (s-prepend im-jira-feature-branch-prefix)
      (read-string "Branch name: ")))

  (defun im-jira--format-ticket-name (it)
    "Format ticket name for displaying in completing-read window."
    (let-alist it
      (format
       "%-7s [%-11s] %-15s => %-15s - %s"
       (propertize .key
                   'face 'bold)
       (propertize (s-truncate 11 .fields.status.name)
                   'face 'italic)
       (propertize (s-truncate 15 (or .fields.reporter.name "N/A"))
                   'face 'italic)
       (propertize (s-truncate 15 (or .fields.assignee.name "N/A"))
                   'face 'italic)
       .fields.summary)))

  (defun im-jira-issue-actions (issue)
    (interactive
     (list (jiralib2-get-issue (read-string "Jira issue: " (or (im-jira-issue-at-point) "")))))
    (cl-loop
     (with-completing-read-exact-order
      (let-alist issue
        (let* ((action
                (completing-read
                 (format "Act on %s: " (s-truncate 20 .fields.summary))
                 '("Open" "View" "Update" "To branch" "To worktree" "Assign to..." "Insert as task" "Change status" "Raw" "[Cancel]"))))
          (pcase action
            ("Open"
             (im-open-jira-issue .key)
             (cl-return))
            ("View"
             (im-jira-view-ticket .key)
             (cl-return))
            ("Update"
             (im-jira-update-ticket .key .fields.summary .fields.description)
             (cl-return))
            ("To branch"
             (im-jira-ticket-to-branch .key .fields.summary)
             (cl-return))
            ("To worktree"
             (im-jira-ticket-to-worktree .key .fields.summary)
             (cl-return))
            ("Assign to..."
             (jiralib2-assign-issue
              .key
              (alist-get 'name (im-jira--select-user))))
            ("Change status"
             (im-jira-change-issue-status .key))
            ("Insert as task"
             (insert (format "** TODO [#A] %s %s :work:" .key .fields.summary)))
            ("Raw"
             (im-json-encode-and-show issue)
             (cl-return))
            ("[Cancel]"
             (cl-return))))))))

  (defun im-convert-jira-markup-to-org-mode (jira-markup)
    "Convert given JIRA-MARKUP string to org-mode format."
    (with-temp-buffer
      (insert jira-markup)
      ;; This creates loose lists where newlines appear between
      ;; list items and ox-confluence does not handle this well and
      ;; breaks lists.
      (shell-command-on-region
       (point-min) (point-max)
       "pandoc -f jira -t org --wrap=none"
       nil t)
      ;; So I try to remove those unnecassary new lines here.
      ;; Same replacement applied twice.
      (replace-regexp-in-string
       "\\\\\\\\$"
       ""
       (replace-regexp-in-string
        "^\\([ \t]*\\)-\\(.*\\)\n\n\\([ \t]*\\)-"
        "\\1-\\2\n\\3-"
        (replace-regexp-in-string
         "^\\([ \t]*\\)-\\(.*\\)\n\n\\([ \t]*\\)-"
         "\\1-\\2\n\\3-"
         (buffer-string))))))

  (defun im-jira-update-ticket (key summary description)
    (im-get-input
     :init
     (format (concat
              "* %s\n"
              (im-convert-jira-markup-to-org-mode description))
             summary)
     :pre-process
     (lambda ()
       (goto-char (point-min))
       (org-entry-get nil "ITEM"))
     :on-accept
     (lambda (description summary)
       (setq description
             (->>
              (org-export-string-as description 'confluence t)
              (s-split "\n")
              (-drop 1)
              (s-join "\n")))
       (message ">> (im-jira-update-ticket \"%s\" \"%s\" \"%s\")" key summary description)
       (jiralib2-update-summary-description key summary description))))

  ;;
  ;; jira-view-mode
  ;;

  (defvar-local jira-view-mode-ticket nil
    "Currently viewed ticket object.")
  (define-derived-mode jira-view-mode org-mode "JiraView"
    "Mode for viewing JIRA tickets.")

  (defun jira-view-mode-open-externally ()
    (interactive)
    (with-default-browser
     (let-alist jira-view-mode-ticket
       (im-open-jira-issue .key))))

  (defun jira-view-mode-edit ()
    (interactive)
    (let-alist jira-view-mode-ticket
      (im-jira-update-ticket .key .fields.summary .fields.description)))

  (defun jira-view-mode-reload ()
    (interactive)
    (let-alist jira-view-mode-ticket
      (im-jira-view-ticket .key)))

  (defun jira-view-mode-act ()
    (interactive)
    (im-jira-issue-actions jira-view-mode-ticket))

  (evil-define-key 'normal jira-view-mode-map
    (kbd "&") #'jira-view-mode-open-externally
    (kbd "ge") #'jira-view-mode-edit
    (kbd "gr") #'jira-view-mode-reload
    ;; TODO All actions might be single keypress.
    (kbd "ga") #'jira-view-mode-act)

  (defun im-jira-view-ticket (key)
    (interactive "sIssue key: ")
    (when-let (match (s-match "browse/\\([a-zA-Z0-9-]+\\)/?" key))
      (setq key (nth 1 match)))
    (let ((buffer (get-buffer-create (format "*jira:%s*" key))))
      (unless (eq (current-buffer) buffer)
        (switch-to-buffer-other-window buffer)))
    (erase-buffer)
    (let ((ticket (jiralib2-get-issue key)))
      (let-alist ticket
        (insert
         (format (concat
                  "* %s - %s\n"
                  (im-convert-jira-markup-to-org-mode .fields.description))
                 key
                 .fields.summary))
        (jira-view-mode)
        (setq header-line-format "Hit `&' to open in browser, `ge' to edit, `gr' to reload, `ga' to see actions.")
        (setq-local jira-view-mode-ticket ticket)
        (goto-char (point-min))
        (org-set-property "STATUS" (or .fields.status.name "N/A"))
        (org-set-property "REPORTER" (or .fields.reporter.name "N/A"))
        (org-set-property "ASSIGNEE" (or .fields.assignee.name "N/A"))
        (org-fold-show-all))))
#+end_src

** My Android phone and Emacs
I have an Android phone that is running [[https://termux.com/][Termux]] all the time. If you install Termux through [[https://www.f-droid.org/][F-Droid]] you can also install [[https://f-droid.org/en/packages/com.termux.api/][Termux:API]] package which brings bunch of commands like =termux-clipboard-set=, =termux-sms-list= etc. Much of the commands requires to be called in foreground, so they are not very useful over SSH but you can work around that by starting a =tmux= session on the phone and executing commands on that tmux session through SSH. This way I can send arbitrary text to my phones clipboard using the commands below.

#+begin_src emacs-lisp
  (evil-leader/set-key
    "ept" #'im-send-text-to-my-phone
    "epc" #'im-send-clipboard-to-my-phone)

  (defvar im-phone-hostname
    "f3"
    "Hostname or local address to connect to my phone by SSH.")

  (defun im-send-termux-command (cmd &rest args)
    "Send CMD to my phone."
    (interactive "sText: ")
    (with-temp-buffer
      (insert cmd " ")
      (--each args
        (insert "\"" (s-replace "\"" "\\\"" it) "\"" " "))
      (shell-command-on-region
       (point-min)
       (point-max)
       (format "ssh -T %s" im-phone-hostname)
       t t)
      (buffer-string)))

  (cl-defun im-send-notification-to-my-phone
      (&key
       title
       content
       url-to-open)
    "Send a notification to my phone."
    (interactive
     (list :title (im-read-string "Title: ")
           :content (im-read-string "Content: ")
           :url-to-open (im-read-string "URL(?): ")))
    (set-process-sentinel
     (start-process
      "gotify" "*gotify-out*"
      "gotify" "push" (format "--title='%s'" title) (format "--clickUrl='%s'" url-to-open) content)
     (lambda (proc text)
       (message "here %s %s" (process-exit-status proc) text)
       ;; Try sending notification through termux if gotify fails
       (unless (eq (process-exit-status proc) 0)
         (im-send-termux-command
          "termux-notification"
          "--title"
          title
          "--content"
          (or content "")
          "--action"
          (format "termux-open %s" url-to-open))))))

  (defun im-send-text-to-my-phone (text)
    "Send TEXT to my phones clipboard. This only works if the phone
  is already open."
    (interactive "sText: ")
    (im-send-termux-command "termux-clipboard-set" text))

  (defun im-send-clipboard-to-my-phone ()
    "Send current clipboard content to my phones clipboard. This only
  works if the phone is already open."
    (interactive)
    (im-send-text-to-my-phone (current-kill 0)))

  (defun im-list-phone-text-messages ()
    "List messages from my phone."
    (interactive)
    (let ((result (completing-read
                   "Messages: "
                   (seq-map
                    (lambda (msg) (let-alist msg (format "%s :: %s" .number .body)))
                    (json-read-from-string
                     (im-send-termux-command "termux-sms-list"))))))
      (switch-to-buffer-other-window (get-buffer-create "*im-message*"))
      (insert result)))
#+end_src

** Signal
#+begin_src emacs-lisp
  (require 'dbus)

  (evil-leader/set-key
    "epn" #'im-signal-send-note-to-myself
    "epm" #'im-signal-send-message)

  (defconst im-signal-dbus-args '(:session "org.asamk.Signal"
                                                "/org/asamk/Signal"
                                                "org.asamk.Signal"))

  (defun im-signal (&rest args)
    "Send a signal DBUS command with ARGS."
    (apply #'dbus-call-method `(,@im-signal-dbus-args ,@args)))

  (defun im-signal-async (&rest args)
    "Send an async Signal DBUS command with ARGS."
    (apply #'dbus-call-method-asynchronously `(,@im-signal-dbus-args ,@args)))

  (defun im-signal-send-note-to-myself (note &optional attachments)
    "Send a NOTE with attachments to my phone."
    (interactive
     (list
      (if (use-region-p)
          (buffer-substring (region-beginning) (region-end))
        (read-string "Enter note: "))
      (when (y-or-n-p "Want to attach something? ")
        (list (read-file-name "Attachment: ")))))
    (im-signal-async
     "sendNoteToSelfMessage"
     (lambda (msg) (message ">> Signal %s" msg))
     note
     (or (mapcar 'expand-file-name attachments)
         '(:array))))

  (defun im-signal-send-message (recipient content &optional attachments)
    "Send message to RECIPIENT with CONTENT."
    (interactive
     (list
      (im-signal-select-contact)
      (if (use-region-p)
          (buffer-substring (region-beginning) (region-end))
        (read-string "Enter message: "))
      (when (y-or-n-p "Want to attach something? ")
        (list (read-file-name "Attachment: ")))))
    (im-signal-async
     (if (plist-get recipient :number)
         "sendMessage"
       "sendGroupMessage")
     (lambda (msg) (message ">> Signal %s" msg))
     content
     (or (mapcar 'expand-file-name attachments)
         '(:array))
     (cadr recipient)))

  (defun im-signal-select-contact ()
    "Select a contact interactively."
    (let* ((contacts (--map
                      (cons (im-signal "getContactName" it) it)
                      (im-signal "listNumbers")))
           (groups (--map
                    (cons (format
                           "%s [GROUP]"
                           (im-signal "getGroupName"
                                           (dbus-string-to-byte-array (dbus-byte-array-to-string it))))
                          it)
                    (im-signal "getGroupIds")))
           (all (append contacts groups))
           (selected (cdr (assoc (completing-read "Send message to: " all) all))))
      (if (stringp selected)
          (list :number selected)
        (list :group (dbus-string-to-byte-array (dbus-byte-array-to-string selected))))))

  (defun im-signal-sync-message-received-handler (ts source receiver _ msg attchs)
    (message ">> [signal] sender=%s, receiver=%s, msg=%s, attach=%s" source receiver msg attchs)
    (when (and (string= im-my-phone-number source)
               (or
                (string= receiver im-my-phone-number)
                (-contains?
                 (--map (alist-get 'uuid it) (alist-get 'accounts (json-read-file (expand-file-name "~/.local/share/signal-cli/data/accounts.json"))))
                 receiver)))
      (cond
       ((s-prefix? "run" msg)
        (im-signal-send-note-to-myself
         (shell-command-to-string (s-chop-prefix "run " msg))))
       ((string= "help" msg)
        (im-signal-send-note-to-myself
         (concat "run <shell-command>\n"
                 "grab <file-path>\n"
                 "note <note-details>\n"
                 "help")))
       ((s-prefix? "grab" msg)
        (im-signal-send-note-to-myself
         "" (list (s-chop-prefix "grab " msg))))
       ((s-prefix? "note" msg)
        (kill-new (s-chop-prefix "note " msg))
        (im-clear-side-windows)
        (org-capture nil "dN")
        (im-signal-send-note-to-myself (format ">> Noted: %s" msg)))
       ((s-prefix? "http" msg)
        (message ">> [signal] Copied to clipboard: %s" msg)
        (kill-new msg))
       ((s-equals? "clip" msg)
        (im-signal-send-note-to-myself (car kill-ring)))
       (attchs
        (--each attchs
          (let ((mime (im-mimetype it)))
            (cond
             ((s-prefix? "image/" mime)
              (message "TODO: Handle self images %s" it))
             ((s-prefix "audio/" mime)
              (message "TODO: Handle self sound %s" it)))))))))

  (defvar im-signal-bot-object nil)

  (defun im-start-signal-bot ()
    (interactive)
    (unless im-signal-bot-object
      (message ">> signal-bot is starting...")
      (setq
       im-signal-bot-object
       (apply
        #'dbus-register-signal
        `(,@im-signal-dbus-args
          ,"SyncMessageReceived"
          ,#'im-signal-sync-message-received-handler)))))

  (defun im-stop-signal-bot ()
    (interactive)
    (dbus-unregister-object im-signal-bot-object)
    (setq im-signal-bot-object nil))

  (run-with-timer 60 nil #'im-start-signal-bot)
#+end_src
** people.org - Contact management
Please see [[https://isamert.net/2021/04/21/managing-your-contacts-in-org-mode-and-syncing-them-to-your-phone-android-ios-whatever-.html][this post]] for further information.

#+begin_src emacs-lisp
  (defun im-contacts--build-contact-item (template-string contact-property)
    (cond
     ((s-contains? "$1" contact-property)
      (->>
       (org-entry-properties)
       (--filter (s-matches? (s-replace "$1" ".*" contact-property) (car it)))
       (--map (let ((subprop (nth 1 (s-match (s-replace "$1" "\\([a-zA-Z0-9_-]+\\)" contact-property) (car it)))))
                (concat (format (s-replace "$1" subprop template-string) (cdr it)) "\n")))))
     (t (if-let ((stuff (org-entry-get nil contact-property)))
            (concat (format template-string stuff) "\n")
          ""))))

  (defun im-contacts--contact-entry? ()
    (thread-last
      (org-entry-properties)
      (-map #'car)
      (--any (s-prefix? "PHONE" it))))

  (defun im-contacts-export-as-vcard (&optional file-name)
    "Create a .vcf file containing all contact information."
    (interactive
     (list
      (read-file-name
       "Where to save the .vcf file?"
       "~/Documents/sync/"
       "contacts.vcf")))
    (write-region
     (thread-last
       (org-map-entries
        (lambda ()
          (when (im-contacts--contact-entry?)
            (string-join
             `("BEGIN:VCARD\nVERSION:2.1\n"
               ,(format "UID:urn:uuid:%s\n" (org-id-get nil t))
               ,(im-contacts--build-contact-item "FN:%s" "ITEM")
               ,@(im-contacts--build-contact-item "TEL;$1:%s" "PHONE_$1")
               ,(im-contacts--build-contact-item "EMAIL:%s" "EMAIL")
               ,(im-contacts--build-contact-item "ORG:%s" "GROUP")
               ,@(im-contacts--build-contact-item "ADR;$1:;;%s" "ADDRESS_$1")
               ,(format "REV:%s\n" (format-time-string "%Y-%m-%dT%T"))
               "END:VCARD")
             "")))
        "LEVEL=1")
       (-filter #'identity)
       (s-join "\n"))
     nil
     file-name))
#+end_src
** Google search
#+begin_src emacs-lisp
  (defun im-google-this ()
    "Search selected region or current word in Google. Let's you edit the query beforehand."
    (interactive)
    (browse-url
     (format
      "https://google.com/search?q=%s"
      (read-string
       "Googling: "
       (im-region-or 'word)))))

  (evil-leader/set-key
    "/g"   'im-google-this)
#+end_src

** TODO org-mode enhancements
I need to rewrite these functions using [[https://github.com/im-marks][marks]] for both speed and accuracy.

#+begin_src emacs-lisp
  ;; Keybindings

  (evil-leader/set-key
    "ol" #'im-org-link-header
    "oj" #'im-org-jump-to-header
    ;; TODO: rewrite this:
    ;;"oL" 'im-org-backlinks
  )

  ;;
  ;; Utility
  ;;

  (defun im-org-header-line-to-title (line)
    "Remove TODO/*/unnecessary whitespace from given LINE.
  Then return the title of given `org-mode` header.
  Just like (org-entry-get nil \"ITEM\") but works on given string."
    (->> line
      (s-replace-regexp "\\(\\*\\|TODO\\|PROG\\|DONE\\|WAIT\\)" "") ;; Remove TODO states
      (s-replace-regexp "\\(\\[#.\\{1\\}\\]\\\)" "") ;; Remove priorities
      (s-replace-regexp ":\\(\\w+:\\)+$"  "") ;; Remove tags
      (replace-regexp-in-string "\\[\\[.*\\]\\[\\(.*\\)\\]\\]"  "\\1") ;; Fix links
      (replace-regexp-in-string "\\[\\[\\(.*\\)\\]\\]"  "\\1") ;; Fix links
      (s-trim)))

  (defun im-org-file-get-header-id (file-path header-line)
    "Return the id of given header at HEADER-LINE in FILE-PATH."
    (interactive)
    (save-excursion
      (with-current-buffer (let ((enable-local-variables nil)) (find-file-noselect file-path))
        (save-restriction
          (save-excursion
            (widen)
            (goto-char 0)
            (forward-line header-line)
            (org-id-get nil 'create)
            (save-buffer)
            (org-id-get nil 'create))))))

  (defun im-org-all-headers ()
    "Return all headers in `org-directory'."
    (->> (concat "cd " org-directory "; "
                 "rg"
                 " --no-heading" " --with-filename"
                 " --line-number" " -t org"
                 " " "\"^\\*+ \" ")
      (shell-command-to-string)
      (s-split "\n")
      (--filter (not (s-blank? it)))
      (--map
       (-let* (((fname line . content) (split-string it ":"))
               (header (im-org-header-line-to-title (string-join content ":"))))
         `(,(format
             "%s:%s %s %s"
             (propertize fname 'face '(:foreground "plum"  :slant italic))
             (propertize line 'face '(:slant italic :weight thin))
             (propertize "»" 'face '(:foreground "green"))
             (propertize header 'face '(:foreground "sky blue" :weight bold)))
           .
           (:fname ,(concat org-directory "/" fname) :line ,(1- (string-to-number line)) :header ,header))))))

  (defun im-org-link-header ()
    "Interactively select a header and insert it as a link into the buffer.
  Headers are gathered from all the org files found in `org-directory'."
    (interactive)
    (save-some-buffers)
    (let* ((selected (im-alist-completing-read
                      "Select header: "
                      (im-org-all-headers)
                      (when (use-region-p)
                        (buffer-substring-no-properties (region-beginning) (region-end)))))
           (header-id (im-org-file-get-header-id (plist-get selected :fname) (plist-get selected :line))))
      (org-insert-link
       nil
       (concat "id:" header-id)
       (unless (use-region-p)
         (read-string "Enter link text: " (plist-get selected :header))))))


  (defun im-org-jump-to-header ()
    "Jump to selected header."
    (interactive)
    (let* ((selected (im-alist-completing-read "Select header:" (im-org-all-headers))))
      (with-current-buffer (find-file-other-window (plist-get selected :fname))
        (widen)
        (goto-char 0)
        (forward-line (plist-get selected :line)))))

  ;; TODO Removed backlinks implementation, I will implement it once
  ;; minimal functionality within "marks" is done
#+end_src

** bullet.org
I have a ~bullet.org~ file that I keep my daily journal and here are some utility functions that use with it. I may document this later (or even publish it as a package?)

#+begin_src emacs-lisp
  ;; Keybindings

  (evil-leader/set-key
    "obb" 'im-bullet-focus-non-day-header
    "oby" 'im-bullet-focus-yesterday
    "obY" 'im-bullet-focus-yesterday-indirect
    "obt" 'im-bullet-focus-today
    "obT" 'im-bullet-focus-tomorrow
    "obf" 'im-bullet-focus-given-day
    "obr" 'im-bullet-focus-recurring
    "obR" 'im-bullet-focus-recurring-indirect
    "obw" 'im-bullet-focus-work
    "obW" 'im-bullet-focus-work-indirect
    "obl" 'im-bullet-focus-life
    "obL" 'im-bullet-focus-life-indirect
    "obc" 'im-bullet-focus-computer
    "obC" 'im-bullet-focus-computer-indirect)

  ;;
  ;; Date utils
  ;;

  (defun im-today ()
    "Get todays date in format YYYY-MM-DD Day."
    (format-time-string "%Y-%m-%d %a"))

  (defun im-u ()
    "Get day of week as number."
    (string-to-number (format-time-string "%u")))

  (defun im-d ()
    "Get day of month as number."
    (string-to-number (format-time-string "%d")))

  (defun im-V ()
    "Get week number."
    (string-to-number (format-time-string "%V")))

  (defun im-date (date &optional str)
    "Display the time described by DATE.
  DATE can be 'now', 'yesterday', 'two days ago' etc."
    (s-trim-right
     (shell-command-to-string
      (concat (locate-file "date" exec-path) " --date='" date "' +'" (or str "%Y-%m-%d %a") "'"))))

  ;;
  ;; Create utils
  ;;

  (defun im-bullet-create-a-day (date)
    "Create given DATE heading in bullet.org in the appropriate place..
  DATE should be in the form of YYYY-MM-DD."
    (when-let ((point (im-bullet-find-a-day date)))
      (goto-char point)
      (user-error "The day already exists"))
    (widen)
    (goto-char (point-max))
    (cl-loop
     (when (not (re-search-backward "^* \\[\\([0-9]+-[0-9]+-[0-9]+\\)\\( \\w+\\)?\\].*" nil t))
       (cl-return))
     (when (time-less-p
            (date-to-time (concat (match-string 1) "T000"))
            (date-to-time (concat date "T000")))
       (org-insert-heading-after-current)
       (insert (format "[%s%s] [%%]"
                       date
                       (if (s-matches? "[a-zA-Z]+$" date)
                           ""
                         (format " %s" (format-time-string "%a" (date-to-time (concat date "T000")))))))
       (org-narrow-to-subtree)
       (cl-return))))

  ;;
  ;; Focus a day
  ;;

  (defun im-bullet-find-a-day (day)
    (save-excursion
      (widen)
      (goto-char (point-max))
      (when (re-search-backward (concat "^* \\[" day "\\( \\w+\\)?\\]") nil t)
        (point-marker))))

  (defun im-bullet-focus-a-day (day)
    "Focus to given DAY."
    (widen)
    (when-let ((day-entry (im-bullet-find-a-day day)))
      (goto-char day-entry)
      (beginning-of-line)
      (org-narrow-to-subtree)
      (im-show-outline-only)
      t))

  (defun im-bullet-focus-given-day (date)
    "Focus given DATE's header.
  If it does not exists, create it."
    (interactive
     (list (org-read-date)))
    (when (not (im-bullet-focus-a-day date))
      (im-bullet-create-a-day date)))

  (defun im-bullet-focus-today ()
    "Focus todays header.
  If it does not exists, create it."
    (interactive)
    (let ((today (if (<= (string-to-number (format-time-string "%H")) 3)
                     (im-date "yesterday")
                   (format-time-string "%Y-%m-%d"))))
      (when (not (im-bullet-focus-a-day today))
        (im-bullet-create-a-day today))))

  (defun im-bullet-focus-tomorrow ()
    "Focus yesterdays header."
    (interactive)
    (let ((tomorrow (im-date "tomorrow")))
      (when (not (im-bullet-focus-a-day tomorrow))
        (im-bullet-create-a-day tomorrow))))

  (defun im-bullet-focus-tomorrow-indirect ()
    "Like `im-bullet-focus-tomorrow' but in an indirect buffer."
    (interactive)
    (im-org-focused-tree-to-indirect-buffer
     (im-bullet-focus-tomorrow)))

  (defun im-bullet-focus-yesterday ()
    "Focus yesterdays header."
    (interactive)
    (im-bullet-focus-a-day (im-date "yesterday")))

  (defun im-bullet-focus-yesterday-indirect ()
    "Like `im-bullet-focus-yesterday' but in an indirect buffer."
    (interactive)
    (im-org-focused-tree-to-indirect-buffer
     (im-bullet-focus-yesterday)))

  (defun im-bullet-focus-heading (heading)
    (interactive)
    (widen)
    (goto-char (point-min))
    (when (re-search-forward (format "^*+ %s" heading))
      (beginning-of-line)
      (org-narrow-to-subtree)
      (im-show-outline-only)
      t))

  (defun im-bullet-focus-recurring ()
    (interactive)
    (im-bullet-focus-heading "Recurring"))

  (defun im-bullet-focus-recurring-indirect ()
    "Like `im-bullet-focus-recurring' but in an indirect buffer."
    (interactive)
    (im-org-focused-tree-to-indirect-buffer
     (im-bullet-focus-recurring)))

  (defun im-bullet-focus-work ()
    (interactive)
    (im-bullet-focus-heading "Work backlog"))

  (defun im-bullet-focus-work-indirect ()
    "Like `im-bullet-focus-work' but in an indirect buffer."
    (interactive)
    (im-org-focused-tree-to-indirect-buffer
     (im-bullet-focus-work)))

  (defun im-bullet-focus-life ()
    (interactive)
    (im-bullet-focus-heading "Life backlog"))

  (defun im-bullet-focus-life-indirect ()
    "Like `im-bullet-focus-life' but in an indirect buffer."
    (interactive)
    (im-org-focused-tree-to-indirect-buffer
     (im-bullet-focus-life)))

  (defun im-bullet-focus-computer ()
    (interactive)
    (im-bullet-focus-heading "Computer backlog"))

  (defun im-bullet-focus-computer-indirect ()
    "Like `im-bullet-focus-computer' but in an indirect buffer."
    (interactive)
    (im-org-focused-tree-to-indirect-buffer
     (im-bullet-focus-computer)))

  ;;
  ;; Focus non-day
  ;;

  (defun im-bullet-focus-non-day-header ()
    "Interactively select and focus a non-day header."
    (interactive)
    (save-match-data
      (widen)
      (goto-char 0)
      (re-search-forward "^\\*+ \\[[0-9]+-" nil t)
      (narrow-to-region (point-min) (point-at-bol))
      (consult-org-heading)
      (org-narrow-to-subtree)))

  ;;
  ;; Template utils
  ;;

  (defun im-bullet-current-date ()
    "Return current date."
    (save-excursion
      (when (re-search-backward "^* \\[" nil t)
        (-some->> (org-get-heading t t t t)
          (s-match "\\[.*?\\]")
          (car)
          (substring-no-properties)
          (s-chop-prefix "[")
          (s-chop-suffix "]")))))

  (defmacro im-when-weekday (template &rest template-args)
    `(when (<= (im-u) 5)
       (s-trim (im-s-interpolated ,template ,@template-args))))

  (defmacro im-when-weekday-n (n template &rest template-args)
    `(when (= (im-u) ,n)
       (s-trim (im-s-interpolated ,template ,@template-args))))

  (defmacro im-when-monthday-n (n template &rest template-args)
    `(when (= (im-d) ,n)
       (s-trim (im-s-interpolated ,template ,@template-args))))

  (defmacro im-when-weekend (template &rest template-args)
    `(when (> (im-u) 5)
       (s-trim (im-s-interpolated ,template ,@template-args))))

  (defmacro im-when-saturday (template &rest template-args)
    `(when (= (im-u) 6)
       (s-trim (im-s-interpolated ,template ,@template-args))))

  (defmacro im-when-sunday (template &rest template-args)
    `(when (= (im-u) 7)
       (s-trim (im-s-interpolated ,template ,@template-args))))

  ;;
  ;; Daily summary
  ;;

  ;; Implementation is a bit cumbersome but it's easy to adopt for my ad-hoc requests
  (defun org-dblock-write:daily-summary (params)
    "Create a daily summary for my bullet.org."
    (let* ((items (org-map-entries
                   (lambda nil
                     (list
                      :name
                      (org-entry-get nil "ITEM")
                      :clock
                      (org-clock-sum-current-item)
                      :tags
                      (or (org-get-tags) '(empty))
                      :level
                      (org-current-level)
                      :parent
                      (save-excursion
                        (when (org-up-heading-safe)
                          (org-entry-get nil "ITEM")))))
                   "LEVEL>1"))
           (total-time (->> items
                            (--filter (= (plist-get it :level) 2))
                            (--map (plist-get it :clock))
                            (-sum)
                            (org-minutes-to-clocksum-string)))
           (routines (--filter (s-equals? (plist-get it :parent) "Routines") items))
           (work (--filter (-contains? (plist-get it :tags) "work") items))
           (others (--filter (not (or
                                   (-contains? (plist-get it :tags) "work")
                                   (s-equals? (plist-get it :parent) "Routines")
                                   (s-equals? (plist-get it :name) "Routines"))) items)))

      (insert "| [Event] | [Duration] ||\n")
      (insert "|-|\n")

      (->> items
           (--find (s-equals? "Routines" (plist-get it :name)))
           (funcall (-flip #'plist-get) :clock)
           (org-minutes-to-clocksum-string)
           (format "|Routines|%s||\n")
           (insert))

      (->> routines
           (--filter (-contains? '("Breakfast" "Dinner") (plist-get it :name)))
           (--map (plist-get it :clock))
           (-sum)
           (org-minutes-to-clocksum-string)
           (format "|\\-- Eating||%s|\n")
           (insert))

      (->> routines
           (--filter (not (-contains? '("Breakfast" "Dinner") (plist-get it :name))))
           (--map (plist-get it :clock))
           (-sum)
           (org-minutes-to-clocksum-string)
           (format "|\\-- Other||%s|\n")
           (insert))

      (insert "|-|\n")

      (->> work
           (--map (plist-get it :clock))
           (-sum)
           (org-minutes-to-clocksum-string)
           (format "|Work|%s||\n")
           (insert))

      (->> work
           (--filter (-contains? (plist-get it :tags) "meeting"))
           (--map (plist-get it :clock))
           (-sum)
           (org-minutes-to-clocksum-string)
           (format "|\\-- Meetings||%s|\n")
           (insert))

      (->> work
           (--filter (not (-contains? (plist-get it :tags) "meeting")))
           (--map (plist-get it :clock))
           (-sum)
           (org-minutes-to-clocksum-string)
           (format "|\\-- Other||%s|\n")
           (insert))

      (insert "|-|\n")

      (->> others
           (--map (plist-get it :clock))
           (-sum)
           (org-minutes-to-clocksum-string)
           (format "|Other|%s||\n")
           (insert))

      (->> others
           (--filter (-contains? (plist-get it :tags) "side"))
           (--map (plist-get it :clock))
           (-sum)
           (org-minutes-to-clocksum-string)
           (format "|\\-- Side projects||%s|\n")
           (insert))

      (->> others
           (--filter (not (-contains? (plist-get it :tags) "side")))
           (--map (plist-get it :clock))
           (-sum)
           (org-minutes-to-clocksum-string)
           (format "|\\-- Other||%s|\n")
           (insert))

      (insert "|-|\n")
      (insert (format "|Total|%s||\n" total-time))
      (delete-char 1)
      (org-table-align)))
#+end_src

** Scratch/temporary buffers in side windows
Here I define two important functions and their helpers.  The following functions are pretty useful for quick note taking or evaluating elisp. Having these buffers in a side window makes them immune to some window commands which is what I want.

- im-display-side-scratch-buffer :: This one opens (or closes if it's open) the *scratch* buffer in a side window, on the right. This is nice for quickly evaluating elisp, taking elisp related notes.
- im-display-side-temp-org-buffer :: This one opens (or closes if it's open) the ~temp.org~ file in a in a side window, on the right. This is nice for taking some quick notes, writing some temporary todos etc.

#+begin_src emacs-lisp
  (defun im-buffer-visible-p (buffer)
   "Check if given BUFFER is visible or not.  BUFFER is a string representing the buffer name."
    (or (eq buffer (window-buffer (selected-window))) (get-buffer-window buffer)))

  (defun im-display-buffer-in-side-window (buffer)
    "Just like `display-buffer-in-side-window` but only takes a BUFFER and rest of the parameters are for my taste."
    (set-window-dedicated-p
     ;; ^ Setting this to nil so that `pop-to-buffer-same-window' calls works in this window
     ;;   otherwise it'll set `window-dedicated-p' to `side' and this will cause `pop-to-buffer-same-window'
     ;;   to open stuff in another window.
     (select-window
      (display-buffer-in-side-window
       buffer
       '((side . right)
         (slot . 0)
         (window-width . 84)
         (window-parameters
          (no-delete-other-windows . t)
          (no-other-window . nil)))))
     nil))

  (defun im-remove-window-with-buffer (the-buffer-name)
    "Remove window containing given THE-BUFFER-NAME."
    (mapc (lambda (window)
            (when (string-equal (buffer-name (window-buffer window)) the-buffer-name)
              (delete-window window)))
          (window-list (selected-frame))))

  (defun im-toggle-side-buffer-with-file (file-path)
    "Toggle FILE-PATH in a side buffer. The buffer is opened in side window so it can't be accidentaly removed."
    (interactive)
    (let ((fname (file-name-nondirectory file-path)))
    (if (im-buffer-visible-p fname)
        (im-remove-window-with-buffer fname)
      (im-display-buffer-in-side-window
       (save-window-excursion
         (find-file file-path)
         (current-buffer))))))

  (defun im-toggle-side-buffer-with-name (buffer-name)
    "Hide/show given BUFFER-NAME in a side window."
    (interactive)
    (if (im-buffer-visible-p buffer-name)
        (im-remove-window-with-buffer buffer-name)
      (im-display-buffer-in-side-window (get-buffer buffer-name))))

  (defun im-toggle-side-scratch-buffer ()
    "Toggle the scratch buffer in side window.  The buffer is opened in side window so it can't be accidentaly removed."
    (interactive)
    (im-toggle-side-buffer-with-file "~/.emacs.d/scratch.el"))

  (defun im-toggle-side-temp-org-buffer ()
    "Toggle `temp.org` in a side buffer for quick note taking.  The buffer is opened in side window so it can't be accidentaly removed."
    (interactive)
    (im-toggle-side-buffer-with-file temp-org))

  (defun im-toggle-side-bullet-org-buffer ()
    "Toggle `bullet.org` in a side buffer for quick note taking.  The buffer is opened in side window so it can't be accidentaly removed."
    (interactive)
    (im-toggle-side-buffer-with-file bullet-org))

  (defun im-toggle-side-projects-buffer ()
    "Toggle `projects.org` in a side buffer for quick note taking.  The buffer is opened in side window so it can't be accidentaly removed."
    (interactive)
    (im-toggle-side-buffer-with-file projects-org))

  (defun im-toggle-side-messages-buffer ()
    "Toggle `projects.org` in a side buffer for quick note taking.  The buffer is opened in side window so it can't be accidentaly removed."
    (interactive)
    (im-toggle-side-buffer-with-name "*Messages*"))

  ;; Toggle temproary buffers
  (evil-leader/set-key
    "ts" 'im-toggle-side-scratch-buffer
    "to" 'im-toggle-side-temp-org-buffer
    "th" 'im-toggle-side-bullet-org-buffer
    "tp" 'im-toggle-side-projects-buffer
    "tm" 'im-toggle-side-messages-buffer)
#+end_src

** org-babel extension functions
#+BEGIN_SRC emacs-lisp
  (defun im-org-babel-remove-all-results nil
    (interactive)
    (goto-char 1)
    (let ((total-removed 0))
      (while (org-babel-next-src-block)
        (when (org-babel-remove-result)
          (setq total-removed (+ total-removed 1))))
      (message (format "%d result blocks are removed." total-removed))))
#+END_SRC

** Functions for easy indentation switching
- http://blog.binchen.org/posts/easy-indentation-setup-in-emacs-for-web-development.html

#+BEGIN_SRC emacs-lisp
  (defun im-setup-indent-local (n)
    (interactive "nHow many spaces do you want? ")
    (setq-local tab-width n)
    (setq-local c-basic-offset n)
    (setq-local sh-basic-offset n)
    (setq-local coffee-tab-width n) ; coffeescript
    (setq-local java-ts-mode-indent-offset n)
    (setq-local javascript-indent-level n) ; javascript-mode
    (setq-local js-indent-level n) ; js-mode
    (setq-local web-mode-markup-indent-offset n) ; web-mode, html tag in html file
    (setq-local web-mode-css-indent-offset n) ; web-mode, css in html file
    (setq-local web-mode-code-indent-offset n) ; web-mode, js code in html file
    (setq-local css-indent-offset n) ; css-mode
    (setq-local typescript-indent-level n) ; typescript-mode
    (message "OK!"))

  (defun im-setup-indent-global (n)
    (interactive "nHow many spaces do you want? ")
    (setq tab-width n)
    (setq c-basic-offset n)
    (setq sh-basic-offset n)
    (setq coffee-tab-width n) ; coffeescript
    (setq java-ts-mode-indent-offset n)
    (setq javascript-indent-level n) ; javascript-mode
    (setq js-indent-level n) ; js-mode
    (setq web-mode-markup-indent-offset n) ; web-mode, html tag in html file
    (setq web-mode-css-indent-offset n) ; web-mode, css in html file
    (setq web-mode-code-indent-offset n) ; web-mode, js code in html file
    (setq css-indent-offset n) ; css-mode
    (setq typescript-indent-level n) ; typescript-mode
    (message "OK!"))
#+END_SRC

** Current file functionality
Sometimes I just want to delete/rename/move etc. the current file without resorting to dired or any other file manager. Here are some interactive functions to do that.

#+begin_src emacs-lisp
  ;; Slightly modified from:
  ;; http://steve.yegge.googlepages.com/my-dot-emacs-file
  (defun im-rename-current-file-name-and-buffer (new-name)
    "Renames both current buffer and file it's visiting to NEW-NAME."
    (interactive "FNew name: ")
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (when (not filename)
        (user-error "Buffer '%s' is not visiting a file!" name))
      (when (get-buffer new-name)
        (user-error "A buffer named '%s' already exists!" new-name))
      (rename-file filename new-name 1)
      (rename-buffer new-name)
      (set-visited-file-name new-name)
      (set-buffer-modified-p nil)))

  ;; Slightly modified version of: http://www.ergoemacs.org/emacs/elisp_delete-current-file.html
  (defalias 'im-delete-this-file #'im-delete-current-file)
  (defun im-delete-current-file ()
    "Delete the current file and copy it's content to `kill-ring'."
    (interactive)
    (when (y-or-n-p (format "Do you really want to remove this: \"%s\"?" (buffer-file-name)))
      (kill-new (buffer-string))
      (message "Buffer content copied to kill-ring.")
      (when (and (buffer-file-name) (file-exists-p (buffer-file-name)))
        (delete-file (buffer-file-name))
        (message "Deleted file: 「%s」." (buffer-file-name)))
      (let ((buffer-offer-save nil))
        (set-buffer-modified-p nil)
        (kill-buffer (current-buffer)))))

  (defalias 'im-remove-current-file #'im-delete-current-file)
#+end_src

** xah-open-file-at-cursor
This is better than =find-file-at-point= because it takes line numbers etc. into account.

#+begin_src emacs-lisp
  (defun xah-open-file-at-cursor ()
    "Open the file path under cursor.
  If there is text selection, uses the text selection for path.
  If the path starts with “http://”, open the URL in browser.
  Input path can be {relative, full path, URL}.
  Path may have a trailing “:‹n›” that indicates line number, or “:‹n›:‹m›” with line and column number. If so, jump to that line number.
  If path does not have a file extension, automatically try with “.el” for elisp files.
  This command is similar to `find-file-at-point' but without prompting for confirmation.

  URL `http://ergoemacs.org/emacs/emacs_open_file_path_fast.html'
  Version 2020-10-17"
    (interactive)
    (let* (
           ($inputStr
            (if (use-region-p)
                (buffer-substring-no-properties (region-beginning) (region-end))
              (let ($p0 $p1 $p2
                        ;; chars that are likely to be delimiters of file path or url, e.g. whitespace, comma. The colon is a problem. cuz it's in url, but not in file name. Don't want to use just space as delimiter because path or url are often in brackets or quotes as in markdown or html
                        ($pathStops "^  \t\n\"`'‘’“”|[]{}「」<>〔〕〈〉《》【】〖〗«»‹›❮❯❬❭〘〙·。\\"))
                (setq $p0 (point))
                (skip-chars-backward $pathStops)
                (setq $p1 (point))
                (goto-char $p0)
                (skip-chars-forward $pathStops)
                (setq $p2 (point))
                (goto-char $p0)
                (buffer-substring-no-properties $p1 $p2))))
           ($path
            (replace-regexp-in-string
             "^file:///" "/"
             (replace-regexp-in-string
              ":\\'" "" $inputStr))))
      (if (string-match-p "\\`https?://" $path)
          (if (fboundp 'xahsite-url-to-filepath)
              (let (($x (xahsite-url-to-filepath $path)))
                (if (string-match "^http" $x )
                    (browse-url $x)
                  (find-file $x)))
            (progn (browse-url $path)))
        (progn ; not starting “http://”
          (if (string-match "#" $path )
              (let (
                    ( $fpath (substring $path 0 (match-beginning 0)))
                    ( $fractPart (substring $path (1+ (match-beginning 0)))))
                (if (file-exists-p $fpath)
                    (progn
                      (find-file $fpath)
                      (goto-char 1)
                      (search-forward $fractPart ))
                  (when (y-or-n-p (format "file no exist: 「%s」. Create?" $fpath))
                    (find-file $fpath))))
            (if (string-match "^\\`\\(.+?\\):\\([0-9]+\\)\\(:[0-9]+\\)?\\'" $path)
                (let (
                      ($fpath (match-string 1 $path))
                      ($line-num (string-to-number (match-string 2 $path))))
                  (if (file-exists-p $fpath)
                      (progn
                        (find-file $fpath)
                        (goto-char 1)
                        (forward-line (1- $line-num)))
                    (when (y-or-n-p (format "file no exist: 「%s」. Create?" $fpath))
                      (find-file $fpath))))
              (if (file-exists-p $path)
                  (progn ; open f.ts instead of f.js
                    (let (($ext (file-name-extension $path))
                          ($fnamecore (file-name-sans-extension $path)))
                      (if (and (string-equal $ext "js")
                               (file-exists-p (concat $fnamecore ".ts")))
                          (find-file (concat $fnamecore ".ts"))
                        (find-file $path))))
                (if (file-exists-p (concat $path ".el"))
                    (find-file (concat $path ".el"))
                  (when (y-or-n-p (format "file no exist: 「%s」. Create?" $path))
                    (find-file $path ))))))))))

(define-key evil-normal-state-map (kbd "gf") 'xah-open-file-at-cursor)
#+end_src

** xah-{escape,unescape}-quotes
#+begin_src emacs-lisp
  (defun xah-escape-quotes (@begin @end)
    "Replace 「\"」 by 「\\\"」 in current line or text selection.
    See also: `xah-unescape-quotes'

    URL `http://ergoemacs.org/emacs/elisp_escape_quotes.html'
    Version 2017-01-11"
    (interactive
     (if (use-region-p)
         (list (region-beginning) (region-end))
       (list (line-beginning-position) (line-end-position))))
    (save-excursion
      (save-restriction
        (narrow-to-region @begin @end)
        (goto-char (point-min))
        (while (search-forward "\"" nil t)
          (replace-match "\\\"" "FIXEDCASE" "LITERAL")))))

  (defun xah-unescape-quotes (@begin @end)
    "Replace  「\\\"」 by 「\"」 in current line or text selection.
  See also: `xah-escape-quotes'

  URL `http://ergoemacs.org/emacs/elisp_escape_quotes.html'
  Version 2017-01-11"
    (interactive
     (if (use-region-p)
         (list (region-beginning) (region-end))
       (list (line-beginning-position) (line-end-position))))
    (save-excursion
      (save-restriction
        (narrow-to-region @begin @end)
        (goto-char (point-min))
        (while (search-forward "\\\"" nil t)
          (replace-match "\"" "FIXEDCASE" "LITERAL")))))
#+end_src

** eksisozluk gundem
#+begin_src emacs-lisp
  (defun im-eksi-gundem-sirali ()
    "Eksi gundemini entry sayisina gore sirala ve `completing-read' yap."
    (interactive)
    (with-completing-read-exact-order
     (let ((results (->>
                     (with-temp-buffer
                       (insert
                        (shell-command-to-string "curl --silent https://eksisozluk.com/basliklar/gundem | grep '?a=popular' | sed -E 's/[ ]*href=\"(.*)\">(.*) <small>(.*)<\\/small>(.*)/(\\3) \\2|||\\1/' | sort -V -r | uniq"))
                       (goto-char (point-min))
                       (xml-parse-string))
                     (s-trim)
                     (s-split "\n")
                     (--map (s-split "|||" it))
                     (--map `(,(car it) . ,(cadr it))))))
       (->> results
            (completing-read "Baslik: ")
            (funcall (-flip 'assoc-string) results)
            (cdr)
            (format "https://eksisozluk.com/%s")
            (browse-url)))))
#+end_src
** insert uuid
#+begin_src emacs-lisp
  (defun im-uuid ()
    "Generate a UUID."
    (s-trim (shell-command-to-string "uuidgen")))

  (defun im-insert-uuid ()
    "Insert UUID."
    (interactive)
    (insert (im-uuid)))
#+end_src

** im-shell-command
#+begin_src emacs-lisp
  (defvar-local im-shell-command-mode-command nil
    "Current shell command that belongs to the buffer.")

  (define-minor-mode im-shell-command-mode
    "Shell command mode."
    :lighter "iscm"
    :keymap (make-sparse-keymap))

  (evil-define-key 'normal im-shell-command-mode-map
    (kbd "gr") #'im-shell-command-mode-rerun-command)

  (defun im-shell-command-mode-rerun-command ()
    "Re-run the shell command."
    (interactive)
    (apply #'im-shell-command im-shell-command-mode-command))


  ;; In normal mode, hitting ! will display im-shell-command but in
  ;; visual mode hitting ! will open evil's default evil-shell-command
  ;; on selected region.
  (evil-define-key 'normal 'global (kbd "!") #'im-shell-command)

  (defun im-zsh-smart-history ()
    (->>
     (with-temp-buffer
       (insert-file-contents "~/.zsh_history")
       (buffer-string))
     s-trim
     (s-split "\n")
     (--map (if (s-prefix? ":" it)
                (s-replace-regexp "^: [0-9:]+;" "" it)
              it))
     (--filter (and (not (s-blank? it))
                    (> (length it) 5)
                    (not (s-matches? "^\\(ls\\|pwd\\|exit\\|cd\\|echo\\)" it))))))

  (cl-defun im-shell-command
      (&key
       command
       args
       (switch t)
       (buffer-name (concat "*" command "*"))
       (on-start (lambda (&rest _)))
       (on-finish (lambda (&rest _)))
       (on-fail (lambda (&rest _))))
    "Run given shell COMMAND and redirect output to given BUFFER-NAME.
  This is a wrapper around `start-process-shell-command' that adds
  support for ANSI term colors and some syntactic convenience.

  If ARGS is non-nil list, then use `start-process' with command as
  COMMAND and args as ARGS.

  When called interactively, asks for a command to run (with eshell
  completion)."
    (interactive
     (let ((command (completing-read "Command: " (im-zsh-smart-history))))
       (list
        :command command
        :on-finish
        (lambda (&rest _)
          (let ((msg (format ">> \"%s\" finished successfully." command)))
            (message msg)
            (when (not (frame-focus-state))
              (alert msg))))
        :on-fail
        (lambda (&rest _)
          (let ((msg (format ">> \"%s\" FAILED." command)))
            (message msg)
            (when (not (frame-focus-state))
              (alert msg)))))))
    (let* ((proc
            (if args
                (apply #'start-process command buffer-name command args)
              (start-process-shell-command command buffer-name command)))
           (proc-out ""))
      (set-process-sentinel
       proc
       (lambda (p e)
         (with-current-buffer buffer-name
           (read-only-mode -1))
         (if (= 0 (process-exit-status p))
             (funcall on-finish proc-out)
           (funcall on-fail))))
      (set-process-filter
       proc
       (lambda (proc str)
         (with-current-buffer buffer-name
           (setq proc-out (concat proc-out str))
           (let ((inhibit-read-only t))
             (goto-char (point-max))
             (insert (ansi-color-apply (s-replace "" "\n" str)))))))
      (with-current-buffer buffer-name
        (prog-mode)
        (im-shell-command-mode 1)
        (evil-normal-state)
        (setq-local
         im-shell-command-mode-command
         (list
          :command command
          :args args
          :buffer-name buffer-name
          :on-start on-start
          :on-finish on-finish
          :on-fail on-fail))
        (funcall on-start))
      (when switch
        (switch-to-buffer buffer-name))))
#+end_src

** Copy current/buffers filename into clipboard
#+begin_src emacs-lisp
  (defalias 'im-copy-current-filename-to-clipboard 'im-copy-file-name-to-clipboard)
  (defun im-copy-file-name-to-clipboard (&optional uri)
    "Copy the current buffer file name to the clipboard.
  If the URI is non-nil, then add file:// in front of the
  file-path."
    (interactive "P")
    (let* ((fname (if (equal major-mode 'dired-mode)
                         default-directory
                       (buffer-file-name)))
           (filename (if (and fname uri)
                         (concat "file://" fname)
                       fname)))
      (if filename
          (progn
            (kill-new filename)
            (message ">> Copied buffer file name '%s' to the clipboard." filename))
        (user-error ">> Failed to copy"))))
#+end_src
** Password manager
#+begin_src emacs-lisp
  (defun im-password-all ()
    "Get list of all passwords and their properties from `passwords.org'."
    (with-current-buffer "passwords.org"
      (->>
       (lambda ()
         (let ((link "")
               (match (org-entry-get nil "MATCH"))
               (header-link (save-excursion (forward-char 5) (org-element-context)))
               (title (org-entry-get nil "ITEM"))
               (props (im-alist-to-plist (org-entry-properties))))
           (when (plist-get props :username)
             ;; ^ A password entry should contain at least the :username: prop
             (when (eq (org-element-type header-link) 'link)
               (setq link (org-element-property :raw-link header-link))
               (save-excursion
                 (setq title
                       (buffer-substring-no-properties
                        (org-element-property :contents-begin header-link)
                        (org-element-property :contents-end header-link)))))
             `(:title ,title :link ,link ,@props))))
       (org-map-entries)
       (-filter #'identity))))

  ;; TODO Better matching algorithm Check if full string matches any,
  ;; then check if host matches. Return full string match only if it
  ;; exists. Also check if toplevel domain matches, if it does not match
  ;; fully
  (defun im-password-find-for (url)
    "Return matching accounts for given URL.
  If there are multiple accounts registered for one entry, then
  list them as seperate entries."
    (interactive)
    (let ((urlobj (url-generic-parse-url url)))
      (setq url (url-host urlobj))
      (when-let ((port (url-port-if-non-default urlobj)))
        (setq url (format "%s:%s" url port))))
    (let* ((candidates (--filter
                        (when (or (ignore-errors (s-match (plist-get it :match) url))
                                  (s-contains? url (plist-get it :link)))
                          it)
                        (im-password-all))))
      (-flatten-n
       1
       (-map (lambda (info)
               (let ((unames (s-split " " (plist-get info :username)))
                     (pwds (s-split " " (plist-get info :password))))
                 (-zip  (--map (format "%s - %s" (plist-get info :title) it) unames)
                        (--map (list :info info :acc it)
                               (-zip unames pwds)))))
             candidates))))

  (defun im-password-qutebrowser (url fifo)
    "Find credentials for currently open link in Qutebrowser and fill."
    (let* ((candidates (im-password-find-for url))
           (result (plist-get
                    (alist-get (completing-read "Select account: " candidates) candidates nil nil #'equal) :acc))
           (username (car result))
           (password (-some->> (cdr result)
                       (s-replace "\"" "\\\"")
                       (s-replace "'" "\\'"))))
      (when (and username password)
        (pcase (completing-read "Method: " '("Fill all with TAB" "Fill username" "Fill password"))
          ("Fill all with TAB"
           (write-region "mode-enter insert\n" nil fifo 'append)
           (write-region (format "fake-key %s\n" username) nil fifo 'append)
           (write-region "fake-key <Tab>\n" nil fifo 'append)
           (write-region (format "fake-key %s\n" password) nil fifo 'append))
          ("Fill username"
           (write-region "mode-enter insert\n" nil fifo 'append)
           (write-region (format "fake-key %s\n" username) nil fifo 'append))
          ("Fill password"
           (write-region "mode-enter insert\n" nil fifo 'append)
           (write-region (format "fake-key %s\n" password) nil fifo 'append))))))

  ;; TODO Add other actions:
  ;; - Fill with tab
  ;; - Copy username/password etc.
  (defun im-password-act ()
    (interactive)
    (and-let* ((passwords (im-password-all))
               (candidates (--map (cons (plist-get it :title) it) passwords))
               (selected (im-alist-completing-read "Select: " candidates)))
      (let-plist selected
        (pcase (completing-read
                "Action: "
                (list "Copy as username:password"
                      "Copy as PostgreSQL connection string"
                      "Copy as SQL src block header args"
                      "Copy as Couchbase (CBC, N1QL) src block header args"))
          ("Copy as username:password"
           (kill-new
            (format "%s:%s" .username .password)))
          ("Copy as PostgreSQL connection string"
           (kill-new
            (format "postgresql://%s:%s@%s:%s/%s"
                    .username .password .host .port .db)))
          ("Copy as SQL src block header args"
           (kill-new
            (format ":engine postgresql :dbhost %s :dbuser %s :dbpassword %s :database %s :dbport %s"
                    .host .username .password .db .port)))
          ("Copy as Couchbase (CBC, N1QL) src block header args"
           (kill-new
            (format ":host %s :username %s :password %s"
                    .host .username .password)))))))

#+end_src
** Kubernetes
My main use case is drop into a shell of a pod. The code below makes it quite easy. Use ~im-kube-select-pod~ to select a pod and do some actions on it.

#+begin_src emacs-lisp
  (defun im-kube--current-context ()
    (s-trim (shell-command-to-string "kubectl config current-context")))

  (defun im-kube-use-context ()
    (interactive)
    (im-output-select
     :cmd "kubectl config get-contexts --output=name"
     :drop 1
     :keep-order t
     :prompt (format "Select context (current=%s): " (im-kube--current-context))
     :do (shell-command-to-string (format "kubectl config use-context '%s'" it))))

  (defalias 'im-kube-get-context-server-ip 'im-kube-get-cluster-server-ip)
  (defun im-kube-get-cluster-server-ip ()
    (interactive)
    (im-output-select
     :cmd "kubectl config get-clusters"
     :drop 1
     :keep-order t
     :prompt (format "Select context (leave blank to use %s): " (im-kube--current-context))
     :do
     (->>
      (if (s-blank? it) (im-kube--current-context) it)
      (format "kubectl config view -o jsonpath=\"{.clusters[?(@.name == '%s')].cluster.server}\"")
      shell-command-to-string
      im-kill)))

  (defun im-kube-select-pod (&optional switch-context)
    "Select a pod and act on it.
  If SWITCH-CONTEXT is non nil, switch to another context before
  selecting a pod."
    (interactive "P")
    (when switch-context
      (im-kube-use-context))
    (im-output-select
     :cmd "kubectl get pods --all-namespaces"
     :drop 1
     :prompt (format "Select a pod from '%s': " (im-kube--current-context))
     :keep-order t
     :do (let ((info (s-split " " it t)))
           (im-kube-pod--act (list :name (nth 1 info) :namespace (nth 0 info))))))

  (defun im-kube-pod--act (pod)
    (with-completing-read-exact-order
     (let ((namespace (plist-get pod :namespace))
           (name (plist-get pod :name)))
       (pcase (completing-read (format "Act on '%s'" name) '("Exec into default container" "Exec into container" "Logs" "App logs" "Remove"))
         ("Exec into default container"
          (with-current-buffer (im-eshell (format "$pod: %s" name))
            (insert
             (im-kill (format "kubectl exec --namespace='%s' -i -t '%s' -- bash"
                              namespace
                              name)))))
         ("Exec into container"
          (let ((container (im-kube-pod--select-container pod)))
            (with-current-buffer (im-eshell (format "$pod: %s" name))
              (insert
               (im-kill (format "kubectl exec --namespace='%s' --container='%s' -i -t '%s' -- bash"
                                namespace
                                container
                                name))))))
         ("Logs"
          (let ((container (im-kube-pod--select-container pod)))
            (with-current-buffer (im-eshell (format "$pod: %s" name))
              (insert
               (im-kill (format "kubectl logs %s -f --namespace='%s' --container='%s'"
                                name
                                namespace
                                container))))))
         ;; Logs from all pods combined for given pod's app
         ("App logs"
          (let ((container (im-kube-pod--select-container pod)))
            (with-current-buffer (im-eshell (format "$pod: %s" name))
              (insert (im-kill
                             (format "kubectl logs -f --selector app=%s --namespace='%s' --container='%s'"
                                     (im-kube-pod--get-app-name pod)
                                     namespace
                                     container))))))
         ("Remove" (user-error "Not implemented"))))))

  (defun im-kube-pod--select-container (pod)
    (im-output-select
     :cmd (format
           "kubectl get pods '%s' --namespace='%s' -o jsonpath='{.spec.containers[*].name}'"
           (plist-get pod :name)
           (plist-get pod :namespace))
     :prompt (format "Container for %s: " (plist-get pod :name))
     :split " "))

  (defun im-kube-pod--get-app-name (pod)
    "Return the application name of the POD belongs."
    (s-trim
     (shell-command-to-string
      (format
       "kubectl get pod %s --namespace='%s' -o custom-columns=:metadata.labels.app"
       (plist-get pod :name)
       (plist-get pod :namespace)))))
#+end_src
** Kafka
#+begin_src emacs-lisp
  ;; TODO rewrite this using kafkactl
  ;; Also add functions like `im-kafka-switch-context' etc.
  (defun im-kafka-describe-consumer-group ()
    (interactive)
    ;; `im-select-kafka-consumers' is a private function that
    ;; returns a kafka server list
    (let ((servers (im-select-kafka-consumers)))
      (im-output-select
       :cmd (format "kafka-consumer-groups.sh --list --bootstrap-server %s" servers)
       :prompt "Select a consumer group: "
       :do (im-output-to-tabulated-list
            (shell-command-to-string
             (format "kafka-consumer-groups.sh --describe --group %s --bootstrap-server %s" it servers))
            :buffer (get-buffer-create "*kafka-describe:%s*" it)))))
#+end_src
** Run functions globally
:PROPERTIES:
:ID:       30465D2E-AB40-4E53-B6EA-9D72F7242700
:END:
Simply use ~im-dmenu~ function instead of the default ~completing-read~ function when the code is called inside this macro. This way, you can use your ~completing-read~ based functions within your system, without needing to focus Emacs first.

#+begin_src emacs-lisp
  (defmacro im-globally (&rest body)
    `(let ((completing-read-function #'im-dmenu))
       ,@body))
#+end_src
** Archive URLs with single-file
#+begin_src emacs-lisp
  (cl-defun im-archive-url (url &key where (backend 'chrome) crawl tidy on-finish on-fail)
    "Archive the URL into WHERE. WHERE can be a directory or a
  file. If it's a directory, it should already exists otherwise
  WHERE is interpreted as a file name."
    (interactive
     (list (or
            (im-org-link-copy)
            (thing-at-point 'url)
            (read-string "URL: "))
           (read-directory-name "Save files into: ")))
    (setq where (expand-file-name where))
    (let* ((command
            (format
             "single-file --filename-replacement-character='-' %s %s %s \"%s\" \"%s\""
             (if (eq system-type 'darwin)
                 "--browser-executable-path=\"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome\""
               "--browser-executable-path=chromium")
             (if (eq backend 'firefox)
                 "--back-end=webdriver-gecko"
               "")
             (if crawl
                 ;; FIXME --crawl-replace-urls=true does not work
                 "--crawl-links=true --crawl-external-links-max-depth=1 --crawl-max-depth=1 --crawl-replace-urls=true --crawl-inner-links-only=false --crawl-no-parent=true"
               "")
             url
             (cond
              ((f-dir? where)
               (format "--output-directory=%s" where))
              (where where)
              (t (format "--output-directory=%s" default-directory))))))
      (im-shell-command
       :command command
       :switch nil
       :buffer-name "*single-file output*"
       :on-finish
       (lambda (&rest _)
         (when (called-interactively-p 'any)
           (message "Archived `%s'!" url)
           (kill-new command))
         ;; single-file does not return the created file name, finding that manually
         (let ((created-file (cond
                              ((f-file? where) where)
                              ((f-dir? where) (im-latest-file where))
                              (t (error "Can't find file created backup file")))))
           (when tidy
             (unless (executable-find "tidy")
               (user-error "`tidy' not found in the path"))
             (shell-command (format "tidy -q -w 120 -m '%s'" created-file)))
           (and on-finish (funcall on-finish created-file))))
       :on-fail
       (lambda ()
         (when (called-interactively-p 'any)
           (message "Archiving failed: '%s'. Command is copied to your kill ring." url)
           (kill-new command))
         (and on-fail (funcall on-fail 'abnormal-exit))))))
#+end_src
** im-narrow-dwim
#+begin_src emacs-lisp
  (evil-leader/set-key "n" #'im-narrow-dwim)

  (defun im-narrow-dwim ()
    "Smart narrowing."
    (interactive)
    (cond
     ((use-region-p) (narrow-to-region (region-beginning) (region-end)))
     ((eq major-mode 'org-mode) (org-narrow-to-subtree))
     ((eq major-mode 'markdown-mode) (markdown-narrow-to-subtree))
     ((eq major-mode 'emacs-lisp-mode) (narrow-to-defun))
     ((s-contains? "-ts-" (symbol-name major-mode))
      (when-let (def (treesit-defun-at-point))
        (narrow-to-region (treesit-node-start def)
                          (treesit-node-end def))))))
#+end_src
** im-meme-downloader
#+begin_src emacs-lisp
  (defun im-meme-downloader (url &optional file-title)
    (interactive
     (list
      (read-string "URL: ")
      (read-string "Title: ")))
    (let* ((title
            (or file-title
                (s-trim
                 (thread-last
                   url
                   im-url-get-title
                   im-string-url-case
                   s-downcase))))
           (dir (expand-file-name "~/Documents/memes"))
           (default-directory dir)
           (cmd (format "yt-dlp --output '%s.%%(ext)s' '%s'" title url)))
      (message "im-meme-downloader :: %s" cmd)
      (im-shell-command
       :command cmd
       :switch nil
       :on-finish
       (lambda (output &rest _)
         (if-let* ((matches (or
                             (s-match "\\[download\\] \\(.*\\) has already been downloaded" output)
                             (s-match "^\\[Merger\\] Merging formats into \"\\(.*\\)\"" output)
                             (s-match "^\\[download\\] Destination: \\(.*\\)" output)))
                   (fname (abbreviate-file-name (nth 1 matches))))
             (progn
               (alert (format "Downloaded: %s!" fname))
               (kill-new (format "%s/%s" dir fname)))
           (alert "Can't parse yt-dlp output!")))
       :on-fail
       (lambda (&rest _)
         (alert (format "Error while downloading: %s!" url))))))
#+end_src
** im-jump-to-definition-at-config
#+begin_src emacs-lisp
  (defun im-jump-to-definition-at-config (symbol)
    "Like normal jump-to-definition functionality but jumps to my
  literate config instead of tangled real definition. Pretty dumb
  but works most of the time."
    (interactive (list (read-string "Symbol: " (im-region-or 'symbol))))
    (with-current-buffer (find-file-noselect "~/Workspace/projects/dotfiles/emacs/index.org")
      (org-save-outline-visibility nil
        (save-restriction
          (save-excursion
            (org-show-all)
            (goto-char (point-min))
            (when (re-search-forward (format "\\((def.*\\) %s" symbol nil t))
              (call-interactively #'org-edit-special)))))))

  (define-key embark-symbol-map (kbd "J") 'im-jump-to-definition-at-config)
#+end_src
** zoom
#+begin_src emacs-lisp
  (defun im-open-zoom-meeting-dwim (&optional link)
    (interactive
     (list
      (or (thing-at-point 'url) (read-string "Link: "))))
    (when-let* ((zoom (s-match
                       "https://.*zoom\\.us/j/\\(\\w+\\)\\?pwd=\\(\\w+\\)"
                       link))
                (cmd (format
                      "open 'zoommtg://zoom.us/join?confno=%s&pwd=%s'"
                      (nth 1 zoom)
                      (nth 2 zoom))))
      (message ">> Running %s" cmd)
      (shell-command cmd)))
#+end_src
** macOS calendar functions
My work computer is a Mac. I synchronize my work calendar into my local by using macOS' Calendar app and I utilize [[https://hasseg.org/icalBuddy/][icalBuddy]] to interact with that calendar from Emacs.

#+begin_src emacs-lisp
  (defun im-calendar-now ()
    "Show the current calendar item details in a buffer and open the
  zoom link if it has one."
    (interactive)
    (im-shell-command
     :command "icalBuddy -f -ea eventsNow"
     :buffer-name "*calendar-now*"
     :on-start (lambda (&rest _) (erase-buffer))
     :on-finish (lambda (it)
                  (when-let ((zoom (nth 1 (s-match "\\(https://.*zoom.us/j/.*\\)\\(\b\\|\n\\)" it))))
                    (im-open-zoom-meeting-dwim zoom)))))

  (defun im-calendar-today ()
    "Show today's calendar in a buffer. The resulting buffer has
  outline-mode enabled, so you can use outline-mode specific
  bindings to jump, hide/show stuff."
    (interactive)
    (im-shell-command
     :command "icalBuddy -f eventsToday"
     :on-start (lambda (&rest _) (erase-buffer))
     :on-finish (lambda (&rest _)
                  (outline-mode)
                  (setq-local outline-regexp "• ")
                  (goto-char (point-min))
                  (outline-cycle-buffer))
     :buffer-name "*calendar-today*"))
#+end_src
** im-clipboard-image-to-text
#+begin_src emacs-lisp
  (defalias 'im-clipboard-tesseract-ocr-text #'im-clipboard-image-to-text)
  (defun im-clipboard-image-to-text ()
    (interactive)
    (let ((temp-image (make-temp-file "tesseract-image" nil ".png"))
          (temp-text (make-temp-file "tesseract-text"))
          (buffer (get-buffer-create "*ocr-result*")))
      (im-save-clipboard-image-to-file temp-image)
      (set-process-sentinel
       (start-process "*tesseract-ocr*" nil "tesseract" temp-image temp-text)
       (lambda (proc out)
         (if (and
              (eq 'exit (process-status proc))
              (eq 0 (process-exit-status proc)))
             (progn
               (with-current-buffer buffer
                 (erase-buffer)
                 (insert (format "[[%s]]\n\n\n" temp-image))
                 (insert-file-contents (concat temp-text ".txt"))
                 (iimage-mode))
               (switch-to-buffer buffer))
           (message "*tesseract-ocr*: %s" (string-trim out)))))))

#+end_src
** Update all git projects
#+begin_src emacs-lisp
  ;; TODO: switch to master/main before if head is not dirty?
  (defun im-pull/update-all-projects ()
    "Pull all projects."
    (interactive)
    (--map
     (let ((fname (f-filename it))
           (default-directory it))
       (set-process-sentinel
        (start-process (format "*git-pull-%s*" fname) nil "git" "pull" "--rebase")
        (lambda (proc _code)
          (if (eq (process-exit-status proc) 0)
              (message ">> Pulled %s on branch '%s'." fname (let ((default-directory it)) (lab-git-current-branch)))
            (message ">> Failed to pull %s, exit code is %s." fname (process-exit-status proc))))))
     (im-all-project-roots)))
#+end_src
** im-gnuplot
#+begin_src emacs-lisp
  (cl-defmacro im-gnuplot (settings &rest forms)
    "A horrible hack for using `gnuplot' in emacs-lisp. Example usage:

      (im-gnuplot
          (:persist t)
        (plot sin(x))
        (plot sin(x)/x)
        (plot cos(x))
        (plot cos(x)/x)
        (plot sin(x) title \"Sin\", tan(x) title \"Tangent\"))

  First argument is a plist which consists gnuplot configs or
  variable definitions.  Configs are`:persist', `:default',
  `:slow'. See `man gnuplot' for more information on these
  settings. They can be either `t' or `nil'. Default is `nil' for
  each one.

  Variable definitions are like the `let' form, simply define
  variables and use them in the gnuplot code below. Variable
  namings should follow `:this-style:' and the values can be
  arbitrary elisp.

      (im-gnuplot
          (:data: (make-temp-file \"im-gnuplot\" nil \".dat\" \"a 1\nb 2\nc 3\")
           :out-file: \"~/output.png\")
        (set terminal pngcairo size 900,300 enhanced font \"Verdana,8\")
        (set output :out-file:)
        (set style data histograms)
        (set boxwidth 0.9)
        (set style fill solid)
        (set xlabel \"Time\")
        (set ylabel \"Log count\")
        (set title \"Log count over time\")
        (plot :data: using 2:xtic(1) title \"\"))"
    (declare (indent 1))
    (let* ((script (thread-last
                     forms
                     (mapcar
                      (lambda (it)
                        (thread-first
                          it
                          (prin1-to-string)
                          (string-trim-left "(")
                          (string-trim-right ")"))))
                     (s-join "\n")
                     (s-replace-regexp " (\\\\, \\(.*?\\))" ",\\1"))))
      `(progn
         (let* ((items (list ,@(-flatten-n 1 (map-apply (lambda (key val) (list key val)) settings))))
                (script-last (thread-last
                               ,script
                               (s-prepend "reset\n")
                               (s-replace-regexp
                                "\\(:[a-zA-Z-]+:\\)"
                                (lambda (match) (format " %s " (prin1-to-string (plist-get items (intern (s-trim match))))))))))
           (with-temp-buffer
             (insert script-last)
             (shell-command-on-region
              (point-min) (point-max)
              (format "gnuplot%s%s%s"
                      (if (plist-get items :persist) " --persist" "")
                      (if (plist-get items :default) " --default" "")
                      (if (plist-get items :slow) " --slow" ""))
              nil t)
             (buffer-string))))))
#+end_src
** Image and file system tags
#+begin_src emacs-lisp
  (defun im-image-edit-tags (tags image &optional clear-all)
    "Add TAGS to IMAGE.
  If CLEAR-ALL is non-nil, clear all tags before setting TAGS as
  image tags. Otherwise TAGS are appended.  If cursor is on an org
  link, use that as the IMAGE (when called interactively)."
    (interactive
     (let* ((org-link? (org-in-regexp org-link-any-re 1))
            (file
             (if org-link?
                 (progn
                   (goto-char (car org-link?))
                   (plist-get (cadr (org-element-link-parser)) :path))
               (read-file-name "Image file: ")))
            (file-tags (s-join ", " (im-image-tags file)))
            (tags (completing-read-multiple
                   "Tags: "
                   (im-directory-image-tags (f-dirname file))
                   nil nil
                   (if (s-blank? file-tags) nil (concat file-tags ",")))))
       (list
        tags
        file
        t)))
    (setq image (expand-file-name image))
    (when clear-all
      (shell-command (format "exiftool -overwrite_original -keywords='' '%s'" image)))
    (shell-command
     (format "exiftool -overwrite_original %s '%s'"
             (s-join " " (--map (format "-keywords+='%s'" (s-trim it)) tags))
             image))
    ;; Also add these tags as file extended attribute which helps KDE to
    ;; easily index these files.  I'm using this in conjunction with exif
    ;; attributes because it's quite easy to loose extended attributes
    ;; and exif attributes serves as a backup.
    (if clear-all
        (im-set-file-attribute image "user.xdg.tags" (s-join "," tags))
      (im-set-file-attribute
       image "user.xdg.tags"
       (s-join "," (cons (im-get-file-attribute image "user.xdg.tags") tags)))))

  (defun im-image-tags (image)
    "Return tags of IMAGE."
    (let ((result
           (plist-get
            (seq-first
             (json-parse-string
              (shell-command-to-string (format "exiftool -quiet -json -keywords '%s'" (expand-file-name image)))
              :array-type 'list
              :object-type 'plist))
            :Keywords)))
      (if (listp result) result (list result))))

  (defun im-directory-image-tags (&optional directory)
    "Return all unique image tags in DIRECTORY.
  If DIRECTORY is null, `default-directory' is used."
    (-uniq
     (--mapcat
      (plist-get it :Keywords)
      (json-parse-string
       (shell-command-to-string (format "exiftool -m -quiet -json -keywords '%s'" (expand-file-name (or directory default-directory))))
       :object-type 'plist :array-type 'list))))

  (defun im-get-file-attribute (file name)
    "Get extended attribute NAME for FILE."
    (shell-command-to-string (format "getfattr --absolute-names --only-values --name='%s' '%s'" name (expand-file-name file))))

  (defun im-set-file-attribute (file name value)
    "Set extended attribute NAME as VALUE for FILE.
  When called interactively, set given NAME to VALUE as extended
  attribute for current buffers file or selected file."
    (interactive
     (let ((attr (completing-read "Attribute: " '("user.xdg.tags"))))
       (list
        (or (buffer-file-name) (read-file-name "File: "))
        attr
        (read-string (format "Value for '%s': " attr)))))
    (shell-command-to-string (format "setfattr --name='%s' --value='%s' '%s'" name value (expand-file-name file))))
#+end_src
* Operating system related
** Sound output chooser
#+begin_src emacs-lisp
  (defun im-osx-select-audio-output ()
    ;; This is required: https://github.com/deweller/switchaudio-osx
    ;; brew install switchaudio-osx
    (im-output-select
     :cmd "SwitchAudioSource -a"
     :prompt (let ((current (im-shell-command-to-string "SwitchAudioSource -c")))
               (format "Select audio source (%s): " current))
     :do (shell-command-to-string (format "SwitchAudioSource -s '%s'" it))))

  (defun im-linux-select-audio-output ()
    (let ((sink
           (->>
            (shell-command-to-string
             "pactl list sinks | grep -E 'Name|device.description' | cut -d: -f2 | cut -d= -f2 | tr -d '\"'")
            (s-trim)
            (s-split "\n")
            (mapcar #'s-trim)
            (-partition 2)
            (mapcar #'nreverse)
            (im-alist-completing-read "Select sink: ")
            car)))
      ;; Set default sink
      (shell-command-to-string (format "pacmd set-default-sink %s" sink))
      ;; Move inputs to the new sink
      (->>
       (shell-command-to-string "pactl list short sink-inputs | cut -d'\t' -f1")
       (s-trim)
       (s-split "\n")
       (--map (shell-command-to-string (format "pactl move-sink-input %s %s" it sink))))))

  (defun im-select-audio-output ()
    (interactive)
    (funcall
     (pcase system-type
       ('darwin #'im-osx-select-audio-output)
       ('gnu/linux #'im-linux-select-audio-output))))

  (evil-leader/set-key "ea" #'im-select-audio-output)
#+end_src

** Bluetooth device connector
#+begin_src emacs-lisp
    ;; TODO: osx version?
  (defun im-linux-connect-paired-bluetooth-device ()
    (interactive)
    (let* ((paired-devices (->>
                            (shell-command-to-string "bluetoothctl devices Paired")
                            (s-trim)
                            (s-split "\n")))
           (connected-devices (->>
                               (shell-command-to-string "bluetoothctl devices Connected")
                               (s-trim)
                               (s-split "\n")))
           (device
            (->>
             (-difference paired-devices connected-devices)
             (--map (->>
                     (s-split-up-to " " it 2)
                     (-drop 1)
                     (nreverse)))
             (im-alist-completing-read "Select bluetooth device to connect: ")
             (car))))
      (set-process-filter
       (start-process "im-connect-bluetooth" nil "bluetoothctl" "connect" device)
       (lambda (proc out)
         (cond
          ((s-matches? "Failed to connect" out) (message "%s" out))
          ((s-matches? "Connection successful" out) (message "%s" out)))))))

  (evil-leader/set-key "eb" #'im-linux-connect-paired-bluetooth-device)
#+end_src
** Switch next monitor input
#+begin_src emacs-lisp
  (defun im-ddcutil-toggle/switch-monitor-input ()
    "Switch to other monitor, USBC or HDMI."
    (interactive)
    (let* ((hdmi "0x11")
           (usbc "0x1b")
           (cmd (format
                 "ddcutil -b $(ddcutil detect | grep I2C | cut -d- -f2 | tail -n 1) setvcp 0x60 %s"
                 (if (s-contains? hdmi (shell-command-to-string "ddcutil -d 1 getvcp 60"))
                     usbc hdmi))))
      (shell-command-to-string
       (if (workpc?)
           (format "ssh x220 '%s'" cmd)
         cmd))))
#+end_src
* Postamble
#+begin_src emacs-lisp
  ;; Load the remaining external files that I want to be loaded
  (--each
      (directory-files im-load-path t (rx ".el" eos))
    (load it))

  (unless (daemonp)
   ;; This is good for the cases where emacsclient may be called inside
   ;; emacs (from vterm etc.). Otherwise Emacs acts weird about the
   ;; window placement.
    (setq server-window #'pop-to-buffer)
    (server-start))

  (message ">>> Started in %s" (emacs-init-time))
#+end_src

;; Local Variables:
;; eval: (add-hook 'after-save-hook (lambda () (if (y-or-n-p "Tangle?") (org-babel-tangle))) nil t)
;; End:
