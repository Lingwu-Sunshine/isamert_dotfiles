#+TITLE: Emacs configuration file
#+AUTHOR: İsa Mert Gürbüz
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes :noweb yes
#+PROPERTY: header-args:emacs-lisp :lexical yes
#+STARTUP: overview
#+OPTIONS: toc:3

* Introduction
This is my emacs configuration. My main focus is sanity. I'm a person who get frustrated pretty easily. So instead of optimizing the time spent on doing things, I try to find ways of doing things that does not make me frustrated. Most of the time you get speed boost as a byproduct.

#+begin_src emacs-lisp
  ;;; index.el --- isamert's configuration -*- lexical-binding: t; -*-

  ;;; Commentary:

  ;; isamert's configuration

  ;;; Code:
#+end_src

* Usage notes
** General notes and conventions
- This configuration is meant to be used with /emacs daemon/, so I don't really care about the startup time etc.
- I try to split package configurations into multiple org src blocks and unify them using ~noweb~ references under a single =use-package= directive.
- I try to put things in way that easily copyable from the configuration. An example would be using multiple =(setq ...)= lines instead of having one =(setq ... ...)= call and setting multiple variables in one go.
- I make use of =use-package= features quite minimally. See [[id:3d974e67-11fc-4f07-8cd4-ec6fd63152c4][here]] for more information that. This is generally related with the item above and future-proofing.
- I use =verbatim text= and ~code text~ completely randomly.
- I try to prefer built-in packages or packages that enhances built-in ones where possible. I'm also trying to simplify my configuration, so another goal is to reduce the package number. Although I intend to keep packages that enhances the overall experience with no special configuration (just install and forget type of packages).

** Keybinding conventions
- After leader
  - =e= :: is reserved for independent programs, that is not related to editing/programming. For example, "ec" opens calendar, "ee" opens elfeed, "er..." controls the radio.
  - =t= :: is reserved for toggling stuff. Toggle the terminal, toggle a frequently accessed buffer etc.
  - =h= :: is reserved for any menu with fuzzy selection that does not fit anywhere else.
  - =g= :: is for git related functionality.
  - =p= :: is for project related functionality.
  - =/= :: is for search/translate related functionality. (Generally external programs)
  - =b= :: is for buffers.
  - =w= :: is for windows. I also use =C-w= for this, which is default prefix for window-related functions in vim.
  - =o= :: is for org-mode/outline mode.
** Updating packages
Currently, I don't use an external package manager, =package.el= satisfies my needs. Here is how I do the updates:
- =package-refresh-contents=
- =list-packages=
- Hit =U= to mark all packages that needs updating.
- Hit =X= to update all those packages.

I do this quite infrequently. If everything is working fine as it is, I tend to not update anything.

* early-init.el
#+begin_src emacs-lisp :tangle ~/.emacs.d/early-init.el
  ;; Some stuff are taken from:
  ;; https://github.com/emacs-lsp/lsp-mode#performance

  (setq package-enable-at-startup nil)
  (setq-default lexical-binding 'lv)
  (setq native-comp-async-report-warnings-errors nil)

  (setq gc-cons-threshold 3000000)
  ;; ^ Set gc threshold to ~30MB
  (setq read-process-output-max (* 1024 1024))
  ;; ^ Better than default
  (setq confirm-kill-processes nil)
  ;; ^ When exitting, kill processes withouh asking
  (setq ring-bell-function 'ignore)
  ;; ^ This completely disables alarms
  (setq column-number-mode t)
  ;; ^ Show column number
  (setq create-lockfiles nil)
  ;; ^ These just clutter the filesystem
  (setq dabbrev-case-fold-search nil)
  ;; ^ Expansions are done respecting the case (Ctrl-n and Ctrl-p was
  ;; not behaving the way I wanted before this in evil mode)
  (setq vc-follow-symlinks t)
  ;; ^ Don't ask about following symlinks
  ;; Ask y/n instead of yes/no
  (fset 'yes-or-no-p 'y-or-n-p)

  ;; Visuals
  (menu-bar-mode 0)                ;; Disable menubar
  (tool-bar-mode 0)                ;; Disable toolbar
  (blink-cursor-mode 0)            ;; Disable blinking cursor
  (scroll-bar-mode -1)             ;; Disable scrollbars
  (setq inhibit-startup-message t) ;; Close startup screen
  (setq frame-resize-pixelwise t)  ;; Fix gap issues with tiling WMs
  (defconst im-init-file (expand-file-name "~/.emacs.d/scratch.el"))
  (setq initial-buffer-choice im-init-file)
  (add-to-list 'default-frame-alist '(undecorated . t))
#+end_src
* Preparation
** straight.el and use-package

#+begin_src emacs-lisp
  ;; Install straight.el
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" (or (ignore-errors straight-base-dir) user-emacs-directory)))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  ;; Install use-package
  (straight-use-package 'use-package)

  (use-package straight
    :custom (straight-use-package-by-default t))
#+END_SRC

I tend to not use the =use-package= goodies while configuring my packages, meaning that I don't use =:hook=, =:bind= etc. as they have relatively simpler alternatives in Emacs and using =use-package= alternatives of these makes copy/pasting harder. Here are the keywords that I use the most:
- =:init= :: This gets called before the package gets initialized.
- =:config= :: This gets called after the package is initialized.
- =:after= :: This makes the current definition to wait the loading of listed packages, like =:after (evil org)= makes it wait for the =evil= and =org= packages to be loaded.
- =:if= :: Loads the package conditionally, like =:if (eq system-type 'darwin)=.

*** Hiding mode indicators from modeline
~diminish.el~ provides a way to hide mode indicators from mode line. Either pass ~:diminish t~ to use-package while installing or just call ~(diminish 'x-mode)~.

#+BEGIN_SRC emacs-lisp
  (use-package diminish)
#+END_SRC

Currently I use [[mini-modeline]] as my modeline and it already hides minor mode indicators from the modeline. So this package is not needed but better have it as I might change my modeline in the future.

** Essential packages
I use =s.el= and =dash.el= extensively. They already come as a dependency with other packages but I may use them before loading any package, so:

#+begin_src emacs-lisp
  (use-package dash)
  (use-package s)

  ;; For parsing yaml.
  (use-package yaml)

  ;; Following provides defmemoize macro. Use (memoize-restore
  ;; 'fn-name) to restore the original function.
  (use-package memoize)
#+end_src

*** emacs-async
To be able execute elisp asynchronously. Of course this has lot's of
limitations, the lambda passed to ~async-start~ will be executed in a
freshly started Emacs instance and it will not have the any context of
the currently running Emacs instance. There are ways to pass variables
into the context of newly created Emacs instance which helps a lot.

#+begin_src emacs-lisp
  (use-package async)
#+end_src

** Variables and functions
Some basic variable and function definitions that will be used in configuration.

*** General utilities
#+BEGIN_SRC emacs-lisp
  (defun im-mkdir-if-not (dir)
    "Create the DIR if it does not exist return DIR."
    (unless (file-exists-p dir)
      (make-directory dir))
    dir)

  (defun im-font-exists-p (font)
    "Check if FONT exists."
    (x-list-fonts font))

  (defun im-assoc-regexp (key list &optional fn)
    "Like `assoc` but uses `string-match (car pair) KEY` for
  comparasion and returns all the matching pairs. FN is applied to
  the keys before matching, if present."
    (seq-filter
     (lambda (pair)
       (when (string-match-p (if fn (funcall fn (car pair)) (car pair)) key)
         pair))
     list))

  (defun im-region-or (what)
    "Returns currently selected string or WHAT-at-point string. WHAT
  can be 'symbol 'word or a function that returns string etc."
    (if (use-region-p)
        (buffer-substring-no-properties (region-beginning) (region-end))
      (if (functionp what)
          (funcall what)
        (thing-at-point what t))))

  (defun im-inner-back-quote-at-point ()
    "Return text inside the back quotes at point."
    (let ((bounds (evil-inner-back-quote)))
      (buffer-substring-no-properties
       (nth 0 bounds)
       (nth 1 bounds))))

  (defun im-shell-command-to-string (cmd)
    "Like `shell-command-to-string' but only stdout is returned."
    (string-trim
     (with-output-to-string
       (with-current-buffer standard-output
         (process-file
          shell-file-name nil '(t nil)  nil shell-command-switch
          cmd)))))

  (defun im-serialize-into-file (file data)
    (with-temp-file (expand-file-name file)
      (prin1 data (current-buffer))))

  (defun im-deserialize-from-file (file)
    (let ((fpath (expand-file-name file)))
      (when (and (file-exists-p fpath))
        (with-temp-buffer
          (insert-file-contents fpath)
          (goto-char (point-min))
          (read (current-buffer))))))

  ;; TODO Add a way to invalidate the file after given date
  (defmacro defmemoizefile (name arglist file &rest body)
    "Like a normal memoize function but persist the memoize cache to
  a file so that when Emacs is opened freshly, it'll continue using
  the memoize cache."
    (declare (indent 3) (doc-string 4))
    (let ((origfn (intern (concat (symbol-name name) "---defmemoizefile-origfn")))
          (memoizemap (intern (concat (symbol-name name) "---defmemoizefile-memoizemap"))))
      `(progn
         (setq ,memoizemap (make-hash-table :test 'equal))
         (when (file-exists-p (expand-file-name ,file))
           (setq ,memoizemap (im-deserialize-from-file ,file)))

         (defun ,origfn ,arglist
           ,@body)

         (defun ,name (&rest ___args)
           (if-let ((memoizedresult (gethash ___args ,memoizemap)))
               memoizedresult
             (let ((___result (apply #',origfn ___args)))
               (map-put! ,memoizemap ___args ___result)
               (im-serialize-into-file ,file ,memoizemap)
               ___result))))))

  (defun im-select-window-with-buffer (buffer-name)
    "Select the first visible window that matches given BUFFER-NAME."
    (declare (indent 1))
    (--first
     (-as-> (window-buffer it) buffer
            (buffer-name buffer)
            (when (string-match buffer-name buffer)
              (select-window it)))
     (window-list)))

  (defmacro im-with-visible-buffer (buffer-name &rest body)
    "Evaluate BODY within the BUFFER-NAME that is currently visible."
    `(with-selected-window (selected-window)
       (when (im-select-window-with-buffer ,buffer-name)
         ,@body)))

  (defun im-sync-async-command-to-string (command &rest args)
    "Run async command and wait until it's finished. This may seem stupid but I had to use it."
    (with-temp-buffer
      (let ((process (apply 'start-process `("sync-async-proc" ,(current-buffer) ,command ,@args))))
        (while (process-live-p process)
          (sit-for 0.1))
        (buffer-string))))

  (defmacro let-plist (plist &rest form)
    "Like `let-alist' but for plists."
    (declare (indent 1))
    `(let-alist (transient-plist-to-alist ,plist)
       ,@form))

  (defun im-mimetype (path)
    "Return mimetype of given file at PATH."
    (string-trim (shell-command-to-string (format "file --brief --mime-type '%s'" path))))

  (defun im-to-keyword (it)
    "Convert given string or symbol to a :keyword."
    (thread-last
      (cond
       ((stringp it) it)
       ((symbolp it) (symbol-name it))
       (t (error "Trying to convert %s to symbol" it)))
      (string-remove-prefix ":")
      (concat ":")
      (downcase)
      (intern)))

  (defun im-alist-to-plist (alist)
    "Convert association list ALIST into the equivalent property-list form.
  The plist is returned.  This converts from

  \((a . 1) (b . 2) (c . 3))

  into

  \(:a 1 :b 2 :c 3)

  The original alist is not modified.

  This function is taken from `mm-decode.el' and modified."
    (let (plist)
      (while alist
        (let ((el (car alist)))
          (setq plist (cons (cdr el) (cons (im-to-keyword (car el)) plist))))
        (setq alist (cdr alist)))
      (nreverse plist)))

  (defmacro λ-interactive (&rest body)
    "Useful for defining keybindings."
    `(lambda () (interactive) ,@body))

  (defun im-kill (x &optional replace)
    (kill-new x replace)
    x)

  (defun im-force-focus-emacs ()
    "Focus Emacs frame if not focused already."
    (unless (frame-focus-state)
      (pcase system-type
        ('darwin
         (shell-command-to-string
          "osascript -e 'tell application \"System Events\" to click UI element \"Emacs\" of list 1 of application process \"Dock\"'"))
        ('gnu/linux
         (user-error "Implement this: im-force-focus-emacs")))))

  (defun im-line-count-below-cursor ()
    "Return the number of lines displayed below the cursor in the current window."
    (let ((line (line-number-at-pos)))
      (save-excursion
        (move-to-window-line 0)
        (- (window-height) (- line (line-number-at-pos))))))
#+end_src

*** Elisp utils
#+begin_src emacs-lisp
  (defmacro im-tap (form)
    `(let ((result ,form))
       (message "[im-tap :: %s] → %s" ,(prin1-to-string form) result)
       result))

  (defun im-debug (thing)
    "Like `im-tap' but uses `pp-display-expression' to display the
  result instead of `message'."
    (pp-display-expression thing "*im-debug*")
    thing)

  (defmacro im-append! (lst item)
    "Append ITEM to end of the LST.
  Modifies LST. Only meant to be used in configuration."
    `(setq ,lst (append ,lst (list ,item))))

  (defun im-elisp-find-file-prefix ()
    "Extract prefix from defgroup statement in current buffer.
  I use this in my `defun' snippet via yasnippet."
    (or (save-excursion
          (goto-char (point-min))
          (when (search-forward-regexp ":prefix \"\\(.*\\)\"" nil t)
            (match-string 1)))
        "im-"))
#+end_src
*** Clipboard functions
#+begin_src emacs-lisp
  (defun im-clipboard-command ()
    "Get clipboard command for current system.
        The returned command directly puts the image data into stdout."
    (cond
     ((locate-file "xclip" exec-path) "xclip -selection clipboard -target image/png -out")
     ((locate-file "pngpaste" exec-path) "pngpaste -")))

  (defun im-clipboard-contains-image-p ()
    "Check whether the clipboard has image or not."
    (pcase system-type
      ('gnu/linux (s-contains? "image/" (im-sync-async-command-to-string "xclip" "-o" "-sel" "c" "-t" "TARGETS")))
      ('darwin (eq (shell-command "pngpaste - &>/dev/null") 0))))

  (defun im-save-clipboard-image-to-file (file)
    "Save the image in clipboard (if there is any) to given FILE.
    Also see `im-clipboard-contains-image-p' to check if there is one."
    (interactive "FFile to save the image: ")
    (shell-command (format "%s > %s" (im-clipboard-command) file)))
#+end_src
*** User input
#+begin_src emacs-lisp
  (cl-defun im-get-input (&key (mode #'org-mode)
                                    (init "")
                                    on-accept
                                    on-reject
                                    pre-process)
    "Display a buffer to user to enter some input."
    (let* ((buffer (get-buffer-create "*isamert-input*"))
           (success-handler (lambda ()
                              (interactive)
                              (let ((pre-proc-result (when pre-process
                                                       (with-current-buffer buffer
                                                         (funcall pre-process))))
                                    (result (substring-no-properties (buffer-string))))
                                (kill-buffer buffer)
                                (if pre-process
                                    (funcall on-accept result pre-proc-result)
                                  (funcall on-accept result)))))
           (reject-handler (lambda ()
                             (interactive)
                             (kill-buffer buffer)
                             (when on-reject
                               (funcall on-reject)))))
      (switch-to-buffer buffer)
      (with-current-buffer buffer
        (funcall mode)
        (use-local-map (copy-keymap (current-local-map)))
        (local-set-key (kbd "C-c C-c") success-handler)
        (local-set-key (kbd "C-c C-k") reject-handler)
        (setq header-line-format "Hit `C-c C-c' to save `C-c C-k' to reject.")
        (insert init))))

  (defun im-alist-completing-read (prompt alist &optional initial)
    "Like `completing-read' but returns value of the selected key in given ALIST."
    (alist-get
     (completing-read prompt alist nil nil initial)
     alist nil nil #'equal))

  (cl-defun im-completing-read
      (prompt objects &key (formatter #'identity) category (sort? t) def multiple?)
    "Provide an interactive completion interface for selecting an item from a list of objects.

  - PROMPT: The prompt string to display to the user.
  - OBJECTS: A list of objects to choose from.
  - FORMATTER: (Optional) A function that formats each object
    before displaying it to the user. The default is `'identity',
    which means no formatting.
  - CATEGORY: (Optional) A category symbol associated with the
    completion. This can be used to provide additional completion
    behavior.
  - SORT?: (Optional) A boolean value indicating whether the
    completion list should be sorted. The default is t.
  - DEF: (Optional) The default value to return if no selection is
    made. If multiple selections are allowed, this value will be
    returned as a list.
  - MULTIPLE?: (Optional) A boolean value indicating whether
    multiple selections are allowed. The default is `nil`.

  If MULTIPLE? is nil, this function returns the selected object
  from the completion list. If MULTIPLE? is t, this function
  returns a list of selected objects. If no selection is made, the
  DEF value is returned."
    (let* ((object-table
            (make-hash-table :test 'equal :size (length objects)))
           (object-strings
            (mapcar
             (lambda (object)
               (let ((formatted-object (funcall formatter object)))
                 (puthash formatted-object object object-table)
                 (propertize formatted-object 'empv-item object)))
             objects))
           (selected
            (funcall
             (if multiple? #'completing-read-multiple #'completing-read)
             (format "%s " prompt)
             (lambda (string predicate action)
               (if (eq action 'metadata)
                   `(metadata
                     ,(when category (cons 'category category))
                     ,@(unless sort?
                         '((display-sort-function . identity)
                           (cycle-sort-function . identity))))
                 (complete-with-action
                  action object-strings string predicate))))))
      (if multiple?
          (or (mapcar (lambda (it) (gethash it object-table)) selected) def)
        (gethash selected object-table (or def selected)))))


  (defun im-dmenu (prompt items &rest ignored)
    "Like `completing-read' but instead use dmenu.
  Useful for system-wide scripts."
    (with-temp-buffer
      (thread-first
        (cond
         ((functionp items)
          (funcall items "" nil t))
         ((listp (car items))
          (mapcar #'car items))
         (t
          items))
        (string-join "\n")
        string-trim
        insert)
      (shell-command-on-region
       (point-min)
       (point-max)
       (pcase system-type
         ('gnu/linux (format "rofi -dmenu -fuzzy -i -p '%s'" prompt))
         ('darwin "choose"))
       nil t "*im-dmenu error*" nil)
      (string-trim (buffer-string))))

  (cl-defmacro im-output-select
      (&key cmd prompt keep-order (formatter 'it) (split "\n") (drop 0) (filter t) (map 'it) (do 'it) category)
    "Run given CMD and do a `completing-read' on it.
  This macro is intended to quicken up the process of running a
  shell command and doing a completing-read on it and then using
  the result in another context, possibly on another shell
  command."
    `((lambda (it) ,do)
      (im-completing-read
       ,prompt
       (seq-map-indexed
        (lambda (it idx) ,map)
        (seq-filter
         (lambda (it) ,filter)
         (seq-drop
          (s-split
           ,split
           (shell-command-to-string ,cmd)
           t)
          ,drop)))
       :formatter (lambda (it) ,formatter)
       :sort? ,(not keep-order)
       :category ,category)))

  (defun im-read-string (prompt &rest rest)
    "Like `read-string' but returns `nil' on empty input."
    (let ((result (string-trim (apply #'read-string prompt rest))))
      (if (string-equal result "")
          nil
        result)))
#+end_src

*** String utils
#+begin_src emacs-lisp
  ;; Source: https://gist.github.com/jordonbiondo/c4e22b4289be130bc59b
  (defmacro im-s-interpolated (str)
    "Elisp string interpolation.
  Uses #{elisp-code} syntax."
    (let ((exprs nil))
      (with-temp-buffer
        (insert str)
        (goto-char 1)
        (while (re-search-forward "#{" nil t 1)
          (let ((here (point))
                (emptyp (eql (char-after) ?})))
            (unless  emptyp (push (read (buffer-substring (point) (progn (forward-sexp 1) (point)))) exprs))
            (delete-region (- here 2) (progn (search-forward "}") (point)))
            (unless emptyp (insert "%s"))
            (ignore-errors (forward-char 1))))
        (append (list 'format (buffer-string)) (reverse exprs)))))

  (defun im-s-upcase-until (until s)
    "Make prefix of a string S uppercase until given char UNTIL.
  `(im-s-upcase-until \"-\" \"aha-hehe\")' -> \"AHA-hehe\""
    (let ((end (s-index-of until s)))
      (concat
       (s-upcase (substring s 0 end))
       (substring s end))))

  (defun im-string-url-case (str)
    "Convert STR to something like `a-string-appropriate-for-urls'."
    (->> (downcase str)
         (s-replace-all
          '(("," . "")
            ("'" . "")
            ("ö" . "o")
            ("ı" . "i")
            ("ğ" . "g")
            ("ü" . "u")
            ("ş" . "s")
            ("ö" . "o")
            ("ç" . "c")))
         (s-trim)
         (replace-regexp-in-string "[^a-zA-Z0-9]" "-" str)
         (replace-regexp-in-string "-+" "-")))

  (defun im-human-readable-size (size-in-bytes)
    (let* ((units '("B" "KB" "MB" "GB" "TB" "PB" "EB" "ZB" "YB"))
           (unit (car units))
           (bytes (float size-in-bytes))
           (exponent (floor (log bytes 1024))))
      (setq units (cdr units))
      (while (> exponent 0)
        (setq bytes (/ bytes 1024.0))
        (setq exponent (1- exponent))
        (setq unit (car units))
        (setq units (cdr units)))
      (format "%.2f %s" bytes unit)))
#+end_src
*** List/hash-table/vector utils
#+begin_src emacs-lisp
  (defun im-ht-to-alist (val)
    "Bad way to convert hash-tables with vectors into alists. I use
  this only for debugging."
    (cond
     ((hash-table-p val) (im-ht-to-alist (ht-to-alist val)))
     ((vectorp val) (mapcar #'im-ht-to-alist (cl-coerce val 'list)))
     ((json-alist-p val) (map-apply (lambda (key it) (cons key (im-ht-to-alist it))) val))
     ((listp val) (mapcar (lambda (key it) (cons key (im-ht-to-alist it))) val))
     (t val)))
#+end_src
*** Quick table
#+begin_src emacs-lisp
  (cl-defun im-output-to-tabulated-list (str &key buffer (sep " "))
    (with-current-buffer buffer
      (let* ((lines (s-split "\n" str t))
             (header-items (s-split sep (car lines) t))
             (header (cl-coerce (--map (list it (/ 100 (length header-items)) nil) header-items) 'vector))
             (rows (thread-last lines
                     (-drop 1)
                     (--map-indexed (list (number-to-string it-index) (coerce (s-split sep it t) 'vector))))))
        (tabulated-list-mode)
        (setq tabulated-list-format header)
        (setq tabulated-list-entries rows)
        (setq tabulated-list-padding 4)
        (tabulated-list-init-header)
        (tabulated-list-print t))
      (switch-to-buffer buffer)))
#+end_src
*** API call
This function is for doing easy REST calls and it uses plists for everything because it's more readable and easier to type than alists (but you can still use alists if you want or need to). I use this to quickly prototype stuff in elisp.

#+begin_src emacs-lisp
  (cl-defun im-request
      (endpoint
       &rest params
       &key (-type "GET") (-headers) (-data) (-params) (-async?) (-success) (-raw)
       &allow-other-keys)
    "Like `request' but plist and JSON oriented. JSON responses are
  automatically parsed, query parameters are constructed from
  top-level keywords, request body can be a plist (which will be
  serialized into JSON). Examples:

      (im-request \"some/endpoint\")

  With url parameters:

      (im-request \"...\" :query \"test\" :page 3 :page_size 15)

  If you want to pass an alist as url params:

      (im-request \"...\" :-params '((query . \"test\") (page . 3) (page_size . 15)))

  POST with json body:

      (im-request \"...\" :-type 'POST :-data '(:key1 1 :key2 2))

  With some HTTP headers:

      (im-request \"...\" :-headers '(:Authorization \"Bearer e21ewqfasdwtkl\"))

  Async request:

      (im-request \"...\"
        :-async? t
        :-success (cl-function
                    (lambda (&key data &allow-other-keys)
                      ...use the parsed json DATA...)))
  "
    (interactive (list (read-string "URL: ") :-raw t))
    (declare (indent defun))
    (let (json
          (json-object-type 'alist)
          (json-array-type #'list)
          (json-key-type 'symbol))
      ;; Remove request related items from params list
      (dolist (key '(:-type :-headers :-data :-params :-async? :-success :-raw))
        (cl-remf params key))

      (request
        endpoint
        :type -type
        ;; TODO Maybe roll my own plist-to-alist function
        :headers (cond
                  ((and -headers (json-alist-p -headers)) -headers)
                  ((and -headers (json-plist-p -headers)) (transient-plist-to-alist -headers))
                  (t nil))
        :parser (if -raw #'buffer-string #'json-read)
        :success (if -async?
                     -success
                   (cl-function
                    (lambda (&key data &allow-other-keys)
                      (setq json data))))
        :error (cl-function
                (lambda (&key status data &allow-other-keys)
                  (user-error "STATUS: %s, DATA: %s," status data)))
        :sync (not -async?)
        :data (cond
               ((and -data (json-alist-p -data)) -data)
               ((and -data (json-plist-p -data)) (transient-plist-to-alist -data))
               ((stringp -data) -data)
               (t nil))
        :params (cond
                 ((and -params (json-alist-p -params)) -params)
                 ((and -params (json-plist-p params)) (transient-plist-to-alist -params))
                 (t (transient-plist-to-alist params))))
      (when (called-interactively-p 'interactive)
        (with-current-buffer (get-buffer-create "*im-request-response*")
          (erase-buffer)
          (insert json)
          (json-pretty-print-buffer)
          (json-ts-mode)
          (switch-to-buffer-other-window (current-buffer))
          (goto-char (point-min))))
      json))
#+end_src
*** URL/web utils
#+begin_src emacs-lisp
  (defun im-url-parse-title ()
    (dom-text (car (dom-by-tag (libxml-parse-html-region (point-min) (point-max)) 'title))))

  (defun im-url-get-title (url)
    "Get title of the URL."
    (with-current-buffer (url-retrieve-synchronously url :silent :inhibit-cookies)
      (im-url-parse-title)))

  (defun im-url-get-title-async (url cb)
    "Get title of the URL, async."
    (url-retrieve
     url
     (lambda (_status)
       (funcall cb (im-url-parse-title))
       (kill-buffer))
     nil :silent :inhibit-cookies))

  (defmacro with-default-browser (&rest body)
    `(let* ((browse-url-handlers nil)
            (browse-url-browser-function browse-url-secondary-browser-function))
       ,@body))

  (defun im-json-encode-and-show (obj)
    "Show given elisp OBJ as pretty printed JSON."
    (switch-to-buffer-other-window (get-buffer-create "*raw-pretty*"))
    (insert (json-encode obj))
    (json-pretty-print-buffer)
    (json-ts-mode))

  (defun im-url? (url)
    "Check if given URL is really an URL or not."
    (or (s-match "^\\(https?\\|file\\)://\\|www." url)
        (s-match "\\.\\(org\\|net\\|com\\)$" url)))
#+end_src
*** Other
#+begin_src emacs-lisp
  (defun im-kill-this-buffer ()
    "Kill current buffer.
  Function `kill-this-buffer' does not work reliably.  See
  documentation of it."
    (interactive)
    (kill-buffer (current-buffer)))

  (defun im-add-to-path (path)
    "Add given PATH to PATH variable.
  Useful for adding something to Emacs' PATH without restarting it."
    (interactive "sPath: ")
    (add-to-list 'exec-path (expand-file-name path))
    (setenv "PATH" (concat (getenv "PATH") ":" (expand-file-name path))))
#+end_src
*** File operations
#+begin_src emacs-lisp
  (defun im-latest-file (&optional path)
    "Get latest file in PATH."
    (car (directory-files (or path default-directory) 'full "^\\([^.]\\|\\.[^.]\\|\\.\\..\\)" #'file-newer-than-file-p)))

  (defun im-directory-files-recursively (dir regexp)
    "Faster alternative to `directory-files-recursively'."
    (->>
     (format
      "fd '%s' '%s' --type file --maxdepth 4 --absolute-path"
      regexp
      (expand-file-name dir))
     (shell-command-to-string)
     (s-trim)
     (s-split "\n")))
#+end_src
** Load path
Add =~/.emacs.d/load/= to =load-path=. I have extra configuration kept in this path.

#+begin_src emacs-lisp
  (defconst im-load-path (expand-file-name "~/.emacs.d/load/"))
  (add-to-list 'load-path im-load-path)
#+end_src

Also load ~isamert-secrets~ from =load-path=. I'll be utilizing some variables defined here throughout my configuration. It contains some api-keys, some tokens or some passwords etc. that I don't want to leak into public. Instead of doing mutations on an external hidden script, I define variables in this external hidden script and reference them in the configuration. This way the logic stays in the public configuration file so that everyone can take a look, but only the variable itself will be hidden from the public.

#+begin_src emacs-lisp
  (load "isamert-secrets")
#+end_src

* Basics
** Overriding some defaults
#+begin_src emacs-lisp
  ;; Feels better
  (setq switch-to-prev-buffer-skip t)
#+end_src
*** M-Backspace should delete, instead of killing
#+begin_src emacs-lisp
  ;; https://www.emacswiki.org/emacs/BackwardDeleteWord
  (defun delete-word (arg)
    "Delete characters forward until encountering the end of a word.
  With argument, do this that many times."
    (interactive "p")
    (if (use-region-p)
        (delete-region (region-beginning) (region-end))
      (delete-region (point) (progn (forward-word arg) (point)))))

  (defun backward-delete-word (arg)
    "Delete characters backward until encountering the end of a word.
  With argument, do this that many times."
    (interactive "p")
    (delete-word (- arg)))

  (global-set-key (read-kbd-macro "<M-DEL>") 'backward-delete-word)
#+end_src

** Recent files
Save recent files. Also exclude package files that appears after installing a package or after an update from recent list.

#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :straight (:type built-in)
    :defer 5
    :config
    (setq recentf-max-saved-items 500)
    (add-to-list 'recentf-exclude (format ".*\\.elc" (getenv "HOME")))
    (add-to-list 'recentf-exclude "/tmp/.*")
    (add-to-list 'recentf-exclude "/var/folders/.*")
    (recentf-mode t))

#+END_SRC

** Save minibuffer, kill-ring, search-ring history
#+begin_src emacs-lisp
  (use-package savehist
    :straight (:type built-in)
    :config
    ;; Clipboard selections are copied into the kill-ring
    (setq save-interprogram-paste-before-kill t)
    (setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
    (setq savehist-file "~/.emacs.d/savehist")
    (savehist-mode 1))
#+end_src

** Better scrolling
*** Better settings for mouse scroll
#+BEGIN_SRC emacs-lisp
  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
  (setq mouse-wheel-progressive-speed nil)            ;; don't accelerate scrolling
  (setq mouse-wheel-follow-mouse 't)                  ;; scroll window under mouse
#+END_SRC

*** Mouse shortcuts for zooming
- Ctrl-Scroll to zoom in and out

#+BEGIN_SRC emacs-lisp
  (global-set-key [C-mouse-4] 'text-scale-increase)
  (global-set-key [C-mouse-5] 'text-scale-decrease)
  (global-set-key (kbd "C-+") 'text-scale-increase)
  (global-set-key (kbd "C-=") 'text-scale-decrease)
#+END_SRC

*** Conservative scrolling
If the cursor is at the end of the file, when you scroll emacs does a strange jump. This fixes it.

#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 100) ;; When cursor reaches end, just scroll line-by-line
  ;; (setq scroll-margin 10) ;; Start scolling earlier
#+END_SRC

** Backups
Instead of having a file that ends with ~ or '# files in same directory, save all backup files in =~/.emacs.d/backups=.

#+BEGIN_SRC emacs-lisp
  (defconst im-backup-dir (im-mkdir-if-not "~/.emacs.d/backups/"))

  (setq backup-directory-alist `((".*" . ,im-backup-dir)))
  (setq auto-save-file-name-transforms `((".*" ,im-backup-dir t)))

  (setq backup-by-copying t)
  ;; ^ Don't delink hardlinks
  (setq version-control t)
  ;; ^ Use version numbers on backups
  (setq delete-old-versions t)
  ;; ^ Automatically delete excess backups
  (setq kept-new-versions 20)
  ;; ^ How many of the newest versions to keep
  (setq kept-old-versions 5)
  ;; ^ How many of the old versions to keep
#+END_SRC

** Remove trailing space before save
#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

** Make script files executable automatically
#+begin_src emacs-lisp
  (add-hook 'after-save-hook #'executable-make-buffer-file-executable-if-script-p)
  (with-eval-after-load 'ob-tangle
    (add-hook 'org-babel-post-tangle-hook #'executable-make-buffer-file-executable-if-script-p))
#+end_src

** Automatically run some commands after saving specific files
This is like =autocmd BufWritePost= of vim. When a particular file is edited, I want to make sure a command runs after the save.

#+BEGIN_SRC emacs-lisp
  (defvar im-run-after-save-alist
    '(("~/.\\(Xresources\\|Xdefaults\\)" . "xrdb %; notify-send 'xrdb updated'")
      ("~/.Xresources.d/.*"              . "xrdb ~/.Xresources; notify-send 'xrdb updated'")
      ("~/.config/sxhkd/sxhkdrc"         . "pkill -USR1 -x sxhkd; notify-send 'sxhkd updated'")
      ("~/.config/skhd/skhdrc"           . "skhd --reload; osascript -e 'display notification \"skhd updated\"'")
      ("~/.config/kmonad-linux.kbd"      . "systemctl --user restart kmonad")
      ;; ("~/.ssh/config" . im-unison-sync)
      ;; ("~/.emacs.d/bookmarks" . im-unison-sync)
      ;; ("~/.emacs.d/scratch.el" . im-unison-sync)
      ;; ("~/.emacs.d/im-.*" . im-unison-sync)
      ;; ("~/.emacs.d/load/isamert.*" . im-unison-sync)
      )
    "File association list with their respective command.")

  (add-hook 'after-save-hook #'im-post-save-run-command)
  (with-eval-after-load 'ob-tangle
    (add-hook 'org-babel-post-tangle-hook #'im-post-save-run-command))

  (defun im-post-save-run-command ()
    "Execute the specified command after saving specified file."
    (when-let* ((fname (buffer-file-name))
                (match (im-assoc-regexp fname im-run-after-save-alist #'expand-file-name)))
      (mapcar
       (-lambda ((_ . command))
         (cond
          ((stringp command)
           (shell-command (s-replace "%" fname command)))
          ((functionp command)
           (funcall command fname))
          (t
           (message ">> Wrong specification in `im-run-after-save-alist' for %s" fname))))
       match)))

  (defun im-unison-sync (&optional _)
    (interactive)
    (save-window-excursion
      (async-shell-command
       (format "DISPLAY= unison sync -ui text -batch -root ~ -root ssh://%s"
               (if (workpc?) "x220" "mac")))))
#+END_SRC

** repeat-mode
Enables you to have repeatable keybindings.

#+begin_src emacs-lisp
  (use-package repeat
    :straight (:type built-in)
    :hook (after-init . repeat-mode))

  (defmacro im-make-repeatable (name &rest rest)
    "Put given pairs in a keymap and mark them as repeatable."
    (declare (indent 1))
    (let ((pairs (-partition 2 rest))
          (map-name (intern (format "im-repeat-map-for-%s" name))))
      `(progn
         (defvar ,map-name
           (let ((map (make-sparse-keymap)))
             ,@(--map `(define-key map (kbd ,(car it)) ',(cadr it)) pairs)
             map))
         (--each ',(-map #'cadr pairs)
           (put it 'repeat-map ',map-name)))))
#+end_src

* Visuals
** General
#+begin_src emacs-lisp
  ;; Disable menubar
  (menu-bar-mode 0)
  ;; Wrap long lines
  (global-visual-line-mode t)
  ;; Highlight current line
  (global-hl-line-mode t)
  ;; Disable global-hl-line-mode in eshell, ansi-term, vterm

  (defun im-disable-hl-line-mode-for-buffer ()
    "Disable `global-hl-line-mode' for current buffer only.
  I explicitly disable this mode for some modes in my configuration
  using this function."
    (setq-local global-hl-line-mode nil))
#+end_src

** Fonts and theme
#+BEGIN_SRC emacs-lisp
  (use-package doom-themes)
  (use-package modus-themes)
  (use-package ef-themes)

  (defconst im-theme 'modus-vivendi)
  (defconst im-fonts '("Iosevka Comfy" "Iosevka Nerd Font"))
  (defconst im-font-height (pcase system-type ('gnu/linux 138) ('darwin 160)))

  (defun im-set-font-and-theme-config ()
    "Configure font and theme."
    (interactive)
    ;; Set the first avilable font from the `im-fonts' list
    (ignore-errors
      (let ((font (->>
                   im-fonts
                   (-filter #'im-font-exists-p)
                   car)))
        (set-face-attribute 'default nil
                            :font font
                            :weight 'normal
                            :width 'normal
                            :height im-font-height))
      ;; ...and load the theme
      (load-theme im-theme t)))

  (defun im-set-font-and-theme-config-in-frame (frame)
    (with-selected-frame frame
      (im-set-font-and-theme-config)))

  (if (daemonp)
      ;; Following sets font/font-size for each emacsclients frame
      (add-hook
       'after-make-frame-functions
       #'im-set-font-and-theme-config-in-frame)
    ;; Not in daemon mode, set theme etc directly
    (im-set-font-and-theme-config))
#+END_SRC

** prettify-symbols-mode
I make use of this mode quite frequently throughout the configuration.

#+begin_src emacs-lisp
  (setq prettify-symbols-unprettify-at-point t)

  (defmacro im-prettify-mode (mode pairs)
    "Prettify given PAIRS in given MODE.
  Just a simple wrapper around `prettify-symbols-mode`"
    (declare (indent 1))
    (let ((hook (intern (concat (symbol-name mode) "-prettify-symbols-hook"))))
      `(progn
         (defun ,hook ()
           (setq prettify-symbols-alist `(,@prettify-symbols-alist ,@',(eval pairs)))
           (prettify-symbols-mode 1))
         (add-hook ',mode #',hook))))
#+end_src

** fira-code-mode (font ligatures)
This adds Fira Code ligatures into Emacs, meaning that it prettifies well-known code symbols. This mode also saves the length of the chars, so it does not break spacing.
- After the first install, you need to call =fira-code-mode-install-fonts= and then maybe restart Emacs etc.

#+begin_src emacs-lisp :tangle no
  ;; FIXME: having problems with X forwarding
  (use-package fira-code-mode
    :hook
    ((prog-mode org-mode) . fira-code-mode)
    :config
    (setq fira-code-mode-disabled-ligatures '(":" "x" "[]")))
#+end_src

** Pages & page-break-lines & repeat-mode
You can jump between /pages/ by using ~C-x [~ and ~C-x ]~. See [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Pages.html][this]] for more information.

#+begin_src emacs-lisp
  (define-advice forward-page (:after (&rest _) recenter-buffer)
    "Recenter the page after doing a forward-page. This is always
  what I want."
    (when (cl-find this-command '(backward-page forward-page))
      (recenter nil)))
#+end_src

Displays ~^L~ (page breaks) as full-width straight lines:

#+begin_src emacs-lisp
  (use-package page-break-lines
    :hook ((emacs-lisp-mode . page-break-lines-mode)
           (lisp-mode . page-break-lines-mode)
           (lisp-data-mode . page-break-lines-mode)
           (scheme-mode . page-break-lines-mode)
           (compilation-mode . page-break-lines-mode)
           (outline-mode . page-break-lines-mode)
           (clojure-mode . page-break-lines-mode)
           (help-mode . page-break-lines-mode)))
#+end_src

After doing ~C-x [,]~ you can continue spamming ~[~ or ~]~ to jump prev/next pages with the help of ~repeat-mode~.

** Frame title
Make window title contain buffer name so it's easier to identify windows. I use ~rofi~ to switch between windows in my DE, so it helps to have buffer name in window title.

#+BEGIN_SRC emacs-lisp
  (setq frame-title-format "%b - emacs")
#+END_SRC

** Parentheses
*** Matching
Just enable parenthesis matching.

#+BEGIN_SRC emacs-lisp
  (use-package show-paren
    :straight (:type built-in)
    :hook (prog-mode . show-paren-local-mode)
    :config
    (setq show-paren-style 'parenthesis))
#+END_SRC

*** Rainbow
Colors parentheses depending on their dept.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

** Highlight trailing spaces
- Following highlights trailing spaces. Also see: [[Remove trailing space before save]]

#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :hook (after-init . global-whitespace-mode)
    :config
    (setq whitespace-style '(face empty tabs trailing))
    (setq whitespace-global-modes '(not org-mode markdown-mode vterm-mode magit-log-mode nov-mode eshell-mode dired-mode dirvish-mode w3m-mode)))

  (defun im-whitespace-mode-toggle ()
    "Toggle between more and less agressive whitespace modes.
  Toggles between showing every whitespace (tabs, spaces, newlines
  etc.) and only showing trailing spaces and tabs.  By default I use
  the latter but sometimes I want to see everything and the
  function helps me go between these modes easily."
    (interactive)
    (if (member 'spaces whitespace-style)
        (setq whitespace-style '(face empty tabs trailing))
      (setq whitespace-style '(face tabs spaces trailing lines space-before-tab newline indentation empty space-after-tab space-mark tab-mark newline-mark)))
    (whitespace-mode 0)
    (whitespace-mode 1))
#+END_SRC

** Spaces instead of tabs
#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 2)
  (setq-default indent-tabs-mode nil)
#+END_SRC

** Shackle windows
Make some temproary windows appear at bottom. This makes buffer management so much easier. Buffers that will match given regex will appear at bottom while covering the given amount of screen.

#+BEGIN_SRC emacs-lisp
  ;; SOURCE: https://www.reddit.com/r/emacs/comments/345vtl/make_helm_window_at_the_bottom_without_using_any/
  (defun im-shackle-window (name size)
    "Make the buffer NAME appear at bottom of the window, filling
    SIZE percent of the window."
    (add-to-list 'display-buffer-alist
                 `(,name
                   (display-buffer-in-side-window)
                   (inhibit-same-window . t)
                   (window-height . ,size))))

  (defun im-clear-side-windows ()
    "Clear all side windows.
  This is sometimes required to get around the error: `Cannot make
  side window the only window'"
    (interactive)
    (when (window-with-parameter 'window-side)
      (window-toggle-side-windows)))
#+END_SRC

** Miscellaneous packages
Some small packages that enriches editing experience visually. I don't enable all of them by default, I enable most of them whenever I need the functionality. I utilize an appearance [[Hydra]] to quickly toggle the functionality I need.

#+begin_src emacs-lisp
  ;; Show column guidelines
  (use-package fill-column-indicator
    :defer t)

  ;; By default Emacs scales fonts with text-scale-{increase,decrease}
  ;; per buffer. This scales fonts with
  ;; default-text-scale-{increase,decrease} globally.
  (use-package default-text-scale
    :demand t)

  ;; Highlights changed lines in git. You need to save the buffer to see
  ;; the changes.
  (use-package diff-hl
    :hook (prog-mode . diff-hl-mode))

  ;; It helps you to find your cursor when you change buffers/windows
  ;; etc with a little animation.
  (use-package beacon
    :hook (after-init . beacon-mode)
    :config
    (setq beacon-blink-duration 0.5)
    (setq beacon-push-mark 50)
    (setq beacon-color "#9F72D9")
    (add-to-list 'beacon-dont-blink-major-modes 'dirvish-mode)
    (add-to-list 'beacon-dont-blink-major-modes 'eshell-mode))

  ;; This shows some indent guides and it's highly configurable.
  (use-package highlight-indent-guides
    :defer t
    :config
    (set-face-background 'highlight-indent-guides-odd-face "darkgray")
    (set-face-background 'highlight-indent-guides-even-face "dimgray")
    (set-face-foreground 'highlight-indent-guides-character-face "dimgray")
    (setq highlight-indent-guides-method 'bitmap)
    (setq highlight-indent-guides-bitmap-function 'highlight-indent-guides--bitmap-line))
#+end_src

* evil-mode
** Basic configuration
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :demand t
    :init
    ;; Following two is required by evil-collection. It's probably wiser
    ;; to set evil-want-keybinding to t if you will not use
    ;; evil-collection
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    ;; This generally confuses me.
    (setq evil-jumps-cross-buffers nil)
    ;; Disable evil bindings in insert mode. This needs to be called
    ;; before loading evil mode...
    (setq evil-disable-insert-state-bindings t)
    (setq evil-undo-system 'undo-redo)
    :config
    ;; ...but I want some default evil bindings in insert mode, so just
    ;; remap them
    (evil-define-key 'insert 'global
      (kbd "C-d") #'evil-shift-left-line
      (kbd "C-t") #'evil-shift-right-line
      (kbd "C-n") #'evil-complete-next
      (kbd "C-p") #'evil-complete-previous
      (kbd "C-o") #'evil-execute-in-normal-state)

    ;; C-i interferes with TAB key, so disable it
    (setq evil-want-C-i-jump nil)
    ;; C-i is bound to TAB, so I use C-l for `evil-jump-forward'
    (evil-define-key 'normal 'global (kbd "C-l") #'evil-jump-forward)

    ;; When I paste something in visual mode, I don't want it to take
    ;; over the kill ring I also use evil-exchange, which eliminates the
    ;; need for this totally
    (setq evil-kill-on-visual-paste nil)
    ;; Over the time I found myself utilizing emacs C-u more and more,
    ;; so disable this
    (setq evil-want-C-u-scroll nil)

    ;; Make horizontal movement cross lines
    (setq-default evil-cross-lines t)

    ;; Open ex-mode with `<`> text instead of '<'> by default while
    ;; visual mode is active. This way commands will work on selected
    ;; char range instead of selected line range.
    (setq evil-ex-visual-char-range t)

    ;; This is needed for being able to use *-eval-last-sexp kind of
    ;; functions in normal mode. Elisp-related ones works out of the box
    ;; but other ones (like for Racket, Clojure etc.) are not patched by
    ;; default.
    (setq evil-move-beyond-eol t)

    ;; Makes # and * search for symbols instead of words.
    (setq evil-symbol-word-search t)

    ;; Move between visual lines instead of real lines
    (evil-define-key 'normal 'global
      (kbd "<remap> <evil-next-line>") #'evil-next-visual-line
      (kbd "<remap> <evil-previous-line>") #'evil-previous-visual-line)
    (evil-define-key 'motion 'global
      (kbd "<remap> <evil-next-line>") #'evil-next-visual-line
      (kbd "<remap> <evil-previous-line>") #'evil-previous-visual-line)

    ;; Use default yank-pop because it integrates itself with consult
    ;; The binding may seem a bit weird but it's how it's done.
    (define-key evil-normal-state-map [remap yank-pop] 'yank-pop)

    ;; Change cursor colors based on current mode.
    (setq evil-normal-state-cursor '("green" box)
          evil-visual-state-cursor '("orange" box)
          evil-emacs-state-cursor '("purple" box)
          evil-insert-state-cursor '("pink" bar)
          evil-replace-state-cursor '("red" bar)
          evil-operator-state-cursor '("red" hollow))

    (evil-mode 1))
#+END_SRC

** general.el
#+begin_src emacs-lisp
  (use-package general
    ;; Not required to be installed after evil but loading it before
    ;; causes some problems like keys not getting bound sometimes etc.
    :demand t
    :config
    (general-override-mode))

  (general-create-definer im-leader
    :prefix "<SPC>"
    ;; This is important because if you don't set it some modes will
    ;; fail to pick up leader bindings.  See:
    ;; https://github.com/noctuid/general.el/issues/190
    :keymaps 'override
    :states 'normal)

  (general-create-definer im-leader-v
    :prefix "<SPC>"
    :keymaps 'override
    :states '(normal visual))
#+end_src
** evil-collection
#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init 'ibuffer)
    (evil-collection-init 'compile)
    (evil-collection-init 'eshell)
    (evil-collection-init 'geiser)
    (evil-collection-init 'dired)
    (evil-collection-init 'grep)
    (evil-collection-init 'replace)
    (evil-collection-init 'elfeed)
    (evil-collection-init 'consult)
    (evil-collection-init 'vterm)
    (evil-collection-init 'term)
    (evil-collection-init 'xref)
    (evil-collection-init 'magit)
    (evil-collection-init 'magit-todos)
    (evil-collection-init 'git-timemachine)
    (evil-collection-init 'calendar)
    (evil-collection-init 'w3m)
    (evil-collection-init 'eww)
    (evil-collection-init 'vc-git)
    (evil-collection-init 'vc-dir)
    (evil-collection-init 'log-view)
    (evil-collection-init 'log-edit)
    (evil-collection-init 'vc-annotate)
    (evil-collection-init 'help)
    (evil-collection-init 'Custom)
    (evil-collection-init 'imenu-list)
    (evil-collection-init 'custom)
    (evil-collection-init 'xwidget)
    <<evil-unimpaired>>)
#+end_src
** evil-unimpaired
Apparently [[evil-collection]] has a vim-unimpaired implementation already. It contains bindings like:
  - ~[<SPC>~ ~]<SPC>~ Insert newline above/below.
  - ~[b~ ~]b~ Go to prev/next buffer.
  - ~[p~, ~]p~ Paste up/down.
  - ~[e~, ~]e~ Move line up/down.
  - ~[d~, ~]d~ Delete line above/below.
  - ~[q~ ~]q~ Go to prev/next error.
  - ~[Q~ ~]Q~ Go to first/last error.
  - ~[n~ ~]n~ Go to prev/next conflict marker.
  - ~[t~ ~]t~ Go to prev/next TODO. (This is defined in [[Dummy IDE mode]])

These also support repeat-mode. You can do ~]b~ and spam ~b~ to switch buffers.

Following are my extensions:

#+name: evil-unimpaired
#+begin_src emacs-lisp :tangle no
  (evil-collection-define-key 'normal 'evil-collection-unimpaired-mode-map
    "[d" #'im-delete-line-above
    "]d" #'im-delete-line-below)

  (defun im-delete-line-above ()
    "Delete the line above."
    (interactive)
    (save-excursion
      (previous-line 1)
      (beginning-of-line)
      (kill-line)
      (when (s-blank? (s-trim (thing-at-point 'line t)))
        (kill-line))))

  (defun im-delete-line-below ()
    "Delete the line below."
    (interactive)
    (save-excursion
      (next-line 1)
      (beginning-of-line)
      (kill-line)
      (when (s-blank? (s-trim (thing-at-point 'line t)))
        (kill-line))))

  (setq evil-collection-unimpaired-want-repeat-mode-integration t)
  (evil-collection-unimpaired-setup)
#+end_src
** evil-mc (multiple cursors)
Multiple cursors for evil.

- Basics
  - =C-n= / =C-p= are used for creating cursors
  - =M-n= / =M-p= are used for moving between cursors
  - =A= and =I= creates cursors in visual selection mode as you may expect.
  - =gkk= to clear all cursors.

- To be able to create cursors at arbitrary positions:
  - =gkp= to pause all cursors. (Your main cursors moves freely while mc cursors stays still)
  - =gkr= to resume paused cursors.
  - =gkh= create a cursor at the point of main cursor. (Use after =gkp=).

#+begin_src emacs-lisp
  (use-package evil-mc
    :after evil
    :general
    (:states '(normal visual) :keymaps 'evil-mc-key-map
     "gr" nil
     ;; Add my bindings using "gc"
     "gcc" #'evil-mc-undo-all-cursors
     "gcp" #'evil-mc-pause-cursors
     "gcr" #'evil-mc-resume-cursors
     "gch" #'evil-mc-make-cursor-here)
    (:states 'visual
     "A" #'evil-mc-make-cursor-in-visual-selection-end
     "I" #'evil-mc-make-cursor-in-visual-selection-beg)
    :hook
    (after-init . global-evil-mc-mode))
#+end_src

** evil-surround
- Change surroundings. Do =cs"'= to turn ="Hello world!"= into ='Hello world!'=.
  - ='Hello world!'= ~cs'<q>~ =<q>Hello world!</q>=
  - =Hel|lo= ~ysiw"~ ="Hello"= (| is the cursor position.)
  - =Hello= ~ysw{~ ={ Hello }=  (~{[(~ adds spaces)
  - =Hello= ~ysw}~ ={Hello}=    (~}])~ does not add spaces)

- Wrap selection with ~<visual-state> S~.
- Wrap selection on new lines with ~<visual-state> gS~

#+BEGIN_SRC emacs-lisp
  (use-package evil-surround
    :after evil
    :init
    (global-evil-surround-mode 1)

    ;; Invert some default pairs
    (require 'map)
    (map-put! evil-surround-pairs-alist ?\( '("(" . ")"))
    (map-put! evil-surround-pairs-alist ?\) '("( " . " )"))
    (map-put! evil-surround-pairs-alist ?\[ '("[" . "]"))
    (map-put! evil-surround-pairs-alist ?\] '("[ " . " ]"))
    (map-put! evil-surround-pairs-alist ?\{ '("{" . "}"))
    (map-put! evil-surround-pairs-alist ?\} '("{ " . " }"))

    ;; Convert `` to `' in emacs-lisp mode
    (add-hook 'emacs-lisp-mode-hook (lambda () (push '(?` . ("`" . "'")) evil-surround-pairs-alist))))
#+END_SRC

** evil-escape
Return back to normal mode using ~jk~ from anywhere. It does not play well with multiple cursors, so use ~ESC~ to when using evil-mc related stuff.

#+BEGIN_SRC emacs-lisp
  (use-package evil-escape
    :after evil
    :config
    (setq evil-escape-key-sequence "jk") ;; Just Kidding bro, I didn't mean that *escapes*
    (setq evil-escape-delay 0.2)
    (setq evil-escape-excluded-major-modes '(magit-status-mode magit-log-mode magit-diff-mode))
    (evil-escape-mode 1))
#+END_SRC

** evil-matchit
Jump between matching tags using ~%~, like =<div>...</div>=, ={...}= etc. =ci%=, =da%= etc. works as expected.

#+BEGIN_SRC emacs-lisp
  (use-package evil-matchit
    :after evil
    :config
    (global-evil-matchit-mode 1))
#+END_SRC

** evil-goggles
~evil-goggles~ gives nice visual feedbacks while editing with evil-mode. When you do =dd=, =yw=, =ciw= or something similar, it will give a visual feedback for the selection. Feels kinda natural to have this.

#+BEGIN_SRC emacs-lisp
  (use-package evil-goggles
    :after evil
    :config
    (setq evil-goggles-duration 0.20
          evil-goggles-pulse nil
          evil-goggles-enable-change t
          evil-goggles-enable-delete t
          evil-goggles-enable-indent t
          evil-goggles-enable-yank t
          evil-goggles-enable-join t
          evil-goggles-enable-fill-and-move t
          evil-goggles-enable-paste t
          evil-goggles-enable-shift t
          evil-goggles-enable-surround t
          evil-goggles-enable-commentary t
          evil-goggles-enable-nerd-commenter t
          evil-goggles-enable-replace-with-register t
          evil-goggles-enable-set-marker t
          evil-goggles-enable-undo t
          evil-goggles-enable-redo t)
    (evil-goggles-mode)
    (evil-goggles-use-diff-faces))

#+END_SRC

** evil-snipe
- Overall better =f/F/t/T= and . Nice visual feedbacks.

#+BEGIN_SRC emacs-lisp
  (use-package evil-snipe
    :after evil
    :hook (magit-mode . turn-off-evil-snipe-override-mode)
    :demand t
    :config
    ;; (evil-snipe-mode 1) ;; This enables s/S bindings. I use those keys with avy
    (evil-snipe-override-mode 1) ;; This overrides default f/F, t/T bindings
    (setq evil-snipe-scope 'visible)
    ;; See https://github.com/hlissner/evil-snipe/issues/72
    (setq evil-snipe-skip-leading-whitespace nil))
#+END_SRC

** evil-exchange
Change two parts of the text.
- Mark some text in visual mode and do =gx=.
- Mark some other text in visual mode and do =gx= again to exchange two parts.
- You can use ~gx<motion>~ instead of visual mode too.

#+begin_src emacs-lisp
  (use-package evil-exchange
    :config
    (evil-exchange-install))
#+end_src

** evil-visualstar
With this package, you can do a visual selection and ~*~, ~#~ keys will work on them.

#+begin_src emacs-lisp
  (use-package evil-visualstar
    :after evil
    :config
    (setq evil-visualstar/persistent t)
    (global-evil-visualstar-mode 1))
#+end_src

** evil-numbers
Pretty useful for macros. Increment or decrement number at point with ~+,-~ in normal mode.

#+begin_src emacs-lisp
  (use-package evil-numbers
    :general
    (:states 'normal
     "+" #'evil-numbers/inc-at-pt
     "-" #'evil-numbers/dec-at-pt))
#+end_src

** goto-chg
- =g;= goes to the last change. (repeatable)
- There is also =gv= which selects the last selection. Not related to this package, it's a default functionality but I wanted to mention.

#+BEGIN_SRC emacs-lisp
  (use-package goto-chg
    :after evil)
#+END_SRC
** Custom text-objects
*** org blocks
#+begin_src emacs-lisp
  ;; There is `org-babel-mark-block' but it only works for source blocks
  ;; but this one works for everything between #begin_<> ... #end_<>.
  ;; There is also "e" object defined by evil-org, which works for quite
  ;; most things but it does not work, for example, org-ai blocks etc.

  (evil-define-text-object im-evil-inner-org-block (count &optional beg end type)
    "Select inner side of org source blocks."
    :extend-selection nil
    (im-find-hash-positions))

  (evil-define-text-object im-evil-outer-org-block (count &optional beg end type)
    "Select outer side of org source blocks."
    :extend-selection nil
    (im-find-hash-positions t))

  (define-key evil-inner-text-objects-map "#" 'im-evil-inner-org-block)
  (define-key evil-outer-text-objects-map "#" 'im-evil-outer-org-block)

  (defun im-find-hash-positions (&optional include-hash-lines)
    "Find the positions of the first line starting with '#' upwards and downwards."
    (let ((up-pos nil)
          (down-pos nil))
      ;; Search upwards for the first line starting with "#"
      (save-excursion
        (beginning-of-line)
        (while (and (not up-pos) (not (bobp)))
          (forward-line -1)
          (beginning-of-line)
          (when (looking-at "^#")
            (unless include-hash-lines
              (forward-line 1))
            (setq up-pos (point)))))
      ;; Search downwards for the first line starting with "#"
      (save-excursion
        (beginning-of-line)
        (while (and (not down-pos) (not (eobp)))
          (forward-line 1)
          (beginning-of-line)
          (when (looking-at "^#")
            (when include-hash-lines
              (forward-line 1))
            (setq down-pos (point)))))
      (list up-pos down-pos)))
#+end_src
* org-mode
** Tips etc.
- Some lesser known functions:
  - org-copy-visible :: Useful for only sending the outline. Also works with selection.
  - orgtbl-create-or-convert-from-region :: Useful for data that is separated by \t or spaces.
    - After converting to table, I can use ~org-table-sort-lines~. Alternative is using ~sort-fields~ without converting the data into table but it's not that nice to use.
    - I generally use it in combination with ~embark-collect~. Any completing-read → embark-collect → orgtbl-create-or-convert-from-region.
** org-plus-contrib
#+begin_src emacs-lisp
  <<org-personal-files>>

  (use-package org
    :mode ("\\.org\\'" . org-mode)
    :config
    (setq org-return-follows-link t)
    ;; ^ Open links with RET
    (setq org-src-fontify-natively t)
    ;; ^ Enable code highlighting in ~SRC~ blocks.
    (setq org-hierarchical-todo-statistics t)
    ;; ^ Show all children in todo statistics [1/5]
    (setq org-imenu-depth 7)
    ;; ^ include up to 7-depth headers in imenu search
    (setq org-image-actual-width nil)
    ;; ^ Disable showing inline images in full width. Now you can add `#+ATTR_*: :width 300` to resize inline images
    ;; (setq org-ellipsis "⤵")
    (setq org-ellipsis "…")
    ;; ^ Replace ... with … in collapsed sections
    (setq org-hide-emphasis-markers t)
    ;; Hide *...* /.../ etc.
    (setq org-pretty-entities t)
    (setq org-log-into-drawer t)
    ;; ^ Log into LOGBOOK drawer instead of directly loging under the heading
    (setq org-extend-today-until 3)
    ;; ^ Consider the current day to end at 3AM
    (setq org-use-effective-time t)
    ;; ^ Make timestamp processing functions aware of the previous config
    (setq org-element-use-cache nil)
    ;; ^ Cache causes bunch of random errors although disabling cache
    ;; reduces the agenda performance significantly
    (setq org-tags-column 0)
    ;; Tags starts right after the heading.
    (setq org-reverse-note-order t)
    ;; ^ I keep new notes at the beginning. This helps with that.
    (setq org-confirm-babel-evaluate nil)
    ;; ^ Don't ask permissions for evaluating code blocks
    (setq org-clock-clocked-in-display 'mode-line)
    ;; ^ Shows in the tab-bar, if tab-bar is enabled.

    ;; TODO Remove when upstream fixes this
    ;; https://github.com/minad/consult/issues/563#issuecomment-1186612641
    (defun org-show-entry-consult-a (fn &rest args)
      (when-let ((pos (apply fn args)))
        (org-fold-show-entry)))
    (advice-add 'consult-line :around #'org-show-entry-consult-a)
    (advice-add 'consult-org-heading :around #'org-show-entry-consult-a)

    (add-to-list 'org-link-abbrev-alist '("imdb" . "https://www.imdb.com/title/%s"))
    (add-to-list 'org-link-abbrev-alist '("yt" . "https://youtu.be/%s"))
    ;; ^ More info: https://orgmode.org/manual/Link-Abbreviations.html

    ;; http://www.foldl.me/2012/disabling-electric-indent-mode/
    (defun im-disable-electric-indent ()
      (set (make-local-variable 'electric-indent-functions)
           (list (lambda (arg) 'no-indent))))

    (add-hook 'org-mode-hook #'im-disable-electric-indent)

    ;; Automatically invoke `org-indent-mode' which gives nice little
    ;; indentation under subsections. It makes reading easier. This does
    ;; not add any spaces/tabs to the text file, the indentation is only
    ;; visually apparent in Emacs.
    ;; (add-hook 'org-mode-hook #'org-indent-mode t)

    <<org-lob-ingest>>
    <<org-faces>>
    <<org-refile>>
    <<org-capture>>
    <<org-icalendar>>)

  (use-package org-contrib :after org)
#+end_src

** Keybindings
#+begin_src emacs-lisp
  (use-package evil-org
    :after (org org-agenda)
    :general
    (:keymaps 'org-mode-map :states '(normal insert)
     "<RET>" #'org-return
     "S-<return>" #'im-org-link-to-indirect-buffer)
    (im-leader
      "oyy" #'im-org-store-link-dwim
      "oa"  #'org-agenda
      "ow"  #'widen
      ;; org-capture
      "og" #'org-capture
      "oG" #'org-capture-goto-last-stored
      ;; org-clock
      "occ" #'org-clock-in
      "ocC" #'org-clock-cancel
      "ocl" #'org-clock-in-last
      "oco" #'org-clock-out
      "ocg" #'org-clock-goto)
    (im-leader :keymaps 'org-mode-map
      ;; general
      "op"  #'org-set-property
      "oi"  #'org-toggle-inline-images
      "oI"  #'org-redisplay-inline-images
      "or"  #'org-refile
      "oR"  #'org-mode-restart
      "oh"  #'outline-show-only-headings
      "os"  #'org-schedule
      "od"  #'org-deadline
      "ov"  #'org-babel-expand-src-block
      "oq"  #'im-org-tree-to-indirect-buffer
      "oQ"  #'im-org-link-to-indirect-buffer
      "o1"  #'im-show-outline-only
      ;; link stuff
      "oyi" #'org-copy-id
      ;; src blocks etc
      "d" #'org-babel-remove-result
      "D" #'im-org-babel-remove-all-results
      "oo" #'im-org-babel-result-to-buffer
      "oe" #'org-edit-special
      "ot" #'im-org-babel-tangle-current-block
      "o-" #'org-babel-demarcate-block)
    (im-leader-v :keymaps 'org-mode-map
      "o#" #'org-insert-structure-template)
    (im-leader-v :keymaps 'org-src-mode-map
      "oe" #'org-edit-src-exit
      "oE" #'org-edit-src-abort)
    :hook
    (org-mode . evil-org-mode)
    :config
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys)
    (evil-org-set-key-theme '(textobjects insert navigation additional shift todo heading))
    (add-hook 'org-src-mode-hook #'evil-normalize-keymaps))

  (defun im-org-tree-to-indirect-buffer ()
    "Same as `org-tree-to-indirect-buffer' but let's you open
  multiple indirect buffers."
    (interactive)
    (let ((current-prefix-arg '(4)))
      (call-interactively #'org-tree-to-indirect-buffer)))

  (defmacro im-org-focused-tree-to-indirect-buffer (&rest forms)
    "Same as `org-tree-to-indirect-buffer' but let's you open
  multiple indirect buffers."
    `(let ((current-prefix-arg '(4))
           (source-buffer (current-buffer))
           target-buffer)
       (save-excursion
         (save-restriction
           (widen)
           ,@forms
           (call-interactively #'org-tree-to-indirect-buffer)
           (setq target-buffer (current-buffer))))
       ;; If the link points to another buffer, current window will start
       ;; showing that buffer. We don't want that, so we are restoring
       ;; the current buffer here:
       (set-window-buffer nil source-buffer)
       ;; Newly opened indirect buffer is not focused automatically, we
       ;; fix that here:
       (im-select-window-with-buffer (format "%s::.*" (buffer-name target-buffer)))
       (im-show-outline-only)))

  (defun im-org-link-to-indirect-buffer ()
    "Open link at point on a new indirect buffer."
    (interactive)
    ;; Force org to open the link in current window
    (with-default-browser
     (let ((org-link-frame-setup (cons (cons 'file 'find-file) org-link-frame-setup)))
       (pcase (org-element-property :type (org-element-context))
         ((or "http" "https") (org-open-at-point))
         (_ (im-org-focused-tree-to-indirect-buffer
             (org-open-at-point)))))))

  (defun im-show-outline-only ()
    "Show all headers but hide all bodies."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (outline-next-heading)
      (outline-show-branches)
      (outline-hide-body)))
#+end_src

** Personal files
#+name: org-personal-files
#+begin_src emacs-lisp  :tangle no
  (defconst watchlist-org "~/Documents/notes/watchlist.org")
  (defconst readinglist-org "~/Documents/notes/readinglist.org")
  (defconst courses-org "~/Documents/notes/courses.org")
  (defconst bullet-org "~/Documents/notes/bullet.org")
  (defconst directory-notes-org "~/Documents/notes/directory-notes.org")
  (defconst life-org "~/Documents/notes/life.org")
  (defconst reality-org "~/Documents/notes/reality.org")
  (defconst projects-org "~/Documents/notes/projects.org")
  (defconst people-org "~/Documents/notes/people.org")
  (defconst diary-org "~/Documents/notes/diary.org")
  (defconst snippets-org "~/Documents/notes/snippets.org")
  (defconst bookmarks-org "~/Documents/notes/bookmarks.org")
  (defconst work-org "~/Documents/notes/trendyol.org")
  (defconst temp-org "~/Documents/notes/temp.org")
  (defconst passwords-org "~/Documents/notes/passwords.org")
  (defconst engineering-org "~/Documents/notes/engineering.org")
  (defconst netherlands-org "~/Documents/notes/netherlands.org")

  ;; Put archive files under an archive/ directory
  ;; I don't want them to pollute my directory
  (setq org-archive-location "archive/%s_archive::")
  (setq org-directory "~/Documents/notes")
  (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)
  ;; ^ org-store-link creates an ID for header only if called interactively and if there is no custom id
  (setq org-agenda-files `(,bullet-org ,projects-org ,work-org ,people-org ,readinglist-org ,watchlist-org ,life-org ,netherlands-org))
#+end_src

#+name: org-lob-ingest
#+begin_src emacs-lisp :tangle no
  ;; With the following, I can call functions defined inside this file in other org files
  (org-babel-lob-ingest (concat org-directory "/utils.org"))
#+end_src

** Babel
*** General configuration
#+name: org-babel-configuration
#+begin_src emacs-lisp :tangle no
  ;; Allow these languages to run in code blocks
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (shell . t)
     (scheme . t)
     (python . t)
     (verb . t)
     (http . t)
     (R . t)
     (haskell . t)
     (js . t)
     (sql . t)
     (dot . t)
     (gnuplot . t)
     (plantuml . t)))

  ;; TODO: im-load-ob-lang-lazy
  ;; (defmacro im-load-ob-lang-lazy (&rest langs)
  ;;   "Like `org-babel-do-load-languages' but load them lazily using `use-package'."
  ;;   `(progn
  ;;      ,@(mapcar (lambda (lang)
  ;;                  `(use-package ,(intern (concat "ob-" (symbol-name lang)))
  ;;                     :defer t
  ;;                     :straight (:type built-in)
  ;;                     ;; TODO add view
  ;;                     :commands (,(intern (concat "org-babel-execute:" (symbol-name lang))))))
  ;;                langs)))
  ;; (im-load-ob-lang-lazy
  ;;  emacs-lisp shell scheme python verb http R haskell js sql dot gnuplot plantuml)
#+end_src
*** Helper functions
#+begin_src emacs-lisp
  ;; Some codeblocks produce image files as it's result (like dot
  ;; language). Re-executing these blocks removes the image
  ;; overlay. With this hook images are automatically updated after
  ;; code-block execution and not removed from screen.
  (add-hook 'org-babel-after-execute-hook #'im-org-redisplay-images-if-enabled)

  (defalias 'im-org-babel-split-or-wrap-src-code-block #'org-babel-demarcate-block)

  (defun im-org-babel-tangle-current-block ()
    "Tangle the current source block and all other related
  blocks (the ones that tangles into the same file).

  This function also works inside `org-edit-special' buffers."
    (interactive)
    (let ((src-edit? (org-src-edit-buffer-p))
          (current-prefix-arg '(16)))
      ;;     ^ '(4) only tangles current file, '(16) tangles all code
      ;;     blocks related to current tangle file target
      (when src-edit? (org-edit-src-exit))
      (call-interactively 'org-babel-tangle)
      (when src-edit? (org-edit-special))))

  ;; https://emacs.stackexchange.com/questions/23870/org-babel-result-to-a-separate-buffer/27190#27190
  (defun im-org-babel-result-to-buffer ()
    "A function to efficiently feed babel code block result to a separate buffer."
    (interactive)
    (org-open-at-point)
    (org-babel-remove-result))

  (defun im-org-redisplay-images-if-enabled ()
    (when org-inline-image-overlays
      (org-redisplay-inline-images)))
#+end_src

*** ob-http & verb-mode
#+begin_src emacs-lisp
  ;; Http request in org-mode babel.
  ;; You can get the generated curl command after executing the code
  ;; block, from *curl command history* buffer
  (use-package ob-http
    :straight (:host github :repo "zweifisch/ob-http")
    :after org)

  ;; An alternative to ob-http, might be better
  (use-package verb
    :straight (:host github :repo "federicotdn/verb")
    :after org
    :hook (org-mode . verb-mode))

  (defun im-curl-to-org-http (curl-str)
    "Convert CURL-STR into an ob-http block.
  More concretely this function converts given curl command (that
  is copied from Chrome/Firefox dev tools, using the `Copy as curl'
  option) into an ob-http block to be able to use all the goodies
  that is provided by ob-http."
    (interactive
     (list
      (if (use-region-p)
          (buffer-substring-no-properties (region-beginning) (region-end))
        (read-string "Curl string: "))))
    (let ((tokens (im-cmdargs-tokenize curl-str))
          (headers '())
          (request "GET")
          url
          (query-params '())
          data)
      (--each-indexed tokens
        (pcase it
          ((or "-H" "--header")
           (push (nth (1+ it-index) tokens) headers))
          ((or "-d" "--data-binary" "--data-raw")
           (setq data (nth (1+ it-index) tokens)))
          ((or "-X" "--request" "--data-raw")
           (setq request (nth (1+ it-index) tokens)))
          ;; Only supports --data-urlencode in the GET context. It will
          ;; append --data-urlencode arguments to url as query string.
          ("--data-urlencode"
           (push (nth (1+ it-index) tokens) query-params))
          ((pred (lambda (x) (s-prefix? "http" x)))
           (setq url it))))
      (when-let ((query-params)
                 (qs (url-build-query-string (--map (s-split-up-to "=" it 2) query-params))))
        (if (s-contains? "?" url)
            (setq url (concat url "&" qs))
          (setq url (concat url "?" qs))))
      (insert
       (s-trim (im-s-interpolated "#{request} #{url}\n#{(s-join \"\\n\" headers)}\n\n#{(or data \"\")}")))))

  (defun im-cmdargs-tokenize (input)
    (with-temp-buffer
      (insert input)
      (goto-char (point-min))
      (let ((tokens '()))
        (while-let ((chr (get-byte))
                    ((not (eobp))))
          (pcase chr
            ((or ?\s ?\t ?\n) (forward-char))
            (?\"
             (forward-char)
             (push
              (replace-regexp-in-string
               (regexp-quote "\\\"") "\""
               (buffer-substring
                (point)
                (1- (re-search-forward "[^\\]\"" nil t))))
              tokens))
            (?\'
             (forward-char)
             (push (buffer-substring
                    (point)
                    (1- (re-search-forward "'" nil t)))
                   tokens))
            (_ (push (buffer-substring
                      (point)
                      ;; TODO Handle eol
                      (1- (re-search-forward "[ \t]" nil t)))
                     tokens))))
        (nreverse tokens))))
#+end_src

** Exporting
*** HTML
#+BEGIN_SRC emacs-lisp
  (use-package htmlize
    :after org)
#+END_SRC

*** iCalendar settings
#+name: org-icalendar
#+BEGIN_SRC emacs-lisp :tangle no
  (setq org-icalendar-store-UID t)
  (setq org-icalendar-alarm-time 15)
  (setq org-icalendar-use-scheduled '(todo-start event-if-todo))
  (setq org-icalendar-use-deadline '(todo-due event-if-todo))
#+END_SRC

** Agenda
Some general settings.

#+begin_src emacs-lisp
  (use-package org-agenda
    :straight nil
    :after org
    :general
    (:states 'normal :keymaps 'org-agenda-mode-map
     (kbd "<RET>") #'org-agenda-switch-to
     (kbd "\t") #'org-agenda-goto
     "s" #'org-agenda-schedule
     "w" #'org-agenda-week-view
     "d" #'org-agenda-day-view
     "t" #'org-agenda-todo
     "L" #'org-agenda-log-mode
     "q" #'org-agenda-quit
     "R" #'org-agenda-clockreport-mode
     "r" #'org-agenda-redo)
    :config
    (evil-set-initial-state 'org-agenda-mode 'normal)
    (setq org-agenda-remove-tags t)
    (setq org-agenda-include-diary t)
    (setq org-agenda-use-time-grid t)
    (setq org-agenda-time-grid
          '((daily today require-timed remove-match)
            (800 900 1000 1100 1200 1300 1400 1500 1600 1700 1800 1900 2000 2100 2200 2300 2400)
            " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄"))
    ;; Make it open faster
    ;; https://orgmode.org/manual/Speeding-Up-Your-Agendas.html
    ;; https://orgmode.org/worg/agenda-optimization.html
    (setq org-agenda-dim-blocked-tasks nil)
    (setq org-agenda-inhibit-startup t)
    (setq org-agenda-use-tag-inheritance nil)
    (setq org-agenda-ignore-drawer-properties '(effort appt category)))
#+end_src
** ToDo keywords & faces
#+name: org-faces
#+begin_src emacs-lisp :tangle no
  ;; Add this to org files if you need:
  ;; #+TODO: TODO PROG WAITING DONE
  ;; OR
  (setq org-todo-keywords
    '((sequence "TODO(t)" "PROG(p)" "WAIT(w)" "DONE(d)")))
  ;; Now you can do C-c C-t {t,p,w,d} to set the state directly

  (setq org-todo-keyword-faces
        '(("WAIT" . (:foreground "yellow" :weight bold))
          ("PROG" . (:foreground "magenta" :weight bold :underline t))))

  (custom-set-faces
   '(org-headline-done ((t (:strike-through t))))
   '(org-agenda-done ((t (:strike-through t))))
   '(org-column ((t (:background nil))))
   '(org-scheduled-today ((t (:foreground "light green"))))

   ;; Make some stuff small
   '(org-drawer ((t (:height 0.8))))
   '(org-special-keyword ((t (:height 0.8))))
   '(org-block-end-line ((t (:height 0.8)))))

#+end_src

** org-capture
:PROPERTIES:
:ID:       4e8609e8-8485-4868-a942-35b2571d46ae
:END:
See [[https://orgmode.org/manual/Template-elements.html#Template-elements][this page]] for more detail on template elements.

#+name: org-capture
#+begin_src emacs-lisp :tangle no
  (setq
   org-capture-templates
   '(("g" "General todo/note")
     ("gi" "Study later" item
      (file+olp bullet-org "Life backlog" "Investigate")
      "- [ ] %U %(im-org-make-link-string (read-string \"URL: \"))"
      :prepend t)
     ("gt" "Life todo" entry
      (file+headline bullet-org "Life backlog")
      "** %?")
     ("gc" "Computer todo" entry
      (file+headline bullet-org "Computer backlog")
      "**  %?" :prepend t)
     ("gw" "Work todo" entry
      (file+headline bullet-org "Work backlog")
      "** TODO [#B] %?" :prepend t)
     ("gb" "Free time backlog" item
      (file+headline bullet-org "Free time backlog")
      "- %U %?" :prepend t)

     ("d" "Daily todo/summary/note")
     ("dt" "Daily TODO" plain
      (file+function bullet-org im-org-capture--find-daily-last-entry)
      "** TODO [#B] %?")
     ("ds" "Daily summary" item
      (file+function bullet-org im-org-capture--find-daily-summary)
      "- %U %?")

     ("i" "Inbox" item
      (file+headline bullet-org "Inbox")
      "- %U %?"
      :prepend t)
     ("I" "Inbox (for capturing from Signal, send \"note ...\" as text to myself)" item
      (file+headline bullet-org "Inbox")
      "- %U %c"
      :prepend t
      :immediate-finish t)

     ("s" "Snippets")
     ("ss" "Snippet" entry
      (file+function snippets-org im-org-capture--find-snippet)
      "** ")
     ("so" "One liner snippet" item
      (file+function snippets-org im-org-capture--find-snippet-one-liner)
      "- %? :: ")

     ("D" "Diary" entry
      (file diary-org)
      "* %u\n"
      :prepend t)
     ("c" "Meeting/clock note" item
      (clock))))

  (defun im-org-capture--find-daily-last-entry ()
    (im-bullet-focus-today)
    (end-of-buffer))

  (defun im-org-capture--find-daily-summary ()
    (im-bullet-focus-today)
    (re-search-forward "^** Summary" nil t))

  (defun im-org-capture--find-snippet ()
    (let* ((mode-name (with-current-buffer (org-capture-get :original-buffer)
                        (symbol-name major-mode)))
           (result (org-find-exact-headline-in-buffer mode-name)))
      (if result
          (goto-char result)
        (goto-char (point-min))
        (re-search-forward (concat "^\\(" org-outline-regexp "\\)") nil t)
        (forward-line -1)
        (insert (format "\n* %s" mode-name)))))

  (defun im-org-capture--find-snippet-one-liner ()
    (im-org-capture--find-snippet)
    (unless (re-search-forward "\\*\\* One-liners" nil t)
      (end-of-line)
      (insert "\n** One-liners")))
#+end_src
** org-refile
#+name: org-refile
#+begin_src emacs-lisp :tangle no
  (setq org-refile-targets '((nil . (:maxlevel . 2))))
#+end_src
** org-modern
#+begin_src emacs-lisp
  (use-package org-modern
    :after org
    :custom
    (org-use-sub-superscripts nil)
    (org-modern-table nil)
    (org-modern-hide-stars " ")
    (org-modern-list
     '(;; (?- . "-")
       (?* . "•")
       (?+ . "‣")))
    (org-modern-todo-faces
     '(("TODO" :inverse-video t :weight semibold :inherit (org-todo org-modern-label))
       ("PROG" :inverse-video t :weight semibold :inherit (org-todo org-modern-label) :foreground "magenta1")
       ("WAIT" :inverse-video t :weight semibold :inherit (org-todo org-modern-label) :foreground "yellow1")
       ("DONE" :inverse-video t :weight semibold :inherit (org-todo org-modern-label) :foreground "dark gray")))
    (org-modern-priority-faces
     '((?A :inverse-video t :weight semibold :inherit (org-priority org-modern-label) :foreground "green1")
       (?B :inverse-video t :weight semibold :inherit (org-priority org-modern-label) :foreground "green2")
       (?C :inverse-video t :weight semibold :inherit (org-priority org-modern-label) :foreground "green3")
       (?D :inverse-video t :weight semibold :inherit (org-priority org-modern-label) :foreground "green4")))
    :hook
    (org-mode . org-modern-mode)
    (org-agenda-finalize . org-modern-agenda))
#+end_src
** org-rainbow-tags
#+begin_src emacs-lisp
  (use-package org-rainbow-tags
    :custom
    (org-rainbow-tags-hash-start-index 6)
    (org-rainbow-tags-extra-face-attributes
     '(:inverse-video t :box nil :weight 'bold))
    :hook
    (org-mode . org-rainbow-tags-mode))
#+end_src
** org-ql
#+BEGIN_SRC emacs-lisp
  (use-package org-ql
    :after org
    ;; Load org-ql-search prematurely to be able to use org-ql blocks in
    ;; org-mode
    :hook (org-mode . (lambda () (require 'org-ql-search))))
#+END_SRC

Here are some utility functions that I use in org-ql dynamic blocks:

#+begin_src emacs-lisp
  (defun sort-by-num-prop (prop x y)
    (< (string-to-number (or (org-element-property prop y) "0"))
       (string-to-number (or (org-element-property prop x) "0"))))

  (defun sort-by-prop (prop x y)
    (string< (or (org-element-property prop y) "")
             (or (org-element-property prop x) "")))
#+end_src

You have to use ~:sort (lambda ...)~ syntax in org-ql dynamic blocks if you want to supply a function for the ~:sort~ parameter. You can't use a function that returns a lambda, hence the functions defined above should be used like this:

#+begin_example
  ,#+begin: org-ql :query ... :sort (lambda (x y) (sort-by-num-prop :RATING x y))
  ,#+end
#+end_example

Here are some predefined searches:

#+begin_src emacs-lisp
  (defun im-org-ql-current-week-tasks ()
    (interactive)
    (let ((week-end (im-date "next monday - 1 day")))
      (org-ql-search org-agenda-files
        `(and (or (scheduled :to ,week-end)
                  (deadline :to ,week-end))
              (not (done)))
        :title (format "W%s" (format-time-string "%U"))
        :super-groups '((:auto-category))
        :sort '(date))))
#+end_src

** Linking improvements
Org does not provide an easy way to copy link at point. Here is a fix for that:

#+begin_src emacs-lisp
  ;; Source: https://emacs.stackexchange.com/a/60555
  (defun im-org-link-copy ()
    "Extract URL from org-mode link and add it to kill ring."
    (interactive)
    (let* ((link (org-element-lineage (org-element-context) '(link) t))
           (type (org-element-property :type link))
           (url (org-element-property :path link))
           (url (when (and type url (not (s-blank? url))) (concat type ":" url))))
      (when (called-interactively-p 'any)
        (message (concat "Copied URL: " (im-kill url))))
      url))

  (defun im-org-store-link-dwim ()
    "Like `org-store-link' but if point is on an org-link, just copy
    it to clipboard. Otherwise call `org-store-link'."
    (interactive)
    (if (org-in-regexp org-link-any-re 1)
        (call-interactively #'im-org-link-copy)
      (org-store-link nil t)))
#+end_src

This following trick (got it from [[https://www.reddit.com/r/emacs/comments/o68i0v/weekly_tips_tricks_c_thread/h2rizey?utm_source=share&utm_medium=web2x&context=3][this]] comment) simply calls =C-h .= (=display-local-help=) when idle, which shows the destination of links in the echo area (and maybe displays other helpful stuff).

#+begin_src emacs-lisp
  (defun im-help-at-point-mode ()
    "Show tooltips in the echo area automatically for current buffer."
    (interactive)
    (setq-local help-at-pt-display-when-idle t)
    (setq-local help-at-pt-timer-delay 0)
    (help-at-pt-cancel-timer)
    (help-at-pt-set-timer))

  (with-eval-after-load 'org
    (add-hook 'org-mode-hook #'im-help-at-point-mode))
#+end_src

Insert links/images more intelligently,
- if region is selected and there is a url in the clipboard, convert it to a link directly.
- if nothing is selected and there is a link in clipboard, just insert it as a link with the link's own title.
- if clipboard has in image in it, save that into a file that you interactively select and then insert it into the buffer.
- otherwise call ~org-insert-link~

#+begin_src emacs-lisp
  (im-leader-v "oP" #'im-org-insert-dwim)

  (defun im-org-insert-dwim ()
    "Like `org-insert-link' but improved with dwim features.
      Based on: https://xenodium.com/emacs-dwim-do-what-i-mean/"
    (interactive)
    (let* ((point-in-link (org-in-regexp org-link-any-re 1))
           (clipboard-url (when (string-match-p "^http" (current-kill 0))
                            (current-kill 0)))
           (region-content (when (region-active-p)
                             (buffer-substring-no-properties (region-beginning)
                                                             (region-end)))))
      (cond
       ((im-clipboard-contains-image-p)
        (call-interactively 'im-org-attach-image-from-clipboard))
       ((and region-content clipboard-url (not point-in-link))
        (delete-region (region-beginning) (region-end))
        (insert (org-make-link-string clipboard-url region-content)))
       ((and clipboard-url (not point-in-link))
        (insert (im-org-make-link-string clipboard-url)))
       (t
        (call-interactively 'org-insert-link)))))

  (defun im-org-attach-image-from-clipboard (&optional file-path)
    "Attach the image in the clipboard into your org-buffer.
      This function saves the image file into the FILE-PATH or
      if it's not provided then it saves the image into ~/.cache."
    (interactive "FSave file to (leave empty to create a temp file): ")
    (let ((file (if (and file-path (not (string-empty-p file-path)))
                    (file-relative-name file-path)
                  (make-temp-file "~/.cache/org_temp_image_" nil ".png"))))
      (if (im-save-clipboard-image-to-file file)
          (insert (format "#+ATTR_ORG: :width 400\n[[file:%s]]" file))
        (user-error "Saving file failed!"))))

  (defun im-org-make-link-string (url)
    "Like `org-make-link-string' but fetches URL and extracts the
  title automatically. Also adds author and duration info to
  YouTube links."
    (cond
     ((im-youtube-link-extract-id url) (im-org-format-youtube-link url))
     (t (org-link-make-string url (im-url-get-title url)))))

  ;; YouTube related

  (defun im-youtube-link-extract-id (link)
    (nth 4 (s-match "https?://\\(www\\.\\)?\\(youtu\\.be\\|youtube.com\\)/\\(watch\\?v=\\)?\\([a-zA-Z0-9_-]+\\)\\(\\?\\|&\\)?/?" link)))

  (defun im-org-format-youtube-link (link)
    "Format given YouTube link as org-mode link.
  Length, author, title etc. are appended to the link."
    (let ((id (im-youtube-link-extract-id link)))
      (let-alist (im-request (format "%s/videos/%s" empv-invidious-instance id))
        (org-link-make-string
         link
         (format "%0.2f mins, by %s || %s" (/ .lengthSeconds 60.0) .author .title)))))
#+end_src

** Insert image with width
This function is especially useful when used in combination with =embark-act-all=. The workflow is as follows:
- =M-x= =im-org-insert-image-file-with-width=
- Filter the files that you want to insert to your buffer.
- Hit enter if there is only one item.
- If there are multiple items that you want to insert, do =M-a= (embark-act) and then =S= (=embark-collect-snapshot=).
- Then you can do =embark-act-all= or just hit enter on the items that you want to insert to your buffer.

#+begin_src emacs-lisp
  (defun im-org-insert-image-file-with-width ()
    "Insert interactively selected image file with fixed width information."
    (interactive)
    (let ((fname (file-relative-name (read-file-name "Select file: "))))
      (insert (format "#+ATTR_ORG: :width 400\n[[file:%s]]\n\n" fname))))
#+end_src

** Renaming files under cursor
#+begin_src emacs-lisp
  (defun im-org-rename-file-at-point ()
    "Interactively rename the file under cursor and update the link."
    (interactive)
    (let* ((link (org-element-context))
           (type (org-element-property :type link))
           (path (org-element-property :path link))
           (begin (org-element-property :begin link))
           (end (org-element-property :end link))
           (cbegin (org-element-property :contents-begin link))
           (cend (org-element-property :contents-end link))
           content)
      (unless (equal type "file")
        (user-error "Link is not a file"))
      (when (and cbegin cend)
        (setq content (format "[%s]" (buffer-substring-no-properties cbegin cend))))
      (let ((use-relative? (not (file-name-absolute-p path)))
            (fname (read-file-name "New name: "
                                   (expand-file-name
                                    (file-name-directory path))
                                   path)))
        (when use-relative?
          (setq fname (concat "./" (file-relative-name fname))))
        (save-excursion
          (rename-file path fname)
          (delete-region begin end)
          (insert (format "[[file:%s]%s]"
                          fname
                          (or content "")))))))
#+end_src

** Project management
I'm doing all of my project management in org-mode. Here you can find some supplementary functionality that makes project management within org-mode easy.

*** Do a regexp search in a project inside a org dynamic block
Here I create a dynamic block for org-mode, named ~project-grep~. You can create a block like the following:

#+begin_example
  ,#+begin: project-grep :root "~/Workspace/projects/dotfiles" :regexp "TODO"
  ,#+end
#+end_example

When you invoke =C-c C-c= on that block, it will automatically run given REGEXP in given ROOT and create a nicely formatted table containing all the results. Results are formatted into org-links you can easily jump into.

#+begin_src emacs-lisp
  (defun org-dblock-write:project-grep (params)
    "Do a regular expression search in given project.
  PARAMS may contain `:root' or `:regexp'.

  `:root' - Where to run the search. If it's skipped, it's
  `default-directory'.

  `:regexp' - Regexp to grep in given folder. If it's skipped it
  searches for TODO/FIXME items in given folder."
    (let* ((root (or (plist-get params :root) default-directory))
           (regexp (or (plist-get params :regexp) "(//|#|--|;)+ ?(TODO|FIXME)"))
           (default-directory root))
      (--map (insert (format "%s | " it)) '("" "ID" "File" "Content"))
      (insert "\n")
      (insert "|-|\n")
      (--each-indexed
          (s-split
           "\n"
           (shell-command-to-string (format "rg --line-number '%s'" regexp))
           'omit-nulls)
        (let* ((data (s-split-up-to ":" it 2))
               (file (s-join ":" (-take 2 data)))
               (file-link (concat "[[file:" default-directory "/" (s-replace ":" "::" file) "][" file "]]"))
               (content (s-replace "|" " \\vert " (-last-item data))))
          (insert "| ")
          (insert (format "%s" it-index))
          (insert " | ")
          (insert file-link)
          (insert " | ")
          (insert content)
          (insert " |\n"))))
    (delete-char 1)
    (org-table-align))
#+end_src

** Archiving URLS
#+begin_src emacs-lisp
  (defvar im-org-archive-url-path "~/Documents/notes/data/archvive/")

  (defun im-org-archive-url ()
    "Archive URL and generate an new org entry for it."
    (interactive)
    (let (url update?)
      ;; If we are on a heading and calling this function, we probably
      ;; just want to update/initialize the archive for current
      ;; heading. Otherwise we are creating a new archive.
      (if-let ((_ (org-at-heading-p))
               (old-url (org-entry-get nil "URL")))
          (progn
            (setq url old-url)
            (setq update? t))
        (progn
          (setq url (read-string "URL: "))
          (org-insert-heading)))

      ;; Precautionary call
      (org-id-get-create)

      (let* ((url-title (read-string "Title: " (im-url-get-title url)))
             (archive-path (format
                            "%s/%s_%s_%s.html"
                            im-org-archive-url-path
                            (org-id-get-create)
                            (format-time-string "%Y%m%dT%H%M%S")
                            (im-string-url-case url-title))))
        (org-set-property
         "ARCHIVED_AT"
         (format "%s[[file:./%s][%s]]"
                 (if-let ((older-archives (org-entry-get nil "ARCHIVED_AT")))
                     (format "%s, " older-archives)
                   "")
                 (f-relative archive-path)
                 (format-time-string "%Y-%m-%dT%H:%M")))
        (unless update?
          (insert (org-make-link-string url url-title)))

        (org-set-property "URL" url)
        (unless (org-entry-get nil "CREATED")
          (org-set-property "CREATED" (format-time-string "[%Y-%m-%d %a %H:%M]")))

        ;; Create the archive
        (f-mkdir im-org-archive-url-path)
        (im-archive-url
         url
         :where archive-path
         :tidy t))))

  (with-eval-after-load 'org-capture
    (add-to-list
     'org-capture-templates
     `("b" "Bookmark" entry
       (file+headline ,bookmarks-org "Unsorted")
       "** (call-interactively #'im-org-archive-url)\n-Don't forget tot TAG!")))
#+end_src
** Convert items to TODO entries
#+begin_src emacs-lisp
  (defun im-org-convert-item-to-todo-and-refile (&optional yank-only)
    "Convert org item to todo header and refile.
  I take notes in the following format during the day via
  org-capture template:

      - [2023-04-09 Sun 23:57] Some note

  At the end of the day, I convert these notes into tasks if
  applicable. This means rewriting them into a TODO header with
  CREATED_AT property and refiling into the appropriate
  header. This function automatizes that.

  If YANK-ONLY is non-nil (with prefix arg while calling
  interactively), only yank the result, do not refile.

  >> (with-temp-buffer
      (insert \"- [2023-06-28 Wed 10:13] Test\\n\")
      (beginning-of-buffer)
      (im-org-convert-item-to-todo-and-refile t))
  => \"** TODO [#B] Test
  :PROPERTIES:
  :CREATED_AT: [2023-06-28 Wed 10:13]
  :END:
  \"

  >> (with-temp-buffer
      (insert \"- [2023-06-28 Wed 10:13] Test :: The body.\\n\")
      (beginning-of-buffer)
      (im-org-convert-item-to-todo-and-refile t))
  => \"** TODO [#B] Test
  :PROPERTIES:
  :CREATED_AT: [2023-06-28 Wed 10:13]
  :END:
  The body.
  \"

  Version: 2023-06-28
  - Initial version."
    (interactive "P")
    (save-excursion
      (beginning-of-line)
      (let ((line (substring-no-properties (thing-at-point 'line)))
            (timestamp nil)
            (text nil))
        (when-let (match (s-match "^- \\(\\[[ X-]] \\)?\\(\\[.*]\\) \\(.*\\)" line))
          (setq timestamp (nth 2 match))
          (setq text (nth 3 match))
          (let* ((buffer (current-buffer))
                 (data (s-split " :: " text))
                 (header (nth 0 data))
                 (body (nth 1 data))
                 result)
            (with-temp-buffer
              (insert
               (concat "** TODO [#B] " header "\n"
                       ":PROPERTIES:" "\n"
                       ":CREATED_AT: " timestamp "\n"
                       ":END:" "\n"
                       (if body (concat body "\n") "")))
              (setq result (buffer-string))
              ;; To be able to refile
              (org-mode)
              (if yank-only
                  (im-kill result)
                (let ((org-refile-targets nil))
                  (org-refile nil buffer))
                ;; Remove the line after everything to prevent loss of data
                (with-current-buffer buffer
                  (delete-region (line-beginning-position) (1+ (line-end-position))))
                result)))))))
#+end_src
* Other packages
** display-time-mode
I started using Emacs in full screen (Emacs maximalism goes on), so this is helpful.
#+begin_src emacs-lisp
  (use-package display-time
    :straight (:type built-in)
    :hook (after-init . display-time-mode)
    :init
    (setq display-time-format "%b %d, %H:%M %a")
    (setq display-time-default-load-average nil))
#+end_src
** outline-mode
This is a built-in mode for providing basic outlining features. Here are a few configurations to make the navigation a bit more like what I use in org-mode:

#+begin_src emacs-lisp
  (use-package outline-mode
    :straight (:type built-in)
    :general
    (:states 'normal :keymaps 'outline-mode-map
     "[[" #'outline-previous-heading
     "]]" #'outline-next-heading)
    :bind
    (:repeat-map outline-mode-repeat-map
     ("[" . outline-previous-heading)
     ("]" . outline-next-heading)))
#+end_src

** debugger-mode
#+begin_src emacs-lisp
  (evil-set-initial-state 'debugger-mode 'normal)
#+end_src
** eat & eshell
#+begin_src emacs-lisp
  (use-package eshell
    :straight (:type built-in)
    :defer t
    :hook (eshell-mode . im-disable-hl-line-mode-for-buffer)
    :general
    (:states 'normal
     "M-_" #'im-eshell-vertically
     "M-|" #'im-eshell-horizontally)
    (:states 'insert :keymaps '(eshell-prompt-mode-map override)
     "C-l" (λ-interactive (eshell/clear t)))
    :config
    ;; This is nil on purpose. Because `im-eshell-append-history' does
    ;; duplication check before writing it to history and if this is
    ;; non-nil then it fails to do the duplication check because
    ;; duplicated items will not be inserted to history-ring at all.
    (setq eshell-hist-ignoredups nil)
    (setq eshell-history-size 10000)
    ;; I manage history with `im-eshell-append-history''
    (setq eshell-save-history-on-exit nil))

  (use-package eshell-syntax-highlighting
    :after eshell
    :config
    (eshell-syntax-highlighting-global-mode +1))

  (use-package eat
    :straight (:repo "https://codeberg.org/akib/emacs-eat.git")
    :after eshell
    :config
    (eat-eshell-mode))

  (defun im-eshell (name)
    (interactive (list (read-string "Bufffer name: " "$eshell: ")))
    (with-current-buffer (eshell t)
      (rename-buffer name t)
      (current-buffer)))

  (defun im-eshell-send-input (input)
    (eat--send-input t input))

  (defun im-eshell-send-key (key)
    (eat-self-input 1 key))

  (defun im-eshell-vertically ()
    (interactive)
    (select-window (split-window-vertically))
    (call-interactively #'im-eshell))

  (defun im-eshell-horizontally ()
    (interactive)
    (select-window (split-window-horizontally))
    (call-interactively #'im-eshell))
#+end_src

*** Proper command completion
This package provides command, subcommand and argument completion using fish shell. You need to have fish shell installed. There is also helm version that provides argument documentation but I haven't tried it yet and I need to make it work with corfu instead of helm.

#+begin_src emacs-lisp
  (use-package fish-completion
    :after eshell
    :hook (eshell-mode . fish-completion-mode))
#+end_src
*** Reading bash/zsh aliases into Eshell
#+begin_src emacs-lisp
  (defun im-eshell-load-my-aliases ()
    "Load zsh/bash aliases into eshell.
  '$*' is appended after each alias so that they can take
  positional parameters in eshell. There is also a special syntax
  for defining eshell-specific aliases that is read verbatim:

  #eshell test='ls'
  "
    (interactive)
    (setq
     eshell-command-aliases-list
     (-filter
      #'identity
      (--map
       (-when-let ((_ eshell? name imp)
                   (s-match "^\\(alias\\|#eshell\\) \\([a-zA-Z0-9_-]+\\)='\\(.*\\)'\\( *#.*\\)*$" it))
         (list name (if (s-prefix? "#eshell" eshell?)
                        imp
                      (concat imp " $*"))))
       (--mapcat
        (s-split "\n" (with-temp-buffer (insert-file-contents it) (buffer-string)))
        (directory-files "~/.config/aliases/" t directory-files-no-dot-files-regexp))))))

  (add-hook 'eshell-alias-load-hook #'im-eshell-load-my-aliases)
#+end_src

*** Eshell-specific aliases
Look at [[id:0B508237-3BBE-416A-A6AD-31C5C78340DB][Aliases]] section in my config to see all bash/zsh aliases. These are eshell specific:

#+begin_src bash :tangle ~/.config/aliases/eshell
  #eshell clear='clear 1'
#+end_src

Also here are some aliases/functions for eshell defined in elisp:

#+begin_src emacs-lisp
  (defun eshell/mkcd (&rest args)
    (eshell/mkdir args)
    (eshell/cd args))
#+end_src

*** Automatically print notes for given directory
I have the file ~im-autodir-file~ which contains notes for directories, like in the following format:

#+begin_src org :tangle no
  ,* ~/a/directory
  Here are my notes for the directory...

  ,* ~/another/directory: This one contains some source code
  Use the following to compile this:
  ...
#+end_src

When I enter any of the listed directories, eshell automatically prints out my notes.

#+begin_src elisp
  (defvar im-autodir-file directory-notes-org)
  (defvar im-autodir-last-doc nil)

  (defun im-eshell-handle-dir-change ()
    (let ((dir (file-name-as-directory (expand-file-name default-directory))))
      (setq im-autodir-last-doc
            (with-current-buffer (find-file-noselect im-autodir-file)
              (save-restriction
                (widen)
                (catch 'found
                  (org-map-entries
                   (lambda ()
                     (when (->>
                            (org-entry-get nil "ITEM")
                            (s-split ":")
                            (car)
                            (expand-file-name)
                            (file-name-as-directory)
                            (equal dir))
                       (throw 'found (buffer-substring-no-properties
                                      (org-element-property :contents-begin (org-element-at-point))
                                      (org-element-property :contents-end (org-element-at-point))))))
                   "LEVEL=1")
                  nil))))
      (when im-autodir-last-doc
        (insert "im-autodir-show-doc")
        (eshell-send-input))))

  (defun im-autodir-show-doc ()
    (->>
     im-autodir-last-doc
     s-lines
     (-take 20)
     (s-join "\n")))

  (add-hook 'eshell-directory-change-hook #'im-eshell-handle-dir-change)
  ;; eshell-directory-change-hook is not get triggered when eshell is opened, hence:
  (add-hook 'eshell-mode-hook #'im-eshell-handle-dir-change)

  (defun im-org-jump-to-project-documentation ()
    "Jump to *my* documentation for current project."
    (interactive)
    (let* ((projdir (abbreviate-file-name (im-current-project-root)))
           (buf (find-file-noselect directory-notes-org))
           (pos (with-current-buffer buf
                  (widen)
                  (org-find-exact-headline-in-buffer projdir))))
      (unless pos
        (if (y-or-n-p "Note not found for this project. Want to create?")
            (with-current-buffer buf
              (widen)
              (goto-char (point-max))
              (org-insert-heading nil nil t)
              (org-edit-headline projdir)
              (org-set-property "CREATED_AT" (concat "[" (im-today) "]"))
              (setq pos (point)))
          (user-error "Doc not found directory: %s" projdir)))
      (switch-to-buffer buf)
      (goto-char pos)
      (org-fold-show-entry)
      (org-narrow-to-subtree)))
#+end_src
*** Consistent history
Normally, if you have more than one eshell instance open and quit them consecutively, the last closed one will overwrite the ~eshell-history-file~. The following /appends/ issued command to history after each command.
#+begin_src emacs-lisp
  (defvar im-eshell-history-blacklist "^\\(ls\\|pwd\\|cd\\|clear\\|exit\\|rm\\|mkdir\\|mkcd\\|im-autodir\\)")

  ;; Adapted from: https://emacs.stackexchange.com/questions/18564/merge-history-from-multiple-eshells
  ;; Changes:
  ;; - Duplication check
  ;; - Blacklisted commands
  ;; - Process only successful commands
  ;;    - Not quite sure if this is a good idea though. Just experimenting.
  (defun eshell-append-history ()
    "Call `eshell-write-history' with the `append' parameter set to `t'."
    (when (and eshell-history-ring (eq eshell-last-command-status 0))
      (let ((last-elem (s-trim (car (ring-elements eshell-history-ring))))
            (prev-elem (s-trim (nth 1 (ring-elements eshell-history-ring)))))
        (when (and (not (string= last-elem prev-elem))
                   (not (s-matches? im-eshell-history-blacklist last-elem)))
          (let ((newest-cmd-ring (make-ring 1)))
            (ring-insert newest-cmd-ring last-elem)
            (let ((eshell-history-ring newest-cmd-ring))
              (eshell-write-history eshell-history-file-name t)))))))

  (add-hook 'eshell-post-command-hook #'eshell-append-history)
#+end_src

(add-hook 'eshell-pre-command-hook #'eshell-append-history)
** bookmark.el
You can use ~list-bookmarks~ command to view/edit/delete them but using ~consult-bookmark~ and calling ~embark-act~ on them to view/delete/edit given bookmark might be easier.

#+begin_src emacs-lisp
  (setq bookmark-save-flag 1)
  ;; ^ Save bookmarks automatically

  (im-leader
    "bs" #'bookmark-set
    "bm" #'consult-bookmark)
#+end_src
** process-menu-mode
#+begin_src emacs-lisp
  (evil-define-key 'normal process-menu-mode
    "x" #'process-menu-delete-process)
#+end_src
** timer-list-mode
#+begin_src emacs-lisp
  (evil-define-key 'normal timer-list-mode-map
    "x" #'timer-list-cancel)
#+end_src
** tabulated-list-mode
- It's a built-in mode that shows some kind of tabulated data.
- It is used by many major modes, like [[docker]], [[prodigy]], etc. I just add these common keybindings to have a consistent way of navigating in them.
- I also try to bind following keys in their respective mode maps:
  - =a= key to a function that lists all the actions that can be taken on current column.
  - =Enter= to the default action (generally opening something etc.)

#+begin_src emacs-lisp
  (use-package tabulated-list
    :straight (:type built-in)
    :defer t
    :config
    (evil-define-key 'normal tabulated-list-mode-map
      (kbd "{") #'tabulated-list-narrow-current-column
      (kbd "}") #'tabulated-list-widen-current-column
      (kbd "H") #'tabulated-list-previous-column
      (kbd "L") #'tabulated-list-next-column
      (kbd "s") #'tabulated-list-sort
      (kbd "r") #'tabulated-list-revert))
#+end_src

** alert & im-notify-posframe
Several packages are using this package to show system-level notifications. Here I set some defaults/fallback values.

#+begin_src emacs-lisp
  (use-package alert
    :defer t
    :config
    (alert-define-style
     'im-alert-posframe
     :title "Posframe alerts"
     :notifier
     (lambda (info)
       (im-notify-posframe
        :title (plist-get info :title)
        :message (plist-get info :message)
        :margin t
        :duration (unless (plist-get info :persistent) alert-fade-time)
        :severity (plist-get info :severity))))
    (setq alert-fade-time 15)
    (setq alert-default-style 'im-alert-posframe)

    (im-leader
      "yy" #'im-notify-posframe-notifications
      "yu" #'im-notify-posframe-enable-dnd
      "yU" #'im-notify-posframe-disable-dnd
      "yb" #'im-notify-posframe-blacklist
      "ys" #'im-notify-posframe-snooze-last
      "yc" #'im-notify-posframe-clear-all
      "yC" (λ-interactive  (im-notify-posframe-clear-all t)))

    ;; org-clock sends notification if the current tasks estimated effort is met.
    (setq
     org-show-notification-handler
     (lambda (notification)
       (im-notify-posframe :title "*org-mode*" :message notification :margin t))))

  (defvar im-notify-posframe-blacklist-regexp nil)
  (defvar im-notify-posframe-dnd nil)
  (defvar im-notify-posframe--active '())
  (defvar-local im-notify-posframe--notification-data nil)
  (cl-defun im-notify-posframe (&rest data &key id title message duration margin (severity 'normal) &allow-other-keys)
    (setq title (propertize title 'face '(:weight bold)))
    (let ((bname (format "*im-notify-%s*"
                         (or id (format "%s-%s" (if title (im-string-url-case title) "") (random))))))
      (when (and (not im-notify-posframe-dnd)
                 (not (and im-notify-posframe-blacklist-regexp
                           (s-matches?
                            (if (stringp im-notify-posframe-blacklist-regexp)
                                im-notify-posframe-blacklist-regexp
                              (eval im-notify-posframe-blacklist-regexp))
                            (concat (or title "") "\n" message)))))
        (posframe-show
         (with-current-buffer (get-buffer-create bname)
           (setq im-notify-posframe--notification-data
                 (thread-first
                   data
                   (map-insert :time (float-time))
                   (map-insert :id (substring-no-properties bname))))
           (current-buffer))
         :string
         (if margin
             (format "\n  %s  \n  %s  \n\n" title (s-trim (s-join "  \n" (--map (concat "  " it) (s-lines message)))))
           (format "%s\n%s" title message))
         :poshandler
         (lambda (info)
           (let ((posy (* (line-pixel-height)
                          (--reduce-from (+ acc
                                            (with-current-buffer it
                                              (count-lines (point-min) (point-max))))
                                         0
                                         (remove bname im-notify-posframe--active)))))
             (cons (/ (- (plist-get info :parent-frame-width)
                         (plist-get info :posframe-width))
                      2)
                   (if (> posy 0)
                       (+ posy (+ 3 3 15))
                     15))))
         :border-width 3
         :max-height 10
         :min-width 30
         :max-width 80
         :border-color (pcase severity
                         ((or 'high 'urgent) "red3")
                         ('normal "yellow3")
                         (_ nil)))
        (push bname im-notify-posframe--active)

        ;; Clear the notification after a certain time, if requested
        (when duration
          (run-with-timer
           duration nil
           (lambda ()
             (posframe-hide bname)
             (push bname im-notify-posframe--active)
             (setq im-notify-posframe--active (delete bname im-notify-posframe--active)))))

        ;; Also use native notifications if Emacs is not focused
        (unless (frame-focus-state)
          (let ((alert-default-style
                 (pcase system-type
                   ('gnu/linux 'libnotify)
                   ;; TODO osx-notifier having troubles showing messages
                   ;; with Turkish characters.
                   ('darwin 'osx-notifier)
                   (_ 'message))))
            (alert message :title title :severity severity)))

        ;; Based on the severity, send it to my phone but only if Emacs is
        ;; idle for a certain time
        (pcase severity
          ((or 'urgent 'high)
           (when (and (current-idle-time)
                      (>= (time-to-seconds (current-idle-time)) 60))
             (im-send-notification-to-my-phone
              :title (or title "Emacs")
              :content message)))))))

  (defun im-notify-posframe-clear-all (&optional delete?)
    (interactive "P")
    (--each
        (--filter (s-prefix? "*im-notify" (buffer-name it)) (buffer-list))
      (if delete?
          (posframe-delete it)
        (posframe-hide it)))
    (setq im-notify-posframe--active '()))

  (defun im-dummy-notification ()
    (interactive)
    (im-notify-posframe :title (format "%s" (random)) :message (with-temp-buffer (spook) (buffer-string)) :margin t))

  (defun im-notify-posframe-notifications ()
    (interactive)
    (let ((notification (im-notify-posframe--select)))
      (empv--select-action "Act on notification"
        "Open" → (switch-to-buffer-other-window (plist-get notification :buffer-name))
        "Delete" → (progn (posframe-delete (plist-get notification :buffer-name)) (message ">> Deleted."))
        "Snooze" → (im-notify-posframe-snooze notification (im-read-duration)))))

  (defun im-notify-posframe-enable-dnd (seconds)
    "Enable DND mode for SECONDS."
    (interactive (list (im-read-duration)))
    (setq im-notify-posframe-dnd t)
    (message ">> Disabling notifications for %s seconds." seconds)
    (run-with-timer seconds nil #'im-notify-posframe-disable-dnd))

  (defun im-notify-posframe-disable-dnd ()
    "Disable DND mode."
    (interactive)
    (setq im-notify-posframe-dnd nil))

  (defun im-notify-posframe-blacklist ()
    (interactive)
    (let* ((pp-use-max-width t)
           (result (read-string
                    "Blacklist expr: "
                    (if (stringp im-notify-posframe-blacklist-regexp)
                        im-notify-posframe-blacklist-regexp
                      (s-trim (pp-to-string im-notify-posframe-blacklist-regexp))))))
      (setq im-notify-posframe-blacklist-regexp
            (if (s-blank? result)
                nil
              (if (s-prefix? "(rx" result)
                  (car (read-from-string result))
                result)))))

  ;; TODO Add ack, like tmr? Maybe add ack option to im-notify-posframe
  ;; itself and call with ack within this function
  (defun im-notify-posframe-snooze (notification seconds)
    (interactive (list
        (im-notify-posframe--select)
        (im-read-duration)))
    (run-with-timer
     seconds nil
     (lambda () (apply #'im-notify-posframe notification)))
    (message ">> You will be reminded about '%s' in %s seconds." (plist-get notification :title) seconds))

  (defun im-notify-posframe-snooze-last ()
    (interactive)
    (im-notify-posframe-snooze (car (im-notify-posframe-notifications-list)) (im-read-duration)))

  (defun im-notify-posframe-notifications-list ()
    "Return notification datas in sorted order.
  First one is the latest one."
    (thread-last
      (buffer-list)
      (--filter (string-prefix-p "*im-notify" (buffer-name it)))
      (--map (with-current-buffer it (when-let (x im-notify-posframe--notification-data) (map-insert x :buffer-name (buffer-name)))))
      (--filter it)
      (--sort (> (plist-get it :time) (plist-get other :time)))))

  (defun im-notify-posframe--format-notification (it)
    (format "%s | %s - %s"
            (format-time-string "%Y-%m-%d %H:%M" (plist-get it :time))
            (plist-get it :title)
            (plist-get it :message)))

  (defun im-notify-posframe--select ()
    (im-completing-read
     "Select notification: "
     (im-notify-posframe-notifications-list)
     :formatter #'im-notify-posframe--format-notification
     :category 'im-notification
     :sort? nil))

  (defun im-read-duration ()
    "Ask the user to type a duration in a human-readable way.
  Return parsed seconds from users answer."
    (tmr--parse-duration (current-time) (tmr--read-duration)))
#+end_src

** Hydra
Hydra creates a menu for quickly calling/toggling functions/modes in a visually easy way. My main use case for it right now is grouping bunch of appearance related functions/modes that I use infrequently. I believe for hydra's are not very useful for commands that you use frequently, it makes things slower than a plain keybinding but it's quite useful for the stuff that you forget or use infrequently.

#+begin_src emacs-lisp
  (use-package hydra)

  (use-package pretty-hydra
    :after hydra
    :defer t
    :general
    (im-leader "a" #'im-appearance/body)
    :config
    (pretty-hydra-define im-appearance
      (:foreign-keys warn :title "Appearance" :quit-key "q" :color amaranth)
      ("Writeroom"
       (("W" writeroom-mode "Writeroom mode" :toggle t)
        (">" writeroom-increase-width "Width +")
        ("<" writeroom-decrease-width "Width -")
        ("m" writeroom-toggle-mode-line "Toggle modeline" :toggle t))
       "Zoom"
       (("0" text-scale-increase "Zoom In (Buffer)")
        ("9" text-scale-decrease "Zoom Out (Buffer)")
        ("+" default-text-scale-increase "Zoom In (All)")
        ("-" default-text-scale-decrease "Zoom Out (All)")
        ("=" default-text-scale-reset "Zoom Reset (All)"))
       "Tabs"
       (("tl" tab-line-mode "Tab Line mode (buffer)" :toggle t)
        ("tL" global-tab-line-mode "Tab Line mode (global)" :toggle t)
        ("tb" tab-bar-mode "Tab Bar mode (global)" :toggle t))
       "Highlighting"
       (("hg" diff-hl-mode "Highlight git diff" :toggle t)
        ("hd" rainbow-delimiters-mode "Rainbow parens" :toggle t)
        ("hl" global-hl-line-mode "Highlight current line" :toggle t)
        ("hb" beacon-mode "Cursor trailer (baecon)" :toggle t)
        ("hw" im-whitespace-mode-toggle "Whitespaces" :toggle t)
        ("ht" highlight-thing-mode "Highlight current symbol" :toggle t))
       "Miscellaneous"
       (("n" display-line-numbers-mode "Line numbers" :toggle t)
        ("l" visual-line-mode "Wrap lines" :toggle t)
        ("T" toggle-truncate-lines "Truncate lines")
        ("v" visual-fill-column-mode "Wrap lines at 72th col" :toggle t)
        ("i" highlight-indent-guides-mode "Indent Guides" :toggle t)
        ("f" fci-mode "Fill column" :toggle t)
        ("<SPC>" nil "Quit" :color blue)))))
#+end_src
** wgrep
With this package, you can make =grep= buffers editable and your edits can be applied to the files itself. Also =embark= has a feature where you can export the current completing-read results into a grep buffer, the action is called =embark-export= and it works on =consult-ripgrep= etc.
- Do ~C-c C-p~ (or =i=, enabled by evil-collection) on a =grep= buffer to make it editable.
- Do ~C-j~ or ~C-k~ (enabled by evil-collection, by default you need to use =n=) to peek at next/prev instance.

#+begin_src emacs-lisp
  (use-package wgrep
    :defer t)
#+end_src
** dired/dirvish
There is also ~wdired-mode~ which you can use to do bulk rename intuitively.

#+begin_src emacs-lisp
  (use-package dired
    :straight (:type built-in)
    :config
    (setq dired-dwim-target t)
    (setq dired-listing-switches "-l -A -h -v --group-directories-first")
    (setq ls-lisp-dirs-first t)
    (setq ls-lisp-use-insert-directory-program nil)
    (setq dired-kill-when-opening-new-dired-buffer t)
    (setq dired-clean-confirm-killing-deleted-buffers nil)
    (setq dired-recursive-copies 'always)
    (setq dired-recursive-deletes 'always)
    (setq dired-dwim-target t)
    (put 'dired-find-alternate-file 'disabled nil))

  (use-package dirvish
    :straight (:host github :repo "alexluigit/dirvish")
    :after dired
    :general
    (:states 'normal
     "M-f" #'dirvish-side)
    (im-leader
      "ed" #'dirvish-dwim
      "eD" #'im-dirvish)
    ;; Add a way to open dirvish in selected directory using Embark
    (:keymaps 'embark-file-map "J" #'im-dirvish)
    (:keymaps 'dirvish-mode-map :states 'normal
     "\\"    #'dired-find-file-other-window
     "h"     #'dired-up-directory
     "l"     #'dired-find-alternate-file
     "q"     #'dirvish-quit
     "<tab>" #'dirvish-toggle-subtree
     "f"     #'dirvish-file-info-menu
     "s"     #'dirvish-setup-menu
     "H"     #'dirvish-history-go-backward
     "L"     #'dirvish-history-go-forward)
    ;; Other keybindings comes from dired-mode (which comes from
    ;; evil-collection)
    :init
    ;; Need to load this eagerly, otherwise `dired-jump' calls does not
    ;; load dirvish.
    (dirvish-override-dired-mode)
    :config
    (setq dirvish-subtree-always-show-state t)
    (setq dirvish-attributes '(vc-state subtree-state all-the-icons collapse git-msg file-time file-size))
    (setq dirvish-side-width 55)

    (dirvish-side-follow-mode)

    ;; Disable wrapping lines in some modes so that full-screen dirvish looks good
    (add-hook 'dirvish-directory-view-mode-hook #'im-disable-line-wrapping)
    (add-hook 'dired-mode-hook #'im-disable-line-wrapping)
    (add-hook 'dired-mode-hook #'im-disable-tab-line))

  (defun im-dirvish (dir)
    "Start dirvish in selected DIR."
    (interactive "DOpen Dirvish in: ")
    (dirvish dir))

  (defun im-disable-line-wrapping ()
    (let ((inhibit-message t))
      (visual-line-mode -1)
      (toggle-truncate-lines +1)))

  (defun im-disable-tab-line ()
    (tab-line-mode -1))
#+end_src
*** im-dired-rsync
Dired copies files sync. This function uses rsync to copy stuff async, especially useful while copying stuff over tramp/ssh.

#+begin_src emacs-lisp
  (defun im-dired-rsync (dest)
    "Copy selected files with rsync to DEST.
  This works over TRAMP (but only ssh and remote to local is
  supported).

  NOTE: Use \"rsync --version\" > 3 or something like that."
    (interactive
     (let ((target (dired-dwim-target-directory)))
       (list
        (expand-file-name
         (read-file-name
          "Copy selected files to: "
          (if (s-contains? "ssh:" target) "~/" target))))))
    (setq dest (expand-file-name dest))
    (let* ((files (dired-get-marked-files nil current-prefix-arg))
           (ssh-regexp "/ssh:\\([a-zA-Z0-9_-\\.@]+\\):")
           (fix-remote-files
            (lambda (it)
              (if-let (host (nth 1 (s-match ssh-regexp it)))
                  (concat host ":" (string-trim-left it ssh-regexp))
                (shell-quote-argument it))))
           ;; If `default-directory' points to ssh'ed directory, that
           ;; may cause some issues. This is just to keep things simple
           ;; and error-free. Also it's better to use target directory
           ;; as the `default-directory'.
           (default-directory (if (f-dir? dest) dest (f-dirname dest))))
      (im-shell-command
       :command "rsync"
       :eat t
       :args
       `("-s" "--archive" "--recursive" "--verbose" "--human-readable" "--partial" "--xattrs" "--info=progress1"
         ,@(when (--any? (s-matches? ssh-regexp it) files)
             '("-e" "ssh"))
         ,@(mapcar fix-remote-files files)
         ,dest)
       :on-finish
       (lambda (&rest _)
         (message ">> Files copied successfully."))
       :on-fail
       (lambda (&rest _)
         (message "!! Error while copying files.")))))
#+end_src
** image-mode
I want to be able to kill image buffers with simply hitting =q=. This does that.

#+begin_src emacs-lisp
  (evil-set-initial-state 'image-mode 'normal)
  (evil-define-key 'normal image-mode-map
    "q" #'evil-delete-buffer
    "r" #'image-rotate)
#+end_src

** calendar & diary & appt
Some tips:
- ~.~ go to today
- ~0,$~ beginning/end of the week
- ~(,)~ beginning/end of the month
- ~{,}~ prev/next month
- ~[,]~ prev/next year
- ~gs~ show sunrise/sunset time of date under cursor
- ~gd~ go to a date with a wizard.
- ~a~ to jump org-agenda for that day.
- ~d~ to show diary entries only. (agenda already shows these)
- ~ii~ to insert entry for that date.
- ~iw/im/iy/ia/ib~ to insert weekly/monthly/anneversary/block (block being between the marked day and selected day) entry.
- Set a mark by hitting ~v~, then go to another date and hit ~M-=~ which will show day count between those two dates.
#+begin_src emacs-lisp
  (use-package calendar
    :straight (:type built-in)
    ;; Enable including other diary entries using the #include "..." syntax
    ;; I use this to separate my work and normal diary
    :hook ((diary-list-entries . diary-include-other-diary-files)
           (diary-list-entries . diary-sort-entries)
           ;; Show week numbers on calendar
           (after-init . im-calendar-week-number-mode)
           ;; Show sunrise/sunset when calendar opens
           (calendar-today-visible . calendar-sunrise-sunset)
           (calendar-today-visible . calendar-mark-today))
    :general
    (im-leader "ec" #'calendar)
    :commands calendar
    :init
    (evil-define-key 'normal diary-fancy-display-mode-map "q" #'evil-delete-buffer)
    (evil-define-key 'normal calendar-mode-map (kbd "a") #'im-calendar-jump-org-agenda)
    :config
    (calendar-set-date-style 'european)

    ;; Start the week from Monday
    (setq calendar-week-start-day 1)

    ;; lng and lat for my location, to get sunrise/sunset times on my
    ;; calendar (press `gs'). `calendar-sunrise-sunset' shows the
    ;; sunrise/sunset times for time under the cursor which means you
    ;; can look up sunrise/sunset times of past/future times.
    (setq calendar-latitude 52.37403)
    (setq calendar-longitude 4.88969)

    ;; Use 24-hour format to display times
    (setq calendar-time-display-form
          '(24-hours ":" minutes (if time-zone " (") time-zone (if time-zone ")")))

    (setq diary-display-function #'diary-fancy-display)
    (setq diary-number-of-entries 7)

    (evil-collection-define-key 'normal 'calendar-mode-map
      "ii" #'diary-insert-entry
      "id" #'diary-insert-entry
      "iw" #'diary-insert-weekly-entry
      "im" #'diary-insert-monthly-entry
      "iy" #'diary-insert-yearly-entry
      "ia" #'diary-insert-anniversary-entry
      "ib" #'diary-insert-block-entry)

    ;; Show calendar at the bottom
    (im-shackle-window "Calendar" 0.3))

  (defun im-calendar-jump-org-agenda ()
    "Open the currently selected calendar date on org-agenda."
    (interactive nil calendar-mode)
    (let ((org-agenda-window-setup 'other-window)
          (org-agenda-span 1))
      (org-calendar-goto-agenda)))

  ;; https://www.emacswiki.org/emacs/CalendarWeekNumbers
  (defun im-calendar-week-number-mode ()
    "Show week numbers in M-x calendar."
    (copy-face font-lock-constant-face 'calendar-iso-week-face)
    (set-face-attribute 'calendar-iso-week-face nil :height 0.7)
    (setq
     calendar-intermonth-text
     '(propertize
       (format "%2d"
               (car
                (calendar-iso-from-absolute
                 (calendar-absolute-from-gregorian (list month day year)))))
       'font-lock-face 'calendar-iso-week-face)))
#+end_src

*** Automatically syncing with remote calendars
I'm experimenting with using default Emacs calendar as my work calendar. To do so, I import the remote calendar into my diary using the following function. Set ~im-calendar-remote-ics-file~ to the url of ICS file beforehand.

You also need to import work diary file in your main diary file, like this:

#+begin_src diary
  #include "~/.emacs.d/.cache/work-diary"
#+end_src

#+begin_src emacs-lisp
  (defconst im-work-diary-path (expand-file-name "~/.emacs.d/.cache/work-diary"))

  (defun im-update-calendar ()
    "Sync emacs calendar/diary with my remote calendar."
    (interactive)
    (message ">> Updating the calender...")
    (url-retrieve
     im-calendar-remote-ics-file
     (lambda (status)
       (delete-region (point-min) url-http-end-of-headers)
       ;; Following is required because some diary entries may contain
       ;; Turkish characters and url-retrieve does not set
       ;; buffer-multibyte to t automatically
       (set-buffer-multibyte t)
       ;; Clean the work-diary first, so that items do not get
       ;; duplicated
       (with-current-buffer (find-file-noselect im-work-diary-path)
         (delete-region (point-min) (point-max)))
       (icalendar-import-buffer im-work-diary-path t)
       (message ">> Updating the calendar... DONE"))))
#+end_src

To sync it automatically:

#+begin_src emacs-lisp
  ;; (run-with-timer 60 (* 30 60) #'im-update-calendar)
#+end_src

*** appt.el: notifications for org-agenda and diary items
~appt.el~ shows notifications for upcoming events in your diary and in your org-agenda.

- By default appt shows only the entries found in diary and the included files in ~diary-file~
- If you want to add an appt but do not want to edit ~diary-file~, you can use ~appt-add~ which adds it to the ~appt-time-msg-list~.
- You can use ~appt-delete~ to remove appts from the list.
- ~appt-time-msg-list~ updated when
  - this package is initialized, aka ~(require 'appt)~
  - at 00:01
  - manually by ~appt-check~
  - manually by ~org-agenda-to-appt~
  - whenever ~diary-file~ (and the files it includes) is edited
  - whenever one of ~org-agenda-files~ is edited. (see below)

~appt-message-warning-time~ is the minutes before appt.el starts showing warnings and it shows warnings every ~appt-display-interval~ minutes until the event starts.

#+begin_src emacs-lisp
  (use-package appt
    :defer 20
    :straight (:type built-in)
    ;; Automatically update `appt-time-msg-list' after editing an
    ;; org-agenda file
    :hook (org-mode . im-org-agenda-to-appt-on-save)
    :config
    ;; Use my notification function for appt notifications
    (setq appt-disp-window-function #'im-appt-notify)
    (setq appt-message-warning-time 10)
    (setq appt-display-interval 4)

    (save-window-excursion
      (appt-activate 1)))

  (defun im-org-agenda-to-appt-on-save ()
    (add-hook
     'after-save-hook
     (lambda ()
       (when (-contains? (org-agenda-files 'unrestricted) (buffer-file-name))
         (org-agenda-to-appt)
         (appt-check)
         (message ">> appt updated.")))
     nil t))

  (defun im-appt-notify (min-to-appt new-time appt-msg)
    (if (listp min-to-appt)
        (--each (-zip-pair min-to-appt appt-msg)
          (im-appt-notify--helper (car it) new-time (cdr it)))
      (im-appt-notify--helper min-to-appt new-time appt-msg)))

  (defun im-appt-notify--helper (min-to-appt new-time appt-msg)
    (setq min-to-appt (string-to-number min-to-appt))
    (message ">> appt :: %s, remaining %s mins" appt-msg min-to-appt)
    (let ((important? (cond
                       ((s-contains? "meeting" (s-downcase appt-msg)) t)
                       (t nil))))
      (alert
       (im-org-header-line-to-title appt-msg)
       :title (format "Reminder, %s mins left" min-to-appt new-time)
       :severity (if important? 'high 'normal)
       :persistent important?
       :category 'appt
       :id appt-msg)))
#+end_src

*** More org-mode and diary integration and utilities
#+begin_src emacs-lisp
  (defun im-diary-kill-entry-as-bullet-task (&optional include-description)
    "Copy current diary entry as a bullet.org task."
    (interactive "P")
    (-as->
     (thing-at-point 'line) it
     (s-match "\\([0-9]+:[0-9]+-[0-9]+:[0-9]+\\) \\(.*\\)" it)
     (format
      "** TODO [#A] %s :work:\nSCHEDULED: <%s %s>\n%s"
      (if-let ((link (ignore-errors (im-diary-entry-meeting-link))))
          (format "[[%s][%s]]" link (nth 2 it))
        (nth 2 it))
      (im-today)
      (nth 1 it)
      (if include-description (im-diary-entry-description) ""))
     (im-kill it)))

  (defun im-diary-entry-meeting-link ()
    "Get meeting/zoom link of current diary entry."
    (let ((entry-details (im-diary-entry-description)))
      (with-temp-buffer
        (insert entry-details)
        (goto-char (point-min))
        (re-search-forward "https://.*zoom")
        (thing-at-point 'url))))

  (defun im-diary-entry-description ()
    "Get details/description of current diary entry."
    (interactive)
    (save-window-excursion
      (push-button)
      (let ((beg (save-excursion
                   (re-search-backward "^[^ \n].+")
                   (forward-line)
                   (point)))
            (end (save-excursion
                   (re-search-forward "^[^ \n].+")
                   (beginning-of-line)
                   (point))))
        (im-kill (buffer-substring beg end)))))
#+end_src
** tramp
#+begin_src emacs-lisp
  (setq tramp-default-method "ssh")
  (setq tramp-verbose 2)
  ;; ^ Only show errors and warnings
  (setq vc-handled-backends '(Git))
  ;; ^ Only try to handle git, this speeds up things a little bit
#+end_src

** w3m
*** Installation/Keybindings
#+begin_src emacs-lisp
  (use-package w3m
    :commands (w3m im-w3m-open-url-dwim)
    :hook (w3m-mode . (lambda () (setq-local scroll-margin 0)))
    :config
    (evil-define-key 'normal w3m-mode-map
      (kbd "&") (λ-interactive (funcall browse-url-secondary-browser-function w3m-current-url))
      (kbd "^") (λ-interactive (browse-url w3m-current-url))
      (kbd "K") #'w3m-next-buffer
      (kbd "J") #'w3m-previous-buffer
      (kbd "o") #'im-w3m-open-url-dwim
      (kbd "O") #'w3m-edit-url
      (kbd "t") (λ-interactive (im-w3m-open-url-dwim (read-string "URL: ") :new-session))
      (kbd "T") (λ-interactive (im-w3m-open-url-dwim (read-string "URL: " w3m-current-url) :new-session))
      (kbd "M-j") #'w3m-tab-move-left
      (kbd "M-k") #'w3m-tab-move-right
      (kbd "x") #'w3m-delete-buffer
      (kbd "Y") #'im-w3m-yank-url
      (kbd "f") #'im-w3m-avy-link
      (kbd "F") #'im-w3m-avy-link-new-session)
    (setq w3m-fill-column 80)
    (setq w3m-use-title-buffer-name t)
    (setq w3m-default-display-inline-images t)
    (setq w3m-use-tab-line nil)
    ;; (setq w3m-display-mode 'plain)
    (w3m-display-mode 'plain))

  (defun im-w3m-open-url-dwim (url &optional new-session)
    (interactive "sURL: ")
    (if (im-url? url)
        (if new-session (w3m-goto-url-new-session url) (w3m-goto-url url))
      (if new-session (w3m-search w3m-search-default-engine url) (w3m-search-new-session w3m-search-default-engine url))))
#+end_src

*** Extras
#+begin_src emacs-lisp
  (defun im-w3m-all-anchor-points (&optional start end)
    "Return all anchor points for current w3m buffer.
  If START and/or END is given, only return anchor points between
  START and END positions of the buffer, otherwise return all
  anchor points in the buffer."
    (let ((points (list))
          (start (or start (point-min)))
          (end (or end (point-max)))
          (prev 0))
      (save-excursion
        (goto-char start)
        (while (and (w3m-next-anchor)
                    (> (point) prev)
                    (<= (point) end))
          (setq prev (point))
          (when-let* ((url (w3m-url-valid (w3m-anchor)))
                      (_ (string-match "\\`https?:" url)))
            (push (point) points))))
      points))

  (defun im-w3m-avy-link ()
    "Jump to a link and open it automatically."
    (interactive)
    (avy-process (im-w3m-all-anchor-points (window-start) (window-end)))
    (w3m-goto-url (w3m-anchor)))

  (defun im-w3m-avy-link-new-session ()
    "Jump to a link and open it automatically."
    (interactive)
    (avy-process (im-w3m-all-anchor-points (window-start) (window-end)))
    (w3m-goto-url-new-session (w3m-anchor)))

  (defun im-w3m-yank-url ()
    "Copy current URL to clipboard."
    (interactive nil 'w3m-mode)
    (im-kill w3m-current-url))

  ;; Rename w3m buffer names in a way that works with my
  ;; `im-tab-line-buffers' implementation
  (define-advice w3m-buffer-name-add-title (:after (&rest _) rename-w3m-buffer-name)
    (when w3m-use-title-buffer-name
      (rename-buffer
       (format
        "*w3m: %s *w3m*<%d>" (w3m-current-title)
        ;; Lot's of functions on w3m depend on this number. Hence I left
        ;; it here. Ugly but not worth dealing with
        (w3m-buffer-number (current-buffer))))))
#+end_src

** eww -- web browser
#+begin_src emacs-lisp
  (setq browse-url-secondary-browser-function #'browse-url-firefox)
  (setq browse-url-handlers
        '((".*jtracker.trendyol.*/browse/.*" . (lambda (link &rest _) (im-jira-view-ticket link)))
          (".*slack.com/archives/.*" . (lambda (link &rest _) (im-slack-open-link link)))
          (".*reddit.com/r/[a-zA-Z0-9_-]+/comments/[a-zA-Z0-9_-]+/\\([a-zA-Z0-9_-]+/?\\)?$" . (lambda (link &rest _) (reddigg-view-comments link)))
          (".*\\(stackoverflow.com\\|stackexchange.com\\).*" . (lambda (link &rest _) (im-open-stackexchange-link link)))
          (".*\\(youtube.com/watch.*\\|youtu.be/.*\\)" . (lambda (link &rest _) (empv--play-or-enqueue link)))
          (".*\\.mp3" . (lambda (link &rest _) (empv--play-or-enqueue link)))
          (".*zoom.us/j/.*" . (lambda (link &rest _) (im-open-zoom-meeting-dwim link)))
          (".*github.com/.*issues/.*" . (lambda (link &rest _) (im-github-issue-view link)))
          (".*\\(trendyol\\|gitlab\\|github\\|slack\\|docs.google\\).*" . browse-url-firefox)
          ("." . (lambda (link &rest _) (im-eww link)))))

  (use-package eww
    :commands eww
    :hook (eww-mode . tab-line-mode)
    :general
    (im-leader
      "ew" #'im-eww)
    (:keymaps 'eww-mode-map :states 'normal
     "Y" #'eww-copy-page-url
     "d" #'im-eww-save-image
     "O" (λ-interactive (eww (read-string "URL: " (eww-current-url))))
     "t" #'im-eww
     "T" (λ-interactive (im-eww (read-string "URL: " (eww-current-url))))
     "f" #'im-eww-avy-follow
     "F" (λ-interactive (im-eww-avy-follow :new-session))
     "r" #'eww-reload
     "R" #'eww-readable
     (kbd "<f2>") #'im-eww-open-in-xwidget-webkit
     (kbd "<f3>") (λ-interactive (browse-url (eww-current-url)))
     (kbd "<f4>") (λ-interactive (funcall browse-url-secondary-browser-function (eww-current-url)))
     "&" (λ-interactive (funcall browse-url-secondary-browser-function (eww-current-url))))
    :config
    ;; Gifs make my computer suffer, so I just disable them
    ;; (setq shr-image-animate nil)
    (setq shr-max-image-proportion 0.6)
    (setq shr-discard-aria-hidden t)
    (setq shr-use-xwidgets-for-media t)

    (setq eww-search-prefix "https://www.google.com/search?q=")
    (setq eww-auto-rename-buffer
          (lambda () (format "*eww: %s*" (or (plist-get eww-data :title) "...")))))

  (defun im-eww (url)
    "Like `eww' but opens in a new eww buffer instead of reusing the same one."
    (interactive (list (read-string "URL: ")))
    (eww url t))

  (defun im-eww-avy-follow (&optional follow-type)
    (interactive)
    (let ((wend (window-end))
          (urls '()))
      (save-excursion
        (goto-char (window-start))
        (while-let ((match (text-property-search-forward 'shr-tab-stop nil nil t))
                    ((< (point) wend)))
          (goto-char (prop-match-beginning match))
          ;; (push (get-text-property (point) 'shr-url) urls)
          (push (point) urls)))
      (avy-process (nreverse urls))
      (pcase follow-type
        (:new-session
         (eww (get-text-property (point) 'shr-url) :new-session))
        (:external (eww-browse-with-external-browser  t))
        (_ (eww-follow-link)))))

  (defun im-eww-save-image ()
    "Save the image at point."
    (interactive)
    (let ((image (get-text-property (point) 'display))
          ;; Disable all save hooks as they might damage the file
          (before-save-hook '())
          (after-save-hook '()))
      (unless (and image
                   (eq (car image) 'image))
        (user-error "No images at point!"))
      (with-temp-buffer
        (setq buffer-file-name
              (read-file-name "Save to: "  nil default-directory nil))
        (insert (plist-get (cdr image) :data))
        (save-buffer))))
#+end_src
*** Language detection and code highlighting in eww buffers
#+begin_src emacs-lisp
  (use-package language-detection)

  (defun eww-tag-pre (dom)
    (let ((shr-folding-mode 'none)
          (shr-current-font 'default))
      (shr-ensure-newline)
      (insert (eww-fontify-pre dom))
      (shr-ensure-newline)))

  (defun eww-fontify-pre (dom)
    (with-temp-buffer
      (shr-generic dom)
      (let ((mode (eww-buffer-auto-detect-mode)))
        (when mode
          (eww-fontify-buffer mode)))
      (buffer-string)))

  (defun eww-fontify-buffer (mode)
    (delay-mode-hooks (funcall mode))
    (font-lock-default-function mode)
    (font-lock-default-fontify-region (point-min)
                                      (point-max)
                                      nil))

  (defun eww-buffer-auto-detect-mode ()
    (let* ((map '((ada ada-mode)
                  (awk awk-mode)
                  (c c-mode)
                  (cpp c++-mode)
                  (clojure clojure-mode lisp-mode)
                  (csharp csharp-mode java-mode)
                  (css css-mode)
                  (dart dart-mode)
                  (delphi delphi-mode)
                  (emacslisp emacs-lisp-mode)
                  (erlang erlang-mode)
                  (fortran fortran-mode)
                  (fsharp fsharp-mode)
                  (go go-mode)
                  (groovy groovy-mode)
                  (haskell haskell-mode)
                  (html html-mode)
                  (java java-mode)
                  (javascript javascript-mode)
                  (json json-mode javascript-mode)
                  (latex latex-mode)
                  (lisp lisp-mode)
                  (lua lua-mode)
                  (matlab matlab-mode octave-mode)
                  (objc objc-mode c-mode)
                  (perl perl-mode)
                  (php php-mode)
                  (prolog prolog-mode)
                  (python python-mode)
                  (r r-mode)
                  (ruby ruby-mode)
                  (rust rust-mode)
                  (scala scala-mode)
                  (shell shell-script-mode)
                  (smalltalk smalltalk-mode)
                  (sql sql-mode)
                  (swift swift-mode)
                  (visualbasic visual-basic-mode)
                  (xml sgml-mode)))
           (language (language-detection-string
                      (buffer-substring-no-properties (point-min) (point-max))))
           (modes (cdr (assoc language map)))
           (mode (cl-loop for mode in modes
                          when (fboundp mode)
                          return mode)))
      (message (format "%s" language))
      (when (fboundp mode)
        mode)))

  (setq shr-external-rendering-functions
        '((pre . eww-tag-pre)))
#+end_src
** shell-mode
#+begin_src emacs-lisp
  (use-package shell
    :straight (:type built-in)
    :defer t
    :init
    (evil-define-key 'insert 'shell-mode-map (kbd "C-l") #'comint-clear-buffer))
#+end_src

** which-key
A package that shows key combinations. (for example press C-x and wait) It also works with ~general.el~, just press leader key and wait to see your options. I made a few adjustment so that it's more compact and you can see full function names (most of the time) and it shows up at the top center instead of bottom left corner. This mostly eliminates the need for creating a [[Hydra]].

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :hook (after-init . which-key-mode)
    :config
    (setq which-key-min-display-lines 1)
    (setq which-key-max-display-columns 1)
    (setq which-key-max-description-length 70)
    (setq which-key-show-docstrings t)
    (setq which-key-idle-delay 0.5)
    (setq which-key-sort-order #'which-key-prefix-then-key-order))
#+END_SRC

** magit & vc
While I mainly use magit for version control stuff, ~vc~ has some nicer parts that I make use of. Like
- =vc-annotate= :: Faster and simpler alternative to =magit-blame=. (Bound to ~SPC gB~). Use =L= on line to show commit message.

Sometimes I use =vc= for pure speed. Because it supports multiple backends, the terminology is a bit different but here is how you stage and commit (keybindings are coming from [[evil-collection]]):
- =C-x v d= to open magit-status like status buffer.
- =TAB= to show diff of the file at point.
- =m/u= (vc-dir-mark) to mark/unmark files to take an action on them. You can also think this as staging if your next action is going to be committing.
- =c= (vc-next-action) to commit /staged/ files.

Note that it's not possible to stage hunks with =vc=.

*** Installation
- Read this for some useful status mode keymaps: https://endlessparentheses.com/it-s-magit-and-you-re-the-magician.html
  - y :: Branch viewer (delete branches with ~k~)
  - ll :: Log current
  - bs :: Branch spin-off; create and checkout to a new branch, carry over the ongoing changes. It also undoes the changes in the current branch
  - bc :: Branch create; you can directly create new branch from *origin/develop* for instance

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :defer t
    :init
    (im-leader
      "gv" #'project-vc-dir
      "gd" #'vc-diff
      "gD" #'vc-root-diff
      "gn" #'vc-next-action
      "gs" #'magit-status
      "gS" #'magit-stash
      "gf" #'magit-file-dispatch
      "gp" #'vc-pull
      "gP" #'magit-push
      "gr" #'magit-reset
      "gcc" #'vc-switch-branch
      "gB" #'vc-annotate ;; Git Blame
      "gR" #'vc-refresh-state
      "gbc" #'vc-create-branch
      "gL" #'vc-print-root-log
      "gbb" #'magit-branch)
    :config
    (define-advice magit-checkout (:after (&rest _) refresh-vc-state) (vc-refresh-state))
    (define-advice magit-branch-and-checkout (:after (&rest _) refresh-vc-state) (vc-refresh-state))
    (define-advice vc-create-branch (:after (&rest _) refresh-vc-state) (vc-refresh-state))
    (define-advice vc-switch-branch (:after (&rest _) refresh-vc-state) (vc-refresh-state)))
#+END_SRC

*** vc configuration
#+begin_src emacs-lisp
  (use-package vc
    :straight (:type built-in)
    :general
    (:keymaps 'vc-dir-mode-map :states 'normal
     "r" #'vc-dir-refresh)
    :config
    ;; Magit like commit interface:
    ;; - Open commit window
    ;; - Clear all other windows
    ;; - Open diff
    ;; - When committed, kill diff buffer and window.
    (require 'log-edit)
    (remove-hook 'log-edit-hook #'log-edit-show-files)
    (add-hook 'log-edit-hook #'im-vc-show-diff))

  (defvar im--last-log-diff-buffer nil)
  (defun im-vc-show-diff ()
    "Same as log-edit-show-diff but do not focus to the diff window."
    (let ((bname (buffer-name (current-buffer))))
      (delete-other-windows)
      (log-edit-show-diff)
      (setq im--last-log-diff-buffer (current-buffer))
      (im-select-window-with-buffer bname)))

  ;; Restore window configuration etc. after we are done.
  ;; log-edit-done-hook only works on successful case but this advice
  ;; works for every case
  (define-advice log-edit-kill-buffer (:after (&rest args) kill-diff-window)
    (im-select-window-with-buffer (buffer-name im--last-log-diff-buffer))
    (when (equal (window-buffer) im--last-log-diff-buffer)
      (im-quit))
    (kill-buffer im--last-log-diff-buffer)
    (tab-bar-history-back))
#+end_src
*** git-timemachine
- Toggle with ~git-timemachine~ (SPC gt).
- When in timemachine mode,
  - use =gt<SOMETHING>= to do timemachine specific operations. Some useful ones are:
    - t -> =git-timemachine-show-revision-fuzzy=, selects a revision through completing-read interface.
    - y/Y -> Yank (abbreviated) revision hash.
  - ~C-j/k~ to go to prev/next revision of the file.

#+begin_src emacs-lisp
  (use-package git-timemachine
    :general
    (im-leader-v
     "gt" #'git-timemachine-toggle))
#+end_src

*** magit-delta (for diff syntax highlighting)
You need to install ~delta~ (or ~git-delta~) before to get this working. See [[https://github.com/dandavison/delta][here]].

#+begin_src emacs-lisp
  (use-package magit-delta
    :after magit
    :hook
    ((magit-mode . magit-delta-mode)
     (magit-delta-mode . im-delta-fix-bg-colors))
    :config
    (setq magit-delta-default-light-theme "GitHub")
    (setq magit-delta-default-dark-theme "Monokai Extended Bright")
    (setq magit-delta-hide-plus-minus-markers nil)

    ;; Apply diff colors to whole visual line
    ;; See https://github.com/dandavison/magit-delta/issues/6
    (set-face-attribute 'magit-diff-added-highlight nil :background "#002800")
    (set-face-attribute 'magit-diff-added nil :background "#002800")
    (set-face-attribute 'magit-diff-removed-highlight nil :background "#3f0001")
    (set-face-attribute 'magit-diff-removed nil :background "#3f0001"))

  (defun im-delta-fix-bg-colors ()
    (setq face-remapping-alist
          (seq-difference face-remapping-alist
                          '((magit-diff-removed . default)
                            (magit-diff-removed-highlight . default)
                            (magit-diff-added . default)
                            (magit-diff-added-highlight . default)))))
#+end_src

** diff-mode
Some small enhancments to diff mode:
- Cycle hunks with TAB, SHIFTTAB.
- Reverse hunks with "x" (like magit diff).
- Split hunks with "-", which enables you to split and then reverse so that you can reverse individual lines/portions etc.
- TODO: maybe add ability to stage hunks

#+begin_src emacs-lisp
  (add-hook 'diff-mode-hook #'outline-minor-mode)

  (evil-define-key 'normal diff-mode-map
    "r" #'vc-diff
    "x" #'im-diff-reverse-hunk
    "-" #'diff-split-hunk
    (kbd "RET") #'diff-goto-source
    (kbd "<tab>") #'outline-cycle
    (kbd "<backtab>") #'outline-cycle-buffer
    ;; Add ability to exit from commit window (log-edit) of vc from the
    ;; diff buffer. Because it automatically opens, sometimes I decide
    ;; to discard what I'm currently doing inside the diff buffer
    (kbd "C-c C-k") (λ-interactive
                     (when (im-select-window-with-buffer "*vc-log*")
                       (call-interactively #'log-edit-kill-buffer))))

  (defun im-diff-reverse-hunk ()
    "Reverse hunk at point."
    (interactive)
    (pcase-let ((`(,buf ,_line-offset ,_pos ,_src ,_dst ,_switched)
                 (diff-find-source-location nil nil)))
      (when (y-or-n-p "Really want to revert?")
        (save-window-excursion
          (save-excursion
            (diff-apply-hunk :reverse)
            (with-current-buffer buf
              (save-buffer))))
        (diff-hunk-kill))))
#+end_src
** avy
avy is very similar to ~vim-easymotion~. It simply jumps to a visible text using a given char.
- =s= for jumping to beginning of a word
- =S= for jumping any part of the text
- =gl= for going into beginning of a line

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :commands (avy-goto-subword-1 avy-goto-word-1)
    :init
    (evil-define-key 'normal 'global
      (kbd "S") #'avy-goto-subword-1
      (kbd "s") #'avy-goto-word-1)
    :config
    (setq avy-keys '(?q ?w ?e ?r ?t ?a ?s ?d ?f ?j ?k ?l ?u ?i ?o ?p)
          avy-case-fold-search nil
          avy-all-windows t))
#+END_SRC

** vertico & marginalia & orderless & mini-frame
A nice, fast minibuffer narrowing framework. It works well with quite a lot of package.
- =marginalia.el= brings annotations to completing-read, ie. it adds current keybinding of a command, summary of command to M-x.
- =miniframe.el= shows all completing-read prompts in a nice mini popup frame.
- Also see [[embark]].

Keybindings:
- =SPC 0= to repeat/open last vertico window you closed.

Some shortcuts you can use on any vertico window:
- =M-{n,p}= goes {back,forward} in minibuffer history.
- =M-{[,]}= goes {previous,next} group.
- =M-m= cycles the marginalia detail level.
- =M-a= brings up embark-act menu. See [[embark]].
- =M-w= copy the current candidate.
- =TAB= inserts the current candidate (into minibuffer).

#+begin_src emacs-lisp
  (use-package vertico
    :hook ((after-init . vertico-mode))
    :config
    ;; Grow and shrink the Vertico minibuffer
    ;; (setq vertico-resize t)

    ;; Show more candidates
    (setq vertico-count 15)
    ;; Enable cycling for `vertico-next' and `vertico-previous'.
    (setq vertico-cycle t)
    ;; Hide commands in M-x which do not work in the current mode.
    (setq read-extended-command-predicate #'command-completion-default-include-p)

    ;; Add prompt indicator to `completing-read-multiple'.
    (defun crm-indicator (args)
      (cons (concat "[CRM] " (car args)) (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

    ;; Enable recursive minibuffers
    (setq enable-recursive-minibuffers t)

    ;; Bindings
    (define-key vertico-map (kbd "M-[") #'vertico-previous-group)
    (define-key vertico-map (kbd "M-]") #'vertico-next-group)
    (define-key vertico-map (kbd "M-j") #'next-line)
    (define-key vertico-map (kbd "M-k") #'previous-line)

    ;; Use `consult-completion-in-region' which works with vertico
    (setq completion-in-region-function #'consult-completion-in-region))
#+end_src

Here I enable a few extensions for vertico:

#+begin_src emacs-lisp
  ;; Load vertico extensions
  (add-to-list 'load-path (expand-file-name (format "%sstraight/build/vertico/extensions" straight-base-dir)))

  ;; Enable avy style candidate selection
  (use-package vertico-quick
    :straight nil
    :after vertico
    :config
    (setq vertico-quick1 "asdfgqwe")
    (setq vertico-quick2 "hjklui")
    (define-key vertico-map "\M-q" #'vertico-quick-exit))

  (use-package vertico-repeat
    :straight nil
    :after vertico
    :config
    (add-hook 'minibuffer-setup-hook #'vertico-repeat-save)
    (im-leader "0" #'vertico-repeat))

  ;; Enable showing vertico in a buffer instead of minibuffer
  (use-package vertico-buffer
    :straight nil
    :after vertico)

  ;; Switch between different vertico display forms for different commands
  (use-package vertico-multiform
    :straight nil
    :after vertico
    :config
    ;; Toggle grid mode by hitting M-g while in vertico
    ;; Toggling grid mode does not work well with mini-frame.
    (define-key vertico-map "\M-g" #'vertico-multiform-grid)

    ;; '(command display-type... (buffer-local-variable . value))
    ;; vertico README explains this very well
    (setq vertico-multiform-commands
          '((consult-org-heading
             buffer
             (vertico-buffer-display-action . (display-buffer-in-side-window
                                               (side . right)
                                               (window-width . 0.4))))
            (consult-imenu
             buffer
             (vertico-buffer-display-action . (display-buffer-in-side-window
                                               (side . right)
                                               (window-width . 0.4))))))
    (vertico-multiform-mode))

  ;; Enable displaying candidates in a grid.
  (use-package vertico-grid
    :straight nil
    :after vertico)
#+end_src

Other complementary packages:

#+begin_src emacs-lisp
  (use-package orderless
    :config
    (setq completion-styles '(orderless partial-completion basic))
    (setq completion-category-defaults nil)
    (setq completion-category-overrides '((file (styles partial-completion)))))

  (use-package marginalia
    :config
    (define-key minibuffer-local-map (kbd "M-m") #'marginalia-cycle)
    (setq marginalia-censor-variables '("pass\\|auth-source-netrc-cache\\|auth-source-.*-nonce\\|token\\|key\\|password\\|cookie\\|phone-number\\|app-id\\|feed-link"))
    (marginalia-mode))

  (use-package mini-frame
    ;; :hook (after-init . mini-frame)
    :config
    (setq mini-frame-show-parameters
          '((top . 0.15)
            (width . 0.70)
            (left . 0.5)))
    (setq mini-frame-color-shift-step 15)

    ;; Disable mini-frame while using some functions either that does
    ;; not work well with mini-frame or it doesn't make sense to use it
    ;; with mini-frame
    (setq mini-frame-ignore-commands
          '(completion-at-point
            evil-ex
            ctrlf-forward-default
            tab-jump-out
            consult-line
            consult-ripgrep
            consult-bookmark
            jq-interactively
            im-consult-ripgrep
            consult-org-heading
            consult-imenu)))
#+end_src
** ~project.el~ and project management
~(project-remember-projects-under im-projects-root t)~ does not work as I expect, so I add all of my projects using a custom function that returns all of my projects' paths.

#+begin_src emacs-lisp
  ;; (use-package project
  ;;   :straight (:type built-in)
  ;;   ;; I dynamically load projects list
  ;;   ;; FIXME Setting it to nil breaks project.el
  ;;   :custom (project-list-file nil))

  (defconst im-projects-root "~/Workspace/projects")

  (defun im-current-project-root ()
    "Return the root path of current project."
    (interactive)
    (ignore-errors
      (expand-file-name (project-root (project-current)))))
  ;; (when-let (path (locate-dominating-file default-directory ".git"))
  ;;   (expand-file-name path)))

  (defun im-current-project-name ()
    "Return current projects name."
    (if-let ((curr-proj (im-current-project-root))
             (projects-root (expand-file-name im-projects-root)))
        (if (string-prefix-p projects-root curr-proj)
            (string-trim (string-remove-prefix projects-root curr-proj) "/" "/")
          (file-name-nondirectory (directory-file-name curr-proj)))
      (file-name-nondirectory (directory-file-name default-directory))))

  (defun im-is-git-dir (dir)
    (file-directory-p (concat dir "/.git")))

  (defun im-all-project-roots ()
    "Find every project dir under `im-projects-root'.
  It simply checks for folders with `.git' under them."
    (->>
     (expand-file-name im-projects-root)
     (format "fd . '%s' --type directory --maxdepth 4 --absolute-path")
     (shell-command-to-string)
     (s-trim)
     (s-split "\n")
     (--filter (im-is-git-dir it))
     (--map (abbreviate-file-name (f-full it)))))

  (defalias 'im-import-projects #'im-load-projects-list)
  (defun im-load-projects-list ()
    (interactive)
    (message "Loading projects....")
    ;; Ensure all projects are known by project.el
    ;; The following does not recurse as I like it to be
    ;; (project-remember-projects-under im-projects-root t)
    (setq project--list '())
    (--each (--map (project--find-in-directory it) (im-all-project-roots))
      (project-remember-project it t))
    (message "Loading projects...Done."))

  (run-with-timer 10 nil #'im-load-projects-list)
#+end_src

- project.el offers ~C-x p~ keymap with very useful bindings. I also keep my project related bindings under ~SPC p~.
- After doing ~project-switch-project~, you are expected to hit a key to trigger a project action, like finding a file in the project or doing a project grep. You need to add these actions into ~project-switch-commands~ list and you need to define a key in ~project-prefix-map~ (that is ~C-x p~) to make it triggerable by given key.

#+begin_src emacs-lisp
  (im-leader "p" (λ-interactive
                  (if-let (root (im-current-project-root))
                      (project-switch-project root)
                    (call-interactively #'project-switch-project))))

  (cl-defmacro im-projectelify (&key cmd desc key non-interactive dont-wrap dir-as-param)
    "If you add a command to `project-switch-commands', it will not
  work properly everytime becuse the function should be aware of
  what the current project is, provided by the `project-current'
  function. This function simply wraps the original CMD to make it
  work in the `project-current's directory.

  If CMD is already project.el aware, then pass DONT-WRAP as
  non-nil so that you only add it to `project-prefix-map'."
    (let ((fn (if dont-wrap
                  (symbol-name cmd)
                (concat (symbol-name cmd) "-projectel"))))
      `(progn
         (unless ,dont-wrap
           (defun ,(intern fn) ()
             (interactive)
             (let ((default-directory (project-root (project-current t))))
               (cond
                (,non-interactive (funcall #',cmd))
                (,dir-as-param (funcall #',cmd default-directory))
                (t (call-interactively #',cmd))))))
         (when ,desc
           (add-to-list 'project-switch-commands '(,(intern fn) ,desc)))
         (when ,key
           (define-key project-prefix-map ,key #',(intern fn))))))

  (setq project-switch-commands '())
  (im-projectelify :cmd im-shell-for :desc "Eshell" :key "e")
  (im-projectelify :cmd project-query-replace-regexp :desc "Replace in project (regexp)" :key "r" :dont-wrap t)
  (im-projectelify :cmd project-kill-buffers :desc "Kill buffers" :key "k" :dont-wrap t)
  (im-projectelify :cmd im-vterm-project :desc "vterm" :key "t" :dont-wrap t)
  (im-projectelify :cmd im-shell-command :desc "Run shell command" :key "!")
  (im-projectelify :cmd im-find-file-in :desc "Files" :key "f" :non-interactive t)
  (im-projectelify :cmd dired :desc "Dired" :key "D" :dir-as-param t)
  (im-projectelify :cmd magit-status :desc "Magit" :key "m")
  (im-projectelify :cmd consult-ripgrep :desc "Grep" :key "g")
  (im-projectelify :cmd lab-list-project-merge-requests :desc "Merge requests" :key "M"  :dont-wrap t)
  (im-projectelify :cmd lab-list-project-pipelines :desc "Pipelines" :key "P" :dont-wrap t)
  (im-projectelify :cmd project-switch-project :desc "Switch" :key "s" :dont-wrap t)
  (im-projectelify :cmd project-vc-dir :desc "VC dir" :key "v" :dont-wrap t)
  (im-projectelify :cmd im-select-any-project-file :desc "Files (all projects)" :key "F" :dont-wrap t)
  (im-projectelify :cmd im-consult-ripgrep-all-projects :desc "Grep (all projects)" :key "G" :dont-wrap t)
  (im-projectelify :cmd git-link-homepage :desc "Homepage" :key "H")

  ;; All-projects commands

  (defun im-select-any-project-file ()
    (interactive)
    (im-find-file-in im-projects-root))

  (defun im-consult-ripgrep-all-projects ()
    (interactive)
    (im-consult-ripgrep im-projects-root))

  ;; Others

  (defvar im-project-shell-last-height 15)
  (defvar im-project-shell-last-window nil)

  (defun im-shell-for (&optional type top?)
    (interactive)
    (require 'eshell)
    (setq type (or type 'project))
    (let* ((proj-dir (or (ignore-errors
                           (project-root (project-current)))
                         default-directory))
           (default-directory (if (eq type 'project) proj-dir default-directory))
           (proj-name (f-base default-directory))
           (name (format "$eshell: %s" proj-name)))
      (if-let* (top?
                (window (--find (s-prefix? "\$eshell: " (buffer-name (window-buffer it))) (window-list)))
                (focused? (equal window (selected-window))))
          (progn
            (setq im-project-shell-last-height (window-height window))
            (delete-window window)
            (when im-project-shell-last-window
              (select-window im-project-shell-last-window)))
        (let* ((term (or (get-buffer name)
                         (save-window-excursion
                           (let ((eshell-buffer-name name))
                             (eshell t))))))
          (with-current-buffer term
            (tab-line-mode -1))
          (setq im-project-shell-last-window (get-buffer-window))
          (if (not top?)
              (switch-to-buffer term)
            (progn
              (display-buffer-in-side-window
               term
               (append
                `((window-height . ,im-project-shell-last-height)
                  (side . top)
                  (slot . 1))))
              (select-window (get-buffer-window term))))))))

  (bind-key "M-`" #'im-shell-for)
  (bind-key "M-~" (λ-interactive (im-shell-for 'dir)))
#+end_src

** consult
Some key points:
- =SPC RET= brings up =consult-buffer=.
  - Typing =SPC {p,f,b,m}= narrows the list into {project files, files, buffers, bookmarks}.
  - Also see: [[id:90769b1b-7baf-4285-80f9-153ae07d73ab][frequently used files]]
- =M-y= brings up =consult-yank=, where you can select from clipboard history and paste.
- =C-f= does fuzzy search on current file lines.
- Do =M-,= on a candidate to preview it.
- Also don't forget to utilize =M-a= (=embark-act=) in consult windows.
- Use =M-n= (future-history) to insert current symbol after running a consult command. Normally you would use =M-{p,n}= to cycle between history items but when you open minibuffer, typing =M-n= directly tries to guess what the user input would be.

#+begin_src emacs-lisp
  (use-package consult
    :general
    (im-leader
      "fo" #'find-file
      "fs" #'save-buffer
      "fd" #'consult-dir
      "fl" #'consult-line
      "cr" #'consult-history
      "RET" #'consult-buffer)
    (:keymaps 'minibuffer-mode-map
     "C-r" #'consult-history)
    (:states 'normal :keymaps 'org-mode-map
     "M-i" #'consult-org-heading
     "M-I" #'consult-org-agenda)
    (:states 'insert :keymaps 'eshell-mode-map
     "C-r" #'consult-history)
    (:states 'normal
     "M-i" (λ-interactive (condition-case nil
                              (consult-imenu)
                            (error (consult-outline)))))
    (:keymaps 'consult-narrow-map
     ;; Shows all narrowing possibilities when you hit "?"
     ;; If no narrowing is available, simply inserts "?"
     "?" #'consult-narrow-help)
    :config
    (advice-add #'register-preview :override #'consult-register-window)

    (setq consult-preview-key "M-,")
    ;; ^ When you do M-, on a candidate, it previews it

    ;; Hide some buffers from consult-buffer window. If you want to jump
    ;; on one of these buffers, start with a space after opening
    ;; `consult-buffer'.
    (add-to-list
     'consult-buffer-filter
     "\\`\\*\\(Help\\|Backtrace\\|Messages\\|Buffer List\\|Flycheck.*\\|scratch.*\\)\\'")

    ;; This also supports previews. Use the `consult-preview-key'.
    (defalias 'im-switch-theme #'consult-theme)

    <<consult-project-management>>
    <<consult-buffer-source-files>>
    <<consult-buffer-source-projects>>)
#+end_src

*** Project & file management
Some functionality for project management. I do some fine-tuning for =find= and =ripgrep= commands that consult uses.

#+name: consult-project-management
#+begin_src emacs-lisp :tangle no
  (im-leader
    "cf"  #'im-find-file-in
    "cG"  #'im-consult-ripgrep-in-given-directory
    "cg"  #'im-consult-ripgrep-current-directory)

  ;; TODO fix search
  (setq
   consult-find-command "fd  --hidden --full-path ARG OPTS"
   consult-ripgrep-command "rg  --hidden --null --line-buffered --color=always --max-columns=500 --no-heading --smart-case --line-number . -e ARG OPTS"
   consult-project-root-function #'im-current-project-root)

  (defun im-consult-ripgrep (&optional path)
    "`consult-ripgrep' in current project.
  `consult-ripgrep' with `consult-project-root-function' shows full path of the
  file in the results.  I don't want that."
    (interactive)
    (consult-ripgrep (or path (im-current-project-root))))

  (defun im-consult-ripgrep-current-directory ()
    "Do ripgrep in `default-directory'."
    (interactive)
    (consult-ripgrep default-directory))

  (defun im-consult-ripgrep-in-given-directory (dir)
    (interactive "DSelect directory: ")
    (consult-ripgrep dir))

  (defun im-find-file-in (&optional dir)
    "Find file in DIR. `fd' is already fast enough, no need for
  `consult-find's async approach."
    (interactive "DFind files in: ")
    (let ((default-directory (or dir default-directory)))
      (im-output-select
       :cmd "fd --exclude '.git' --exclude 'node_modules' --hidden ."
       :prompt "Open file: "
       :category 'file
       :map (s-chop-prefix "./" it)
       :do (find-file it))))
#+end_src

*** consult-buffer and some extensions
:PROPERTIES:
:ID:       90769b1b-7baf-4285-80f9-153ae07d73ab
:END:
I use =(consult-buffer)= function for switching between buffers/files/marks etc. Here I add a source for my frequently used files. This is handy in a way that =(consult-buffer)= becomes my go-to place for switching to anything.

#+name: consult-buffer-source-files
#+begin_src emacs-lisp :tangle no
  (defvar im-consult-source-files
    (list
     :name     "My files"
     :narrow   ?f
     :category 'file
     :face     'consult-file
     :history  'file-name-history
     :state    #'consult--file-state
     :default  t
     :hidden   nil
     :items    #'im-my-files)
    "My frequently accessed files source for `consult-buffer'.")

  (defun im-my-files ()
    "Return list of all files I frequently use."
    `(,@(directory-files org-directory t "^\\w+.*.org$")
      ,@(directory-files im-load-path t "\\.el$")))

  (im-append! consult-buffer-sources 'im-consult-source-files)

  ;; Move bookmarks to the top of buffer sources
  (delq 'consult--source-bookmark consult-buffer-sources)
  (add-to-list 'consult-buffer-sources 'consult--source-bookmark)
#+end_src

I also add a source for listing all of my projects:

#+name: consult-buffer-source-projects
#+begin_src emacs-lisp :tangle no
  (defvar im-consult-source-projects
    (list
     :name     "Projects"
     :narrow   ?a
     :hidden   nil
     :category 'file
     :action  (lambda (it &rest _) (project-switch-project it))
     :items   (lambda () (mapcar #'car project--list)))
    "Projects source for consult-buffer.")

  (im-append! consult-buffer-sources 'im-consult-source-projects)
#+end_src

*** consult-dir: Jump to different places easily in minibuffer
Here is a nice description of the package from it's README:
: Avoid "navigating" long distances when picking a file or directory in any Emacs command that requires one. Think of it like the shell tools autojump, fasd or z but for Emacs.

#+begin_src emacs-lisp
  (defvar consult-dir--my-dirs
    (list
     :name "My favorites"
     :narrow ?m
     :category 'file
     :face 'consult-file
     :items
     (lambda ()
       `("~/Downloads/"
         "~/Documents/"
         "~/Pictures/f3/Camera/"
         "~/Music/"
         "~/Music/mix/"
         "~/Videos/Shows/"
         "~/Videos/Movies/"
         "~/Documents/notes/"
         "~/Documents/notes/img/"
         "~/Workspace/projects/"
         "~/Workspace/temp/"
         "~/Workspace/temp/git/"
         "~/.emacs.d/"
         "~/.local/share/"
         "~/.local/bin/"
         "~/.config/"
         ,(format "/run/media/%s/" (user-login-name))
         ,(format "/run/media/%s/BINGUS/" (user-login-name))))))

  (use-package consult-dir
    :bind (("C-x C-d" . consult-dir)
           :map vertico-map
           ("M-d" . consult-dir))
    :config
    (setq consult-dir-sources '(consult-dir--my-dirs
                                consult-dir--source-bookmark
                                consult-dir--source-recentf
                                consult-dir--source-tramp-local
                                consult-dir--source-default
                                consult-dir--source-project)))
#+end_src

** embark
=embark.el= provides contextual command maps.
  - =M-a= activates command mode. Next key should be command. Do =C-h= to list all commands with their keybindings.
  - Commands are context specific, ie. the commands is based on if currently selected item is a file, folder, buffer etc.
  - It's mostly used within the minnibuffer, some example functions:
    - =M-a w= (~embark-save~) saves the current candidate's text into kill-ring.
    - =M-a i= (~embark-insert~) like the one above but instead of saving to the kill-ring, it directly inserts it to the buffer.
    - =M-a S= (~embark-collect-snapshot~) creates a buffer containing all the candidates.

- To apply an action to multiple items, filter the items first and then do =embark-collect-snapshot=. A buffer will open and you can apply the main action or other actions on the items.

#+begin_src emacs-lisp
  (use-package embark-consult)

  (use-package embark
    :commands (embark embark-act-all)
    :config
    (bind-key (kbd "M-a") #'embark-act)
    (bind-key (kbd "M-A") #'embark-act-all)
    (setq embark-prompter #'embark-completing-read-prompter)
    ;; ^ This directly shows the actions in a completing read window.
    ;; By default, it is set to `embark-keymap-prompter' and you need to
    ;; hit `C-h' to bring this menu up.
    (setq embark-indicators '(embark-highlight-indicator embark-isearch-highlight-indicator))
    ;; ^ I removed embark-mixed-indicator from the list because I'm
    ;; using embark-completing-read-prompter by default which already
    ;; provides same functionality

    ;; Replace describe-symbol with helpful-symbol
    (define-key embark-symbol-map "h" #'helpful-symbol))
#+end_src

*** sudo-file-edit action
Nice little embark action that let's you open files with sudo.

Source: https://karthinks.com/software/fifteen-ways-to-use-embark/
#+begin_src emacs-lisp
  (defun im-sudo-find-file (file)
    "Open FILE as root."
    (interactive "FOpen file as root: ")
    (when (file-writable-p file)
      (user-error "File is user writeable, aborting sudo"))
    (find-file (if (file-remote-p file)
                   (concat "/" (file-remote-p file 'method) ":"
                           (file-remote-p file 'user) "@" (file-remote-p file 'host)
                           "|sudo:root@"
                           (file-remote-p file 'host) ":" (file-remote-p file 'localname))
                 (concat "/sudo:root@localhost:" file))))

  (define-key embark-file-map (kbd "#") 'im-sudo-find-file)
#+end_src

** flycheck
- Use =ge= (=consult-flycheck=) to list and jump any of the errors/warnings in the buffer.
  - Write ~i SPC~, ~w SPC~, ~e SPC~ to show infos, warnings, errors only in the =consult-flycheck=

#+BEGIN_SRC emacs-lisp
  (defun im-flycheck-disable-checkdoc-checker-if-not-needed ()
    "Disable checkdoc on org src, scratch and interaction buffers."
    (when (or (eq major-mode #'lisp-interaction-mode)
              (s-contains? "scratch" (buffer-name))
              (and (eq major-mode #'emacs-lisp-mode) (featurep 'org) (org-src-edit-buffer-p)))
      (flycheck-disable-checker 'emacs-lisp-checkdoc)))

  (use-package flycheck
    :hook ((prog-mode . flycheck-mode))
    :config
    (setq flycheck-idle-change-delay 1)
    (setq flycheck-display-errors-delay 0.3)
    (setq flycheck-emacs-lisp-load-path 'inherit)
    (setq flycheck-emacs-lisp-initialize-packages t)
    (add-hook 'emacs-lisp-mode-hook #'im-flycheck-disable-checkdoc-checker-if-not-needed)
    ;; Not quite sure why but I also need to explicitly add this
    ;; to `org-src-mode-hook'
    (add-hook 'org-src-mode-hook #'im-flycheck-disable-checkdoc-checker-if-not-needed))

  (use-package consult-flycheck
    :after flycheck
    :general
    (:keymap 'flycheck-mode-map :states 'normal
     "ge" #'im-show-error-list))

  (use-package flycheck-posframe
    :straight (:host github :repo "alexmurray/flycheck-posframe")
    :after flycheck
    :hook (flycheck-mode . flycheck-posframe-mode)
    :config
    (setq flycheck-posframe-border-width 2)
    (setq flycheck-posframe-border-use-error-face t)
    (setq flycheck-posframe-position 'window-bottom-center)
    (flycheck-posframe-configure-pretty-defaults))

  (defun im-show-error-list (arg)
    "Show all lsp errors or flycheck erros, depending on which is available."
    (interactive "P")
    (if (bound-and-true-p lsp-mode)
        (consult-lsp-diagnostics arg)
      (consult-flycheck)))
#+END_SRC

** corfu & corfu-doc & kind-icon
- When corfu popup is open
  - ~M-SPC~ to insert a space to be able to filter with orderless.
  - ~M-q~ to show an avy like quick selection keys.
  - ~M-m~ to move completion items to mini-buffer (completing-read).
#+BEGIN_SRC emacs-lisp
  (use-package corfu
    :straight (:files (:defaults "extensions/*.el"))
    :config
    (define-key corfu-map (kbd "M-j") #'corfu-next)
    (define-key corfu-map (kbd "M-k") #'corfu-previous)
    (define-key corfu-map (kbd "RET") #'corfu-complete)

    (set-face-background 'corfu-current "dim gray")
    (setq corfu-cycle t)
    (setq corfu-auto t)
    (setq corfu-auto-prefix 2)
    (global-corfu-mode))

  ;; This is useful because sometimes I just want to collect list of
  ;; completions. With this I can use embark's collect functionality.
  (defun corfu-move-to-minibuffer ()
    (interactive)
    (let ((completion-extra-properties corfu--extra)
          completion-cycle-threshold completion-cycling)
      (apply #'consult-completion-in-region completion-in-region--data)))
  (define-key corfu-map "\M-m" #'corfu-move-to-minibuffer)

  (use-package corfu-quick
    :straight nil
    :after corfu
    :config
    (setq corfu-quick1 "asdfgqwe")
    (setq corfu-quick2 "hjklui")
    (define-key corfu-map "\M-q" #'corfu-quick-insert))

  (use-package kind-icon
    :after corfu
    :config
    (setq kind-icon-default-face 'corfu-default)
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))

  (use-package corfu-popupinfo
    :straight nil
    :after corfu
    :config
    (setq corfu-popupinfo-delay 0)
    (corfu-popupinfo-mode)
    ;; Toggle doc on/off while in corfu
    (define-key corfu-map (kbd "M-d") #'corfu-popupinfo-toggle)
    (define-key corfu-map (kbd "M-p") #'corfu-popupinfo-scroll-down)
    (define-key corfu-map (kbd "M-n") #'corfu-popupinfo-scroll-up))
#+END_SRC

** cape
#+begin_src emacs-lisp
  (use-package cape
    ;; Bind dedicated completion commands
    ;; Alternative prefix keys: C-c p, M-p, M-+, ...
    :bind (("M-o p" . completion-at-point) ;; capf
           ("M-o t" . complete-tag)        ;; etags
           ("M-o d" . cape-dabbrev)        ;; or dabbrev-completion
           ("M-o h" . cape-history)
           ("M-o f" . cape-file)
           ("M-o k" . cape-keyword)
           ("M-o s" . cape-symbol)
           ("M-o a" . cape-abbrev)
           ("M-o i" . cape-ispell)
           ("M-o l" . cape-line)
           ("M-o w" . cape-dict)
           ("M-o \\" . cape-tex)
           ("M-o _" . cape-tex)
           ("M-o ^" . cape-tex)
           ("M-o &" . cape-sgml)
           ("M-o r" . cape-rfc1345))
    :init
    ;; Add `completion-at-point-functions', used by `completion-at-point'.
    ;;(add-to-list 'completion-at-point-functions #'cape-dabbrev)
    ;;(add-to-list 'completion-at-point-functions #'cape-file)
    ;;(add-to-list 'completion-at-point-functions #'cape-history)
    ;;(add-to-list 'completion-at-point-functions #'cape-keyword)
    ;;(add-to-list 'completion-at-point-functions #'cape-tex)
    ;;(add-to-list 'completion-at-point-functions #'cape-sgml)
    ;;(add-to-list 'completion-at-point-functions #'cape-rfc1345)
    ;;(add-to-list 'completion-at-point-functions #'cape-abbrev)
    ;;(add-to-list 'completion-at-point-functions #'cape-ispell)
    ;;(add-to-list 'completion-at-point-functions #'cape-dict)
    ;;(add-to-list 'completion-at-point-functions #'cape-symbol)
    ;;(add-to-list 'completion-at-point-functions #'cape-line)
    )

  (cl-defmacro im-cape
      (&key name generator category bound key annotate (exclusive 'no) kind)
    "Create a cape completion function with given parameters.
  GENERATOR is a function that returns the completion list when
  called.

  BOUND is boundaries of the thing that gets completed. May be
  symbol, word, file etc.

  KEY is key to bind this cape to.

  ANNOTATE is a function that returns annotation for given
  completion. A function called with single argument, current
  completion item.

  KIND is a function that returns the kind for current completion
  item. It should return a symbol like `file' `directory' etc. In
  turn, there is a icon displayed that is associated with the kind
  symbol."
    (let ((cape-fn (intern (format "im-cape-%s" (symbol-name name)))))
      `(progn
         (defun ,cape-fn (&optional interactive)
           (interactive (list t))
           (if interactive
               (cape-interactive #',cape-fn)
             (let ((bounds (cape--bounds ',bound)))
               (append
                (list (car bounds) (cdr bounds)
                      (cape--nonessential-table ,generator)
                      :exclusive ',exclusive)
                (when ,annotate
                  (list :annotation-function ,annotate))
                (when ,kind
                  (list :company-kind ,kind))
                (when ',category
                  (list :category ',category))))))
         (when ,key
           (bind-key ,key #',cape-fn)))))
#+end_src
** lsp-mode
- See: https://emacs-lsp.github.io/lsp-mode/tutorials/how-to-turn-off/
#+BEGIN_SRC emacs-lisp
  (setenv "LSP_USE_PLISTS" "true")
  (use-package lsp-mode
    :hook ((web-mode . lsp)
           (js-mode . lsp)
           (tsx-ts-mode . lsp)
           (typescript-ts-mode . lsp)
           (dhall-mode . lsp)
           (haskell-mode . lsp)
           (kotlin-mode . lsp)
           (rust-mode . lsp)
           (go-mode . lsp)
           (java-mode . lsp)
           (java-ts-mode . lsp)
           ;; See:
           ;; https://github.com/minad/corfu/wiki#configuring-corfu-for-lsp-mode
           ;; Lsp-mode filters candide using the server each time you
           ;; type. Instead of this, we filter candidates on Emacs using
           ;; orderless (so that I can use M-SPC while filtering etc.)
           ;; after the initial candidate list is provided by lsp
           ;; server. I'm not quite sure if this causes some loss of
           ;; candidates but we can always exit the completion and
           ;; re-trigger it to get the fresh list from lsp server.
           (lsp-completion-mode . im-lsp-mode-setup-orderless-completion)
           (lsp-mode . lsp-enable-which-key-integration))
    :commands (lsp lsp-deferred)
    :init
    (setq lsp-use-plists t)
    (setq lsp-keymap-prefix "M-l")
    :config
    (setq lsp-completion-provider :none) ;; for corfu
    (setq lsp-enable-xref t)
    (setq lsp-enable-links t)
    (setq lsp-enable-folding t)
    (setq lsp-enable-symbol-highlighting nil)
    ;; ^ I use highlight-thing instead and it works pretty well.
    (setq lsp-enable-indentation nil)
    (setq lsp-enable-on-type-formatting nil)
    (setq lsp-before-save-edits nil)
    (setq lsp-eldoc-render-all nil)
    (setq lsp-headerline-breadcrumb-enable nil)
    (setq lsp-enable-snippet nil)
    ;; ^ I handle snippets myself with yasnippet
    (setq lsp-ui-doc-include-signature t)
    ;; ^ Show the signature in the doc posframe. This shows the
    ;; posframe even if there is no documentation for the function
    ;; etc.
    (setq lsp-ui-doc-position 'at-point)
    (setq lsp-ui-sideline-show-diagnostics nil)
    ;; ^ Disable showing errors on sideline, because I use
    ;; flycheck-inline already and it does a better job showing
    ;; errors inline
    (setq lsp-modeline-code-actions-enable nil)
    (setq lsp-modeline-diagnostics-enable nil)
    (setq lsp-modeline-workspace-status-enable nil)
    ;; ^ Disable modeline stuff because it's distracting

    (setq
     lsp-imenu-index-symbol-kinds
     '(Module
       File
       Namespace
       Package
       Class
       Method
       Constructor
       Property
       Enum
       Struct
       Field
       Interface
       Function))
    ;; ^ Local variables etc. pollute imenu, so just show these in imenu
    ;; Following are the what's left out: Variable Constant String
    ;; Number Boolean Array Object Key Null Struct Event Operator
    ;; TypeParameter

    (defalias 'im-lsp-list-workspaces #'lsp-describe-session)

    (evil-define-minor-mode-key 'normal 'lsp-mode
      "gr" #'lsp-ui-peek-find-references
      "gd" #'lsp-ui-peek-find-definitions
      "gi" #'lsp-ui-peek-find-implementation
      "ga" #'lsp-execute-code-action
      "K"  #'im-peek-doc))


  (defun im-lsp-mode-setup-orderless-completion ()
    (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
          '(orderless)))

  (defun im-lsp-ui-doc-focus-frame ()
    "Show and focus to the documentation."
    (interactive)
    (unless (lsp-ui-doc-focus-frame)
      (lsp-ui-doc-show)))

  (use-package lsp-ui
    :after lsp
    :commands lsp-ui-mode
    :config
    (setq lsp-ui-sideline-show-code-actions nil))

  ;; consult-lsp-diagnostics and consult-lsp-symbols
  (use-package consult-lsp
    :after lsp
    :config
    (evil-define-key 'normal lsp-mode-map
      (kbd "M-I") 'consult-lsp-symbols))
#+END_SRC

*** lsp-mode & org-mode
#+begin_src emacs-lisp
  (define-advice lsp-org (:before (&rest _) prevent-if-block-is-not-tangled)
    "Error out if current block is not tangled.
  If `lsp-org' is started on a block that has no `:tangle'
  directive, it may mess up files.  Hence I added this advice to
  not fall into this trap."
    (let ((tangle
           (thread-last
             (org-babel-get-src-block-info)
             ;; Get header plist
             (nth 2)
             (alist-get :tangle))))
      (when (or
             (not tangle)
             (s-equals? tangle "no"))
        (user-error ">> Block is not tangled. Not starting LSP. Add :tangle <...> so that LSP mode can work"))))

  (defalias 'im-lsp-org-disconnect #'lsp-virtual-buffer-disconnect)
#+end_src
** dap-mode
Basic workflow is as follows:
- ~dap-breakpoint-add~
- ~dap-debug~
  - You may need to run this on root of your project (like in README etc.) otherwise it may fail.
- When debugger kicks-in, ~dap-hydra~ will be displayed, or you can call it manually anytime you want.
- ~dap-ui-repl~ → This drops you in a REPL where you can run code in the debug context, which is better than the hydra provided eval functionality.

#+begin_src emacs-lisp
  (use-package dap-mode
    :after lsp
    :config
    ;; When debugger kicks-in, run dap-hydra
    (add-hook 'dap-stopped-hook (lambda (arg) (call-interactively #'dap-hydra))))

  (defun im-dap-debug-start ()
    "Like `dap-start' but start debugger at the root of the project.
    Normally `dap-start' uses `default-directory' to start the
    debugger in but it's almost 99% of time not what I want."
    (interactive)
    (if-let ((default-directory (im-current-project-root)))
        (call-interactively #'dap-debug)
      (user-error "Not in a project")))
#+end_src

** vterm
Also check out =~/.zshrc= and =~/.config/zsh/emacs.sh=. These files contains some helpful commands that enriches ~vterm~ usage.

- Use =C-z= to go in/out (you can also use =jk= to go back into normal mode from emacs mode) emacs state so that you can make use of use vi-mode in zsh.

#+BEGIN_SRC emacs-lisp
  (defun evil-collection-vterm-escape-stay ()
    "Go back to normal state but don't move cursor backwards.
    Moving cursor backwards is the default vim behavior but
    it is not appropriate in some cases like terminals."
    (setq-local evil-move-cursor-back nil))

  (use-package vterm
    :hook ((vterm-mode . evil-collection-vterm-escape-stay)
           (vterm-mode . im-disable-hl-line-mode-for-buffer)
           (vterm-mode . evil-emacs-state))
    :general
    (im-leader-v
     "tj" #'im-jump-to-visible-term
     "tl" #'im-run-last-command-on-visible-term
     "ty" #'im-send-selected-text-to-visible-term
     "tr" #'im-run-command-on-visible-term-with-history
     "tn" #'im-vterm-project
     "td" #'im-vterm-dir)
    (:keymaps 'vterm-mode-map :states 'insert
     "C-r" #'vterm--self-insert
     "M-\\" #'vterm--self-insert
     "M--" #'vterm--self-insert
     "C-c" #'vterm--self-insert
     "C-x" #'vterm--self-insert)
    :init
    :config
    (setq vterm-kill-buffer-on-exit t))

  (defun im-vterm-project ()
    "Open vterm for current project."
    (interactive)
    (require 'vterm)
    (when-let ((pname (im-current-project-name)))
      (let* ((vterm-buffer-name (format "*vterm-proj-%s*" pname))
             (default-directory (im-current-project-root))
             (existing (--find
                        (and
                         (s-prefix? "*vterm-proj" (buffer-name it))
                         (equal default-directory (with-current-buffer it default-directory)))
                        (buffer-list))))
        (if existing
            (switch-to-buffer existing)
          (vterm t)))))

  (defun im-vterm-dir ()
    "Open vterm for `default-directory'."
    (interactive)
    (require 'vterm)
    (let* ((vterm-buffer-name (format "*vterm-dir-%s*" (f-filename default-directory)))
           (existing (--find
                      (and
                       (s-prefix? "*vterm-dir" (buffer-name it))
                       (equal default-directory (with-current-buffer it default-directory)))
                      (buffer-list))))
      (if existing
          (switch-to-buffer existing)
        (vterm t))))
#+END_SRC

*** Utility functions
#+begin_src emacs-lisp
  (defun im-run-last-command-on-visible-term ()
    (interactive)
    (save-buffer)
    (or
     (im-with-visible-buffer
      ".*vterm.*"
      (vterm-send-up)
      (vterm-send-return)
      t)
     (im-with-visible-buffer
      ".*eshell.*"
      (eshell-previous-matching-input "" 0)
      (eshell-send-input))))

  (defun im-run-command-on-visible-term (cmd)
    (or
     (im-with-visible-buffer ".*vterm.*"
       (vterm-send-string cmd)
       (vterm-send-return)
      t)
     (im-with-visible-buffer ".*eshell.*"
       (insert cmd)
       (eshell-send-input)))
    cmd)

  (defun im-send-selected-text-to-visible-term (start end)
    (interactive "r")
    (if (use-region-p)
        (im-run-command-on-visible-term (buffer-substring-no-properties start end))
      (im-run-command-on-visible-term (s-trim (buffer-substring-no-properties (line-beginning-position) (line-end-position))))))

  (defvar im-term-run-history '())
  (defvar im-jump-to-term-last-window nil)

  (defun im-jump-to-visible-term ()
    "Jump to the visible term window.
  When invoked in a term window, return back to last window that
  this command is invoked from."
    (interactive)
    (cond
     ((string-match ".*\\(vterm\\|eshell\\).*" (buffer-name (window-buffer (selected-window))))
      (select-window im-jump-to-term-last-window))
     (t
      (setq im-jump-to-term-last-window (selected-window))
      (im-select-window-with-buffer ".*\\(vterm\\|eshell\\).*"))))

  (defun im-run-command-on-visible-term-with-history ()
    (interactive)
    (let ((cmd (im-run-command-on-visible-term
                (completing-read "Run new command: " im-term-run-history))))
      (when cmd
        (setq im-term-run-history (cons cmd (delete cmd im-term-run-history))))))
#+end_src

** moodline modeline
Light weight and nice modeline.

#+begin_src emacs-lisp
  (use-package mood-line
    :straight (:host gitlab :repo "jessieh/mood-line")
    :hook (after-init . mood-line-mode)
    :config
    (set-face-attribute
     'mood-line-unimportant nil
     :foreground "Sky Blue")
    (set-face-attribute
     'mood-line-status-neutral nil
     :foreground "Sky Blue"))
#+end_src

** howdoyou
When you search for something, it opens the results in an org-mode buffer. Results are fetched from SX (stack-exchange, stackoverflow etc) sites.
- =SPC hs= or =howdoyou-query= :: search function
- =C-M-Left= :: prev answer
- =C-M-Right= :: next answer

#+BEGIN_SRC emacs-lisp
  (use-package howdoyou
    :commands (howdoyou-query howdoyou--get-buffer)
    :general
    (:keymaps 'howdoyou-mode-keymap :states '(normal motion)
     "gn" #'howdoyou-next-link
     "gp" #'howdoyou-previous-link)
    (im-leader
     "is" #'howdoyou-query)
    :config
    (setq howdoyou-switch-to-answer-buffer t)
    (setq howdoyou-number-of-answers 5))

  (defun im-open-stackexchange-link (link)
    "Open stackexchange LINK in a nicely formatted org buffer."
    (interactive "sLink: ")
    (switch-to-buffer (howdoyou--get-buffer))
    (insert "Loading...")
    (let ((buffer (current-buffer)))
      (promise-chain (howdoyou-read-so-link link)
        (then #'(lambda (_)
                  (im-url-get-title-async
                   link
                   (lambda (title)
                     (with-current-buffer buffer (rename-buffer (format "*se: %s*" title) :unique)))))))))
#+END_SRC

** tldr
tldr client for Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package tldr
    :commands tldr
    :general
    (im-leader
      "it" #'tldr))
#+END_SRC

** yasnippet & yankpad: template manager
#+begin_src emacs-lisp
  (use-package yasnippet
    :hook
    ((minibuffer-setup . yas-minor-mode)
     ;; ^ Enable expanding in mini-buffer.
     (after-init . yas-global-mode)))

  (use-package yankpad
    :after yasnippet
    :demand t
    :general
    (im-leader
      "sr" #'yankpad-reload
      "sc" #'yankpad-set-category
      "se" #'yankpad-edit
      "ss" #'yankpad-map
      "sm" #'yankpad-map)
    (:states 'insert
     (kbd "M-s") #'yankpad-insert
     (kbd "M-e") #'hippie-expand)
    (:keymaps 'minibuffer-local-map
     (kbd "M-s") #'yankpad-insert
     (kbd "M-e") #'hippie-expand)
    :config
    (setq yankpad-file snippets-org)
    (add-to-list 'hippie-expand-try-functions-list #'yankpad-expand)

    ;; Categories returned by the following functions will be used to
    ;; expand snippets
    (setq
     yankpad-auto-category-functions
     '(yankpad-major-mode-category im-current-project-name)))
#+end_src

I also like to use these snippets outside of Emacs. For this, I defined =im-select-any-snippet=. It let's you select any snippet from the yankpad file (no mode restriction, shows all snippets prefixed with mode name they are defined for) through =completing-read=. Combined with [[id:30465D2E-AB40-4E53-B6EA-9D72F7242700][im-globally]], you can use this outside of Emacs.

#+begin_src emacs-lisp
  (defvar im--all-snippets-cache nil)

  (defun im-load-snippets-list ()
    (interactive)
    (message ">> Loading snippets...")
    (async-start
     `(lambda ()
        ,(async-inject-variables "^load-path$")
        (require 'dash)
        (require 'yankpad)
        ,(async-inject-variables "^yankpad-file$")
        (-mapcat
         (lambda (category)
           (--map (cons (format "%s :: %s" category (car it)) it)
                  ;; Clear some sections of the data that causes
                  ;; issues with emacs-async. It prints out some data
                  ;; like #3 #5 etc. which can't be `read'.
                  (--map
                   (if (alist-get 'src-block (nth 2 it))
                       `(,@(-take 2 it) nil ,@(-take-last 2 it))
                     it)
                   (ignore-errors
                     (yankpad--snippets category)))))
         (yankpad--categories)))
     (lambda (result)
       (message ">> Loading snippets... Done")
       (setq im--all-snippets-cache result))))

  ;; Load snippets for the first time, after the startup
  ;; This may take a bit of time
  (with-eval-after-load 'org
    (run-with-timer 5 nil #'im-load-snippets-list))

  (defun im-select-any-snippet ()
    "List all templates for all modes and return the applied template
  as string."
    (interactive)
    (-let* ((selected (completing-read "Select snippet: " im--all-snippets-cache))
            (snippet (alist-get selected im--all-snippets-cache nil nil #'equal))
            ((_ category _) (s-match "\\(.*\\) :: \\(.*\\)" selected)))
      (with-temp-buffer
        (setq yankpad-category category)
        ;; Activate yas snippet on the temp buffer
        (let ((yas-dont-activate-functions '()))
          (yas-minor-mode-on))
        (yankpad--run-snippet snippet)
        (im-kill (buffer-string)))))
#+end_src

** git-link
#+begin_src emacs-lisp
  (use-package git-link
    :demand t
    :general
    (im-leader-v
      "glm" #'im-git-link-merge-requests
      "gll" #'im-git-link-on-branch
      "glL" #'im-git-link-commit
      "glc" #'git-link-commit
      "glh" #'git-link-homepage)
    :config
    (setq git-link-open-in-browser t))

  (defun im-git-link-homepage ()
    "Like git-link-homepage itself but it does not open in browser, simply returns the address as string."
    (interactive)
    (let ((git-link-open-in-browser nil))
      (call-interactively 'git-link-homepage)
      (car kill-ring)))

  (defun im-git-link-on-branch (branch)
    "Like `git-link' but let's you select the branch first when called interactively."
    (interactive
     (list
      (completing-read
       "Select a branch: "
       (vc-git-branches)
       nil nil (lab-git-current-branch))))
    (let ((git-link-default-branch branch))
      (call-interactively 'git-link)))

  (defun im-git-link-commit ()
    "Like `git-link' but use commit hash in url."
    (interactive)
    (let ((git-link-use-commit t))
      (call-interactively 'git-link)))

  (defun im-git-link-merge-requests ()
    "Open MR page."
    (interactive)
    (browse-url
     (let ((homepage (im-git-link-homepage)))
       (cond
        ((s-contains? "gitlab" homepage) (concat homepage "/-/merge_requests"))
        ((s-contains? "github" homepage) (concat homepage "/pulls"))
        (t (user-error "Forge undefined."))))))
#+end_src

** tab-out
When you press tab, jump out from the current enclosing parens/quotes etc. When there is no enclosing stuff, TAB key automatically fallbacks to it's default behavior.

#+begin_src emacs-lisp
  (use-package tab-jump-out
    :diminish
    :straight (:host github :repo "zhangkaiyulw/tab-jump-out")
    :config
    ;; This is not defined as a global minor mode, so define one and enable it
    (define-globalized-minor-mode global-tab-jump-out-mode tab-jump-out-mode
      (lambda ()
        (tab-jump-out-mode)
        (push "/" tab-jump-out-delimiters)
        (push "=" tab-jump-out-delimiters)))
    (global-tab-jump-out-mode 1))
#+end_src

** completing-read-xref
Provides an interface to xref based on completing-read.

#+begin_src emacs-lisp
  (use-package completing-read-xref
    :diminish
    :straight (:host github :repo "travitch/completing-read-xref.el")
    :config
    (setq xref-show-definitions-function #'completing-read-xref-show-defs))
#+end_src
** helpful and elisp-demos
- helpful :: Better help dialogs with syntax highlighting, references, source etc.
- elisp-demos :: Adds code examples into function help buffers.
  - Code examples are maintained [[https://github.com/xuchunyang/elisp-demos/blob/master/elisp-demos.org][here]], don't forget to contribute!
  - Call ~elisp-demos-add-demo~ to add a demo locally.

#+begin_src emacs-lisp
  (use-package helpful
    ;; Override default help bindings
    :bind (("C-h f" . helpful-callable)
           ("C-h v" . helpful-variable)
           ("C-h k" . helpful-key)
           ("C-h p" . helpful-at-point))
    :config
    (evil-define-key 'normal helpful-mode-map
      "q" 'evil-delete-buffer))

  (use-package elisp-demos
    :after helpful
    :config
    (advice-add 'helpful-update :after #'elisp-demos-advice-helpful-update))
#+end_src

Here, I also bind some keys for convenience. Taken from [[https://github.com/radian-software/radian/blob/23e80b3d865bfb60b166309249ac4db2b176b9fc/emacs/radian.el#LL3970C1-L3982C1][here]].

#+begin_src emacs-lisp
  (bind-key "C-h C-f" #'find-function)
  (bind-key "C-h C-v" #'find-variable)
  (bind-key "C-h C-l" #'find-library)
#+end_src

** expand-region
#+begin_src emacs-lisp
  (use-package expand-region
    :bind (:map evil-normal-state-map ("M-w" . er/expand-region))
    :config
    (setq er/try-expand-list (append er/try-expand-list '(im-tree-sitter-mark-bigger-node))))

  (defun im-tree-sitter-mark-bigger-node ()
    "Select the next parent node.
  Adapted to emacs 29 treesit from: https://github.com/emacs-tree-sitter/elisp-tree-sitter/issues/20"
    (interactive)
    (let* ((node (treesit-node-descendant-for-range
                  (treesit-buffer-root-node) (region-beginning)
                  (if (use-region-p) (region-end) (point))))
           (node-start (treesit-node-start node))
           (node-end (treesit-node-end node)))
      ;; Node fits the region exactly. Try its parent node instead.
      (when (and (= (region-beginning) node-start) (= (region-end) node-end))
        (when-let ((node (treesit-node-parent node)))
          (setq node-start (treesit-node-start node)
                node-end (treesit-node-end node))))
      (set-mark node-end)
      (goto-char node-start)))
#+end_src
** aggressive-indent
It keeps your indentation working all the time. Seems like a good idea but I have some concerns about it, so I just use it with elisp for the time being.

#+begin_src emacs-lisp
  (use-package aggressive-indent
    :hook (emacs-lisp-mode . aggressive-indent-mode)
    :config
    (add-to-list 'aggressive-indent-protected-commands 'evil-undo)
    (add-to-list 'aggressive-indent-protected-commands 'format-all-buffer))
#+end_src
** xmodmap-mode
Simple mode for editing =~/.Xmodmap= file.
- [[https://www.emacswiki.org/emacs/XModMapMode][Source]]

#+begin_src emacs-lisp
  (define-generic-mode 'xmodmap-mode
    '(?!)
    '("add" "clear" "keycode" "keysym" "pointer" "remove")
    nil
    '("[xX]modmap\\(rc\\)?\\'")
    nil
    "Simple mode for xmodmap files.")
#+end_src
** slack
#+begin_src emacs-lisp
  (use-package slack
    :straight (:host github :repo "isamert/emacs-slack")
    :defer t
    :general
    (im-leader
     "ess" #'im-slack-select-rooms
     "esS" #'slack-select-unread-rooms
     "esm" #'im-slack-send-message
     "esr" #'im-slack-recent-messages
     "esl" #'im-slack-open-last-message
     "esy" #'im-slack-yank-last-message)
    :config
    (setq slack-log-level 'error)
    ;; ^ info level shows unnecessary stuff that distracts me
    (setq slack-buffer-emojify nil)
    (setq slack-render-image-p t)
    (setq slack-image-max-height nil)
    (setq slack-prefer-current-team t)
    ;; ^ Set current team with `slack-change-current-team'
    (setq slack-buffer-function #'switch-to-buffer-other-window)

    ;; Disable filling as it fucks with copying stuff
    (setq lui-fill-type nil)
    (setq slack-message-custom-notifier #'im-slack-notify)
    (setq slack-message-custom-delete-notifier #'im-slack-notify)

    (defun im-slack-select-rooms ()
      (interactive)
      (let ((slack-buffer-function #'switch-to-buffer))
        (slack-select-rooms)))

    (defun im-slack--add-reaction-to-message (reaction)
      (defalias (intern (concat "react-" reaction))
        `(lambda ()
           (interactive)
           (slack-buffer-add-reaction-to-message
            slack-current-buffer
            ,reaction
            (slack-get-ts)))))

    (evil-set-initial-state 'slack-mode-map 'normal)

    (evil-define-key 'normal slack-message-edit-buffer-mode-map
      "@"  #'slack-message-embed-mention
      "mc" #'slack-message-embed-channel)
    (evil-define-key 'normal slack-message-compose-buffer-mode-map
      "@"  #'slack-message-embed-mention
      "mc" #'slack-message-embed-channel))

  (defun im-slack-initialize ()
    (interactive)
    (ignore-errors (slack-ws-close))
    (ignore-errors (slack-team-delete))
    (slack-register-team
     :name ty-slack-name
     :token ty-slack-token
     :cookie ty-slack-cookie
     :subscribed-channels ty-slack-channels)
    (slack-start)
    (slack-change-current-team)
    (im-slack-initialize-keymaps))

  (defvar im-slack-dnd nil)
  (defvar im-slack--last-messages '())

  (defun im-slack-toggle-dnd ()
    (interactive)
    (message "slack :: DND is %s." (setq im-slack-dnd (not im-slack-dnd))))

  (defun im-slack-notify (message room team)
    (when (or
           (slack-message-minep message team)
           (slack-mpim-p room)
           (slack-message-notify-p message room team))
      (let* ((sender-name (slack-message-sender-name message team))
             (room-name (slack-room-name room team))
             (title (format "%s - %s" room-name sender-name))
             (msg-str (im-slack--stringify-message
                       (list :message message :team team))))
        (push
         (list :room room
               :team team
               :message message
               :sender-name sender-name
               :room-name room-name
               :title title
               :message-string msg-str)
         im-slack--last-messages)
        (unless (or (slack-message-minep message team)
                    (s-contains? "message deleted" msg-str)
                    (s-contains? "has joined the" msg-str)
                    (s-contains? "has left the" msg-str)
                    ;; Dont show notifications for visible slack windows if emacs is not idle
                    (and
                     (< (time-to-seconds (or (current-idle-time) 0)) 15)
                     (--some
                      (s-contains? room-name it)
                      (--map (buffer-name (window-buffer it)) (window-list)))))
          ;; Only send desktop notifications for the things I'im interested
          ;; mpim || group || in subscribed channels
          (when (slack-message-notify-p message room team)
            ;; msg-str sometimes causes errors with `alert'. Thats why I
            ;; used `ignore-errors'.
            (ignore-errors
              (unless im-slack-dnd
                (alert
                 msg-str
                 :title title
                 :category "slack"))))
          (unless im-slack-dnd
            (message
             ">> Slack: %s // %s"
             title
             (car (s-split "\n" msg-str))))))))

  (defun im-slack-yank-last-message ()
    "Yank the contents of the last received message as text."
    (interactive)
    (im-kill
     (im-slack--stringify-message
      (im-slack--last-message))))

  (defun im-slack-open-last-message ()
    "Open last room that got new message."
    (interactive)
    (im-slack--open-message-or-thread (im-slack--last-message)))

  (defun im-slack--open-message-or-thread (msg)
    (let-plist msg
      (if (ignore-errors (slack-thread-message-p .message))
          (slack-thread-show-messages .message .room .team)
        (slack-room-display
         .room
         .team))
      ;; Focus the message on buffer
      (run-with-timer
       1.3 nil
       (lambda () (slack-buffer-goto (slack-ts .message))))))

  (defalias 'im-slack-recent-messages #'im-slack-last-messages)

  (defun im-slack-last-messages ()
    "List and open rooms that had new messages in them recently."
    (interactive)
    (im-slack--open-message-or-thread
     (im-completing-read
      "Select message: "
      im-slack--last-messages
      :sort? nil
      :formatter
      (lambda (it)
        (let-plist it (format "%s (%s: %s)" .room-name .sender-name .message-string))))))

  (defun im-slack-send-message (msg)
    "Send given MSG or selected region as message to interactively
    selected user."
    (interactive
     (list
      (if (use-region-p)
          (let ((text (buffer-substring-no-properties (region-beginning) (region-end))))
            (if (y-or-n-p "Wrap with backticks? ")
                (format "```\n%s\n```" text)
              text))
        (read-string "Enter message: "))))
    "Send MSG to interactively selected room."
    (-let* (((room team) (im-slack--select-room)))
      (slack-message-send-internal
       msg room team)))

  (defun im-slack-clipboard-image-upload ()
    "Uploads png image from clipboard.

    The default `slack-clipboard-image-upload' was not working
    properly in MacOS."
    (interactive)
    (unless (im-clipboard-contains-image-p)
      (user-error "No image in clipboard."))
    (let* ((file (make-temp-file "clip" nil ".png")))
      (im-save-clipboard-image-to-file file)
      (slack-file-upload file "png" "image.png")))

  ;; TODO multiple message quote
  (defun im-slack-quote-message ()
    (interactive)
    (let ((quote-text (->>
                       (im-slack-current-message-content)
                       (substring-no-properties)
                       (s-trim)
                       (s-split "\n")
                       (-drop 1)
                       (--map (concat "> " it))
                       (s-join "\n")
                       (s-append "\n"))))
      (slack-message-write-another-buffer)
      (insert quote-text)))

  (defun im-slack-current-message-content ()
    (slack-if-let* ((buf slack-current-buffer)
                    (team (slack-buffer-team buf))
                    (room (slack-buffer-room buf))
                    (message (slack-room-find-message room (slack-get-ts))))
        (slack-message-to-string message team)))

  (defun im-slack-open-link (link)
    (interactive
     (list
      (read-string "Link: " (thing-at-point 'url))))
    (let* ((m (s-match
               "https://\\(\\w+\\).slack.com/archives/\\(\\w+\\)/p\\(\\w+\\).*\\(\\?thread_ts=\\(\\w+\\)\\)?"
               link))
           (team (--find (string= (oref it domain) (nth 1 m))
                         (hash-table-values slack-teams-by-token)))
           (room (slack-room-find (nth 2 m) team))
           (message-ts (number-to-string (/ (string-to-number (nth 3 m)) 1000000.0)))
           (message (slack-room-find-message room message-ts))
           (thread (nth 4 m)))
      (im-slack--open-message-or-thread (list :message message :room room :team team))
      thread))

  ;;
  ;; Utils/internals
  ;;

  (defun im-slack--last-message ()
    (--find (not (s-matches? ".*\\(alert\\|practice\\).*" (plist-get it :room-name))) im-slack--last-messages))

  (defun im-slack--stringify-message (msg)
    (let ((message (plist-get msg :message))
          (team (plist-get msg :team)))
      (slack-message-to-alert message team)))

  (defun im-slack--select-room ()
    "Select interactively and return (room team) pair."
    (let* ((team (slack-team-select))
           (room (slack-room-select
                  (cl-loop for team in (list team)
                           append (append (slack-team-ims team)
                                          (slack-team-groups team)
                                          (slack-team-channels team)))
                  team)))
      (list room team)))

  (defun im-slack-initialize-keymaps ()
    (interactive)
    (dolist (mode-map (list slack-message-buffer-mode-map slack-thread-message-buffer-mode-map))
      (evil-define-key* '(normal motion) mode-map
        "q" #'im-quit

        "@" 'slack-message-embed-mention
        "mc" 'slack-message-embed-channel ;
        "mm" 'slack-message-write-another-buffer
        "md" 'slack-message-delete
        "ml" 'slack-message-copy-link
        "me" 'slack-message-edit
        "mt" 'slack-thread-show-or-create
        "mq" 'im-slack-quote-message

        "mrr" 'slack-message-add-reaction
        "mR" 'slack-message-remove-reaction
        "mrs" (im-slack--add-reaction-to-message "seen")
        "mr1" (im-slack--add-reaction-to-message "+1")
        "mr2" (im-slack--add-reaction-to-message "ok_hand")
        "mr3" (im-slack--add-reaction-to-message "eyes")
        "mr4" (im-slack--add-reaction-to-message "ultrafastparrot")
        "mr5" (im-slack--add-reaction-to-message "pepedance")
        "mrp" (im-slack--add-reaction-to-message "pray")

        "[[" 'slack-buffer-goto-prev-message
        "]]" 'slack-buffer-goto-next-message)))
#+end_src

** prodigy
#+begin_src emacs-lisp
  (use-package prodigy
    :straight (:host github :repo "rejeep/prodigy.el")
    :hook (after-init . im-prodigy-autostart)
    :demand t
    :general
    (im-leader
     "et" #'prodigy)
    :config
    (evil-define-key 'normal prodigy-mode-map
      "m" #'prodigy-mark
      "u" #'prodigy-unmark
      "x" #'prodigy-stop
      "S" #'prodigy-start
      "r" #'prodigy-restart
      "R" #'prodigy-refresh
      "f" #'prodigy-jump-file-manager
      "M" #'prodigy-jump-magit
      "t" #'prodigy-add-tag-filter
      "T" #'prodigy-clear-filters
      (kbd "RET") #'prodigy-display-process))

  (defun im-prodigy-autostart ()
    "Start all services with the `:auto-start' set to non-nil if they
  are not already started."
    (interactive)
    (prodigy-with-refresh
     (--each
         prodigy-services
       (when (and (plist-get it :auto-start)
                  (not (prodigy-service-started-p it)))
         (prodigy-start-service it)))))
#+end_src
** poporg
Pop current comment section into an org (or markdown, as it's more widely used for comments) buffer and edit it there. Pretty useful for writing long comments. Use ~poporg-dwim~ on a comment/comment block.

#+begin_src emacs-lisp
  (use-package poporg
    :bind (:map evil-normal-state-map ("gm" . poporg-dwim))
    :config
    (remove-hook 'poporg-edit-hook 'org-mode)
    (add-hook 'poporg-edit-hook 'markdown-mode)
    (add-hook 'poporg-edit-hook (lambda () (setq header-line-format "`SPC fs' → save and quit, C-c C-c → save")) 90))
#+end_src
** nov.el
For reading epub files.

#+begin_src emacs-lisp
  (use-package justify-kp
    :defer t
    :straight (:host github :repo "Fuco1/justify-kp"))

  (use-package nov
    :mode "\\.epub\\'"
    :config
    ;; Just copied the configuration below from
    ;; https://depp.brause.cc/nov.el/

    (require 'justify-kp)
    (setq nov-text-width t)
    (setq nov-text-width 120)
    (setq visual-fill-column-center-text t)

    (add-hook 'nov-mode-hook 'visual-line-mode)
    (add-hook 'nov-mode-hook 'visual-fill-column-mode)

    (defun im-nov-window-configuration-change-hook ()
      (im-nov-post-html-render-hook)
      (remove-hook 'window-configuration-change-hook
                   'im-nov-window-configuration-change-hook
                   t))

    (defun im-nov-post-html-render-hook ()
      (if (get-buffer-window)
          (let ((max-width (pj-line-width))
                buffer-read-only)
            (save-excursion
              (goto-char (point-min))
              (while (not (eobp))
                (when (not (looking-at "^[[:space:]]*$"))
                  (goto-char (line-end-position))
                  (when (> (shr-pixel-column) max-width)
                    (goto-char (line-beginning-position))
                    (pj-justify)))
                (forward-line 1))))
        (add-hook 'window-configuration-change-hook
                  'im-nov-window-configuration-change-hook
                  nil t)))

    (add-hook 'nov-post-html-render-hook 'im-nov-post-html-render-hook))
#+end_src
** all-the-icons
- You should run =all-the-icons-install-fonts= command after this. Also run =fc-cache -f -v= afterwards (=all-the-icons-install-fonts= already does that but it may fail).
- =all-the-icons-completion= gives you icons in completion UI, like in =completing-read= etc.

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)
  (use-package all-the-icons-completion
    :after (all-the-icons vertico)
    :config
    (all-the-icons-completion-mode +1))
#+END_SRC
** reddigg
It lets me display comments of given reddit thread in an org buffer using the =reddigg-view-comments= function.

#+begin_src emacs-lisp
  (use-package reddigg
    :defer t
    :config
    (setq reddigg-convert-md-to-org t))
#+end_src

** jq-mode
A mode for editing ~jq~ scripts. Mostly using it for ~jq-interactively~ function which enables you to write a jq query and update the buffer accordingly in real time.

#+begin_src emacs-lisp
  (use-package jq-mode
    :mode "\\.jq\\'"
    :commands jq-interactively)
#+end_src
** imenu-list
You can also do ~consult-imenu~ and ~embark-collect~ but it does not have a refresh feature.

#+begin_src emacs-lisp
  (use-package imenu-list
    :defer t
    :init
    (im-leader "il" #'imenu-list))
#+end_src
** webpaste
#+begin_src emacs-lisp
  (use-package webpaste
    :defer t
    :config
    (setq webpaste-open-in-browser t))
#+end_src
** wolfram
Easy way to interact with WolframAlpha. I generally use it for unit conversions or stuff like that.

#+begin_src emacs-lisp
  (use-package wolfram
    :straight (:host github :repo "hsjunnesson/wolfram.el")
    :defer t
    :init
    (im-leader "iw" #'wolfram-alpha)
    :config
    (setq wolfram-alpha-app-id im-wolfram-alpha-app-id))
#+end_src
** org-ai
There are bunch of Emacs-ChatGPT integrations and org-ai seems to be best as it fits my workflow quite well. Besides being useful in org-mode, it also has org-mode independent features.

#+begin_src emacs-lisp
  (use-package org-ai
    :straight (:host github :repo "rksm/org-ai")
    :hook (org-mode . org-ai-mode)
    :config
    ;; (setq org-ai-default-chat-model "gpt-4")
    (setq org-ai-default-max-tokens 2000)
    (setq org-ai-openai-api-token im-openai-api-key))
#+end_src
** tmr.el -- timers, reminders etc.
Pretty timers. I forget everything, so it's quite important for me to have a quick way to define timers. I was using ~appt-add~ for this before but it does not let you view/manipulate upcoming timers easily and tmr does this very well with ~tmr-tabulated-view~.

- tmr :: To quickly define a timer, without any description.
- tmr-with-details :: Define a timer with description, also asks if you need acknowledgment. Acknowledgment is useful in a sense that you can re-schedule the timer if you need it. It will ask you to write ~ack~ when the time is up, if you are not ready, you can re-schedule the timer with the same notation you use while creating it which is super convenient.

#+begin_src emacs-lisp
  (use-package tmr
    :defer t
    :init
    (im-leader "T" #'tmr-with-details)
    :config
    ;; Replace the notification function so that it works on my Mac
    (remove-hook 'tmr-timer-finished-functions #'tmr-notification-notify)

    ;; Acknowledge using the GUI dialog as it requires mouse which makes
    ;; me more conscious (and also works when emacs is unfocued)
    (remove-hook 'tmr-timer-finished-functions #'tmr-acknowledge-minibuffer)
    (add-hook 'tmr-timer-finished-functions #'im-tmr-ack 90)

    (add-hook 'tmr-timer-finished-functions #'im-tmr-notify)
    (when (eq system-type 'darwin)
      (setq tmr-sound-file "/System/Library/Sounds/Glass.aiff"))

    ;; evilify
    (with-eval-after-load 'tmr-tabulated
      (define-key tmr-tabulated-mode-map "j" #'next-line)
      (define-key tmr-tabulated-mode-map "k" #'previous-line)
      (define-key tmr-tabulated-mode-map "x" #'tmr-remove)
      (define-key tmr-tabulated-mode-map "d" #'tmr-remove)
      (evil-set-initial-state 'tmr-tabulated-mode 'emacs))

    ;; Show upcoming timers in global-mode-string
    (setq global-mode-string (append global-mode-string '(im-tmr-upcoming-string)))
    (run-with-timer 1 15 #'im-tmr-format-upcoming))

  (defun im-tmr-ack (timer)
    (when (tmr--timer-acknowledgep timer)
      (im-force-focus-emacs)
      ;; Doing jk escapes the acknowledge dialog, so I disable it here
      (let ((evil-escape-inhibit t))
        (tmr-acknowledge-minibuffer timer))))

  (defun im-tmr-notify (timer)
    (alert
     (tmr--long-description-for-finished-timer timer)
     :title "TMR"
     :severity tmr-notification-urgency))

  (defvar im-tmr-upcoming-string nil)
  (put 'im-tmr-upcoming-string 'risky-local-variable t) ;; This is required to make propertize work

  (defun im-tmr-format-upcoming ()
    (setq
     im-tmr-upcoming-string
     (-some->>
         tmr--timers
       (--filter (and (not (tmr--timer-finishedp it))
                      (let ((remaining (- (float-time (tmr--timer-end-date it))
                                          (float-time))))
                        (<= remaining 300))))
       (--map (format "%s (%s)"
                      (propertize (tmr--timer-description it) 'face 'underline)
                      (propertize (tmr--format-remaining it) 'face 'italic)))
       (s-join ", ")
       (s-prepend " «")
       (s-append "» ")))
    (force-mode-line-update t))
#+end_src
** lab.el -- gitlab integration
#+begin_src emacs-lisp
  (use-package lab
    :straight (:host github :repo "isamert/lab.el")
    :demand t ;; I use some functions from this package
    :general
    (im-leader
     "gmb" #'lab-list-branch-merge-requests
     "gmm" #'lab-list-my-merge-requests
     "gma" #'lab-list-group-merge-requests
     "gmp" #'lab-list-project-merge-requests
     "gmc" #'lab-create-merge-request)
    :init
    ;; Add advices for automatically starting to watch pipelines
    (with-eval-after-load 'magit
      (define-advice magit-push-current-to-pushremote (:after (&rest _) start-watching-pipeline)
        (lab-watch-pipeline-for-last-commit)))
    (with-eval-after-load 'vc
      (define-advice vc-push (:after (&rest _) start-watching-pipeline)
        (lab-watch-pipeline-for-last-commit)))
    :config
    ;; Automatically refresh projects list after cloning a project
    (add-hook 'lab-after-git-clone-functions #'im-load-projects-list)
    ;; And jump to that project
    (add-hook 'lab-after-git-clone-functions (lambda () (dired default-directory)))

    (setq lab-projects-directory "~/Workspace/projects/")
    (setq lab-main-branch-name "master")
    (setq lab-pipeline-watcher-initial-delay 45)
    (setq lab-host ty-gitlab-url)
    (setq lab-token ty-gitlab-token)
    (setq lab-group ty-gitlab-group)
    (setq lab-should-open-pipeline-on-manual-action? t))
#+end_src
** activity-watch-mode
#+begin_src emacs-lisp
  (use-package activity-watch-mode
    :straight (:host github :repo "pauldub/activity-watch-mode")
    :hook (after-init . global-activity-watch-mode)
    :config
    (setq activity-watch-project-name-resolvers '(im)))

  (defun activity-watch-project-name-im ()
    (im-current-project-name))
#+end_src
** swagg.el -- Swagger UI
#+begin_src emacs-lisp
  (use-package swagg
    :straight (:host github :repo "isamert/swagg.el"))
#+end_src
* Editing
** Breaking long texts/comments into multiple lines
I use =M-q= (=fill-paragraph=) to break long texts into multiple lines. It
also works well within comment sections. 80 col length is quite
readable. See how this item is formatted, it's done automatically by
the usage of =M-q=.


  #+begin_src emacs-lisp
    (setq fill-column 80)


  #+end_src

** Spell checking (flyspell) & dictionaries & translation
- Use =flyspell-mode= to start spell checking.
- Use =ispell-change-dictonary= to change dictionaries.
- ~z=~ or ~zw~ to correct current spelling mistake.
  - ~C-u zw~ to correct all mistakes in order.

*** Configuration
See [[https://isamert.net/2021/01/31/emacs-te-turkce-imla-denetimi.html][this]] for rationale behind the following configuration.

#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :straight (:type built-in)
    :hook ((org-mode . flyspell-mode)
           (markdown-mode . flyspell-mode)
           (text-mode . flyspell-mode)
           (prog-mode . flyspell-prog-mode))
    :config
    (setq ispell-program-name "hunspell"
          ispell-local-dictionary "en_US"
          ispell-local-dictionary-alist
          '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)
            ("tr_TR" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "tr_TR") nil utf-8))))
#+END_SRC

*** flyspell-correct
Better way to correct spelling mistakes. By default it uses completing-read. This also makes it easy to save words into personal dictonary or silence warnings for session because it shows these options in the correction menu.
#+begin_src emacs-lisp
  (use-package flyspell-correct
    :after flyspell
    ;; Rebind default evil ispell keys to flyspell-correct ones
    :general
    (:keymaps 'evil-normal-state-map
     "z=" #'flyspell-correct-at-point
     ;; This goes to nearest spelling mistake.
     ;; If called with C-u, it goes into rapid mode where you correct all mistakes in order.
     "zw" #'flyspell-correct-wrapper))
#+end_src

*** synosaurus & wordnut
Both synosaurus and wordnut uses ~wordnet~ to work.
- Use ~synosaurus-choose-and-replace~ to replace the current word with one of it's synonyms.

#+begin_src emacs-lisp
  (use-package synosaurus
    :commands synosaurus-choose-and-replace
    :init
    (im-leader "mr" #'synosaurus-choose-and-replace)
    :config
    (setq synosaurus-choose-method nil))

  (use-package wordnut)
#+end_src

*** sozluk.el
Turkish dictionary.

#+begin_src emacs-lisp
  (use-package sozluk
    :straight (:host github :repo "isamert/sozluk.el")
    :defer t
    :config
    ;; (setq sozluk-include-etymology-on-sozluk t)
    (setq sozluk-deasciify-if-not-found t))

  ;; This is an optional dependency for sozluk.
  (use-package turkish :after sozluk)
#+end_src

*** Etymology lookup inside Emacs
#+begin_src emacs-lisp
  (defun im-etymology-en (input)
    "Find and retrieve the given word etymology from etymonline.
  Adapted from: https://babbagefiles.xyz/emacs_etymologies/"
    (interactive
     (list (read-string "Word: " (im-region-or 'word))))
    (let* ((buffer (generate-new-buffer (format "*etymology: %s*" input))))
      (switch-to-buffer buffer)
      (insert (shell-command-to-string (concat "links -dump http://www.etymonline.com/word/" input)))
      (goto-char (point-min))
      (if (re-search-forward "Error 404 (Not Found)" nil t)
          (progn
            (kill-buffer)
            (user-error "Word not found: %s" input))
        (progn
          (delete-region (point-min) (progn
                                       (goto-char (point-min))
                                       (search-forward "[\s\s]")))
          (delete-region (progn
                           (goto-char (point-max))
                           (search-backward-regexp "See all related words"))
                         (point-max))))
      (goto-char (point-min))))
#+end_src
*** go-translate -- Google translate
This is a quite powerful package but implemented a bit weirdly. No
minor/major modes etc. So it's kind of hard to bind anything in
translation buffer without fiddling with advices etc. but I don't
think it's really required. Only binding you need to know is ~h~ (hit it
on either in insert or emacs mode) to list all available options. For
example, hitting ~y~ will speak the word using the translation engine.

#+begin_src emacs-lisp
  (use-package go-translate
    :commands gts-do-translate
    :config
    (setq gts-translate-list '(("en" "tr") ("tr" "en")))
    (setq gts-buffer-follow-p t)
    (setq gts-default-translator
          (gts-translator
           :picker (gts-prompt-picker)
           :engines (list (gts-google-engine) (gts-bing-engine) (gts-stardict-engine))
           :render (gts-buffer-render))))
#+end_src

** string-inflection
- In the case of =string-inflection-ruby-style-cycle=   : ~emacs_lisp => EMACS_LISP => EmacsLisp => emacs_lisp~
- In the case of =string-inflection-python-style-cycle= : ~emacs_lisp => EMACS_LISP => EmacsLisp => emacs_lisp~
- In the case of =string-inflection-java-style-cycle=   : ~emacsLisp => EMACS_LISP => EmacsLisp => emacsLisp~
- In the case of =string-inflection-all-cycle=          : ~emacs_lisp => EMACS_LISP => EmacsLisp => emacsLisp => emacs-lisp => Emacs_Lisp => emacs_lisp~

#+begin_src emacs-lisp
  (use-package string-inflection
    :bind (:map evil-normal-state-map ("M-c" . string-inflection-all-cycle)))
#+end_src

** smartparens
#+begin_src emacs-lisp
  (use-package smartparens
    :general
    (general-def
      :states 'insert
      :keymaps '(override)
      "M-[" #'sp-forward-barf-sexp
      ;; sp-forward-slurp-sexp does not work well with C-like languages,
      ;; hence I use sp-slurp-hybrid-sexp
      "M-]" #'sp-slurp-hybrid-sexp
      "M-{" #'sp-backward-slurp-sexp
      "M-}" #'sp-backward-barf-sexp
      "M-k" #'sp-splice-sexp
      "M-]" (general-predicate-dispatch #'sp-slurp-hybrid-sexp
              (-contains? '(emacs-lisp-mode lisp-interaction-mode) major-mode) #'sp-forward-slurp-sexp))
    :config
    (require 'smartparens-config)
    (smartparens-global-mode))
#+end_src

** writeroom-mode
Gives you a nice, uncluttered editing experience by removing all unneeded visual clutter and by justifying the text in the middle.

#+begin_src emacs-lisp
  (use-package writeroom-mode
    :commands writeroom-mode
    :config
    (setq writeroom-fullscreen-effect 'maximized)
    (setq writeroom-global-effects nil)
    (setq writeroom-mode-line-toggle-position 'header-line-format)
    (setq writeroom-width 81))
#+end_src

* Dummy IDE mode
I try to use ~lsp-mode~ and other language-specific packages for the languages I use (see [[Language specific]]), but sometimes either they are too slow or the computer I'm currently working on requires some extra setup or I just don't want to use them for some reason. For those cases, I use a collection of packages that gives you the power of IDEs but in some dummy/restricted way.

- <<highlight-thing>> :: Automatically highlights the all instances of the symbol under the cursor in the buffer. Simply use evils ~*~ and ~#~ to jump between them.
- <<dumb-jump>> :: Jumps to definition by using predefined-regexps, generally works fine. Use =gd=.
  - To debug why it's not working: M-x ~set-variable dumb-jump-debug t~, then go to *Messages* buffer.
- <<treesit>> :: This is a generic parser for bunch of languages. You can also inspect the syntax tree on the fly and do whatever you want to do with it. Best feature so far is just better (like, miles ahead better) syntax highlighting for some languages. Especially for JS/TS and Rust.
- <<hl-todo>> :: Highlight TODO/FIXME etc.
  - Use ~]t~ and ~[t~ to go next/prev TODO/FIXME item.

#+begin_src emacs-lisp
  (use-package dumb-jump
    :defer t
    :init
    (add-hook 'xref-backend-functions #'dumb-jump-xref-activate 90)
    :config
    ;; ag is supported by nearly every rule but rg is not.
    ;; also see: https://github.com/jacktasia/dumb-jump/issues/376
    (setq dumb-jump-force-searcher 'ag)
    (setq dumb-jump-ignore-context t)
    (setq dumb-jump-fallback-search nil))

  ;; Call treesit-auto-install-all
  (use-package  treesit-auto
    :straight (:host github :repo "renzmann/treesit-auto")
    :hook (after-init . global-treesit-auto-mode))

  (use-package hl-todo
    :hook (prog-mode . hl-todo-mode)
    :bind ( :map evil-normal-state-map
            ("[t" . hl-todo-previous)
            ("]t" . hl-todo-next))
    :config
    (setq hl-todo-keyword-faces '(("TODO"   . "#FF0000")
                                  ("FIXME"  . "#FF0000")
                                  ("DEBUG"  . "#A020F0")
                                  ("GOTCHA" . "#FF4500")
                                  ("STUB"   . "#1E90FF"))))
#+end_src

** Highlight thing at point manually
#+begin_src emacs-lisp
  (setq
   hi-lock-face-defaults
   '("hi-salmon" "hi-aquamarine" "hi-blue" "hi-yellow" "hi-pink" "hi-green" "hi-black-b" "hi-blue-b" "hi-red-b" "hi-green-b" "hi-black-hb"))

  (defun im-highlight-thing-at-point-dwim ()
    "Hightlight or unhighlight current symbol or selection."
    (interactive)
    (cond
     ((--any?
       (-contains? hi-lock-face-defaults
                   (symbol-name it))
       (-flatten (list (plist-get (text-properties-at (point)) 'face))))
      (unhighlight-regexp
       (if (use-region-p)
           (regexp-quote (buffer-substring-no-properties (region-beginning) (region-end)))
         (hi-lock-regexp-okay (find-tag-default-as-symbol-regexp)))))
     ((use-region-p)
      (highlight-regexp
       (regexp-quote (buffer-substring-no-properties (region-beginning) (region-end))))
      (deactivate-mark))
     ((thing-at-point 'symbol)
      (hi-lock-face-symbol-at-point))
     (t (unhighlight-regexp t))))

  (evil-define-key 'normal 'global
    (kbd "M-h") #'im-highlight-thing-at-point-dwim
    (kbd "M-H") (λ-interactive (unhighlight-regexp t)))
#+end_src

* Media/feed/IRC
I try to maximize my Emacs usage which brings it's own benefits and downsides which I will not go over here. Here are some packages and configurations that are not related to programming/editing.

** elfeed (RSS feeds)
Feed reader.

- Filter examples (after hitting ~s~)
  - +tag OR -tag (unread is also a tag)
  - #number-of-entries-limit (like #20)
  - !inverse-regex (!x?emacs will filter out titles containing x?emacs regex)
  - =regex (entries that contains the regex will be shown)
  - +unread +youtube =emacs #10 @5-months-ago
#+begin_src emacs-lisp
  (use-package elfeed
    :commands (elfeed im-elfeed-reload-and-open)
    :general
    (im-leader
     "ee" #'im-elfeed-reload-and-open)
    :config
    ;; When adding tags, don't add any hierarchical tags like (blog blog-software), or (metal metal-black)
    ;; Just use something like: (blog software) and (metal black)

    (load "feeds")
    (setq elfeed-search-title-max-width 100)
    (setq elfeed-curl-extra-arguments '("--netrc"))
    (setq elfeed-feeds (mapcar #'im-elfeed--expand im-feeds))
    (im-elfeed-auto-tag-url '(("youtube\\.com" youtube)))
    (im-elfeed-auto-tag-title '(("youtube\\.com" youtube)
                                ("c\\+\\+"  (programming c++))
                                ("python"   (programming python))
                                ("haskell"  (programming haskell))))

    ;; To apply hooks to all existing entries, use: elfeed-apply-hooks-now

    (evil-define-key 'normal elfeed-search-mode-map
      "o" #'elfeed-search-browse-url
      "O" #'im-elfeed-search-browse-url-in-default-browser))


  ;; TODO: experiment with custom faces
  ;; (defface elfeed-comic
  ;;   '((t :foreground "#BFF"))
  ;;   "Marks comics in Elfeed."
  ;;   :group 'elfeed)
  ;;
  ;; (push '(comic elfeed-comic)
  ;;       elfeed-search-face-alist)

  (defun im-elfeed-search-browse-url-in-default-browser ()
    "Open URL in the default browser."
    (interactive)
    (with-default-browser
     (elfeed-search-browse-url)))

  (defun im-elfeed-auto-tag-url (pairs)
    "Takes a list of url-regex and tag-list pairs and adds a new entry hook for each of them."
    (--map
     (add-hook 'elfeed-new-entry-hook
               (elfeed-make-tagger :feed-url (car it)
                                   :add (cdr it)))
     pairs))

  (defun im-elfeed-auto-tag-title (pairs)
    "Takes a list of title-regex and tag-list pairs and adds a new entry hook for each of them."
    (--map
     (add-hook 'elfeed-new-entry-hook
               (elfeed-make-tagger :entry-title (car it)
                                   :add (cdr it)))
     pairs))

  ;; https://github.com/skeeto/.emacs.d/blob/master/etc/feed-setup.el
  (defvar youtube-feed-format
    '(("^UC" . "https://www.youtube.com/feeds/videos.xml?channel_id=%s")
      ("^PL" . "https://www.youtube.com/feeds/videos.xml?playlist_id=%s")
      (""    . "https://www.youtube.com/feeds/videos.xml?user=%s")))

  (defun im-elfeed--expand (listing)
    "Expand feed URLs depending on their tags."
    (cl-destructuring-bind (url . tags) listing
      (cond
       ((member 'youtube tags)
        (let* ((case-fold-search nil)
               (test (lambda (s r) (string-match-p r s)))
               (format (cl-assoc url youtube-feed-format :test test)))
          (cons (format (cdr format) url) tags)))
       ((member 'reddit tags)
        (cons (format "https://www.reddit.com/r/%s/.rss" url) tags))
       ((member 'gh-release tags)
        (cons (format "https://github.com/%s/releases.atom" url) tags))
       (listing))))

  (defun im-elfeed-reload-and-open ()
    "Reload and open elfeed.
  Useful if .elfeed directory is freshly syncned."
    (interactive)
    (require 'elfeed)
    (elfeed-db-load)
    (elfeed)
    (elfeed-search-update--force))
#+end_src

** empv (music/media/radio/youtube management)
Manage media and streams through =completing-read=.

#+begin_src emacs-lisp
  (use-package empv
    :straight (:host github :repo "isamert/empv.el")
    :defer t
    :init
    (im-leader "r" empv-map)
    :config
    (load "radio-channels")
    (setq empv-radio-channels im-radio-channels)
    (setq empv-radio-log-file "~/Documents/notes/songs.org")
    (setq empv-base-directory "~/Music/")
    (setq empv-video-dir `("~/Videos" ,(format "/run/media/%s/BINGUS/Videos" (user-login-name)) ,(format "/run/media/%s/FLOPPA/Videos" (user-login-name))))
    (setq empv-audio-dir `("~/Music" ,(format "/run/media/%s/BINGUS/Music" (user-login-name)) ,(format "/run/media/%s/FLOPPA/Music" (user-login-name))))
    (setq empv-allow-insecure-connections t)
    (setq empv-invidious-instance "https://inv.zzls.xyz/api/v1")
    ;; ^ see https://api.invidious.io/
    (add-to-list 'empv-mpv-args "--ytdl-format=best")
    (add-to-list 'empv-mpv-args "--save-position-on-quit")
    (add-hook 'empv-init-hook #'empv-override-quit-key)

    (evil-make-overriding-map empv-youtube-results-mode-map 'normal)
    (with-eval-after-load 'embark (empv-embark-initialize-extra-actions))
    (with-eval-after-load 'org
      (add-to-list 'org-file-apps '("\\.\\(mp3\\|ogg\\)\\'" . (lambda (path _str) (empv-play-file path))))))

  (defun im-export-radio-channels-as-m3u (file)
    "Export radio list into an M3U FILE."
    (interactive
     (list
      (read-file-name
       "Where to save the .m3u file?"
       "~/Documents/sync/"
       "radiolist.m3u")))
    (with-temp-file file
      (->>
       im-radio-channels
       (--map
        (format
         "#EXTINF:0, %s\n%s"
         (car it)
         ;; Replace http:// with icyx://, because VLC on Android can't
         ;; retrieve song name if the stream is on http://
         (if (s-contains? "radcap.ru" (car it))
             (s-replace "http://" "icyx://" (cdr it))
           (cdr it))))
       (--reduce (format "%s\n%s" acc it))
       (s-prepend "#EXTM3U\n")
       (insert))))
#+end_src

** orgmdb (movies & shows)
I have a file called ~watchlist.org~ where I keep list of movies and shows that I watched and going to watch. Here are some packages and functions to deal with them.

#+begin_src emacs-lisp
  (use-package orgmdb
    :straight (:host github :repo "isamert/orgmdb.el")
    :bind (:map evil-normal-state-map ("go" . orgmdb-act))
    :config
    (setq orgmdb-omdb-apikey im-orgmdb-omdb-apikey)
    (setq orgmdb-poster-folder "~/Documents/notes/data/posters")
    (setq orgmdb-fill-property-list '(genre runtime director country imdb-id imdb-link imdb-rating metascore actors poster)))
#+end_src
** erc (IRC client)
IRC client for Emacs.

- Some shortcuts:
  - C-c C-b :: switch between channels
  - C-c C-j :: join channel

- TODO items:
  - Autologin
  - Autojoin channels
  - Notifications
  - Add registration notes here
  - Colors?

#+begin_src elisp
  (use-package erc
    :commands erc
    :config

    ;; More compact and cleaner look, nicks and messages are in seperate
    ;; column and total length for nicks are 15 cols
    (setq erc-fill-function 'erc-fill-static)
    (setq erc-fill-static-center 15)

    ;; The rest is from https://www.emacswiki.org/emacs/ErcNickColors
    ;; It's the Option 5

    (defmacro unpack-color (color red green blue &rest body)
      `(let ((,red   (car ,color))
             (,green (car (cdr ,color)))
             (,blue  (car (cdr (cdr ,color)))))
         ,@body))

    (defun rgb-to-html (color)
      (unpack-color color red green blue
                    (concat "#" (format "%02x%02x%02x" red green blue))))

    (defun hexcolor-luminance (color)
      (unpack-color color red green blue
                    (floor (+ (* 0.299 red) (* 0.587 green) (* 0.114 blue)))))

    (defun invert-color (color)
      (unpack-color color red green blue
                    `(,(- 255 red) ,(- 255 green) ,(- 255 blue))))

    (defun erc-get-color-for-nick (nick dark)
      (let* ((hash     (md5 (downcase nick)))
             (red      (mod (string-to-number (substring hash 0 10) 16) 256))
             (blue     (mod (string-to-number (substring hash 10 20) 16) 256))
             (green    (mod (string-to-number (substring hash 20 30) 16) 256))
             (color    `(,red ,green ,blue)))
        (rgb-to-html (if (if dark (< (hexcolor-luminance color) 85)
                           (> (hexcolor-luminance color) 170))
                         (invert-color color)
                       color))))

    (defun erc-highlight-nicknames ()
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward "\\w+" nil t)
          (let* ((bounds (bounds-of-thing-at-point 'symbol))
                 (nick   (buffer-substring-no-properties (car bounds) (cdr bounds))))
            (when (erc-get-server-user nick)
              (put-text-property
               (car bounds) (cdr bounds) 'face
               (cons 'foreground-color (erc-get-color-for-nick nick 't))))))))

    (add-hook 'erc-insert-modify-hook 'erc-highlight-nicknames))
#+end_src
* Keybindings
Keybindings are generally set in-place, following have no context, so they are here.

** macOS
#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    ;; I set the following in Linux using xmodmap but it's kinda
    ;; impossible to do it in OSX I guess.

    ;; I use an external keyboard, this makes AltGr and Meta (Alt) work as expected
    ;; I have also inverted Meta and Control keys system-wide or something, so
    ;; this setting is done according to that.
    (setq ns-option-modifier 'meta
          ns-right-alternate-modifier 'none)

    ;; (define-key key-translition-map ...) is better than (global-define-key ...)
    ;; because this just remaps key everywhere to given key so that the mappings
    ;; works in command mode, isearch etc.
    ;; AltGr + k -> Up
    ;; AltGr + j -> Down
    ;; AltGr + l -> Right
    ;; AltGr + h -> Left
    (define-key key-translation-map (kbd "˚") (kbd "<up>"))
    (define-key key-translation-map (kbd "∆") (kbd "<down>"))
    (define-key key-translation-map (kbd "¬") (kbd "<right>"))
    (define-key key-translation-map (kbd "˙") (kbd "<left>"))

    (define-key key-translation-map (kbd "") (kbd "S-<up>"))
    (define-key key-translation-map (kbd "Ô") (kbd "S-<down>"))
    (define-key key-translation-map (kbd "Ò") (kbd "S-<right>"))
    (define-key key-translation-map (kbd "Ó") (kbd "S-<left>"))

    ;; AltGr + [ -> (
    ;; AltGr + ] -> )
    (define-key key-translation-map (kbd "“") (kbd "("))
    (define-key key-translation-map (kbd "‘") (kbd ")")))
#+end_src

** Some general keybindings

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
  (global-set-key (kbd "C-x <escape>") 'keyboard-escape-quit)
  (global-set-key (kbd "C-c <escape>") 'keyboard-escape-quit)

  (evil-define-key 'normal prog-mode-map
    "gd" 'xref-find-definitions
    "gr" 'xref-find-references)

  (evil-define-key 'normal prog-mode-map (kbd "M-;") 'comment-line)
  (evil-define-key 'visual prog-mode-map (kbd "M-;") 'comment-dwim)

  (evil-define-key 'normal 'global (kbd "M-d") #'im-kill-this-buffer)

  (im-leader "1" (λ-interactive (call-interactively (local-key-binding (kbd "C-c C-c")))))
#+END_SRC

* Programming languages
** General/language-agnostic functionality
*** Jump to beginning/end of a statement
Using [w and ]w, I can jump between statements. For
#+begin_src emacs-lisp
  ;; TODO: should be able to descend down the tree
  (defun im-treesit-end-of-statement ()
    (interactive)
    (treesit-end-of-thing
     (rx (or "local_variable" "return" "if" "for" "with" "try" "method" "lexical" "call")
         (or "_statement" "_declaration" "_definition" "_expression"))))

  (defun im-treesit-beginning-of-statement ()
    (interactive)
    (treesit-beginning-of-thing
     (rx (or "local_variable" "return" "if" "for" "with" "try" "method" "lexical" "call")
         (or "_statement" "_declaration" "_definition" "_expression"))))

  ;; Only tried in java-ts-mode so far
  (evil-define-key 'normal java-ts-mode-map "[w" 'im-treesit-beginning-of-statement)
  (evil-define-key 'normal java-ts-mode-map "]w" 'im-treesit-end-of-statement)
  (evil-define-key 'normal tsx-ts-mode-map "[w" 'im-treesit-beginning-of-statement)
  (evil-define-key 'normal tsx-ts-mode-map "]w" 'im-treesit-end-of-statement)
  (evil-define-key 'normal typescript-ts-mode-map "[w" 'im-treesit-beginning-of-statement)
  (evil-define-key 'normal typescript-ts-mode-map "]w" 'im-treesit-end-of-statement)

  (im-make-repeatable im-treesit-statement
    "[" im-treesit-beginning-of-statement
    "]" im-treesit-end-of-statement)
#+end_src
*** format-all, apheleia -- Format buffers, automatically
- Use =format-all-buffer= function to format current buffer. Works for any language.

Automatically format file with ~format-all-buffer~. It recognizes most language formatters/linters.

#+begin_src emacs-lisp
  (use-package format-all
    :commands (format-all-buffer format-all-region))
#+end_src

/Apheleia/ is like ~format-all~ but works async and automatically formats on buffer save.  I keep both of them because somethimes I need ~format-all-buffer~ and it works with more formatters.

#+begin_src emacs-lisp
  (use-package apheleia
    :hook (after-init . apheleia-global-mode)
    :init
    (defalias 'im-toggle-auto-code-formatter #'apheleia-mode))
#+end_src

*** editorconfig -- Pick up .editorconfig settings
Pick up ~.editorconfig~ settings for current project automatically.

#+begin_src emacs-lisp
  (use-package editorconfig
    :hook (after-init . editorconfig-mode))
#+end_src

*** Display/get currently focused function name in modeline
#+begin_src emacs-lisp
  (use-package which-function
    :straight (:type built-in)
    :hook (after-init . which-function-mode))
#+end_src
*** origami-mode -- Folding
I generally use the built-in hs-minor-mode but it does not work with all languages. Origami is a more generic solution that works fairly well.

#+begin_src emacs-lisp
  (use-package origami
    :hook (yaml-mode . origami-mode)
    :straight (:host github :repo "gregsexton/origami.el"))
#+end_src
*** REPLs
I really like being able to do my development inside REPL. It creates
a really nice feedback loop and fastens the development process. While
support for this type of development is not good in other languages
than Lisps, I at least like to have the ability to run and evaluate
pieces of code in given languages REPL. Here I created a function to
ease up that process. For given REPL, this creates a background REPL
process (like ~jshell~) and sends your inputs to REPL and outputs the
result to echo area. It's like ~eval-last-sexp~ but for all languages
that has a REPL (and with much limited execution functionality of
course, you are limited by the REPL.) This creates only one REPL
process per language, so you can build up a context and use that
throughout your projects.

#+begin_src emacs-lisp
  (im-leader-v
    ";" (general-predicate-dispatch (im-eval-dwim #'eros-eval-last-sexp #'eval-region #'eros-eval-defun)
          (eq major-mode 'java-ts-mode) #'im-jshell-repl-eval
          (eq major-mode 'typescript-ts-mode) #'im-deno-repl-eval
          (eq major-mode  'clojure-mode) (im-eval-dwim #'cider-eval-last-sexp #'cider-eval-region #'cider-eval-defun-at-point)
          (eq major-mode  'lisp-mode) (im-eval-dwim #'slime-eval-last-expression #'slime-eval-region #'slime-eval-region)
          (eq major-mode  'racket-mode) (im-eval-dwim #'racket-eval-last-sexp #'racket-send-region #'racket-send-definition)
          (eq major-mode  'scheme-mode) (im-eval-dwim #'geiser-eval-last-sexp #'geiser-eval-region #'geiser-eval-definition)
          (eq major-mode  'kotlin-mode) (im-eval-dwim #'kotlin-send-line #'kotlin-send-region #'kotlin-send-line)))

  (defun im-eval-dwim (lastf regionf defunf)
    "Generate an interactive function that you can bind to a key
    which calls LASTF, REGIONF or DEFUNF."
    (lambda ()
      (interactive)
      (cond
       ((use-region-p)
        (call-interactively regionf))
       ((or (-contains? '(?\) ?\") (char-before))
            (-contains? '(?\ ?\)) (char-after)))
        (call-interactively lastf))
       (t
        (call-interactively defunf)))))

  (defconst im-repl-result-buffer "*im-repl-result*")
  (defconst im-repl-last-result "")

  (defun im-repl-inspect-last-result ()
    (interactive)
    (with-current-buffer (get-buffer-create im-repl-result-buffer)
      (erase-buffer)
      (insert im-repl-last-result)
      (goto-char (point-min))
      (unless (im-buffer-visible-p (current-buffer))
        (switch-to-buffer-other-window (current-buffer)))))

  (cl-defmacro im-create-repl (&key name args prefix expr parser (process-region #'identity))
    "Create family of functions for interacting with given REPL of NAME.

  NAME is the binary name of the REPL, like jshell, deno etc. (case-insensitive)

  ARGS is the arguments passed to NAME.

  PREFIX is the prefix used while showing the result in echo area.

  EXPR is the expression finder at point. Should return a tree-sitter node.

  PARSER is result parser. Process output is sent to this function
  and if the return value is non-nil, result is shown in the echo
  area.

  As a result, 3 functions are generated:

  - im-NAME-repl-start :: Creates the process and starts the
    repl. Process is associated with *NAME-repl* buffer.
  - im-NAME-repl-send :: Sends given string to REPL.
  - im-NAME-repl-eval :: Entry function. Just bind this to
    something and it starts a REPL if needed when called and sends
    the current expression (or the selected expression) to REPL.

  It was probably a bad idea to use a macro for writing this but I
  already had an implementation for \"deno\" and it was quite easy
  to turn it into something generic using macros.

  Version: 2023-06-26"
    (let* ((process-var (intern (format "im-%s-repl-process" (downcase name))))
           (repl-buffer-name (format "*%s-repl*" (downcase name)))
           (is-repl-running `(lambda ()
                               (and ,process-var (process-live-p ,process-var)))))
      `(progn
         (defvar ,process-var nil)

           ;;; defun im-REPL-repl-start
         (defun ,(intern (format "im-%s-repl-start" (downcase name))) ()
           ,(format "Start (or restart, if already running) the %s REPL on the background." name)
           (interactive)
           (when (,is-repl-running)
             (delete-process ,process-var))
           (setq im-repl-last-result "")
           (let ((repl (start-process ,repl-buffer-name
                                      ,repl-buffer-name
                                      ,(downcase name)
                                      ,@args)))
             (setq ,process-var repl)
             (set-process-filter
              repl
              (lambda (proc out)
                (with-current-buffer ,repl-buffer-name
                  (goto-char (point-max))
                  (insert (ansi-color-apply out))
                  (insert "\n"))
                (setq im-repl-last-result (concat im-repl-last-result (ansi-color-apply out)))
                ;; TODO: change "^> $" per REPL type
                (when (s-matches? "^> $" out)
                  (let* ((result (,parser im-repl-last-result)))
                    (setq im-repl-last-result result)
                    (when result
                      (when-let (get-buffer im-repl-result-buffer)
                        (im-repl-inspect-last-result))
                      (unless (get-buffer im-repl-result-buffer)
                        (message "%s%s" ,prefix (im-kill result))
                        (run-at-time 0 nil (lambda ()
                                             (eros--eval-overlay
                                              result
                                              (point))))))))))
             (set-process-sentinel
              repl
              (lambda (proc out)
                (if (eq (process-exit-status proc) 0)
                    (message ,(format ">> Closed %s REPL session." name))
                  (message ,(format ">> %s REPL has crashed." name)))))))

           ;;; defun im-REPL-repl-send
         (defun ,(intern (format "im-%s-repl-send" (downcase name))) (expr)
           (setq im-repl-last-result "")
           (let ((str (concat (s-trim expr) "\n")))
             (with-current-buffer ,repl-buffer-name
               (insert (format ">>> %s" expr)))
             (process-send-string ,process-var str)))

           ;;; defun im-REPL-repl-eval
         (defun ,(intern (format "im-%s-repl-eval" (downcase name))) ()
           (interactive)
           (unless (,is-repl-running)
             (,(intern (format "im-%s-repl-start" (downcase name)))))
           (let ((expr
                  (if (use-region-p)
                      (funcall
                       ,process-region
                       (buffer-substring-no-properties (region-beginning)
                                                       (region-end)))
                    (let ((curr ,expr)
                          (this-command 'evil-paste-after))
                      (evil-goggles--show-async-hint
                       (treesit-node-start curr)
                       (treesit-node-end curr))
                      (treesit-node-text curr)))))
             (,(intern (format "im-%s-repl-send" (downcase name))) expr))))))

  (im-create-repl
   :name "Deno"
   :args ()
   :prefix "=> "
   ;; Remove block comments before sending, because Deno repl cant
   ;; handle them properly.
   :process-region
   (lambda (str)
     (while (string-match "/\\*\\([^*]\\|\\*[^/]\\)*\\*/" str)
       (setq str (replace-match "" t t str)))
     str)
   :expr (im-ts-current-expression)
   :parser
   (lambda (out)
     (->>
      out
      (s-split "\n")
      (-drop-last 1)
      (s-join "\n"))))

  (im-create-repl
   :name "JShell"
   :args nil
   :prefix ""
   :expr (im-ts-current-expression)
   :parser
   (when-let* ((str (s-trim out))
               ((and (not (s-blank-str? out))
                     (or (s-contains? "==>" out)
                         (s-prefix? "|" out)))))
     str))
#+end_src
*** Other
#+begin_src emacs-lisp
  (defun im-use-block-comments-for-c-style-langs ()
    "Use block style comments for C-style langs, so that poporg works properly.
  Add this function to mode hooks."
    (interactive)
    (setq-local comment-start "/**")
    (setq-local comment-end "*/")
    (setq-local poporg-comment-skip-regexp " *\\* *"))
#+end_src

** markdown
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :mode
    (("README\\.md\\'" . gfm-mode)
     ("\\.md\\'" . gfm-mode)
     ("\\.markdown\\'" . gfm-mode)
     ("\\.txt\\'" . gfm-mode)
     ("qutebrowser-editor-" . gfm-mode))
    :general
    (:keymaps 'markdown-mode-map :states 'normal
     "<RET>" #'markdown-follow-thing-at-point
     "TAB" #'markdown-cycle
     "]]" #'markdown-outline-next
     "[[" #'markdown-outline-previous)
    (im-leader :keymaps 'markdown-mode-map
      "oi" #'markdown-toggle-inline-images)
    :config
    (setq markdown-command "multimarkdown")
    (setq markdown-fontify-code-blocks-natively t))
#+END_SRC

** haskell
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :mode "\\.hs\\'")

  (use-package lsp-haskell
    :after (lsp haskell)
    :config
    (setq lsp-haskell-process-path-hie "ghcide"
          lsp-haskell-process-args-hie '()))

  (use-package ormolu
    :hook (haskell-mode . ormolu-format-on-save-mode))
#+END_SRC

** rust
#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :mode "\\.rs\\'"
    :config
    (setq lsp-rust-server 'rust-analyzer
          lsp-rust-clippy-preference 'on))
#+END_SRC

** javascript
*** jsdoc.el
This is a package I wrote for inserting JSDoc comments easily. Check out the [[https://github.com/im-jsdoc.el][README]].

#+begin_src emacs-lisp
  (use-package jsdoc
    :commands jsdoc
    :straight (:host github :repo "isamert/jsdoc.el"))
#+end_src

*** Add node_modules/.bin to PATH automatically
#+begin_src emacs-lisp
  (defun im-add-node-modules-to-path ()
    "Add node_modules/.bin to `exec-path'."
    (interactive)
    (-some--> (locate-dominating-file "." "node_modules")
      (expand-file-name it)
      (f-join it "node_modules/.bin")
      (setq-local exec-path `(,it ,@exec-path))))

  (add-hook 'js-ts-mode-hook #'im-add-node-modules-to-path)
  (add-hook 'eshell-mode-hook #'im-add-node-modules-to-path)
#+end_src
*** Helper functions
#+begin_src emacs-lisp
  ;; TODO make this idempotent, it breaks absolute imports
  ;; TODO make it work on a line instead of between quotes
  (defun im-js-relative-import-to-abs ()
    "Convert a relative import to an absolute import.
  For example, if you are on the line:
    import Test from '../../test'
  This function transforms the line into:
    import Test from 'src/a/b/test'"
    (interactive)
    (let ((fname (substring-no-properties (thing-at-point 'filename)))
          (bounds (bounds-of-thing-at-point 'filename)))
      (delete-region (car bounds) (cdr bounds))
      (insert (s-chop-prefix (im-current-project-root) (expand-file-name fname)))))


  (defun im-convert-js-object-to-json ()
    "Convert selected JS object into JSON object.
  Example:
    {a: 3, b: 5}
  is converted into
    {
      \"a\": 3,
      \"b\": 5
    }"
    (interactive)
    (if (use-region-p)
        (shell-command-on-region
         (region-beginning)
         (region-end)
         "node -e 'console.log(JSON.stringify(eval(\"(\" + require(\"fs\").readFileSync(0, \"utf-8\") + \")\"), null, 2))'"
         (current-buffer)
         t)
      (user-error "Select something first")))

  (defun im-convert-json-to-js-object ()
    "Convert selected JS object into JSON object.
  Example:
    {
      \"a\": 3,
      \"b\": 5
    }
  is converted into
    {
      a: 3,
      b: 5,
    }"
    (interactive)
    (if (use-region-p)
        (shell-command-on-region
         (region-beginning)
         (region-end)
         "node -e 'console.log(require(\"util\").inspect(JSON.parse(require(\"fs\").readFileSync(0, \"utf-8\")), false, null))'"
         (current-buffer)
         t)
      (user-error "Select something first")))
#+end_src
*** Debug helpers
#+begin_src emacs-lisp
  (defun im-refactor-debug-log-text ()
    "Return a string in the following format: 'BufferName:FunctionName:LineNumber'.
    This is used in my snippets."
    (format "%s:%s:%s" (buffer-name) (which-function) (line-number-at-pos)))

  (defun im-js-insert-debug-log-for-current-variable ()
    "Insert a `console.log' line for currently focused variable."
    (interactive)
    (let* ((curr-indent)
           (node (treesit-node-child-by-field-name
                  (car (jsdoc--tsc-find-descendants-with-type
                        (treesit-node-parent (treesit-node-at (point)))
                        "variable_declarator"))
                  "name"))
           (text (treesit-node-text node)))
      (goto-char (treesit-node-end (treesit-node-parent node)))
      (end-of-line)
      (setq curr-indent (current-indentation))
      (insert "\n")
      (insert (make-string curr-indent ? ))
      (insert
       (format
        "console.log(\"%s\", %s) // FIXME remove log"
        (im-refactor-debug-log-text)
        (->>
         text
         (s-split "\n")
         (-map #'s-trim)
         (s-join " "))))))
#+end_src
** typescript
#+begin_src emacs-lisp
  (setq-default typescript-ts-mode-indent-offset 2)

  (add-to-list 'auto-mode-alist '("\\.ts\\'" . typescript-ts-mode))
  (add-hook 'typescript-ts-mode-hook #'im-add-node-modules-to-path)
  (add-hook 'tsx-ts-mode-hook #'im-add-node-modules-to-path)
  (add-hook 'typescript-ts-mode-hook #'hs-minor-mode)
  (add-hook 'tsx-ts-mode-hook #'hs-minor-mode)
  (add-hook 'typescript-ts-mode-hook #'im-use-block-comments-for-c-style-langs)
  (add-hook 'tsx-ts-mode-hook #'im-use-block-comments-for-c-style-langs)
#+end_src

*** REPL interaction
#+begin_src emacs-lisp
  (defun im-treesit-find-parent-with-type (node wanted-type)
    "Get first parent of NODE where parents type is WANTED-TYPE."
    (let ((curr-node node)
          (curr-type nil))
      (while (and curr-node (not (equal curr-type wanted-type)))
        (setq curr-node (treesit-node-parent curr-node))
        (setq curr-type (when curr-node (treesit-node-type curr-node))))
      curr-node))

  (defun im-ts-current-expression ()
    "Get smallest meaningful expression (as something that can be
  sent to REPL)."
    (let* ((current-node (treesit-node-at (point)))
           (getter (lambda (it)
                     (when-let (node (im-treesit-find-parent-with-type current-node (car it)))
                       (if (numberp (cdr it))
                           (treesit-node-child node (cdr it))
                         node)))))
      (->>
       '(("lexical_declaration")
         ("expression_statement" . 0)
         ("function_declaration")
         ("interface_declaration")
         ("enum_declaration")
         ("import_statement")
         ("class_declaration"))
       (-find getter)
       (funcall getter))))
#+end_src
*** Deno utils
Here are some functions that I use while developing with Deno.

#+begin_src emacs-lisp
  ;; TODO: Generalize LSP client switching
  (defun im-lsp-switch-to-deno ()
    "Start `deno' lsp in current buffer."
    (interactive)
    (let ((lsp-enabled-clients '(deno-ls)))
      (ignore-errors
        (funcall-interactively #'lsp-workspace-shutdown))
      (lsp)))

  (defun im-lsp-switch-to-nodejs ()
    "Start `deno' lsp in current buffer."
    (interactive)
    (let ((lsp-enabled-clients '(ts-ls)))
      (ignore-errors
        (funcall-interactively #'lsp-workspace-shutdown))
      (lsp)))

  (defun im-deno-cache-buffer-dependencies ()
    "Install and cache dependencies stated in current Deno file."
    (interactive)
    ;; TODO reload lsp on file on save?
    (let ((buf (current-buffer)))
      (save-buffer)
      (im-shell-command
       :command (format "deno cache %s" (f-relative (buffer-file-name)))
       :on-start
       (lambda (&rest _)
         (message ">> Downloading deps..."))
       :on-fail
       (lambda (&rest _)
         (user-error ">> Downloading deps...Failed!"))
       :on-finish
       (lambda (&rest _)
         (message ">> Downloading deps...Done.")
         (switch-to-buffer buf)))))
#+end_src
** json
~hs-minor-mode~ works great with JSON.

#+begin_src emacs-lisp
  (add-hook 'json-mode-hook #'hs-minor-mode)
  (add-hook 'json-ts-mode-hook #'hs-minor-mode)
#+end_src

*** Running JQ or Javascript on given JSON
I work with JSON a lot. Here I have some functions that let's you run given expression on selected JSON.

#+begin_src emacs-lisp
  (defvar im-nodejs-runner-preface
    "const R = require(\"ramda\");")

  (defvar im-deno-runner-preface
    "const R = await import(\"https://esm.sh/v122/ramda@0.29.0\");")

  (defun im-run-jq-on-json (json expression &optional replace)
    "Run given EXPRESSION with jq on JSON and return the result.
  If REPLACE is non-nil, then clear the buffer or current
  selection and insert the result.

  When called with prefix argument, REPLACE becomes non-nil."
    (interactive (im--read-json-and-expression))
    (im--run-x-on-json
     (with-temp-buffer
       (insert json)
       (shell-command-on-region (point-min) (point-max) (format "jq -r \"%s\"" expression) nil 't)
       (buffer-string))
     (called-interactively-p 'interactive)
     replace))

  (defun im-run-nodejs-on-json (json expression &optional replace)
    "Run given EXPRESSION with nodejs on JSON and return the result.
  If REPLACE is non-nil, then clear the buffer or current
  selection and insert the result.

  When called with prefix argument, REPLACE becomes non-nil."
    (interactive (im--read-json-and-expression))
    (im--run-x-on-json
     (with-temp-buffer
       (insert im-nodejs-runner-preface)
       (insert "\n")
       (insert (format "const it = %s;" json))
       (insert (format "JSON.stringify(%s, null, 2)" expression))
       (shell-command-on-region (point-min) (point-max) "node -p" nil 't)
       (buffer-string))
     (called-interactively-p 'interactive)
     replace))

  (defun im-run-deno-on-json (json expression &optional replace)
    "Run given EXPRESSION with deno on JSON and return the result.
  If REPLACE is non-nil, then clear the buffer or current
  selection and insert the result.

  When called with prefix argument, REPLACE becomes non-nil."
    (interactive (im--read-json-and-expression))
    (im--run-x-on-json
     (with-temp-buffer
       (insert im-deno-runner-preface)
       (insert "\n")
       (insert (format "const it = %s;" json))
       (insert (format "console.log(JSON.stringify(%s, null, 2))" expression))
       (shell-command-on-region (point-min) (point-max) "deno run --allow-all -" nil 't)
       (buffer-string))
     (called-interactively-p 'interactive)
     replace))

  (defun im--run-x-on-json (result interactive? &optional replace)
    "Run given EXPRESSION with nodejs on JSON and return the result.
  If REPLACE is non-nil, then clear the buffer or current
  selection and insert the result.

  When called with prefix argument, REPLACE becomes non-nil."
    (when (and interactive?
               (not replace))
      (if (>= (max-mini-window-lines) (length (s-lines result)))
          (message ">> %s" (s-trim result))
        (with-current-buffer (get-buffer-create "*nodejs-result*")
          (switch-to-buffer-other-window (current-buffer))
          (insert result))))
    (cond
     ((and replace (use-region-p))
      (delete-region (region-beginning) (region-end))
      (insert result))
     (replace
      (erase-buffer)
      (insert result)))
    result)

  (defun im--read-json-and-expression ()
    (list
     (if (use-region-p)
         (buffer-substring-no-properties (region-beginning) (region-end))
       (let ((json (read-string "JSON (leave empty to use whole buffer): ")))
         (if (s-blank? json)
             (buffer-substring-no-properties (point-min) (point-max)))))
     (read-string "Expression: ")
     current-prefix-arg))
#+end_src
*** Extra functionality
#+begin_src emacs-lisp
  (defun im-jsons-print-path-python ()
    (interactive)
    (let ((jsons-path-printer 'jsons-print-path-python))
      (jsons-print-path)))

  (defun im-jsons-print-path-javascript-js-jq ()
    (interactive)
    (let ((jsons-path-printer 'jsons-print-path-jq))
      (jsons-print-path)))

  ;;  Provides jsons-print-path function, it simply kills the path to the key under point
  (use-package json-snatcher
    :config
    ;; Copies paths like:.definition.summary.pastGroup.trackingResults[0].trackingItemReferenceId
    ;; I've created two functions above for the variations
    (setq jsons-path-printer 'jsons-print-path-jq))

  ;; Add execution ability to json blocks inside org-mode. Either add
  ;; `:jq some-jq-query' or `:node it.accessor' to code block's header
  ;; to filter the json
  (defun org-babel-execute:json (body params)
    (let ((jq (cdr (assoc :jq params)))
          (node (cdr (assoc :node params))))
      (cond
       (jq (im-run-jq-on-json body jq))
       (node (im-run-nodejs-on-json body node)))))
#+end_src

** scala
#+begin_src emacs-lisp
  (use-package scala-mode
    :interpreter
    ("scala" . scala-mode))

  (use-package lsp-metals
    :after lsp
    :custom
    (lsp-metals-server-args '("-J-Dmetals.allow-multiline-string-formatting=off"
                              "-J-Dmetals.icons=unicode"))
    (lsp-metals-enable-semantic-highlighting t)
    :hook (scala-mode . lsp))

  ;; Enable sbt mode for executing sbt commands
  (use-package sbt-mode
    :commands sbt-start sbt-command
    :config
    ;; WORKAROUND: https://github.com/ensime/emacs-sbt-mode/issues/31
    ;; allows using SPACE when in the minibuffer
    (substitute-key-definition
     'minibuffer-complete-word
     'self-insert-command
     minibuffer-local-completion-map)
    (setq sbt:program-options '("-Dsbt.supershell=false")))
#+end_src
** java
=lsp-java= automatically installs =eclipse.jdt.ls= to get lsp.
#+begin_src emacs-lisp
  ;; Set default indent to 2
  (setq java-ts-mode-indent-offset 2)
  ;; hs-minor-mode works well with c-like languages
  (add-hook 'java-ts-mode-hook #'hs-minor-mode)

  (use-package lsp-java
    :demand t
    :config
    ;; This is required for java-ts-mode, otherwise it fails for some reason.
    ;; https://github.com/emacs-lsp/lsp-mode/issues/3135#issuecomment-933539371
    (setq-default c-basic-offset 2)

    (defun im-lsp-java-find-lombok-jar ()
      (car (sort (file-expand-wildcards "~/.m2/repository/org/projectlombok/lombok/*/lombok-*.jar") #'string>)))

    ;; This is required to make lsp work well with Lombok
    (when-let (lombok (im-lsp-java-find-lombok-jar))
      (add-to-list 'lsp-java-vmargs (concat "-javaagent:" (expand-file-name lombok)))))
#+end_src
*** Supplementary functions
#+begin_src emacs-lisp
  (defun im-jshell ()
    "Open JShell with runtime dependencies of the current project loaded.
  Please note that tab-completion for runtime dependencies *do not*
  work.  You need to enter full path while importing by yourself."
    (interactive)
    (let* ((default-directory (im-current-project-root))
           (vterm-shell "mvn -q com.github.johnpoth:jshell-maven-plugin:1.3:run -DtestClasspath")
           ;; ^ This plugin makes it possible to import project's maven dependencies
           ;; another option is to use jshell directly.
           (vterm-buffer-name "*vterm-jshell*"))
      (vterm)))
#+end_src
*** maven helpers
#+begin_src emacs-lisp
  (defun im-maven-goal-run (&optional invalidate)
    "Select a maven goal and run it.
  This function caches the goal list in the firt run. If you want
  to invalidate the cache, pass a non-nil value for INVALIDATE."
    (interactive "P")
    (let* ((cache-dir (expand-file-name "~/.cache/im-maven/"))
           (cache-file (f-join cache-dir (concat (s-replace "/" "!" (im-current-project-root)) "maven-goals")))
           goals)
      (if (and (not invalidate) (f-exists? cache-file))
          (setq goals (im-deserialize-from-file cache-file))
        (progn
          (message "Generating maven goal list, please wait...")
          (f-mkdir-full-path cache-dir)
          (setq goals (im-maven-goals-read))
          (im-serialize-into-file cache-file goals)
          (message "Generating maven goal list, please wait...Done")))
      (let ((selected (lab--completing-read-object
                       "Select maven goal: "
                       goals
                       :formatter #'(lambda (x) (format "%s - %s"
                                                   (propertize (car x) 'face '(:weight bold))
                                                   (propertize (cadr x) 'face '(:weight thin :slant italic))))
                       :category 'maven-goal)))
        (let ((default-directory (im-current-project-root)))
          (im-shell-command
           :command (format "./mvnw %s" (car selected))
           :buffer-name (format "*%s: %s*" (f-filename (im-current-project-name)) (car selected)))))))

  (defun im-maven-goals-read ()
    "Find all maven goals and their descriptions in current project."
    (let ((default-directory (im-current-project-root)))
      (->>
       (shell-command-to-string "mvn help:effective-pom | grep -E -A 1 '<groupId>'")
       (s-split "\n")
       (--filter (not (equal it "--")))
       (-partition 2)
       (--filter (s-contains? "plugin" (nth 1 it)))
       (--map (let ((group-id (nth 1 (s-match ">\\(.*\\)<" (car it))))
                    (artifact-id (nth 1 (s-match ">\\(.*\\)<" (nth 1 it)))))
                (format "-DgroupId=%s -DartifactId=%s" group-id artifact-id)))
       (-uniq)
       (--mapcat
        (--map
         (let ((xd (s-split "\n" (s-trim it))))
           (list (car xd)
                 (s-join " " (mapcar #'s-trim (-drop 1 xd)))))
         (s-split
          "\n\n"
          (let ((x
                 (->
                  (im-tap (format "mvn help:describe %s" it) )
                  shell-command-to-string
                  (string-trim-left "\\(\n\\|.\\)*This plugin has [0-9]+ goals:\n\n")
                  (string-trim-right "\n\nFor more information\\(\n\\|.\\)*"))))
            (if (s-contains? "[ERROR]" x) "" x))))))))
#+end_src

** clojure
Here is the current workflow I use:
- =lein new app project-name=
- =cider-jack-in=

#+begin_src emacs-lisp
  (use-package cider
    :after clojure
    :general
    (:keymaps 'clojure-mode-map :states 'normal
     "K" #'cider-doc)
    (:keymaps 'cider-inspector-mode-map :states 'normal
     "RET" #'cider-inspector-operate-on-point
     "DEL" #'cider-inspector-pop)
    :config
    (setq cider-inspector-page-size 50)
    (setq cider-show-error-buffer nil)

    ;; `compojure' indent
    (define-clojure-indent
      (defroutes 'defun)
      (GET 2)
      (POST 2)
      (PUT 2)
      (DELETE 2)
      (HEAD 2)
      (ANY 2)
      (OPTIONS 2)
      (PATCH 2)
      (rfn 2)
      (let-routes 1)
      (context 2)))
#+end_src

** common-lisp
#+begin_src emacs-lisp
  (use-package slime
    :hook (lisp-mode . slime-mode)
    :general
    (:keymaps 'lisp-mode-map-map :states 'normal
     "K" #'slime-documentation)
    :config
    (setq inferior-lisp-program "sbcl"))
#+end_src
** emmet-mode
Hit <C-j> after these and get:
- =a= ~<a href="|">|</a>~
- =.x= ~<div class="x"></div>~
- =br/= ~<br />~
- =p.x.y.z= ~<p className="x y z"></p>~ (Works well with JSX)
- ~input[type=text]~ ~<input type="text" name="" value=""/>~
- =a>b>c= ~<a href=""><b><c></c></b></a>~
- =b*3= ~<b></b><b></b><b></b>~
#+BEGIN_SRC emacs-lisp
  (use-package emmet-mode
    :hook (js-mode css-mode sgml-mode web-mode tsx-mode)
    :init
    (setq emmet-expand-jsx-className? t
          emmet-self-closing-tag-style " /"))
#+END_SRC

** r
#+BEGIN_SRC emacs-lisp
  (use-package ess
    :mode "\\.r\\'")
#+END_SRC

** kotlin
#+BEGIN_SRC emacs-lisp
  (use-package kotlin-mode
    :mode "\\.kt\\'"
    :config
    ;; ki is a better REPL for Kotlin. You can save and reload your session.
    (setq kotlin-command "ki"))
#+END_SRC

** gradle/groovy
#+BEGIN_SRC emacs-lisp
  (use-package groovy-mode
    :mode "\\.gradle\\'")
#+END_SRC

** yaml
#+begin_src emacs-lisp
  (use-package yaml-mode
    :mode ("\\.yaml\\'" "\\.yml\\'"))
#+end_src

** elisp
*** Inspector/debugging/pretty-printing
There is a built-in function (~data-debug-eval-expression~) to inspect objects (not good as CIDERs inspector but it works). I made a helper function to evaluate last expression and open data-debug window of it.

#+begin_src emacs-lisp
  (defun im-eval-and-inspect-last-sexp ()
    (interactive)
    (require 'data-debug)
    (data-debug-show-stuff (eval-last-sexp nil) "last sexp"))
#+end_src

There is also ~pp-eval-last-sexp~ which evaluates and pretty-prints the result of last expression in a separate buffer, which can be better for inspection sometimes.

*** eros
Like CIDER, it shows the results of ~eval-last-sexp~ etc. in an overlay, right next to the expression itself. There is also ~eros-inspect-last-result~ which essentially shows the result of last evaluation in a pretty printed format in a different buffer.

#+begin_src emacs-lisp
  (use-package eros
    :straight (:host github :repo "isamert/eros")
    :hook (after-init . eros-mode)
    :config
    (add-hook 'eros-inspect-hooks (lambda () (flycheck-mode -1)))
    (im-leader-v
      "'" #'eros-inspect-last-result))
#+end_src
*** Pretty stuff
#+begin_src  emacs-lisp
  (setq
   im-elisp-pretty-symbols
   '((">="     . ?≥)
     ("<="     . ?≤)
     ("defun"  . ?ƒ)
     ("interactive" . ?⎇)
     ("lambda" . ?λ)
     ("thread-last" . ?↠)
     ("thread-first" . ?→)
     ("->>" . ?↠)
     ("->" . ?→)))
  (im-prettify-mode emacs-lisp-mode-hook im-elisp-pretty-symbols)
  (im-prettify-mode lisp-interaction-mode-hook im-elisp-pretty-symbols)


  ;; Highlights quotes. Surprisingly useful
  (use-package highlight-quoted
    :hook (emacs-lisp-mode . highlight-quoted-mode))
#+end_src

*** Linting & package development
#+begin_src emacs-lisp
  (use-package package-lint
    :commands package-lint-current-buffer)

  (use-package flycheck-package
    :after flycheck
    :config (flycheck-package-setup))
#+end_src

*** Folding
#+begin_src emacs-lisp
  (add-hook 'emacs-lisp-mode-hook #'hs-minor-mode)
  (add-hook 'lisp-interaction-mode-hook #'hs-minor-mode)
#+end_src
*** Indentation fix
#+begin_src emacs-lisp
  ;; Taken from: https://github.com/Fuco1/.emacs.d/blob/2c302dcbedf2722c5c412b6a6d3e3258f6ac1ccf/site-lisp/my-redef.el#LL18C1-L100C62
  ;; Redefines the silly indent of keyword lists
  ;; before
  ;;   (:foo bar
  ;;         :baz qux)
  ;; after
  ;;   (:foo bar
  ;;    :baz qux)
  (eval-after-load "lisp-mode"
    '(defun lisp-indent-function (indent-point state)
       "This function is the normal value of the variable `lisp-indent-function'.
  The function `calculate-lisp-indent' calls this to determine
  if the arguments of a Lisp function call should be indented specially.

  INDENT-POINT is the position at which the line being indented begins.
  Point is located at the point to indent under (for default indentation);
  STATE is the `parse-partial-sexp' state for that position.

  If the current line is in a call to a Lisp function that has a non-nil
  property `lisp-indent-function' (or the deprecated `lisp-indent-hook'),
  it specifies how to indent.  The property value can be:

  ,* `defun', meaning indent `defun'-style
    \(this is also the case if there is no property and the function
    has a name that begins with \"def\", and three or more arguments);

  ,* an integer N, meaning indent the first N arguments specially
    (like ordinary function arguments), and then indent any further
    arguments like a body;

  ,* a function to call that returns the indentation (or nil).
    `lisp-indent-function' calls this function with the same two arguments
    that it itself received.

  This function returns either the indentation to use, or nil if the
  Lisp function does not specify a special indentation."
       (let ((normal-indent (current-column))
             (orig-point (point)))
         (goto-char (1+ (elt state 1)))
         (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
         (cond
          ;; car of form doesn't seem to be a symbol, or is a keyword
          ((and (elt state 2)
                (or (not (looking-at "\\sw\\|\\s_"))
                    (looking-at ":")))
           (if (not (> (save-excursion (forward-line 1) (point))
                       calculate-lisp-indent-last-sexp))
               (progn (goto-char calculate-lisp-indent-last-sexp)
                      (beginning-of-line)
                      (parse-partial-sexp (point)
                                          calculate-lisp-indent-last-sexp 0 t)))
           ;; Indent under the list or under the first sexp on the same
           ;; line as calculate-lisp-indent-last-sexp.  Note that first
           ;; thing on that line has to be complete sexp since we are
           ;; inside the innermost containing sexp.
           (backward-prefix-chars)
           (current-column))
          ((and (save-excursion
                  (goto-char indent-point)
                  (skip-syntax-forward " ")
                  (not (looking-at ":")))
                (save-excursion
                  (goto-char orig-point)
                  (looking-at ":")))
           (save-excursion
             (goto-char (+ 2 (elt state 1)))
             (current-column)))
          (t
           (let ((function (buffer-substring (point)
                                             (progn (forward-sexp 1) (point))))
                 method)
             (setq method (or (function-get (intern-soft function)
                                            'lisp-indent-function)
                              (get (intern-soft function) 'lisp-indent-hook)))
             (cond ((or (eq method 'defun)
                        (and (null method)
                             (> (length function) 3)
                             (string-match "\\`def" function)))
                    (lisp-indent-defform state indent-point))
                   ((integerp method)
                    (lisp-indent-specform method state
                                          indent-point normal-indent))
                   (method
                    (funcall method indent-point state)))))))))

#+end_src
*** doctest.el
See this: [[https://ag91.github.io/blog/2023/03/20/doctestel-or-testing-your-pure-elisp-functions-in-your-docstring/][Doctest.el or testing your pure Elisp functions in your docstring - Where parallels cross]]
#+begin_src emacs-lisp
  (use-package doctest
    :straight (:host github :repo "ag91/doctest"))
#+end_src
*** suggest.el -- Function suggestions
Do ~M-x suggest~, enter the inputs and the expected output and it'll suggest you some functions. Quite nice and useful, I used it plenty of time.

#+begin_src emacs-lisp
  (use-package suggest)
#+end_src
** Racket
- Open a racket buffer.
- Do C-c C-c (racket-run)
- It'll drop you on a REPL within the scope of the file.

#+begin_src emacs-lisp
  (use-package racket-mode
    :mode "\\.rkt\\'")
#+end_src
** dhall
#+begin_src emacs-lisp
  (use-package dhall-mode
    :mode "\\.dhall\\'"
    :config
    ;; I use dhall-lsp-server, so I don't need this
    (setq dhall-use-header-line nil))
#+end_src

** nix
#+begin_src emacs-lisp
  (use-package nix-mode
    :mode "\\.nix\\'")

  (defun im-import-env-from-nix-shell ()
    (interactive)
    (let ((default-directory (im-current-project-root)))
      (when (not (and (file-exists-p "shell.nix") (executable-find "nix-shell")))
        (error "Failed to find shell.nix or nix-shell"))
      (--> (shell-command-to-string "nix-shell --quiet --run 'env'")
        (split-string it "\n")
        (--map (-let (((name val) (s-split-up-to "=" it 1)))
                 (setenv name val)
                 (when (string-equal name "PATH")
                   (setq exec-path (split-string val path-separator)))
                 `(,name ,val))
               it))
      (message "Done.")))
#+end_src

** swift
#+begin_src emacs-lisp
  (use-package swift-mode :defer t)
#+end_src

** scheme
#+begin_src emacs-lisp
  (use-package geiser
    :commands geiser
    :config
    (setq geiser-debug-jump-to-debug-p nil)
    (setq geiser-default-implementation 'guile))

  (use-package geiser-guile
    :after geiser)
#+end_src

** Docker stuff
Some major modes for editing files.
#+begin_src emacs-lisp
  (use-package dockerfile-mode
    :mode "Dockerfile\\'")
  (use-package docker-compose-mode
    :mode "docker-compose\\'")
#+end_src

A package for  managing docker.

#+begin_src emacs-lisp
  (use-package docker
    :defer t
    :config
    (evil-define-key 'normal docker-container-mode-map (kbd "a") #'docker-container-help)
    (evil-define-key 'normal docker-image-mode-map     (kbd "a") #'docker-image-help)
    (evil-define-key 'normal docker-machine-mode-map   (kbd "a") #'docker-machine-help)
    (evil-define-key 'normal docker-network-mode-map   (kbd "a") #'docker-network-help)
    (evil-define-key 'normal docker-volume-mode-map    (kbd "a") #'docker-volume-help))
#+end_src
** Kubernetes
- Use ~kubernetes-overview~ to get an overview.
- Use ~kubernetes-contexts-use-context~ to switch between contexts.
- Use ~kubernetes-set-namespace~ to set a namespace.

#+begin_src emacs-lisp
  (use-package kubernetes
    :defer t
    :config
    (setq kubernetes-poll-frequency 3600)
    (setq kubernetes-redraw-frequency 3600)

    (evil-define-key 'normal kubernetes-overview-mode-map
      (kbd "r") #'kubernetes-refresh
      (kbd "a") #'kubernetes-dispatch))

  (use-package kubernetes-evil
    :after kubernetes)
#+end_src
** vimrc
Mostly for editing tridactyl and sometimes real vimrc.

#+begin_src emacs-lisp
  (use-package vimrc-mode
    :defer t)
#+end_src

** Graphviz/dot
#+begin_src emacs-lisp
  (use-package graphviz-dot-mode
    :mode ("\\.dot\\'" "\\.gv\\'"))
#+end_src
** PlantUML
#+begin_src emacs-lisp
  (use-package plantuml-mode
    :mode "\\.\\(plantuml\\|pum\\|plu\\)\\'"
    :init
    (with-eval-after-load 'org
      (add-to-list 'org-src-lang-modes '("plantuml" . plantuml)))
    :config
    (setq plantuml-default-exec-mode 'jar)
    (setq plantuml-jar-path "/nix/store/q0v5nv70zc23fx4hjgghnqf7lvydr6fq-plantuml-1.2021.3/lib/plantuml.jar")
    (setq org-plantuml-jar-path plantuml-jar-path))
#+end_src
** Couchbase
Install couchbase-query package for running interactive queries inside emacs.
#+begin_src emacs-lisp
  (use-package couchbase-query
    :straight (:host github :repo "isamert/couchbase-query.el")
    :defer t
    :config
    (setq couchbase-query-command "/Applications/Couchbase Server.app/Contents/Resources/couchbase-core/bin/cbq"))
#+end_src

Create a mode for n1ql and make n1ql code blocks inside org-mode runnable.

#+begin_src emacs-lisp
  ;; Create a dummy derived mode based on sql-mode for n1ql, so that we
  ;; get some syntax highlighting for free
  (define-derived-mode n1ql-mode sql-mode "n1ql-mode")
  (add-to-list 'auto-mode-alist (cons (rx ".n1ql" string-end) #'n1ql-mode))

  ;; Add a function to execute n1ql code blocks in org-mode. It works
  ;; just like how sql-mode code blocks is executed
  (defun org-babel-execute:n1ql (body params)
    (im-cbq
     body
     :host (alist-get :host params)
     :username (alist-get :username params)
     :password (alist-get :password params)
     :select (or (alist-get :select params) ".")))


  (cl-defun im-cbq (query &key host username password (select "."))
    "Run a couchbase query and return the result."
    (with-temp-buffer
      (insert query)
      (shell-command-on-region
       (point-min)
       (point-max)
       (format "cbq -quiet -engine '%s' -credentials '%s'"
               host
               (format "%s:%s" username password))
       nil t)
      (replace-regexp-in-region "^cbq> " "" (point-min) (point-max))
      (shell-command-on-region (point-min) (point-max) (format "jq -r '%s'" select) nil t)
      (buffer-string)))
#+end_src

Create a mode for cbc binary and make cbc-mode code blocks runnable inside emacs. cbc is not able to read commands from a file, so it does not really makes sense to create a mode for it but I do this to be able to create code blocks in org mode for cbc commands so that I can save some commands in an org file and re-run them whenever I want.

#+begin_src emacs-lisp
  (define-generic-mode 'cbc-mode
    '(?!)
    '("help" "version" "cat" "create" "create" "cp" "incr" "decr" "touch" "rm" "hash" "stats" "observe" "view" "lock" "unlock" "admin" "bucket" "bucket" "bucket" "role" "user" "user" "user" "connstr" "query" "write" "strerror" "ping" "watch" "keygen")
    nil
    '("cbc\\'")
    nil
    "Simple mode for couchbase cbc commandline utility.")

  (defun org-babel-execute:cbc (body params)
    (im-cbc
     body
     :host (alist-get :host params)
     :username (alist-get :username params)
     :password (alist-get :password params)
     :bucket (alist-get :bucket params)
     :select (or (alist-get :select params) ".")))

  (cl-defun im-cbc (cbc-command &key host username password bucket raw (select "."))
    "Run given cbc command."
    (let* ((cmd (format "cbc %s --spec=%s/%s --username='%s' --password='%s'"
                        cbc-command
                        host
                        bucket
                        username
                        password)))
      (message "im-cbc :: %s" cmd)
      (with-temp-buffer
        (insert (im-shell-command-to-string cmd))
        (shell-command-on-region
         (point-min)
         (point-max)
         (format "jq %s '%s'" (if raw "-r" "") select)
         nil
         t)
        (buffer-string))))
#+end_src

** BigQuery
#+begin_src emacs-lisp
  (define-derived-mode bqsql-mode sql-mode "bqsql-mode")
  (add-to-list 'auto-mode-alist (cons (rx ".bqsql" string-end) #'bqsql-mode))

  (defun org-babel-expand-body:bqsql (body params)
    (s-format
     body
     (lambda (key alist) (assoc-default (intern key) alist))
     (mapcar (lambda (x) (when (eq (car x) :var) (cdr x))) params)))

  (defun org-babel-execute:bqsql (query params)
    "Execute QUERY with given PARAMS.
  `:var' syntax is ${var_name} and replaced as-is.

  `:format' can be either `pretty' or `json'.  Former outputs an
  org table, other one outputs the result as json.

  If `:buffer' is non-nil, then output results to a buffer, instead
  of the results drawer."
    (let* ((job-id (im-uuid))
           (format (or (alist-get :format params) "pretty"))
           (buffer? (alist-get :buffer params))
           (json-out? (s-matches? "json" format))
           (buf (get-buffer-create "*im-bqsql*"))
           (org-buffer (current-buffer))
           (start-time (float-time))
           process
           (vars (org-babel--get-vars params)))
      (setq query (org-babel-expand-body:bqsql query params))
      (with-current-buffer buf (erase-buffer))
      (setq process (start-process "query" buf "bq" "query" "--quiet" "--nouse_legacy_sql" "--format" format "--job_id" job-id query))
      (set-process-sentinel
       process
       (lambda (p m)
         (let* ((end-time (float-time))
                (result (with-current-buffer buf
                          (string-trim (buffer-string))))
                (msg (format "=> Query finished, time elapsed: %s"
                             (format-seconds "%Y %D %H %M %z%S" (- end-time start-time))))
                (bname (format "*bqsql:%s" (if (eq buffer? t) job-id buffer?)))
                found?)
           (with-current-buffer org-buffer
             (save-excursion
               (goto-char (point-max))
               (setq found? (re-search-backward job-id nil t))
               (when (or buffer? (not found?))
                 (with-current-buffer (get-buffer-create bname)
                   (erase-buffer)
                   (insert result)
                   (if json-out?
                       (json-ts-mode)
                     (org-mode))
                   (setq header-line-format msg))
                 (unless found?
                   (user-error "Org-block is gone.  Result inserted to the buffer %s" bname)))
               (forward-line -4)
               (org-babel-insert-result
                (if buffer? msg result)
                (list "replace" (cond
                                 ((s-prefix? "Error" result) "drawer")
                                 (buffer? "drawer")
                                 (json-out? "lang")
                                 (t "raw")))
                nil
                nil
                (when json-out? "json"))
               (when buffer?
                 (switch-to-buffer-other-window bname)))))))
      job-id))

  (defun im-big-query-job-status (job-id)
    "Get status for given job id."
    (interactive
     (list (read-string "Job ID: " (im-region-or 'symbol))))
    (let ((buf (get-buffer-create (format "*im-bigquery: %s*" job-id))))
      (switch-to-buffer buf)
      (insert (shell-command-to-string (format "bq show %s -j '%s'" (if current-prefix-arg "--format=prettyjson" "") job-id)))))

  (defun im-big-query-table-info (table-name)
    "Get summary information for TABLE-NAME.
  This information includes schema summary, last modified date,
  total {rows,bytes} etc. and first 10 rows of the table."
    (interactive
     (list (read-string
            "Table: "
            ;; Replace first `.' with `:'
            (s-replace-regexp
             "^\\([A-Za-z0-9_-]+\\)\\." "\\1:"
             (im-region-or
              (lambda () (im-inner-back-quote-at-point)))))))
    (let ((buffer-name (format "*bq table info: %s*" table-name)))
      (im-shell-command
       :buffer-name buffer-name
       :command (format "bq show '%s'" table-name)
       :on-start
       (lambda (&rest _)
         (toggle-truncate-lines +1)
         (im-shell-command
          :buffer-name buffer-name
          :command (format "bq head -n 200 '%s'" table-name))))))

  (defun im-big-query-get-all-datasets (project-id)
    (json-parse-string
     (shell-command-to-string
      (format "bq ls --format=json --project_id=%s" project-id))
     :object-type 'alist
     :array-type 'list))

  (defun im-big-query-get-all-tables (dataset-id)
    (json-parse-string
     (shell-command-to-string
      (format "bq ls --format=json --max_results 5000 '%s'" dataset-id))
     :object-type 'alist
     :array-type 'list))

  (defmemoizefile im-bq-all-tables () "~/.emacs.d/big-query-table-cache"
    (->>
     (im-big-query-get-all-datasets im-bq-project-id)
     (--map (alist-get 'id it))
     (--mapcat (im-big-query-get-all-tables it))))

  (defun im-bq-all-table-names ()
    (--map (alist-get 'id it) (im-bq-all-tables)))

  (im-cape
   :name bq-tables
   :generator (lambda (&rest _) (--map (s-replace ":" "." it) (im-bq-all-table-names)))
   :bound symbol
   :category symbol
   :key "M-o B")
#+end_src

** kbd-mode
For working with [[id:DF9E83D5-CA3E-4E3A-990A-ED2AEBA00983][KMonad]] kbd files. Do ~C-c C-c~ (~kbd-start-demo~) to apply your config and try it in a buffer.

#+begin_src emacs-lisp
  (use-package kbd-mode
    :straight (:host github :repo "kmonad/kbd-mode")
    :mode "\\.kbd\\'"
    :config
    (setq kbd-mode-kill-kmonad "pkill -9 kmonad")
    (setq kbd-mode-start-kmonad "kmonad ~/.config/kmonad.kbd"))
#+end_src

** lua-mode
#+begin_src emacs-lisp
  (use-package lua-mode
    :mode "\\.lua\\'")
#+end_src
** jsonnet-mode
#+begin_src emacs-lisp
  (use-package jsonnet-mode
    :mode ("\\.jsonnet\\'" "\\.libsonnet\\'")
    :config
    ;; Apheleia config, so that it automatically formats on save
    (setf (alist-get 'jsonnet apheleia-formatters) '("jsonnetfmt" "-"))
    (setf (alist-get 'jsonnet-mode apheleia-mode-alist) 'jsonnet))
#+end_src
** sql

I generally do not edit ~.sql~ files but instead I do SQL through code blocks in org-mode. /lsp-mode/ offers ~lsp-org~ command to help using LSP features inside org-mode code blocks. It synergzes well with lsp-sqls. One important thing to remember is that you need to have a ~:tangle <file>~ in the code blocks so that LSP mode can actually have the tangled file to send to the corresponding LSP.

- ~lsp-org~ :: Start LSP mode. Must be executed with cursor being source block.
- ~lsp-virtual-buffer-disconnect~ :: Turn off lsp-mode.

#+begin_src emacs-lisp
  (defun im-sql-setup-lsp ()
    "Set `lsp-sqls-connections' using `sql-connection-alist'.
  Only works for PostgreSQL connections right now."
    (setq
     lsp-sqls-connections
     (--map
      `((driver . "postgresql")
        (dataSourceName . ,(format "host=%s port=%s user=%s password=%s dbname=%s sslmode=disable"
                                   (car (alist-get 'sql-server it))
                                   (car (alist-get 'sql-port it))
                                   (car (alist-get 'sql-user it))
                                   (car (alist-get 'sql-password it))
                                   (car (alist-get 'sql-database it)))))
      sql-connection-alist)))
#+end_src
* Window and buffer management
** tab-bar-mode
It's a great workspace manager that comes bundled with Emacs. I was using an abomination where ~persp.el~ and ~eyebrowse~ was glued together but I guess this is a simpler and more sane alternative to them.

~tab-history-mode~ is just like ~winner-mode~ but tab-local which saves you from a lot of trouble.

#+begin_src emacs-lisp
  (tab-bar-mode)
  (tab-bar-history-mode)

  (setq tab-bar-new-tab-to 'rightmost)
  (setq tab-bar-new-tab-choice im-init-file)
  (setq
   tab-bar-format
   '(tab-bar-format-tabs
     tab-bar-separator
     tab-bar-format-add-tab
     tab-bar-format-align-right
     tab-bar-format-global))

  ;; Don't show global-mode-string in mode-line because we already show
  ;; it on right side of the tab-bar
  (setq mode-line-misc-info (assq-delete-all 'global-mode-string mode-line-misc-info))
#+end_src

Use a slightly modified version of ~tab-bar-tab-name-format~.

#+begin_src emacs-lisp
  (setq tab-bar-tab-hints t)
  ;; ^ Show numbers before tab names
  (setq tab-bar-auto-width nil)
  (setq tab-bar-auto-width-max t)
  ;; ^ Hmmm
  (setq tab-bar-tab-name-format-function #'tab-bar-tab-name-format-default)
  (setq tab-bar-tab-name-function #'im-current-project-name)
#+end_src

Evil has a default binding for switching between tabs with ~gt~ and ~gT~, switching forward and backward respectively. I just make them repeatable so that after first ~gt~ (~gT~) I can hammer down ~t~ (or ~T~) to switch next/prev tab quickly instead of doing ~gt~ (or ~gT~) again and again.

#+begin_src emacs-lisp
  (im-make-repeatable tab-bar-switch
    "t" tab-bar-switch-to-next-tab
    "T" tab-bar-switch-to-prev-tab)
#+end_src

I want to show ~consult-buffer~ when I open a new tab to be able to quickly jump a file. I also want to show it in a buffer, not in mini-buffer.

#+begin_src emacs-lisp
  (defun im-tab-bar-new-tab ()
    "Open a new tab and display consult-buffer."
    (interactive)
    (tab-bar-new-tab)
    (let ((vertico-multiform-commands '((consult-buffer buffer (vertico-buffer-display-action . (display-buffer-same-window)))))
          (mini-frame-ignore-commands `(,@mini-frame-ignore-commands consult-buffer))
          (this-command 'consult-buffer))
      (consult-buffer)))
#+end_src

** tab-line-mode
:PROPERTIES:
:ID:       163981c6-a121-4841-be08-54e359233450
:END:
#+begin_src emacs-lisp
  (setq tab-line-close-button-show 'selected)
  (setq tab-line-tabs-function #'im-tab-line-buffers)
  (setq tab-line-tab-name-function #'tab-line-tab-name-truncated-buffer)
  (setq tab-line-tab-name-truncated-max 25)
  (global-tab-line-mode)

  (defvar im-tab-line-hidden-buffer-name-regexp
    (concat
     "\\*\\(Calc.*\\|Calendar\\|elfeed-log\\|helpful.*\\|Compile-Log\\|Help\\|lsp-log\\)\\*"
     "\\|magit.*"
     "\\|slack-curl-downloader"
     "\\|slack-log"
     "\\|slack-event-log"
     "\\|dir-data"
     "\\|.*-ls\\*"
     "\\|.*stderr\\*"
     "")
    "Regexp to filter out buffer names on tab line.")

  (defun im-tab-line-buffers ()
    "Return releated project buffers (not limited to files, shells
  etc.) to display in tab-line."
    (let* ((proj (or (im-current-project-root)
                     (expand-file-name default-directory)))
           (buffer-name (buffer-name))
           (buffer-filter (if (s-matches? "^\\*\\|\\$" buffer-name)
                              (apply-partially #'im-tab-line--buffer-same-group? buffer-name)
                            (apply-partially #'im-tab-line--buffer-same-project? proj))))
      (seq-sort-by
       #'buffer-name #'string<
       (seq-filter (lambda (b)
                     (with-current-buffer b
                       (and (im-tab-line--buffer-valid?)
                            (funcall buffer-filter))))
                   (funcall tab-line-tabs-buffer-list-function)))))

  (defun im-tab-line--buffer-valid? ()
    (not (s-matches? im-tab-line-hidden-buffer-name-regexp (buffer-name))))

  (defun im-tab-line--buffer-same-project? (project-dir)
    (and
     (s-prefix? project-dir (expand-file-name default-directory))
     (not (s-matches? "^\\*\\|\\$" (buffer-name)))))

  (defun im-tab-line--buffer-same-group? (orig-buffer-name)
    (s-prefix? (substring orig-buffer-name 0 4) (buffer-name)))
#+end_src

** tabgo.el
#+begin_src emacs-lisp
  (use-package tabgo
    :straight (:host github :repo "isamert/tabgo.el")
    :demand t
    :general
    (:states 'normal
     "M-r" #'tabgo)
    (:states 'normal :keymaps 'evil-org-mode-keymap
     "M-r" #'tabgo))
#+end_src
** bufler
Good for buffer management, especially for groupped killings.

#+begin_src emacs-lisp
  (use-package bufler
    :commands (bufler)
    :config
    (evil-define-key 'normal bufler-list-mode-map
      (kbd "q") #'quit-window
      (kbd "x") #'bufler-list-buffer-kill
      (kbd "<return>") #'bufler-list-buffer-switch
      (kbd "<tab>") #'magit-section-cycle
      (kbd "M-,") #'bufler-list-buffer-peek
      (kbd "p") #'bufler-list-buffer-peek))
#+end_src

** Functions
#+begin_src emacs-lisp
  (defun im-quit ()
    "Quit current window or buffer. Source: meow-quit"
    (interactive)
    (if (> (seq-length (window-list (selected-frame))) 1)
        (delete-window)
      (previous-buffer)))

  (defun im-split-window-below ()
    "Split window below and focus."
    (interactive)
    (split-window-below)
    (other-window 1))

  (defun im-split-window-right ()
    "Split window right and focus."
    (interactive)
    (split-window-right)
    (other-window 1))

  (defun im-print-buffer-file-info (&optional kill-file-path)
    (interactive "P")
    (let* ((proj-name (im-current-project-name))
           (proj-path (or (im-current-project-root) (expand-file-name "~/")))
           (fpath (or (buffer-file-name) (buffer-name)))
           (fpath-pretty (string-replace (expand-file-name "~") "~" fpath)))
      (message "[%s] %s\n%s\n%s\n%s\n%s"
               (propertize proj-name 'face 'bold)
               (propertize (string-remove-prefix proj-path fpath) 'face '(:foreground "plum"  :slant italic))
               (format "%s%s" (if kill-file-path (propertize "Copied: " 'face 'bold) "") fpath-pretty)
               (format "Size: %s" (im-human-readable-size (buffer-size)))
               (format "Current branch: %s" (lab-git-current-branch))
               (im-read-time))
      (when kill-file-path
        (im-kill fpath-pretty))))
#+end_src
** Keybindings
#+begin_src emacs-lisp
  (evil-define-key 'normal 'global
    "Q" #'im-quit
    (kbd "M-\\") #'im-split-window-right
    (kbd "M--")  #'im-split-window-below
    (kbd "[2") #'tab-line-switch-to-prev-tab
    (kbd "]2") #'tab-line-switch-to-next-tab
    (kbd "[1") #'tab-bar-switch-to-prev-tab
    (kbd "]1") #'tab-bar-switch-to-next-tab)

  (im-leader
    "l" #'evil-window-right
    "h" #'evil-window-left
    "j" #'evil-window-down
    "k" #'evil-window-up)

  (im-leader
    ;; misc window operations
    "wo" #'other-window
    "w1" #'delete-other-windows
    "w=" #'balance-windows
    ;; window-move
    "wL" #'evil-window-move-far-right
    "wH" #'evil-window-move-far-left
    "wJ" #'evil-window-move-very-bottom
    "wK" #'evil-window-move-very-top
    ;; window-size
    "w+" #'enlarge-window
    "w-" #'shrink-window
    "w>" #'enlarge-window-horizontally
    "w<" #'shrink-window-horizontally
    ;; workspace (tab-bar-mode)
    "wu" #'tab-bar-history-back ;; undo
    "wr" #'tab-bar-history-forward ;; redo
    "wt" #'im-tab-bar-new-tab ;; tab
    "wn" #'tab-bar-rename-tab ;; name
    "wm" #'tab-move ;; move
    "ws" #'tab-bar-switch-to-tab ;; switch
    "wl" #'tab-bar-switch-to-recent-tab ;; last
    "wk" #'tab-close ;; kill
    ;; extra
    "wi" #'im-print-buffer-file-info
    ;; buffer
    "wb" #'bufler)

  (evil-define-key '(normal insert motion) 'global
    (kbd "M-1") (λ-interactive (tab-bar-select-tab 1))
    (kbd "M-2") (λ-interactive (tab-bar-select-tab 2))
    (kbd "M-3") (λ-interactive (tab-bar-select-tab 3))
    (kbd "M-4") (λ-interactive (tab-bar-select-tab 4))
    (kbd "M-5") (λ-interactive (tab-bar-select-tab 5)))

  (im-make-repeatable winner
    "u" tab-bar-history-back
    "r" tab-bar-history-forward)

  (im-make-repeatable window-resize
    "+" enlarge-window
    "-" shrink-window
    ">" enlarge-window-horizontally
    "<" shrink-window-horizontally)
#+end_src
* Misc functions
** marks integration
[[https://github.com/im-marks][marks]] is a grep-like tool for searching org-mode and markdown files. The following snippet provides a ~consult~ support for marks.

#+begin_src emacs-lisp
  (im-leader "cm" #'im-marks-my-docs)

  (defun im-consult--marks-builder (input)
    (pcase-let ((`(,arg . ,opts) (consult--command-split input)))
      (list
       :command
       (list "marks" "--no-color" "--null" "--path" default-directory "--query" input)
       :highlight
       (apply-partially #'consult--highlight-regexps (list (regexp-quote arg)) t))))

  (defun im-marks (&optional directory)
    "Run `marks'."
    (interactive)
    (let ((default-directory (or directory default-directory)))
      (consult--grep "marks" #'im-consult--marks-builder default-directory "")))

  (defun im-marks-my-docs ()
    "Run marks inside `~/Documents/notes'."
    (interactive)
    (im-marks (expand-file-name "~/Documents/notes")))
#+end_src
** Jira
#+begin_src emacs-lisp :lexical yes
  (im-leader
    "ejo" #'im-open-jira-issue-at-point
    "eji" #'im-jira-list-issues
    "ejc" #'im-jira-create-ticket)

  ;;
  ;; Install required JIRA client
  ;;

  (use-package jiralib2
    :config
    (setq jiralib2-url ty-jira-url)
    (setq jiralib2-auth 'basic)
    (setq jiralib2-user-login-name ty-jira-login)
    (setq jiralib2-token nil))

  ;;
  ;; My completing-read based JIRA utilities
  ;;

  (defvar im-git-worktrees-root "~/Workspace/projects/worktrees"
    "Directory to create worktrees in.")

  (defvar im-git-main-branch "master"
    "Main branch name.")

  (defvar im-jira-projects '(("AI"))
    "List of projects that I enrolled in JIRA.")

  (defvar im-jira-base-branch "origin/master"
    "Brach to create feature branches from.
  Consider using origin/something to create the branch from latest
  something.")

  (defvar im-jira-feature-branch-prefix "feature/"
    "Prefix to prepend feature branch names.")

  (defvar im-jira-my-issues-query "Pair-programmer = currentUser() OR assignee = currentUser() OR creator = currentUser() ORDER BY createdDate DESC"
    "Query to find out issues that are assigned to me.")

  (defvar im-jira-kanban-board-query
    "project = AI AND (fixVersion in unreleasedVersions() OR fixVersion is EMPTY) AND createdDate >= -2w ORDER BY Rank ASC"
    "Query to get kanban board issues.")

  (defvar im-jira-board-id
    "1332"
    "Interested board id. TODO: make this a list so that I can access to multiple boards by `im-jira-list-issues'.")

  (defun im-open-jira-issue (issue-number)
    "Open given Jira ISSUE-NUMBER."
    (interactive "sIssue: ")
    (let ((url (format "%s/browse/%s" jiralib2-url (car (s-split " " issue-number)))))
      (kill-new url)
      (browse-url url)))

  (defun im-jira-issue-at-point ()
    (let ((sym (or (thing-at-point 'symbol) "")))
      (when (s-matches? "[a-zA-Z]+-[0-9]+" sym)
        sym)))

  (defun im-open-jira-issue-at-point ()
    "Open issue at point."
    (interactive)
    (im-open-jira-issue
     (or (im-jira-issue-at-point)
         (read-string "Enter issue number: "))))

  (defmemoize im-jira-get-my-issues ()
    (jiralib2-jql-search im-jira-my-issues-query))

  (defun im-jira-get-kanban-issues ()
    (jiralib2-jql-search im-jira-kanban-board-query))

  (defun im-jira-get-board-issues ()
    (jiralib2-board-issues im-jira-board-id nil))

  (defun im-jira-jql (jql)
    (interactive (list (read-string "Enter JQL: " "text ~ \"...\" AND statusCategory = \"To Do|In Progress|Done\"")) "sEnter JQL: ")
    (jiralib2-jql-search jql))

  (defmemoize im-jira-get-current-sprint-issues ()
    (let ((issues '()))
      (mapc
       (lambda (project)
         (setq
          issues
          (thread-last (format "project = \"%s\" AND Sprint in openSprints()"
                               (car project) (car project) (cdr project))
                       (jiralib2-jql-search)
                       (append issues))))
       im-jira-projects)
      issues))

  (defun im-jira-get-new-issues ()
    (let ((issues '()))
      (mapcar
       (lambda (project)
         (setq
          issues
          (thread-last (format "project = \"%s\" AND created > -7d"
                               (car project))
                       (jiralib2-jql-search)
                       (append issues))))
       im-jira-projects)
      issues))

  (defun im-jira-list-issues (&optional arg)
    (interactive "P")
    (im-jira-issue-actions
     (im-completing-read
      "Select ticket: "
      (pcase (completing-read "Issue list: " '("My issues" "Current Sprint" "New issues" "Kanban" "Board" "JQL"))
        ("My issues" (im-jira-get-my-issues))
        ("New issues" (im-jira-get-new-issues))
        ("Current Sprint" (im-jira-get-current-sprint-issues))
        ("Board" (im-jira-get-board-issues))
        ("Kanban" (im-jira-get-kanban-issues))
        ("JQL" (call-interactively #'im-jira-jql)))
      :formatter #'im-jira--format-ticket-name
      :sort? nil)))

  (defun im-jira-ticket-to-branch (key summary)
    "Create a new branch from given ISSUE-NAME and switch to it."
    (interactive "sIssue name: ")
    (let ((branch-name (im-jira--create-branch-name-from-ticket (concat key summary))))
      (message "Updating...")
      (unless (= 0 (shell-command "git fetch --all"))
        (user-error "Cannot git fetch --all"))
      (message "Creating branch...")
      (magit-branch-and-checkout branch-name im-jira-base-branch)
      (vc-refresh-state)
      (im-jira-change-issue-status-to-status key "In Progress")
      (message "Currently on %s." (lab-git-current-branch))))

  (defun im-jira-ticket-to-worktree (key summary)
    (interactive "sIssue name: ")
    (let* ((branch-name (im-jira--create-branch-name-from-ticket (concat key summary)))
           (worktree (expand-file-name (format "%s/%s" im-git-worktrees-root (s-replace "/" "-" branch-name)))))
      (message "Updating...")
      (unless (= 0 (shell-command "git fetch --all"))
        (user-error "Cannot git fetch --all"))
      (message "Creating worktree...")
      (if (-contains? (vc-git-branches) branch-name)
          (magit-worktree-checkout worktree branch-name)
        (magit-worktree-branch worktree branch-name im-jira-base-branch))
      (tab-bar-new-tab)
      (tab-bar-rename-tab worktree)
      (cd worktree)
      (find-file)
      (vc-refresh-state)
      (im-jira-change-issue-status-to-status key "In Progress")
      (message "Currently on %s." (lab-git-current-branch))))

  (defun im-jira-create-ticket ()
    (interactive)
    (let ((project (im-jira--select-project))
          (issue-type (im-jira--select-issue-type))
          (summary (read-string "Issue summary: ")))
      (im-get-input
       :init
       (format (concat
                "* %s\n"
                ":PROPERTIES:\n"
                ":PROJECT-ID: %s\n"
                ":ISSUE-TYPE: %s\n"
                ":SPRINT: active|future\n"
                ":END:\n\n"
                (im-jira--get-issue-template issue-type))
               summary project issue-type)
       :pre-process
       (lambda ()
         (goto-char (point-min))
         (list
          :summary (org-entry-get nil "ITEM")
          :project-id (org-entry-get nil "PROJECT-ID")
          :type (org-entry-get nil "ISSUE-TYPE")
          :rest `((,(im-jira-get-issue-field-id-for "Sprint") .
                   ,(alist-get 'id (im-jira-find-sprint (org-entry-get nil "SPRINT")))))))
       :on-accept
       (lambda (description props)
         (setq description
               (->>
                (org-export-string-as description 'confluence t)
                (s-split "\n")
                (-drop 1)
                (s-join "\n")))
         (message ">> (im-jira-create-ticket %s :description %s)" props description)
         (thread-last
           (apply #'jiralib2-create-issue
                  `(,(plist-get props :project-id)
                    ,(plist-get props :type)
                    ,(plist-get props :summary)
                    ,description
                    ,@(plist-get props :rest)))
           (im-jira-issue-actions))))))

  (defun im-jira-get-issue-fields ()
    (jiralib2-session-call "/rest/api/2/field"))

  ;; TODO support pagination
  (defun im-jira-get-sprints ()
    (alist-get 'values (jiralib2-session-call (format "/rest/agile/1.0/board/%s/sprint" im-jira-board-id))))

  (defun im-jira-find-sprint (sprint)
    "Find a sprint. SPRINT can be a full sprint name or one \"active\"|\"future\"."
    (let ((sprints (im-jira-get-sprints)))
      (or
       (--find (string-equal sprint (alist-get 'name it)) sprints)
       (--find (string-equal sprint (alist-get 'state it)) sprints))))

  (defun im-jira-get-issue-field-id-for (field-name)
    (alist-get
     'id
     (--find
      (string-equal field-name (alist-get 'name it))
      (im-jira-get-issue-fields))))

  (defun im-jira-get-issue-transitions (issue)
    (alist-get
     'transitions
     (jiralib2-session-call (format "/rest/api/2/issue/%s/transitions?expand=transition.fields" issue))))

  (defun im-jira-change-issue-status-to (issue status-id)
    (jiralib2-session-call
     (format "/rest/api/2/issue/%s/transitions?expand=transition.fields" issue)
     :type "POST"
     :data (json-encode
            `((transition (id . ,status-id))))))

  (defun im-jira-change-issue-status (key)
    (interactive "sIssue number: ")
    (->>
     (lab--completing-read-object
      "Select status: "
      (im-jira-get-issue-transitions key)
      :formatter (lambda (it) (let-alist it (format "%s [%s]" .name .to.name))))
     (alist-get 'id)
     (im-jira-change-issue-status-to key)))

  (defun im-jira-change-issue-status-to-status (issue-id status)
    "Same as `im-jira-change-issue-status-to' but uses the
  status name as shown in Jira UI instead of status id."
    (im-jira-change-issue-status-to
     issue-id
     (alist-get
      'id
      (--find
       (string-equal (alist-get 'name it) status)
       (im-jira-get-issue-transitions issue-id)))))

  ;;
  ;; Utility
  ;;

  (defmemoizefile im-jira-get-users () "~/.emacs.d/jira-user-cache"
    (mapcar
     (lambda (project) (cons project (jiralib2-get-users project)))
     (mapcar #'car im-jira-projects)))

  (defun im-jira--select-user ()
    (thread-last
      (im-jira-get-users)
      (assoc-string (im-jira--select-project))
      (cdr)
      (--map (cons (alist-get 'name it) it))
      (im-alist-completing-read "Select a user: ")))

  (defun im-jira--select-project ()
    "Interactively select one of enrolled projects."
    (if (eq (length im-jira-projects) 1)
        (caar im-jira-projects)
      (completing-read "Select project: " im-jira-projects)))

  (defun im-jira--select-issue-type ()
    (completing-read
     "Issue type: "
     (--map
      (let-alist it (cons .name .id))
      (jiralib2-get-issuetypes))))

  (defun im-jira--get-issue-template (issue-type)
    (pcase issue-type
      ("Story" "** Motivation\n\n\n** Description\n\n\n** Acceptance Criteria\n\n\n** Projects\n\n\n** Has Automation Test?\n\n\n** Links (UI/UX, Analysis etc.)\n\n")
      ("Sprint Development Bug" "** Description\n\n\n**Case\n\n\n** Projects\n\n")
      ("Production Bug" "** Description\n\n\n** Steps\n\n\n** Projects\n\n\n** Incident Excel\n\n\n** Links - SS - Video\n\n")))

  (defun im-jira--create-branch-name-from-ticket (issue-name)
    "Create a branch name from given Jira ISSUE-NAME"
    (thread-last
      issue-name
      (s-replace-all '((" " . "-") (":" . "-") ("\"" . "") ("/" . "-") ("&" . "") ("(" . "-") (")" . "-")))
      (s-replace "---" "-")
      (s-replace "--" "-")
      (s-downcase)
      (im-s-upcase-until "-")
      (s-prepend im-jira-feature-branch-prefix)
      (read-string "Branch name: ")))

  ;; TODO Color code status etc.
  (defun im-jira--format-ticket-name (it)
    "Format ticket name for displaying in completing-read window."
    (let-alist it
      (format
       "%-7s\t[%-11s]\t%-15s => %-15s\t%s"
       (propertize .key
                   'face 'bold)
       (propertize (s-truncate 11 .fields.status.name)
                   'face 'italic)
       (propertize (s-truncate 15 (or .fields.reporter.name "N/A"))
                   'face 'italic)
       (propertize (s-truncate 15 (or .fields.assignee.name "N/A"))
                   'face 'italic)
       .fields.summary)))

  (defun im-jira-issue-actions (issue)
    (interactive
     (list (jiralib2-get-issue (read-string "Jira issue: " (or (im-jira-issue-at-point) "")))))
    (cl-loop
     (let-alist issue
       (let* ((action
               (im-completing-read
                (format "Act on %s: " (s-truncate 20 .fields.summary))
                '("View" "Open" "Update" "To branch" "To worktree" "Assign to..." "Insert as task" "Change status" "Raw" "[Cancel]")
                :sort? nil)))
         (pcase action
           ("View"
            (im-jira-view-ticket .key)
            (cl-return))
           ("Open"
            (with-default-browser
             (im-open-jira-issue .key))
            (cl-return))
           ("Update"
            (im-jira-update-ticket .key .fields.summary .fields.description)
            (cl-return))
           ("To branch"
            (im-jira-ticket-to-branch .key .fields.summary)
            (cl-return))
           ("To worktree"
            (im-jira-ticket-to-worktree .key .fields.summary)
            (cl-return))
           ("Assign to..."
            (jiralib2-assign-issue
             .key
             (alist-get 'name (im-jira--select-user))))
           ("Change status"
            (im-jira-change-issue-status .key))
           ("Insert as task"
            (insert (format "** TODO [#A] %s %s :work:" .key .fields.summary)))
           ("Raw"
            (im-json-encode-and-show issue)
            (cl-return))
           ("[Cancel]"
            (cl-return)))))))

  (defun im-convert-jira-markup-to-org-mode (jira-markup)
    "Convert given JIRA-MARKUP string to org-mode format."
    (with-temp-buffer
      (insert jira-markup)
      ;; This creates loose lists where newlines appear between
      ;; list items and ox-confluence does not handle this well and
      ;; breaks lists.
      (shell-command-on-region
       (point-min) (point-max)
       "pandoc -f jira -t org --wrap=none"
       nil t)
      ;; So I try to remove those unnecassary new lines here.
      (->>
       (buffer-string)
       ;; Same replacement applied twice.
       (replace-regexp-in-string "^\\([ \t]*\\)-\\(.*\\)\n\n\\([ \t]*\\)-" "\\1-\\2\n\\3-")
       (replace-regexp-in-string "^\\([ \t]*\\)-\\(.*\\)\n\n\\([ \t]*\\)-" "\\1-\\2\n\\3-")
       (replace-regexp-in-string "\\\\\\\\$" "")
       ;; Fix deeply nested bullet points
       (replace-regexp-in-string "---- " "- ")
       ;; Fix - [ ] markers
       (replace-regexp-in-string "- \\*=( )=\\* " "- [ ] ")
       (replace-regexp-in-string "- \\*=(-)=\\* " "- [-] ")
       (replace-regexp-in-string "- \\*=(X)=\\* " "- [X] "))))

  (defun im-jira-update-ticket (key summary description)
    (im-get-input
     :init
     (concat
      "* "
      summary
      "\n"
      (im-convert-jira-markup-to-org-mode description))
     :pre-process
     (lambda ()
       (goto-char (point-min))
       (org-entry-get nil "ITEM"))
     :on-accept
     (lambda (description summary)
       (setq description
             (->>
              (org-export-string-as description 'confluence t)
              (s-split "\n")
              (-drop 1)
              (s-join "\n")))
       (message ">> (im-jira-update-ticket \"%s\" \"%s\" \"%s\")" key summary description)
       (jiralib2-update-summary-description key summary description))))

  ;;
  ;; jira-view-mode
  ;;

  (defvar-local jira-view-mode-ticket nil
    "Currently viewed ticket object.")
  (define-derived-mode jira-view-mode org-mode "JiraView"
    "Mode for viewing JIRA tickets.")

  (defun jira-view-mode-open-externally ()
    (interactive)
    (with-default-browser
     (let-alist jira-view-mode-ticket
       (im-open-jira-issue .key))))

  (defun jira-view-mode-edit ()
    (interactive)
    (let-alist jira-view-mode-ticket
      (im-jira-update-ticket .key .fields.summary .fields.description)))

  (defun jira-view-mode-reload ()
    (interactive)
    (let-alist jira-view-mode-ticket
      (im-jira-view-ticket .key)))

  (defun jira-view-mode-act ()
    (interactive)
    (im-jira-issue-actions jira-view-mode-ticket))

  (evil-define-key 'normal jira-view-mode-map
    (kbd "&") #'jira-view-mode-open-externally
    (kbd "ge") #'jira-view-mode-edit
    (kbd "gr") #'jira-view-mode-reload
    ;; TODO All actions might be single keypress.
    (kbd "ga") #'jira-view-mode-act)

  (defun im-jira-view-ticket (key)
    (interactive "sIssue key: ")
    (when-let (match (s-match "browse/\\([a-zA-Z0-9-]+\\)/?" key))
      (setq key (nth 1 match)))
    (let ((buffer (get-buffer-create (format "*jira:%s*" key))))
      (unless (eq (current-buffer) buffer)
        (switch-to-buffer-other-window buffer)))
    (erase-buffer)
    (let ((ticket (jiralib2-get-issue key)))
      (let-alist ticket
        (insert
         (concat
          "* "
          key
          " - "
          .fields.summary
          "\n"
          (im-convert-jira-markup-to-org-mode .fields.description)))
        (jira-view-mode)
        (setq header-line-format "Hit `&' to open in browser, `ge' to edit, `gr' to reload, `ga' to see actions.")
        (setq-local jira-view-mode-ticket ticket)
        (goto-char (point-min))
        (org-set-property "STATUS" (or .fields.status.name "N/A"))
        (org-set-property "REPORTER" (or .fields.reporter.name "N/A"))
        (org-set-property "ASSIGNEE" (or .fields.assignee.name "N/A"))
        (org-fold-show-all))))


  (defun im-jira-list-current-sprint-assignee-swimlane ()
    "Draw an org table for the current sprint that resembles assignee
  swimlanes of JIRA.
  It also shows how much story point each assignee has and how much
  story points they have released. See the following figure:

    | Assignee  | Total | Done | Sub-total | Status      | Issue         |
    |-----------+-------+------+-----------+-------------+---------------|
    | someone-1 |   8.0 |  3.0 |           |             |               |
    |           |       |      |       3.0 | Open        | AI-483 - ...  |
    |           |       |      |       3.0 | Done        | AI-423 -  ... |
    |           |       |      |       2.0 | Code Review | AI-488 - ...  |
    |-----------+-------+------+-----------+-------------+---------------|
    | someone-2 |   7.0 |  2.0 |           |             |               |
    |           |       |      |       2.0 | Released    | AI-485 - ...  |
    |           |       |      |       5.0 | In Progress | AI-313 - ...  |"
    (interactive)
    (with-current-buffer (get-buffer-create "*jira: current-sprint-by-points*")
      (erase-buffer)
      (org-mode)
      (insert "| Assignee | Total | Done | Sub-total | Status | Issue |\n|-\n")
      (->>
       (im-jira-get-current-sprint-issues)
       ;; (--filter (let-alist it .fields.assignee.name))
       (--group-by (let-alist it .fields.assignee.name))
       (map-apply
        (lambda (key vals)
          (list
           :assignee key
           :total (-sum (--map (let-alist it (or .fields.customfield_10002 0)) vals))
           :done (->>
                  vals
                  (--filter (-contains? '("Done" "Released") (let-alist it .fields.status.name)))
                  (--map (let-alist it (or .fields.customfield_10002 0)))
                  (-sum))
           :tasks
           (->>
            (--map (let-alist it
                     (list
                      :points .fields.customfield_10002
                      :summary (format "%s - %s" .key .fields.summary)
                      :status .fields.status.name))
                   vals)
            (--sort (string> (plist-get it :status) (plist-get other :status)))))))
       (--sort (> (plist-get it :total) (plist-get other :total)))
       (--map (format "| %s | %s | %s | | | |\n%s"
                      (plist-get it :assignee)
                      (plist-get it :total)
                      (plist-get it :done)
                      (s-join
                       "\n"
                       (--map (format "| | | | %s | %s | %s |"
                                      (plist-get it :points)
                                      (plist-get it :status)
                                      (s-truncate 60 (plist-get it :summary)))
                              (plist-get it :tasks)))))
       (s-join "\n|-\n")
       (insert))
      (org-table-align)
      (goto-char (point-min))
      (switch-to-buffer (current-buffer))))
#+end_src

** My Android phone and Emacs
I have an Android phone that is running [[https://termux.com/][Termux]] all the time. If you install Termux through [[https://www.f-droid.org/][F-Droid]] you can also install [[https://f-droid.org/en/packages/com.termux.api/][Termux:API]] package which brings bunch of commands like =termux-clipboard-set=, =termux-sms-list= etc. Much of the commands requires to be called in foreground, so they are not very useful over SSH but you can work around that by starting a =tmux= session on the phone and executing commands on that tmux session through SSH. This way I can send arbitrary text to my phones clipboard using the commands below.

#+begin_src emacs-lisp
  (im-leader
    "ept" #'im-send-text-to-my-phone
    "epc" #'im-send-clipboard-to-my-phone)

  (defvar im-phone-hostname
    "f3"
    "Hostname or local address to connect to my phone by SSH.")

  (defun im-send-termux-command-async (cmd fn &rest args)
    "Send CMD to my phone.
  When CMD finishes, FN is called with the process output."
    (interactive "sText: ")
    (let (output
          (txt
           (concat cmd " " (s-join "" (--map (concat "\"" (s-replace "\"" "\\\"" it) "\"" " ") args))))
          (proc (start-process
                 "*im-termux-cmd*"
                 nil
                 "ssh"
                 "-T"
                 im-phone-hostname)))
      (set-process-filter proc (lambda (proc out) (setq output (concat output out))))
      (set-process-sentinel proc (lambda (proc event) (funcall fn output)))
      (process-send-string proc txt)
      (process-send-eof proc)
      (process-send-eof proc)
      proc))

  (defun im-send-termux-command (cmd &rest args)
    "Send CMD to my phone."
    (interactive "sText: ")
    (with-temp-buffer
      (insert cmd " ")
      (--each args
        (insert "\"" (s-replace "\"" "\\\"" it) "\"" " "))
      (shell-command-on-region
       (point-min)
       (point-max)
       (format "ssh -T %s" im-phone-hostname)
       t t)
      (buffer-string)))

  (cl-defun im-send-notification-to-my-phone
      (&key
       title
       content
       url-to-open)
    "Send a notification to my phone."
    (interactive
     (list :title (im-read-string "Title: ")
           :content (im-read-string "Content: ")
           :url-to-open (im-read-string "URL(?): ")))
    ;; I used to use Gotify but not using right now
    ;; (set-process-sentinel
    ;;  (start-process
    ;;   "gotify" "*gotify-out*"
    ;;   "gotify" "push" (format "--title='%s'" title) (format "--clickUrl='%s'" url-to-open) content)
    ;;  (lambda (proc text)
    ;;    ;; Try sending notification through termux if gotify fails
    ;;    (unless (eq (process-exit-status proc) 0)
    (im-send-termux-command-async
     "termux-notification"
     (lambda (_out) ">> Sent notification to phone.")
     "--title"
     title
     "--content"
     (or content "")
     "--action"
     (format "termux-open %s" url-to-open)))

  (defun im-send-text-to-my-phone (text)
    "Send TEXT to my phones clipboard. This only works if the phone
  is already open."
    (interactive "sText: ")
    (im-send-termux-command-async "termux-clipboard-set" (lambda (_) (message ">> Text sent: %s." text)) text))

  (defun im-send-clipboard-to-my-phone ()
    "Send current clipboard content to my phones clipboard. This only
  works if the phone is already open."
    (interactive)
    (im-send-text-to-my-phone (current-kill 0)))

  (defun im-list-phone-text-messages ()
    "List messages from my phone."
    (interactive)
    (let ((result (completing-read
                   "Messages: "
                   (seq-map
                    (lambda (msg) (let-alist msg (format "%s :: %s" .number .body)))
                    (json-read-from-string
                     (im-send-termux-command "termux-sms-list"))))))
      (switch-to-buffer-other-window (get-buffer-create "*im-message*"))
      (insert result)))
#+end_src

** Signal
#+begin_src emacs-lisp
  (require 'dbus)

  (im-leader
   "epn" #'im-signal-send-note-to-myself
   "epm" #'im-signal-send-message)

  (defconst im-signal-dbus-args '(:session "org.asamk.Signal"
                                                "/org/asamk/Signal"
                                                "org.asamk.Signal"))

  (defun im-signal (&rest args)
    "Send a signal DBUS command with ARGS."
    (apply #'dbus-call-method `(,@im-signal-dbus-args ,@args)))

  (defun im-signal-async (&rest args)
    "Send an async Signal DBUS command with ARGS."
    (apply #'dbus-call-method-asynchronously `(,@im-signal-dbus-args ,@args)))

  (defun im-signal-send-note-to-myself (note &optional attachments)
    "Send a NOTE with attachments to my phone."
    (interactive
     (list
      (if (use-region-p)
          (buffer-substring (region-beginning) (region-end))
        (read-string "Enter note: "))
      (when (y-or-n-p "Want to attach something? ")
        (list (read-file-name "Attachment: ")))))
    (im-signal-async
     "sendNoteToSelfMessage"
     (lambda (msg) (message ">> Signal %s" msg))
     note
     (or (mapcar 'expand-file-name attachments)
         '(:array))))

  (defun im-signal-send-message (recipient content &optional attachments)
    "Send message to RECIPIENT with CONTENT."
    (interactive
     (list
      (im-signal-select-contact)
      (if (use-region-p)
          (buffer-substring (region-beginning) (region-end))
        (read-string "Enter message: "))
      (when (y-or-n-p "Want to attach something? ")
        (list (read-file-name "Attachment: ")))))
    (im-signal-async
     (if (plist-get recipient :number)
         "sendMessage"
       "sendGroupMessage")
     (lambda (msg) (message ">> Signal %s" msg))
     content
     (or (mapcar 'expand-file-name attachments)
         '(:array))
     (cadr recipient)))

  (defun im-signal-select-contact ()
    "Select a contact interactively."
    (let* ((contacts (--map
                      (cons (im-signal "getContactName" it) it)
                      (im-signal "listNumbers")))
           (groups (--map
                    (cons (format
                           "%s [GROUP]"
                           (im-signal "getGroupName"
                                           (dbus-string-to-byte-array (dbus-byte-array-to-string it))))
                          it)
                    (im-signal "getGroupIds")))
           (all (append contacts groups))
           (selected (cdr (assoc (completing-read "Send message to: " all) all))))
      (if (stringp selected)
          (list :number selected)
        (list :group (dbus-string-to-byte-array (dbus-byte-array-to-string selected))))))

  (defun im-signal-sync-message-received-handler (ts source receiver _ msg attchs)
    (message ">> [signal] sender=%s, receiver=%s, msg=%s, attach=%s" source receiver msg attchs)
    (when (and (string= im-my-phone-number source)
               (or
                (string= receiver im-my-phone-number)
                (-contains?
                 (--map (alist-get 'uuid it) (alist-get 'accounts (json-read-file (expand-file-name "~/.local/share/signal-cli/data/accounts.json"))))
                 receiver)))
      (cond
       ((s-prefix? "run" msg)
        (im-signal-send-note-to-myself
         (shell-command-to-string (s-chop-prefix "run " msg))))
       ((string= "help" msg)
        (im-signal-send-note-to-myself
         (concat "run <shell-command>\n"
                 "grab <file-path>\n"
                 "note <note-details>\n"
                 "help")))
       ((s-prefix? "grab" msg)
        (im-signal-send-note-to-myself
         "" (list (s-chop-prefix "grab " msg))))
       ((s-prefix? "note" msg)
        (kill-new (s-chop-prefix "note " msg))
        (im-clear-side-windows)
        (org-capture nil "I")
        (im-signal-send-note-to-myself (format ">> Noted: %s" msg)))
       ((s-prefix? "http" msg)
        (message ">> [signal] Copied to clipboard: %s" msg)
        (kill-new msg))
       ((s-equals? "clip" msg)
        (im-signal-send-note-to-myself (car kill-ring)))
       (attchs
        (--each attchs
          (let ((mime (im-mimetype it)))
            (cond
             ((s-prefix? "image/" mime)
              (message "TODO: Handle self images %s" it))
             ((s-prefix "audio/" mime)
              (message "TODO: Handle self sound %s" it)))))))))

  (defvar im-signal-bot-object nil)

  (defun im-start-signal-bot ()
    (interactive)
    (unless im-signal-bot-object
      (message ">> signal-bot is starting...")
      (setq
       im-signal-bot-object
       (apply
        #'dbus-register-signal
        `(,@im-signal-dbus-args
          ,"SyncMessageReceived"
          ,#'im-signal-sync-message-received-handler)))))

  (defun im-stop-signal-bot ()
    (interactive)
    (dbus-unregister-object im-signal-bot-object)
    (setq im-signal-bot-object nil))

  (run-with-timer 60 nil #'im-start-signal-bot)
#+end_src
** people.org - Contact management
Please see [[https://isamert.net/2021/04/21/managing-your-contacts-in-org-mode-and-syncing-them-to-your-phone-android-ios-whatever-.html][this post]] for further information.

#+begin_src emacs-lisp
  (defun im-contacts--build-contact-item (template-string contact-property)
    (cond
     ((s-contains? "$1" contact-property)
      (->>
       (org-entry-properties)
       (--filter (s-matches? (s-replace "$1" ".*" contact-property) (car it)))
       (--map (let ((subprop (nth 1 (s-match (s-replace "$1" "\\([a-zA-Z0-9_-]+\\)" contact-property) (car it)))))
            (concat (format (s-replace "$1" subprop template-string) (cdr it)) "\n")))))
     (t (if-let ((stuff (org-entry-get nil contact-property)))
            (concat (format template-string stuff) "\n")
          ""))))

  (defun im-contacts--contact-entry? ()
    (thread-last
      (org-entry-properties)
      (-map #'car)
      (--any (s-prefix? "PHONE" it))))

  (defun im-contacts-export-as-vcard (&optional file-name)
    "Create a .vcf FILE-NAME containing all contact information.
  I use \"Simple Contacts Pro\" to import contacts to my phone."
    (interactive
     (list
      (read-file-name
       "Where to save the .vcf file?"
       "~/Documents/sync/"
       "contacts.vcf")))
    (write-region
     (thread-last
       (org-map-entries
        (lambda ()
          (when (im-contacts--contact-entry?)
            (string-join
             `("BEGIN:VCARD\nVERSION:4.0\nPRODID:ez-vcard 0.11.3\n"
               ,(format "UID:urn:uuid:%s\n" (org-id-get nil t))
               ,(im-contacts--build-contact-item "FN:%s" "ITEM")
               ,(im-contacts--build-contact-item "N:;%s;;;" "ITEM")
               ,@(im-contacts--build-contact-item "TEL;TYPE=$1:%s" "PHONE_$1")
               ,@(im-contacts--build-contact-item "EMAIL;TYPE=$1:%s" "EMAIL_$1")
               ,@(im-contacts--build-contact-item "ADR;TYPE=$1:;;%s;;;;" "ADDRESS_$1")
               ,(im-contacts--build-contact-item "ORG:%s" "GROUP")
               ,(im-contacts--build-contact-item "CATEGORIES:%s" "GROUP")
               ,(thread-last
                  (im-contacts--build-contact-item "BDAY:%s" "SCHEDULED")
                  (s-replace-regexp "BDAY:<[0-9]\\{4\\}\\(.*\\) \\(\\w+\\)>" "BDAY:1900\\1")
                  (s-replace "-" ""))
               ;;,(format "REV:%s\n" (format-time-string "%Y-%m-%dT%T"))
               ;; TODO: add notes
               ;; Be careful while exporting and sending contact to other people
               "TITLE:\nEND:VCARD")
             "")))
        "LEVEL=1")
       (-filter #'identity)
       (s-join "\n"))
     nil
     file-name))
#+end_src
** Google search
#+begin_src emacs-lisp
  (defun im-google-this ()
    "Search selected region or current word in Google. Let's you edit the query beforehand."
    (interactive)
    (browse-url
     (format
      "https://google.com/search?q=%s"
      (read-string
       "Googling: "
       (im-region-or 'word)))))

  (im-leader "mg" #'im-google-this)
#+end_src

** TODO org-mode enhancements
I need to rewrite these functions using [[https://github.com/im-marks][marks]] for both speed and accuracy.

#+begin_src emacs-lisp
  ;; Keybindings

  (im-leader-v
    "ol" #'im-org-link-header
    "oj" #'im-org-jump-to-header
    ;; TODO: rewrite this:
    ;;"oL" 'im-org-backlinks
  )

  ;;
  ;; Utility
  ;;

  (defun im-org-header-line-to-title (line)
    "Remove TODO/*/unnecessary whitespace from given LINE.
  Then return the title of given `org-mode` header.
  Just like (org-entry-get nil \"ITEM\") but works on given string."
    (->> line
      (s-replace-regexp "\\(\\*\\|TODO\\|PROG\\|DONE\\|WAIT\\)" "") ;; Remove TODO states
      (s-replace-regexp "\\(\\[#.\\{1\\}\\]\\\)" "") ;; Remove priorities
      (s-replace-regexp ":\\(\\w+:\\)+$"  "") ;; Remove tags
      (replace-regexp-in-string "\\[\\[.*\\]\\[\\(.*\\)\\]\\]"  "\\1") ;; Fix links
      (replace-regexp-in-string "\\[\\[\\(.*\\)\\]\\]"  "\\1") ;; Fix links
      (s-trim)))

  (defun im-org-file-get-header-id (file-path header-line)
    "Return the id of given header at HEADER-LINE in FILE-PATH."
    (interactive)
    (save-excursion
      (with-current-buffer (let ((enable-local-variables nil)) (find-file-noselect file-path))
        (save-restriction
          (save-excursion
            (widen)
            (goto-char 0)
            (forward-line header-line)
            (org-id-get nil 'create)
            (save-buffer)
            (org-id-get nil 'create))))))

  (defun im-org-all-headers ()
    "Return all headers in `org-directory'."
    (->> (concat "cd " org-directory "; "
                 "rg"
                 " --no-heading" " --with-filename"
                 " --line-number" " -t org"
                 " " "\"^\\*+ \" ")
      (shell-command-to-string)
      (s-split "\n")
      (--filter (not (s-blank? it)))
      (--map
       (-let* (((fname line . content) (split-string it ":"))
               (header (im-org-header-line-to-title (string-join content ":"))))
         `(,(format
             "%s:%s %s %s"
             (propertize fname 'face '(:foreground "plum"  :slant italic))
             (propertize line 'face '(:slant italic :weight thin))
             (propertize "»" 'face '(:foreground "green"))
             (propertize header 'face '(:foreground "sky blue" :weight bold)))
           .
           (:fname ,(concat org-directory "/" fname) :line ,(1- (string-to-number line)) :header ,header))))))

  (defun im-org-link-header ()
    "Interactively select a header and insert it as a link into the buffer.
  Headers are gathered from all the org files found in `org-directory'."
    (interactive)
    (save-some-buffers)
    (let* ((selected (im-alist-completing-read
                      "Select header: "
                      (im-org-all-headers)
                      (when (use-region-p)
                        (buffer-substring-no-properties (region-beginning) (region-end)))))
           (header-id (im-org-file-get-header-id (plist-get selected :fname) (plist-get selected :line))))
      (org-insert-link
       nil
       (concat "id:" header-id)
       (unless (use-region-p)
         (read-string "Enter link text: " (plist-get selected :header))))))


  (defun im-org-jump-to-header ()
    "Jump to selected header."
    (interactive)
    (let* ((selected (im-alist-completing-read "Select header:" (im-org-all-headers))))
      (with-current-buffer (find-file-other-window (plist-get selected :fname))
        (widen)
        (goto-char 0)
        (forward-line (plist-get selected :line)))))

  ;; TODO Removed backlinks implementation, I will implement it once
  ;; minimal functionality within "marks" is done
#+end_src

** bullet.org
I have a ~bullet.org~ file that I keep my daily journal and here are some utility functions that use with it. I may document this later (or even publish it as a package?)

#+begin_src emacs-lisp
  ;; Keybindings

  (im-leader
    "obb" 'im-bullet-focus-non-day-header
    "oby" 'im-bullet-focus-yesterday
    "obY" 'im-bullet-focus-yesterday-indirect
    "obt" 'im-bullet-focus-today
    "obT" 'im-bullet-focus-tomorrow
    "obf" 'im-bullet-focus-given-day
    "obr" 'im-bullet-focus-recurring
    "obR" 'im-bullet-focus-recurring-indirect
    "obw" 'im-bullet-focus-work
    "obW" 'im-bullet-focus-work-indirect
    "obl" 'im-bullet-focus-life
    "obL" 'im-bullet-focus-life-indirect
    "obc" 'im-bullet-focus-computer
    "obC" 'im-bullet-focus-computer-indirect
    "obi" 'im-bullet-focus-inbox
    "obI" 'im-bullet-focus-inbox-indirect)

  ;;
  ;; Date utils
  ;;

  (defun im-today ()
    "Get todays date in format YYYY-MM-DD Day."
    (format-time-string "%Y-%m-%d %a"))

  (defun im-u ()
    "Get day of week as number."
    (string-to-number (format-time-string "%u")))

  (defun im-d ()
    "Get day of month as number."
    (string-to-number (format-time-string "%d")))

  (defun im-V ()
    "Get week number."
    (string-to-number (format-time-string "%V")))

  (defun im-date (date &optional str)
    "Display the time described by DATE.
  DATE can be 'now', 'yesterday', 'two days ago' etc."
    (s-trim-right
     (shell-command-to-string
      (concat (locate-file "date" exec-path) " --date='" date "' +'" (or str "%Y-%m-%d %a") "'"))))

  ;;
  ;; Create utils
  ;;

  (defun im-bullet-create-a-day (date)
    "Create given DATE heading in bullet.org in the appropriate place..
  DATE should be in the form of YYYY-MM-DD."
    (when-let ((point (im-bullet-find-a-day date)))
      (goto-char point)
      (user-error "The day already exists"))
    (widen)
    (goto-char (point-max))
    (cl-loop
     (when (not (re-search-backward "^* \\[\\([0-9]+-[0-9]+-[0-9]+\\)\\( \\w+\\)?\\].*" nil t))
       (cl-return))
     (when (time-less-p
            (date-to-time (concat (match-string 1) "T000"))
            (date-to-time (concat date "T000")))
       (org-insert-heading-after-current)
       (insert (format "[%s%s] [%%]"
                       date
                       (if (s-matches? "[a-zA-Z]+$" date)
                           ""
                         (format " %s" (format-time-string "%a" (date-to-time (concat date "T000")))))))
       (org-narrow-to-subtree)
       (cl-return))))

  ;;
  ;; Focus a day
  ;;

  (defun im-bullet-find-a-day (day)
    (save-excursion
      (widen)
      (goto-char (point-max))
      (when (re-search-backward (concat "^* \\[" day "\\( \\w+\\)?\\]") nil t)
        (point-marker))))

  (defun im-bullet-focus-a-day (day)
    "Focus to given DAY."
    (widen)
    (when-let ((day-entry (im-bullet-find-a-day day)))
      (goto-char day-entry)
      (beginning-of-line)
      (org-narrow-to-subtree)
      (im-show-outline-only)
      t))

  (defun im-bullet-focus-given-day (date)
    "Focus given DATE's header.
  If it does not exists, create it."
    (interactive
     (list (org-read-date)))
    (when (not (im-bullet-focus-a-day date))
      (im-bullet-create-a-day date)))

  (defun im-bullet-focus-today ()
    "Focus todays header.
  If it does not exists, create it."
    (interactive)
    (let ((today (if (<= (string-to-number (format-time-string "%H")) 3)
                     (im-date "yesterday")
                   (format-time-string "%Y-%m-%d"))))
      (when (not (im-bullet-focus-a-day today))
        (im-bullet-create-a-day today))))

  (defun im-bullet-focus-tomorrow ()
    "Focus yesterdays header."
    (interactive)
    (let ((tomorrow (im-date "tomorrow")))
      (when (not (im-bullet-focus-a-day tomorrow))
        (im-bullet-create-a-day tomorrow))))

  (defun im-bullet-focus-tomorrow-indirect ()
    "Like `im-bullet-focus-tomorrow' but in an indirect buffer."
    (interactive)
    (im-org-focused-tree-to-indirect-buffer
     (im-bullet-focus-tomorrow)))

  (defun im-bullet-focus-yesterday ()
    "Focus yesterdays header."
    (interactive)
    (im-bullet-focus-a-day (im-date "yesterday")))

  (defun im-bullet-focus-yesterday-indirect ()
    "Like `im-bullet-focus-yesterday' but in an indirect buffer."
    (interactive)
    (im-org-focused-tree-to-indirect-buffer
     (im-bullet-focus-yesterday)))

  (defun im-bullet-focus-heading (heading)
    (interactive)
    (widen)
    (goto-char (point-min))
    (when (re-search-forward (format "^*+ %s" heading))
      (beginning-of-line)
      (org-narrow-to-subtree)
      (im-show-outline-only)
      t))

  (defun im-bullet-focus-recurring ()
    (interactive)
    (im-bullet-focus-heading "Recurring"))

  (defun im-bullet-focus-recurring-indirect ()
    "Like `im-bullet-focus-recurring' but in an indirect buffer."
    (interactive)
    (im-org-focused-tree-to-indirect-buffer
     (im-bullet-focus-recurring)))

  (defun im-bullet-focus-work ()
    (interactive)
    (im-bullet-focus-heading "Work backlog"))

  (defun im-bullet-focus-work-indirect ()
    "Like `im-bullet-focus-work' but in an indirect buffer."
    (interactive)
    (im-org-focused-tree-to-indirect-buffer
     (im-bullet-focus-work)))

  (defun im-bullet-focus-life ()
    (interactive)
    (im-bullet-focus-heading "Life backlog"))

  (defun im-bullet-focus-life-indirect ()
    "Like `im-bullet-focus-life' but in an indirect buffer."
    (interactive)
    (im-org-focused-tree-to-indirect-buffer
     (im-bullet-focus-life)))

  (defun im-bullet-focus-computer ()
    (interactive)
    (im-bullet-focus-heading "Computer backlog"))

  (defun im-bullet-focus-computer-indirect ()
    "Like `im-bullet-focus-computer' but in an indirect buffer."
    (interactive)
    (im-org-focused-tree-to-indirect-buffer
     (im-bullet-focus-computer)))

  (defun im-bullet-focus-inbox ()
    (interactive)
    (im-bullet-focus-heading "Inbox"))

  (defun im-bullet-focus-inbox-indirect ()
    "Like `im-bullet-focus-inbox' but in an indirect buffer."
    (interactive)
    (im-org-focused-tree-to-indirect-buffer
     (im-bullet-focus-inbox)))

  ;;
  ;; Focus non-day
  ;;

  (defun im-bullet-focus-non-day-header ()
    "Interactively select and focus a non-day header."
    (interactive)
    (save-match-data
      (widen)
      (goto-char 0)
      (re-search-forward "^\\*+ \\[[0-9]+-" nil t)
      (narrow-to-region (point-min) (point-at-bol))
      (consult-org-heading)
      (org-narrow-to-subtree)))

  ;;
  ;; Template utils
  ;;

  (defun im-bullet-current-date ()
    "Return current date."
    (save-excursion
      (when (re-search-backward "^* \\[" nil t)
        (-some->> (org-get-heading t t t t)
          (s-match "\\[.*?\\]")
          (car)
          (substring-no-properties)
          (s-chop-prefix "[")
          (s-chop-suffix "]")))))

  (defmacro im-when-weekday (template &rest template-args)
    `(when (<= (im-u) 5)
       (s-trim (im-s-interpolated ,template ,@template-args))))

  (defmacro im-when-weekday-n (n template &rest template-args)
    `(when (= (im-u) ,n)
       (s-trim (im-s-interpolated ,template ,@template-args))))

  (defmacro im-when-monthday-n (n template &rest template-args)
    `(when (= (im-d) ,n)
       (s-trim (im-s-interpolated ,template ,@template-args))))

  (defmacro im-when-weekend (template &rest template-args)
    `(when (> (im-u) 5)
       (s-trim (im-s-interpolated ,template ,@template-args))))

  (defmacro im-when-saturday (template &rest template-args)
    `(when (= (im-u) 6)
       (s-trim (im-s-interpolated ,template ,@template-args))))

  (defmacro im-when-sunday (template &rest template-args)
    `(when (= (im-u) 7)
       (s-trim (im-s-interpolated ,template ,@template-args))))

  ;;
  ;; Daily summary
  ;;

  ;; Implementation is a bit cumbersome but it's easy to adopt for my ad-hoc requests
  (defun org-dblock-write:daily-summary (params)
    "Create a daily summary for my bullet.org."
    (let* ((items (org-map-entries
                   (lambda nil
                     (list
                      :name
                      (org-entry-get nil "ITEM")
                      :clock
                      (org-clock-sum-current-item)
                      :tags
                      (or (org-get-tags) '(empty))
                      :level
                      (org-current-level)
                      :parent
                      (save-excursion
                        (when (org-up-heading-safe)
                          (org-entry-get nil "ITEM")))))
                   "LEVEL>1"))
           (total-time (->>
                        items
                        (--filter (= (plist-get it :level) 2))
                        (--map (plist-get it :clock))
                        (-sum)
                        (org-minutes-to-clocksum-string)))
           (routines (--filter (s-equals? (plist-get it :parent) "Routines") items))
           (work (--filter (-contains? (plist-get it :tags) "work") items))
           (others (--filter (not (or
                                   (-contains? (plist-get it :tags) "work")
                                   (s-equals? (plist-get it :parent) "Routines")
                                   (s-equals? (plist-get it :name) "Routines"))) items)))

      (insert "| [Event] | [Duration] ||\n")
      (insert "|-|\n")

      (->>
       items
       (--find (s-equals? "Routines" (plist-get it :name)))
       (funcall (-flip #'plist-get) :clock)
       (org-minutes-to-clocksum-string)
       (format "|Routines|%s||\n")
       (insert))

      (->>
       routines
       (--filter (-contains? '("Breakfast" "Dinner") (plist-get it :name)))
       (--map (plist-get it :clock))
       (-sum)
       (org-minutes-to-clocksum-string)
       (format "|\\-- Eating||%s|\n")
       (insert))

      (->>
       routines
       (--filter (not (-contains? '("Breakfast" "Dinner") (plist-get it :name))))
       (--map (plist-get it :clock))
       (-sum)
       (org-minutes-to-clocksum-string)
       (format "|\\-- Other||%s|\n")
       (insert))

      (insert "|-|\n")

      (->>
       work
       (--map (plist-get it :clock))
       (-sum)
       (org-minutes-to-clocksum-string)
       (format "|Work|%s||\n")
       (insert))

      (->>
       work
       (--filter (-contains? (plist-get it :tags) "meeting"))
       (--map (plist-get it :clock))
       (-sum)
       (org-minutes-to-clocksum-string)
       (format "|\\-- Meetings||%s|\n")
       (insert))

      (->>
       work
       (--filter (not (-contains? (plist-get it :tags) "meeting")))
       (--map (plist-get it :clock))
       (-sum)
       (org-minutes-to-clocksum-string)
       (format "|\\-- Other||%s|\n")
       (insert))

      (insert "|-|\n")

      (->>
       others
       (--map (plist-get it :clock))
       (-sum)
       (org-minutes-to-clocksum-string)
       (format "|Other|%s||\n")
       (insert))

      (->>
       others
       (--filter (-contains? (plist-get it :tags) "side"))
       (--map (plist-get it :clock))
       (-sum)
       (org-minutes-to-clocksum-string)
       (format "|\\-- Side projects||%s|\n")
       (insert))

      (->>
       others
       (--filter (not (-contains? (plist-get it :tags) "side")))
       (--map (plist-get it :clock))
       (-sum)
       (org-minutes-to-clocksum-string)
       (format "|\\-- Other||%s|\n")
       (insert))

      (insert "|-|\n")
      (insert (format "|Total|%s||\n" total-time))
      (delete-char 1)
      (org-table-align)))

  ;;
  ;; Misc utils
  ;;

  (defun im-bullet-schedule-all-today ()
    "Schedule all level-2 org mode tasks that have a scheduled date in
  the past to today's date with the same time. If the task is not
  scheduled, schedules them to todays date."
    (interactive)
    (let* ((today (im-today))
           (today-time (date-to-time today)))
      (org-map-entries
       (lambda ()
         (let ((entry-date (org-entry-get nil "SCHEDULED")))
           (when (and
                  (org-entry-get nil "TODO")
                  (if entry-date
                      (time-less-p
                       (date-to-time entry-date)
                       today-time)
                    t))
             (org-schedule nil
                           (if-let ((entry-date)
                                    (hour-min (nth 2 (s-split " " entry-date))))
                               (concat today " " hour-min)
                             today)))))
       "LEVEL=2")))
#+end_src

** Scratch/temporary buffers in side windows
Here I define two important functions and their helpers.  The following functions are pretty useful for quick note taking or evaluating elisp. Having these buffers in a side window makes them immune to some window commands which is what I want.

- im-display-side-scratch-buffer :: This one opens (or closes if it's open) the *scratch* buffer in a side window, on the right. This is nice for quickly evaluating elisp, taking elisp related notes.
- im-display-side-temp-org-buffer :: This one opens (or closes if it's open) the ~temp.org~ file in a in a side window, on the right. This is nice for taking some quick notes, writing some temporary todos etc.

#+begin_src emacs-lisp
  (defun im-buffer-visible-p (buffer)
    "Check if given BUFFER is visible or not.  BUFFER is a string representing the buffer name."
    (or (eq buffer (window-buffer (selected-window))) (get-buffer-window buffer)))

  (defun im-display-buffer-other-frame ()
    "Like `display-buffer-other-frame' but with some sensible defaults."
    (interactive)
    (let ((default-frame-alist '((tab-bar-lines . 0) (vertical-scroll-bars))))
      (tab-line-mode -1)
      (display-buffer-other-frame (current-buffer))))

  (defun im-display-buffer-in-side-window (buffer)
    "Just like `display-buffer-in-side-window` but only takes a BUFFER and rest of the parameters are for my taste."
    (set-window-dedicated-p
     ;; ^ Setting this to nil so that `pop-to-buffer-same-window' calls works in this window
     ;;   otherwise it'll set `window-dedicated-p' to `side' and this will cause `pop-to-buffer-same-window'
     ;;   to open stuff in another window.
     (select-window
      (display-buffer-in-side-window
       buffer
       '((side . right)
         (slot . 0)
         (window-width . 84)
         (window-parameters
          (no-delete-other-windows . t)
          (no-other-window . nil)))))
     nil))

  (defun im-remove-window-with-buffer (the-buffer-name)
    "Remove window containing given THE-BUFFER-NAME."
    (mapc (lambda (window)
            (when (string-equal (buffer-name (window-buffer window)) the-buffer-name)
              (delete-window window)))
          (window-list (selected-frame))))

  (defun im-toggle-side-buffer-with-file (file-path)
    "Toggle FILE-PATH in a side buffer. The buffer is opened in side window so it can't be accidentaly removed."
    (interactive)
    (let ((fname (file-name-nondirectory file-path)))
    (if (im-buffer-visible-p fname)
        (im-remove-window-with-buffer fname)
      (im-display-buffer-in-side-window
       (save-window-excursion
         (find-file file-path)
         (current-buffer))))))

  (defun im-toggle-side-buffer-with-name (buffer-name)
    "Hide/show given BUFFER-NAME in a side window."
    (interactive)
    (if (im-buffer-visible-p buffer-name)
        (im-remove-window-with-buffer buffer-name)
      (im-display-buffer-in-side-window (get-buffer buffer-name))))

  (defun im-toggle-side-scratch-buffer ()
    "Toggle the scratch buffer in side window.  The buffer is opened in side window so it can't be accidentaly removed."
    (interactive)
    (im-toggle-side-buffer-with-file "~/.emacs.d/scratch.el"))

  (defun im-toggle-side-temp-org-buffer ()
    "Toggle `temp.org` in a side buffer for quick note taking.  The buffer is opened in side window so it can't be accidentaly removed."
    (interactive)
    (im-toggle-side-buffer-with-file temp-org))

  (defun im-toggle-side-bullet-org-buffer ()
    "Toggle `bullet.org` in a side buffer for quick note taking.  The buffer is opened in side window so it can't be accidentaly removed."
    (interactive)
    (im-toggle-side-buffer-with-file bullet-org))

  (defun im-toggle-side-projects-buffer ()
    "Toggle `projects.org` in a side buffer for quick note taking.  The buffer is opened in side window so it can't be accidentaly removed."
    (interactive)
    (im-toggle-side-buffer-with-file projects-org))

  (defun im-toggle-side-messages-buffer ()
    "Toggle `projects.org` in a side buffer for quick note taking.  The buffer is opened in side window so it can't be accidentaly removed."
    (interactive)
    (im-toggle-side-buffer-with-name "*Messages*"))

  (defun im-toggle-side-tmr-buffer ()
    (interactive)
    (im-toggle-side-buffer-with-name (get-buffer-create "*tmr-tabulated-view*"))
    (unless (featurep 'tmr-tabulated)
      (require 'tmr-tabulated))
    (tmr-tabulated-mode))

  ;; Toggle temproary buffers
  (im-leader
    "ts" 'im-toggle-side-scratch-buffer
    "to" 'im-toggle-side-temp-org-buffer
    "th" 'im-toggle-side-bullet-org-buffer
    "tp" 'im-toggle-side-projects-buffer
    "tt" 'im-toggle-side-tmr-buffer
    "tm" 'im-toggle-side-messages-buffer)
#+end_src

** org-babel extension functions
#+BEGIN_SRC emacs-lisp
  (defun im-org-babel-remove-all-results nil
    (interactive)
    (goto-char 1)
    (let ((total-removed 0))
      (while (org-babel-next-src-block)
        (when (org-babel-remove-result)
          (setq total-removed (+ total-removed 1))))
      (message (format "%d result blocks are removed." total-removed))))
#+END_SRC

** Functions for easy indentation switching
- http://blog.binchen.org/posts/easy-indentation-setup-in-emacs-for-web-development.html

#+begin_src emacs-lisp
  (defun im-setup-indent-local (n)
    "Set indent for current buffer."
    (interactive "nHow many spaces do you want? ")
    (setq-local tab-width n)
    (setq-local c-basic-offset n)
    (setq-local sh-basic-offset n)
    (setq-local coffee-tab-width n) ; coffeescript
    (setq-local java-ts-mode-indent-offset n)
    (setq-local javascript-indent-level n) ; javascript-mode
    (setq-local js-indent-level n) ; js-mode
    (setq-local web-mode-markup-indent-offset n) ; web-mode, html tag in html file
    (setq-local web-mode-css-indent-offset n) ; web-mode, css in html file
    (setq-local web-mode-code-indent-offset n) ; web-mode, js code in html file
    (setq-local css-indent-offset n) ; css-mode
    (setq-local typescript-indent-level n) ; typescript-mode
    (setq-local typescript-ts-mode-indent-offset 2)
    (setq-local java-ts-mode-indent-offset 2)
    (message "OK!"))

  (defun im-setup-indent-global (n)
    "Set indent globally."
    (interactive "nHow many spaces do you want? ")
    (setq tab-width n)
    (setq c-basic-offset n)
    (setq sh-basic-offset n)
    (setq coffee-tab-width n) ; coffeescript
    (setq java-ts-mode-indent-offset n)
    (setq javascript-indent-level n) ; javascript-mode
    (setq js-indent-level n) ; js-mode
    (setq web-mode-markup-indent-offset n) ; web-mode, html tag in html file
    (setq web-mode-css-indent-offset n) ; web-mode, css in html file
    (setq web-mode-code-indent-offset n) ; web-mode, js code in html file
    (setq css-indent-offset n) ; css-mode
    (setq typescript-indent-level n) ; typescript-mode
    (setq typescript-ts-mode-indent-offset 2)
    (setq java-ts-mode-indent-offset 2)
    (message "OK!"))
#+end_src

** Current file functionality
Sometimes I just want to delete/rename/move etc. the current file without resorting to dired or any other file manager. Here are some interactive functions to do that.

#+begin_src emacs-lisp
  ;; Slightly modified from:
  ;; http://steve.yegge.googlepages.com/my-dot-emacs-file
  (defalias 'im-rename-this-file-name-and-buffer #'im-rename-current-file-name-and-buffer)
  (defun im-rename-current-file-name-and-buffer (new-name)
    "Renames both current buffer and file it's visiting to NEW-NAME."
    (interactive "FNew name: ")
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (when (not filename)
        (user-error "Buffer '%s' is not visiting a file!" name))
      (when (get-buffer new-name)
        (user-error "A buffer named '%s' already exists!" new-name))
      (rename-file filename new-name 1)
      (rename-buffer new-name)
      (set-visited-file-name new-name)
      (set-buffer-modified-p nil)))

  ;; Slightly modified version of: http://www.ergoemacs.org/emacs/elisp_delete-current-file.html
  (defun im-delete-current-file ()
    "Delete the current file and copy it's content to `kill-ring'."
    (interactive)
    (when (y-or-n-p (format "Do you really want to remove this: \"%s\"?" (buffer-file-name)))
      (kill-new (buffer-string))
      (message "Buffer content copied to kill-ring.")
      (when (and (buffer-file-name) (file-exists-p (buffer-file-name)))
        (delete-file (buffer-file-name))
        (message "Deleted file: 「%s」." (buffer-file-name)))
      (let ((buffer-offer-save nil))
        (set-buffer-modified-p nil)
        (kill-buffer (current-buffer)))))

  (defalias 'im-delete/remove-this-file #'im-delete-current-file)
#+end_src

** xah-open-file-at-cursor
This is better than =find-file-at-point= because it takes line numbers etc. into account.

#+begin_src emacs-lisp
  (defun xah-open-file-at-cursor ()
    "Open the file path under cursor.
  If there is text selection, uses the text selection for path.
  If the path starts with “http://”, open the URL in browser.
  Input path can be {relative, full path, URL}.
  Path may have a trailing “:‹n›” that indicates line number, or “:‹n›:‹m›” with line and column number. If so, jump to that line number.
  If path does not have a file extension, automatically try with “.el” for elisp files.
  This command is similar to `find-file-at-point' but without prompting for confirmation.

  URL `http://ergoemacs.org/emacs/emacs_open_file_path_fast.html'
  Version 2020-10-17"
    (interactive)
    (let* (
           ($inputStr
            (if (use-region-p)
                (buffer-substring-no-properties (region-beginning) (region-end))
              (let ($p0 $p1 $p2
                        ;; chars that are likely to be delimiters of file path or url, e.g. whitespace, comma. The colon is a problem. cuz it's in url, but not in file name. Don't want to use just space as delimiter because path or url are often in brackets or quotes as in markdown or html
                        ($pathStops "^  \t\n\"`'‘’“”|[]{}「」<>〔〕〈〉《》【】〖〗«»‹›❮❯❬❭〘〙·。\\"))
                (setq $p0 (point))
                (skip-chars-backward $pathStops)
                (setq $p1 (point))
                (goto-char $p0)
                (skip-chars-forward $pathStops)
                (setq $p2 (point))
                (goto-char $p0)
                (buffer-substring-no-properties $p1 $p2))))
           ($path
            (replace-regexp-in-string
             "^file:///" "/"
             (replace-regexp-in-string
              ":\\'" "" $inputStr))))
      (if (string-match-p "\\`https?://" $path)
          (if (fboundp 'xahsite-url-to-filepath)
              (let (($x (xahsite-url-to-filepath $path)))
                (if (string-match "^http" $x )
                    (browse-url $x)
                  (find-file $x)))
            (progn (browse-url $path)))
        (progn ; not starting “http://”
          (if (string-match "#" $path )
              (let (
                    ( $fpath (substring $path 0 (match-beginning 0)))
                    ( $fractPart (substring $path (1+ (match-beginning 0)))))
                (if (file-exists-p $fpath)
                    (progn
                      (find-file $fpath)
                      (goto-char 1)
                      (search-forward $fractPart ))
                  (when (y-or-n-p (format "file no exist: 「%s」. Create?" $fpath))
                    (find-file $fpath))))
            (if (string-match "^\\`\\(.+?\\):\\([0-9]+\\)\\(:[0-9]+\\)?\\'" $path)
                (let (
                      ($fpath (match-string 1 $path))
                      ($line-num (string-to-number (match-string 2 $path))))
                  (if (file-exists-p $fpath)
                      (progn
                        (find-file $fpath)
                        (goto-char 1)
                        (forward-line (1- $line-num)))
                    (when (y-or-n-p (format "file no exist: 「%s」. Create?" $fpath))
                      (find-file $fpath))))
              (if (file-exists-p $path)
                  (progn ; open f.ts instead of f.js
                    (let (($ext (file-name-extension $path))
                          ($fnamecore (file-name-sans-extension $path)))
                      (if (and (string-equal $ext "js")
                               (file-exists-p (concat $fnamecore ".ts")))
                          (find-file (concat $fnamecore ".ts"))
                        (find-file $path))))
                (if (file-exists-p (concat $path ".el"))
                    (find-file (concat $path ".el"))
                  (when (y-or-n-p (format "file no exist: 「%s」. Create?" $path))
                    (find-file $path ))))))))))

(define-key evil-normal-state-map (kbd "gf") 'xah-open-file-at-cursor)
#+end_src

** xah-{escape,unescape}-quotes
#+begin_src emacs-lisp
  (defun xah-escape-quotes (@begin @end)
    "Replace 「\"」 by 「\\\"」 in current line or text selection.
    See also: `xah-unescape-quotes'

    URL `http://ergoemacs.org/emacs/elisp_escape_quotes.html'
    Version 2017-01-11"
    (interactive
     (if (use-region-p)
         (list (region-beginning) (region-end))
       (list (line-beginning-position) (line-end-position))))
    (save-excursion
      (save-restriction
        (narrow-to-region @begin @end)
        (goto-char (point-min))
        (while (search-forward "\"" nil t)
          (replace-match "\\\"" "FIXEDCASE" "LITERAL")))))

  (defun xah-unescape-quotes (@begin @end)
    "Replace  「\\\"」 by 「\"」 in current line or text selection.
  See also: `xah-escape-quotes'

  URL `http://ergoemacs.org/emacs/elisp_escape_quotes.html'
  Version 2017-01-11"
    (interactive
     (if (use-region-p)
         (list (region-beginning) (region-end))
       (list (line-beginning-position) (line-end-position))))
    (save-excursion
      (save-restriction
        (narrow-to-region @begin @end)
        (goto-char (point-min))
        (while (search-forward "\\\"" nil t)
          (replace-match "\"" "FIXEDCASE" "LITERAL")))))
#+end_src

** eksisozluk gundem
#+begin_src emacs-lisp
  (defun im-eksi-gundem-sirali ()
    "Eksi gundemini entry sayisina gore sirala ve `completing-read' yap."
    (interactive)
    (let ((results (->>
                    (with-temp-buffer
                      (insert
                       (shell-command-to-string "curl --silent https://eksisozluk1923.com/basliklar/gundem | grep '?a=popular' | sed -E 's/[ ]*href=\"(.*)\">(.*) <small>(.*)<\\/small>(.*)/(\\3) \\2|||\\1/' | sort -V -r | uniq"))
                      (goto-char (point-min))
                      (xml-parse-string))
                    (s-trim)
                    (s-split "\n")
                    (--map (s-split "|||" it))
                    (--map `(,(car it) . ,(cadr it))))))
      (->>
       (im-completing-read
        "Baslik: " results
        :sort? nil
        :formatter #'car)
       (cdr)
       (format "https://eksisozluk1923.com/%s")
       (browse-url))))
#+end_src
** insert uuid
#+begin_src emacs-lisp
  (defun im-uuid ()
    "Generate a UUID."
    (s-trim (shell-command-to-string "uuidgen")))

  (defun im-insert-uuid ()
    "Insert UUID."
    (interactive)
    (insert (im-uuid)))
#+end_src

** im-shell-command
#+begin_src emacs-lisp
  (defvar-local im-shell-command-mode-command nil
    "Current shell command that belongs to the buffer.")

  (define-minor-mode im-shell-command-mode
    "Shell command mode."
    :lighter "iscm"
    :keymap (make-sparse-keymap))

  (evil-define-key 'normal im-shell-command-mode-map
    (kbd "gr") #'im-shell-command-mode-rerun-command)

  (defun im-shell-command-mode-rerun-command ()
    "Re-run the shell command."
    (interactive)
    (apply #'im-shell-command im-shell-command-mode-command))


  ;; In normal mode, hitting ! will display im-shell-command but in
  ;; visual mode hitting ! will open evil's default evil-shell-command
  ;; on selected region.
  (evil-define-key 'normal 'global (kbd "!") #'im-shell-command)

  (defun im-zsh-smart-history ()
    (->>
     (with-temp-buffer
       (insert-file-contents "~/.zsh_history")
       (buffer-string))
     s-trim
     (s-split "\n")
     (--map (if (s-prefix? ":" it)
                (s-replace-regexp "^: [0-9:]+;" "" it)
              it))
     (--filter (and (not (s-blank? it))
                    (> (length it) 5)
                    (not (s-matches? "^\\(ls\\|pwd\\|exit\\|cd\\|echo\\)" it))))))

  (cl-defun im-shell-command
      (&key
       command
       args
       eat
       (switch t)
       (buffer-name (concat "*" command "*"))
       (on-start (lambda (&rest _)))
       (on-finish (lambda (&rest _)))
       (on-fail (lambda (&rest _))))
    "Run given shell COMMAND and redirect output to given BUFFER-NAME.
  This is a wrapper around `start-process-shell-command' that adds
  support for ANSI term colors and some syntactic convenience.

  If ARGS is non-nil list, then use `start-process' with command as
  COMMAND and args as ARGS.

  If EAT is non nil, use eat shell to display output which handles
  terminal outputs way better.  ARGS must be a list.

  When called interactively, asks for a command to run (with eshell
  completion).

  In BUFFER-NAME, `im-shell-command-mode' is activated and you can
  use `im-shell-command-mode-rerun-command' or \"gr\" to replay the
  command."
    (interactive
     (let ((command (completing-read "Command: " (im-zsh-smart-history))))
       (list
        :command command
        :on-finish
        (lambda (&rest _)
          (let ((msg (format ">> \"%s\" finished successfully." command)))
            (message msg)
            (when (not (frame-focus-state))
              (alert msg))))
        :on-fail
        (lambda (&rest _)
          (let ((msg (format ">> \"%s\" FAILED." command)))
            (message msg)
            (when (not (frame-focus-state))
              (alert msg)))))))
    (let* ((proc
            (if eat
                (progn
                  (let ((buffer (apply #'eat-make command command nil args)))
                    (setq buffer-name (buffer-name buffer))
                    (get-buffer-process buffer)))
              (if args
                  (progn
                    (message ">>>> %s" args)
                    (apply #'start-process command buffer-name command args))
                (start-process-shell-command command buffer-name command))))
           (proc-out ""))
      (set-process-sentinel
       proc
       (lambda (p e)
         (with-current-buffer buffer-name
           (read-only-mode -1))
         (if (= 0 (process-exit-status p))
             (funcall on-finish proc-out)
           (funcall on-fail))))
      (unless eat
        (set-process-filter
         proc
         (lambda (proc str)
           (with-current-buffer buffer-name
             (setq proc-out (concat proc-out str))
             (let ((inhibit-read-only t))
               (save-excursion
                 (goto-char (point-max))
                 (insert (ansi-color-apply (s-replace "" "\n" str)))))))))
      (with-current-buffer buffer-name
        (unless eat
          (prog-mode))
        (im-shell-command-mode 1)
        (evil-normal-state)
        (setq-local
         im-shell-command-mode-command
         (list
          :command command
          :args args
          :buffer-name buffer-name
          :on-start on-start
          :on-finish on-finish
          :on-fail on-fail))
        (funcall on-start))
      (when switch
        (switch-to-buffer buffer-name))))
#+end_src

** Copy current/buffers filename into clipboard
#+begin_src emacs-lisp
  (defalias 'im-copy-current-filename-to-clipboard 'im-copy-file-name-to-clipboard)
  (defun im-copy-file-name-to-clipboard (&optional uri)
    "Copy the current buffer file name to the clipboard.
  If the URI is non-nil, then add file:// in front of the
  file-path."
    (interactive "P")
    (let* ((fname (if (equal major-mode 'dired-mode)
                         default-directory
                       (buffer-file-name)))
           (filename (if (and fname uri)
                         (concat "file://" fname)
                       fname)))
      (if filename
          (progn
            (kill-new filename)
            (message ">> Copied buffer file name '%s' to the clipboard." filename))
        (user-error ">> Failed to copy"))))
#+end_src
** Password manager
#+begin_src emacs-lisp
  (defun im-password-all ()
    "Get list of all passwords and their properties from `passwords.org'."
    (with-current-buffer "passwords.org"
      (->>
       (lambda ()
         (let ((link "")
               (match (org-entry-get nil "MATCH"))
               (header-link (save-excursion (forward-char 5) (org-element-context)))
               (title (org-entry-get nil "ITEM"))
               (props (im-alist-to-plist (org-entry-properties))))
           (when (plist-get props :username)
             ;; ^ A password entry should contain at least the :username: prop
             (when (eq (org-element-type header-link) 'link)
               (setq link (org-element-property :raw-link header-link))
               (save-excursion
                 (setq title
                       (buffer-substring-no-properties
                        (org-element-property :contents-begin header-link)
                        (org-element-property :contents-end header-link)))))
             `(:title ,title :link ,link ,@props))))
       (org-map-entries)
       (-filter #'identity))))

  ;; TODO Better matching algorithm Check if full string matches any,
  ;; then check if host matches. Return full string match only if it
  ;; exists. Also check if toplevel domain matches, if it does not match
  ;; fully
  (defun im-password-find-for (url)
    "Return matching accounts for given URL.
  If there are multiple accounts registered for one entry, then
  list them as seperate entries."
    (interactive)
    (let ((urlobj (url-generic-parse-url url)))
      (setq url (url-host urlobj))
      (when-let ((port (url-port-if-non-default urlobj)))
        (setq url (format "%s:%s" url port))))
    (let* ((candidates (--filter
                        (when (or (ignore-errors (s-match (plist-get it :match) url))
                                  (s-contains? url (plist-get it :link)))
                          it)
                        (im-password-all))))
      (-flatten-n
       1
       (-map (lambda (info)
               (let ((unames (s-split " " (plist-get info :username)))
                     (pwds (s-split " " (plist-get info :password))))
                 (-zip  (--map (format "%s - %s" (plist-get info :title) it) unames)
                        (--map (list :info info :acc it)
                               (-zip unames pwds)))))
             candidates))))

  (defun im-password-qutebrowser (url fifo)
    "Find credentials for currently open link in Qutebrowser and fill."
    (let* ((candidates (im-password-find-for url))
           (result (plist-get
                    (alist-get (completing-read "Select account: " candidates) candidates nil nil #'equal) :acc))
           (username (car result))
           (password (-some->> (cdr result)
                       (s-replace "\"" "\\\"")
                       (s-replace "'" "\\'"))))
      (when (and username password)
        (pcase (completing-read "Method: " '("Fill all with TAB" "Fill username" "Fill password"))
          ("Fill all with TAB"
           (write-region "mode-enter insert\n" nil fifo 'append)
           (write-region (format "fake-key %s\n" username) nil fifo 'append)
           (write-region "fake-key <Tab>\n" nil fifo 'append)
           (write-region (format "fake-key %s\n" password) nil fifo 'append))
          ("Fill username"
           (write-region "mode-enter insert\n" nil fifo 'append)
           (write-region (format "fake-key %s\n" username) nil fifo 'append))
          ("Fill password"
           (write-region "mode-enter insert\n" nil fifo 'append)
           (write-region (format "fake-key %s\n" password) nil fifo 'append))))))

  ;; TODO Add other actions:
  ;; - Fill with tab
  ;; - Copy username/password etc.
  (defun im-password-act ()
    (interactive)
    (and-let* ((passwords (im-password-all))
               (candidates (--map (cons (plist-get it :title) it) passwords))
               (selected (im-alist-completing-read "Select: " candidates)))
      (let-plist selected
        (pcase (completing-read
                "Action: "
                (list "Copy as username:password"
                      "Copy as PostgreSQL connection string"
                      "Copy as SQL src block header args"
                      "Copy as Couchbase (CBC, N1QL) src block header args"))
          ("Copy as username:password"
           (kill-new
            (format "%s:%s" .username .password)))
          ("Copy as PostgreSQL connection string"
           (kill-new
            (format "postgresql://%s:%s@%s:%s/%s"
                    .username .password .host .port .db)))
          ("Copy as SQL src block header args"
           (kill-new
            (format ":engine postgresql :dbhost %s :dbuser %s :dbpassword %s :database %s :dbport %s"
                    .host .username .password .db .port)))
          ("Copy as Couchbase (CBC, N1QL) src block header args"
           (kill-new
            (format ":host %s :username %s :password %s"
                    .host .username .password)))))))

#+end_src
** Kubernetes
My main use case is drop into a shell of a pod. The code below makes it quite easy. Use ~im-kube-select-pod~ to select a pod and do some actions on it.

#+begin_src emacs-lisp
  (defun im-kube--current-context ()
    (s-trim (shell-command-to-string "kubectl config current-context")))

  (defun im-kube-use-context ()
    (interactive)
    (im-output-select
     :cmd "kubectl config get-contexts --output=name"
     :keep-order t
     :prompt (format "Select context (current=%s): " (im-kube--current-context))
     :do (shell-command-to-string (format "kubectl config use-context '%s'" it))))

  (defalias 'im-kube-get-context-server-ip 'im-kube-get-cluster-server-ip)
  (defun im-kube-get-cluster-server-ip ()
    (interactive)
    (im-output-select
     :cmd "kubectl config get-clusters"
     :drop 1
     :keep-order t
     :prompt (format "Select context (leave blank to use %s): " (im-kube--current-context))
     :do
     (->>
      (if (s-blank? it) (im-kube--current-context) it)
      (format "kubectl config view -o jsonpath=\"{.clusters[?(@.name == '%s')].cluster.server}\"")
      shell-command-to-string
      im-kill)))

  (defun im-kube-select-pod (&optional switch-context)
    "Select a pod and act on it.
  If SWITCH-CONTEXT is non nil, switch to another context before
  selecting a pod."
    (interactive "P")
    (when switch-context
      (im-kube-use-context))
    (im-output-select
     :cmd "kubectl get pods --all-namespaces"
     :drop 1
     :prompt (format "Select a pod from '%s': " (im-kube--current-context))
     :keep-order t
     :do (let ((info (s-split " " it t)))
           (im-kube-pod--act (list :name (nth 1 info) :namespace (nth 0 info) :context (im-kube--current-context))))))

  ;; TODO wtf is this shit
  (defun im-kube-pod--act (pod)
    (let ((namespace (plist-get pod :namespace))
          (name (plist-get pod :name))
          (context (plist-get pod :context)))
      (empv--select-action "Action for"
        "Exec into default container" →
        (with-current-buffer (im-eshell (format "$pod: %s" name))
          (insert
           (im-kill (format "kubectl exec --namespace='%s' -i -t '%s' --context='%s' -- bash"
                            namespace
                            name
                            context))))
        "Exec into container" →
        (let ((container (im-kube-pod--select-container pod)))
          (with-current-buffer (im-eshell (format "$pod: %s" name))
            (insert
             (im-kill (format "kubectl exec --namespace='%s' --container='%s' -i -t '%s' --context='%s' -- bash"
                              namespace
                              container
                              name
                              context)))))
        "Logs" →
        (let ((container (im-kube-pod--select-container pod)))
          (shell-command
           (im-kill
            (format
             "kubectl logs %s --since=0 --namespace='%s' --container='%s' --context='%s'"
             name namespace container context))
           (format "*im-kube-logs:%s-%s*" name container)))
        "Logs (follow)" →
        (with-current-buffer (vterm (format "$pod: %s" name))
          (vterm-insert
           (im-kill (format "kubectl logs %s -f --namespace='%s' --container='%s' --context='%s'"
                            name
                            namespace
                            (im-kube-pod--select-container pod)
                            context))))
        "Logs (to a file)" →
        (let ((container (im-kube-pod--select-container pod))
              (fname (expand-file-name (read-file-name
                                        "File: "
                                        "~/Workspace/temp/"
                                        nil
                                        nil
                                        (format "%s-%s.logs" (format-time-string "%Y-%m-%d") name)))))
          (message ">> Downloading logs for %s. Done." name)
          (set-process-sentinel
           (start-process-shell-command
            "*im-kube-log-write*"
            "*im-kube-log-write*"
            (im-kill (format "kubectl logs %s --since=0 --namespace='%s' --container='%s' --context='%s' > '%s'"
                             name
                             namespace
                             container
                             context
                             fname)))
           (lambda (proc event)
             (if (eq (process-exit-status proc) 0)
                 (progn
                   (message ">> Downloading logs for %s. Done." name)
                   (find-file fname))
               (user-error "Failed to get logs.")))))
        ;; Logs from all pods combined for given pod's app
        "App logs" →
        (let ((container (im-kube-pod--select-container pod)))
          (with-current-buffer (im-eshell (format "$pod: %s" name))
            (insert (im-kill
                     (format "kubectl logs -f --selector app=%s --namespace='%s' --container='%s' --context='%s'"
                             (im-kube-pod--get-app-name pod)
                             namespace
                             container
                             context)))))
        "Top" → (im-shell-command
                 :command (format "kubectl top pod  '%s' --namespace='%s' --context='%s'"
                                  name
                                  namespace
                                  context))
        "Remove" → (format "Copied: %s"
                           (im-kill (format "kubectl delete pod '%s' --namespace='%s' --context='%s'"
                                            name
                                            namespace
                                            context))))))

  (defun im-kube-pod--select-container (pod)
    (im-output-select
     :cmd (format
           "kubectl get pods '%s' --namespace='%s' --context='%s' -o jsonpath='{.spec.containers[*].name}'"
           (plist-get pod :name)
           (plist-get pod :namespace)
           (plist-get pod :context))
     :prompt (format "Container for %s: " (plist-get pod :name))
     :split " "))

  (defun im-kube-pod--get-app-name (pod)
    "Return the application name of the POD belongs."
    (s-trim
     (shell-command-to-string
      (format
       "kubectl get pod %s --namespace='%s' -o custom-columns=:metadata.labels.app"
       (plist-get pod :name)
       (plist-get pod :namespace)))))
#+end_src
** Kafka
#+begin_src emacs-lisp
  ;; TODO rewrite this using kafkactl
  ;; Also add functions like `im-kafka-switch-context' etc.
  (defun im-kafka-describe-consumer-group ()
    (interactive)
    ;; `im-select-kafka-consumers' is a private function that
    ;; returns a kafka server list
    (let ((servers (im-select-kafka-consumers)))
      (im-output-select
       :cmd (format "kafka-consumer-groups.sh --list --bootstrap-server %s" servers)
       :prompt "Select a consumer group: "
       :do (im-output-to-tabulated-list
            (shell-command-to-string
             (format "kafka-consumer-groups.sh --describe --group %s --bootstrap-server %s" it servers))
            :buffer (get-buffer-create "*kafka-describe:%s*" it)))))
#+end_src
** Run functions globally
:PROPERTIES:
:ID:       30465D2E-AB40-4E53-B6EA-9D72F7242700
:END:
Simply use ~im-dmenu~ function instead of the default ~completing-read~ function when the code is called inside this macro. This way, you can use your ~completing-read~ based functions within your system, without needing to focus Emacs first.

#+begin_src emacs-lisp
  (defmacro im-globally (&rest body)
    `(let ((completing-read-function #'im-dmenu))
       ,@body))
#+end_src
** Archive URLs with single-file
#+begin_src emacs-lisp
  (cl-defun im-archive-url (url &key where (backend 'chrome) crawl tidy on-finish on-fail)
    "Archive the URL into WHERE. WHERE can be a directory or a
  file. If it's a directory, it should already exists otherwise
  WHERE is interpreted as a file name."
    (interactive
     (list (or
            (im-org-link-copy)
            (thing-at-point 'url)
            (read-string "URL: "))
           (read-directory-name "Save files into: ")))
    (setq where (expand-file-name where))
    (let* ((command
            (format
             "single-file --filename-replacement-character='-' %s %s %s \"%s\" \"%s\""
             (if (eq system-type 'darwin)
                 "--browser-executable-path=\"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome\""
               "--browser-executable-path=chromium")
             (if (eq backend 'firefox)
                 "--back-end=webdriver-gecko"
               "")
             (if crawl
                 ;; FIXME --crawl-replace-urls=true does not work
                 "--crawl-links=true --crawl-external-links-max-depth=1 --crawl-max-depth=1 --crawl-replace-urls=true --crawl-inner-links-only=false --crawl-no-parent=true"
               "")
             url
             (cond
              ((f-dir? where)
               (format "--output-directory=%s" where))
              (where where)
              (t (format "--output-directory=%s" default-directory))))))
      (im-shell-command
       :command command
       :switch nil
       :buffer-name "*single-file output*"
       :on-finish
       (lambda (&rest _)
         (when (called-interactively-p 'any)
           (message "Archived `%s'!" url)
           (kill-new command))
         ;; single-file does not return the created file name, finding that manually
         (let ((created-file (cond
                              ((f-file? where) where)
                              ((f-dir? where) (im-latest-file where))
                              (t (error "Can't find file created backup file")))))
           (when tidy
             (unless (executable-find "tidy")
               (user-error "`tidy' not found in the path"))
             (shell-command (format "tidy -q -w 120 -m '%s'" created-file)))
           (and on-finish (funcall on-finish created-file))))
       :on-fail
       (lambda ()
         (when (called-interactively-p 'any)
           (message "Archiving failed: '%s'. Command is copied to your kill ring." url)
           (kill-new command))
         (and on-fail (funcall on-fail 'abnormal-exit))))))
#+end_src
** narrow-indirect & im-narrow-dwim
#+begin_src emacs-lisp
  (use-package narrow-indirect)

  (im-leader-v
    "n" #'im-narrow-dwim
    "N" (im-eval-dwim
         #'ni-narrow-to-defun-indirect-other-window
         #'ni-narrow-to-region-indirect-other-window
         #'ni-narrow-to-page-indirect-other-window))


  (defun im-narrow-dwim ()
    "Smart narrowing."
    (interactive)
    (cond
     ((use-region-p) (narrow-to-region (region-beginning) (region-end)))
     ((eq major-mode 'org-mode) (org-narrow-to-subtree))
     ((eq major-mode 'markdown-mode) (markdown-narrow-to-subtree))
     ((eq major-mode 'emacs-lisp-mode) (narrow-to-defun))
     ((s-contains? "-ts-" (symbol-name major-mode))
      (when-let (def (treesit-defun-at-point))
        (narrow-to-region (treesit-node-start def)
                          (treesit-node-end def))))))
#+end_src
** im-meme-downloader
#+begin_src emacs-lisp
  (defun im-meme-downloader (url &optional file-title)
    (interactive
     (list
      (read-string "URL: ")
      (read-string "Title: ")))
    (let* ((title
            (or file-title
                (s-trim
                 (thread-last
                   url
                   im-url-get-title
                   im-string-url-case
                   s-downcase))))
           (dir (expand-file-name "~/Documents/memes"))
           (default-directory dir)
           (cmd (format "yt-dlp --output '%s.%%(ext)s' '%s'" title url)))
      (message "im-meme-downloader :: %s" cmd)
      (im-shell-command
       :command cmd
       :switch nil
       :on-finish
       (lambda (output &rest _)
         (if-let* ((matches (or
                             (s-match "\\[download\\] \\(.*\\) has already been downloaded" output)
                             (s-match "^\\[Merger\\] Merging formats into \"\\(.*\\)\"" output)
                             (s-match "^\\[download\\] Destination: \\(.*\\)" output)))
                   (fname (abbreviate-file-name (nth 1 matches))))
             (progn
               (alert (format "Downloaded: %s!" fname))
               (kill-new (format "%s/%s" dir fname)))
           (alert "Can't parse yt-dlp output!")))
       :on-fail
       (lambda (&rest _)
         (alert (format "Error while downloading: %s!" url))))))
#+end_src
** im-jump-to-definition-at-config
#+begin_src emacs-lisp
  (defun im-jump-to-definition-at-config (symbol)
    "Like normal jump-to-definition functionality but jumps to my
  literate config instead of tangled real definition. Pretty dumb
  but works most of the time."
    (interactive (list (read-string "Symbol: " (im-region-or 'symbol))))
    (with-current-buffer (find-file-noselect "~/Workspace/projects/dotfiles/emacs/index.org")
      (org-save-outline-visibility nil
        (save-restriction
          (save-excursion
            (org-show-all)
            (goto-char (point-min))
            (when (re-search-forward (format "\\((def.*\\) %s" symbol nil t))
              (call-interactively #'org-edit-special)))))))

  (define-key embark-symbol-map (kbd "J") 'im-jump-to-definition-at-config)
#+end_src
** zoom
#+begin_src emacs-lisp
  (defun im-open-zoom-meeting-dwim (&optional link)
    (interactive
     (list
      (or (thing-at-point 'url) (read-string "Link: "))))
    (when-let* ((zoom (s-match
                       "https://.*zoom\\.us/j/\\(\\w+\\)\\?pwd=\\(\\w+\\)"
                       link))
                (cmd (format
                      "open 'zoommtg://zoom.us/join?confno=%s&pwd=%s'"
                      (nth 1 zoom)
                      (nth 2 zoom))))
      (message ">> Running %s" cmd)
      (shell-command cmd)))
#+end_src
** macOS calendar functions
My work computer is a Mac. I synchronize my work calendar into my local by using macOS' Calendar app and I utilize [[https://hasseg.org/icalBuddy/][icalBuddy]] to interact with that calendar from Emacs.

#+begin_src emacs-lisp
  (defun im-calendar-now ()
    "Show the current calendar item details in a buffer and open the
  zoom link if it has one."
    (interactive)
    (im-shell-command
     :command "icalBuddy -f -ea eventsNow"
     :buffer-name "*calendar-now*"
     :on-start (lambda (&rest _) (erase-buffer))
     :on-finish (lambda (it)
                  (when-let ((zoom (nth 1 (s-match "\\(https://.*zoom.us/j/.*\\)\\(\b\\|\n\\)" it))))
                    (im-open-zoom-meeting-dwim zoom)))))

  (defun im-calendar-today ()
    "Show today's calendar in a buffer. The resulting buffer has
  outline-mode enabled, so you can use outline-mode specific
  bindings to jump, hide/show stuff."
    (interactive)
    (im-shell-command
     :command "icalBuddy -f eventsToday"
     :on-start (lambda (&rest _) (erase-buffer))
     :on-finish (lambda (&rest _)
                  (outline-mode)
                  (setq-local outline-regexp "• ")
                  (goto-char (point-min))
                  (outline-cycle-buffer))
     :buffer-name "*calendar-today*"))
#+end_src
** im-clipboard-image-to-text
#+begin_src emacs-lisp
  (defalias 'im-clipboard-tesseract-ocr-text #'im-clipboard-image-to-text)
  (defun im-clipboard-image-to-text ()
    (interactive)
    (let ((temp-image (make-temp-file "tesseract-image" nil ".png"))
          (temp-text (make-temp-file "tesseract-text"))
          (buffer (get-buffer-create "*ocr-result*")))
      (im-save-clipboard-image-to-file temp-image)
      (set-process-sentinel
       (start-process "*tesseract-ocr*" nil "tesseract" temp-image temp-text)
       (lambda (proc out)
         (if (and
              (eq 'exit (process-status proc))
              (eq 0 (process-exit-status proc)))
             (progn
               (with-current-buffer buffer
                 (erase-buffer)
                 (insert (format "[[%s]]\n\n\n" temp-image))
                 (insert-file-contents (concat temp-text ".txt"))
                 (iimage-mode))
               (switch-to-buffer buffer))
           (message "*tesseract-ocr*: %s" (string-trim out)))))))

#+end_src
** Update all git projects
#+begin_src emacs-lisp
  ;; TODO: switch to master/main before if head is not dirty?
  (defun im-pull/update-all-projects ()
    "Pull all projects."
    (interactive)
    (--map
     (let ((fname (f-filename it))
           (default-directory it))
       (set-process-sentinel
        (start-process (format "*git-pull-%s*" fname) nil "git" "pull" "--rebase")
        (lambda (proc _code)
          (if (eq (process-exit-status proc) 0)
              (message ">> Pulled %s on branch '%s'." fname (let ((default-directory it)) (lab-git-current-branch)))
            (message ">> Failed to pull %s, exit code is %s." fname (process-exit-status proc))))))
     (im-all-project-roots)))
#+end_src
** im-gnuplot
#+begin_src emacs-lisp
  (cl-defmacro im-gnuplot (settings &rest forms)
    "A horrible hack for using `gnuplot' in emacs-lisp. Example usage:

      (im-gnuplot
          (:persist t)
        (plot sin(x))
        (plot sin(x)/x)
        (plot cos(x))
        (plot cos(x)/x)
        (plot sin(x) title \"Sin\", tan(x) title \"Tangent\"))

  First argument is a plist which consists gnuplot configs or
  variable definitions.  Configs are`:persist', `:default',
  `:slow'. See `man gnuplot' for more information on these
  settings. They can be either `t' or `nil'. Default is `nil' for
  each one.

  Variable definitions are like the `let' form, simply define
  variables and use them in the gnuplot code below. Variable
  namings should follow `:this-style:' and the values can be
  arbitrary elisp.

      (im-gnuplot
          (:data: (make-temp-file \"im-gnuplot\" nil \".dat\" \"a 1\nb 2\nc 3\")
           :out-file: \"~/output.png\")
        (set terminal pngcairo size 900,300 enhanced font \"Verdana,8\")
        (set output :out-file:)
        (set style data histograms)
        (set boxwidth 0.9)
        (set style fill solid)
        (set xlabel \"Time\")
        (set ylabel \"Log count\")
        (set title \"Log count over time\")
        (plot :data: using 2:xtic(1) title \"\"))"
    (declare (indent 1))
    (let* ((script (thread-last
                     forms
                     (mapcar
                      (lambda (it)
                        (thread-first
                          it
                          (prin1-to-string)
                          (string-trim-left "(")
                          (string-trim-right ")"))))
                     (s-join "\n")
                     (s-replace-regexp " (\\\\, \\(.*?\\))" ",\\1"))))
      `(progn
         (let* ((items (list ,@(-flatten-n 1 (map-apply (lambda (key val) (list key val)) settings))))
                (script-last (thread-last
                               ,script
                               (s-prepend "reset\n")
                               (s-replace-regexp
                                "\\(:[a-zA-Z-]+:\\)"
                                (lambda (match) (format " %s " (prin1-to-string (plist-get items (intern (s-trim match))))))))))
           (with-temp-buffer
             (insert script-last)
             (shell-command-on-region
              (point-min) (point-max)
              (format "gnuplot%s%s%s"
                      (if (plist-get items :persist) " --persist" "")
                      (if (plist-get items :default) " --default" "")
                      (if (plist-get items :slow) " --slow" ""))
              nil t)
             (buffer-string))))))
#+end_src
** Image and file system tags
#+begin_src emacs-lisp
  (defun im-image-edit-tags (tags image &optional clear-all)
    "Add TAGS to IMAGE.
  If CLEAR-ALL is non-nil, clear all tags before setting TAGS as
  image tags. Otherwise TAGS are appended.  If cursor is on an org
  link, use that as the IMAGE (when called interactively)."
    (interactive
     (let* ((org-link? (org-in-regexp org-link-any-re 1))
            (file
             (if org-link?
                 (progn
                   (goto-char (car org-link?))
                   (plist-get (cadr (org-element-link-parser)) :path))
               (read-file-name "Image file: ")))
            (file-tags (s-join ", " (im-image-tags file)))
            (tags (completing-read-multiple
                   "Tags: "
                   (im-directory-image-tags (f-dirname file))
                   nil nil
                   (if (s-blank? file-tags) nil (concat file-tags ",")))))
       (list
        tags
        file
        t)))
    (setq image (expand-file-name image))
    (when clear-all
      (shell-command (format "exiftool -overwrite_original -keywords='' '%s'" image)))
    (shell-command
     (format "exiftool -overwrite_original %s '%s'"
             (s-join " " (--map (format "-keywords+='%s'" (s-trim it)) tags))
             image))
    ;; Also add these tags as file extended attribute which helps KDE to
    ;; easily index these files.  I'm using this in conjunction with exif
    ;; attributes because it's quite easy to loose extended attributes
    ;; and exif attributes serves as a backup.
    (if clear-all
        (im-set-file-attribute image "user.xdg.tags" (s-join "," tags))
      (im-set-file-attribute
       image "user.xdg.tags"
       (s-join "," (cons (im-get-file-attribute image "user.xdg.tags") tags)))))

  (defun im-image-tags (image)
    "Return tags of IMAGE."
    (let ((result
           (plist-get
            (seq-first
             (json-parse-string
              (shell-command-to-string (format "exiftool -quiet -json -keywords '%s'" (expand-file-name image)))
              :array-type 'list
              :object-type 'plist))
            :Keywords)))
      (if (listp result) result (list result))))

  (defun im-directory-image-tags (&optional directory)
    "Return all unique image tags in DIRECTORY.
  If DIRECTORY is null, `default-directory' is used."
    (-uniq
     (--mapcat
      (plist-get it :Keywords)
      (json-parse-string
       (shell-command-to-string (format "exiftool -m -quiet -json -keywords '%s'" (expand-file-name (or directory default-directory))))
       :object-type 'plist :array-type 'list))))

  (defun im-get-file-attribute (file name)
    "Get extended attribute NAME for FILE."
    (shell-command-to-string (format "getfattr --absolute-names --only-values --name='%s' '%s'" name (expand-file-name file))))

  (defun im-set-file-attribute (file name value)
    "Set extended attribute NAME as VALUE for FILE.
  When called interactively, set given NAME to VALUE as extended
  attribute for current buffers file or selected file."
    (interactive
     (let ((attr (completing-read "Attribute: " '("user.xdg.tags"))))
       (list
        (or (buffer-file-name) (read-file-name "File: "))
        attr
        (read-string (format "Value for '%s': " attr)))))
    (shell-command-to-string (format "setfattr --name='%s' --value='%s' '%s'" name value (expand-file-name file))))
#+end_src
** Converting minibuffer candidates to a table automatically
#+begin_src emacs-lisp
  (defun im-minibuffer-to-table ()
    (interactive)
    (let ((buffer (get-buffer-create "*im-minibuffer-table*"))
          (items (completion-all-completions
                  (minibuffer-contents)
                  minibuffer-completion-table
                  minibuffer-completion-predicate
                  (max 0 (- (point) (minibuffer-prompt-end))))))
      (when-let (last (last items))
        (setcdr last nil))
      (with-current-buffer buffer
        (erase-buffer)
        (goto-char (point-min))
        (thread-last
          (cdr items)
          (s-join "\n")
          (insert))
        (goto-char (point-min))
        (push-mark (point-max) t t)
        (orgtbl-create-or-convert-from-region nil)
        (deactivate-mark)
        (org-mode))
      (run-with-timer 0.1 nil (lambda () (switch-to-buffer-other-window buffer)))
      (abort-recursive-edit)))

  (define-key minibuffer-local-map (kbd "M-|") #'im-minibuffer-to-table)
#+end_src
** im-pair-prog-mode -- Minor mode for pair programming
#+begin_src emacs-lisp
  (define-minor-mode im-pair-prog-mode
    "Pair programming mode so that everyone can enjoy the beauty of Emacs."
    :lighter " PairProg"
    :global t
    (unless im-pair-prog-mode
      (message "Restoring normal environment...")
      (global-display-line-numbers-mode -1)
      (default-text-scale-reset)
      (message "Restoring normal environment...Done."))
    (when im-pair-prog-mode
      (message "Preparing pair programming environment...")
      (global-display-line-numbers-mode t)
      (default-text-scale-increment (* 2 default-text-scale-amount))
      (message "Preparing pair programming environment...Done.")))

#+end_src
** im-read-time
#+begin_src emacs-lisp
  (defun im-read-time ()
    "Show approximate read time of the selected area or whole buffer."
    (interactive)
    (funcall
     (if (called-interactively-p 'interactive) #'message #'format)
     "%s min read"
     (ceiling
      (/ (apply #'count-words
                (if (region-active-p)
                    (list (region-beginning) (region-end))
                  (list (point-min) (point-max))))
         ;; I am using a value lower than average wpm to account for other
         ;; things (distractions etc.)
         230.0))))
#+end_src

** im-peek -- Inline/popup documentation/translate/dictionary etc.
#+begin_src emacs-lisp
  (use-package quick-peek
    :straight (:host github :repo "cpitclaudel/quick-peek"))

  (im-leader-v
    "mt" #'im-peek-translate
    "ms" #'im-peek-sozluk
    "mS" #'im-peek-dictionary
    "me" #'im-peek-etimoloji
    "mE" #'im-peek-etymology
    "md" #'im-peek-doc
    "mc" #'im-peek-source)

  (general-def
    :states 'normal
    :keymaps '(emacs-lisp-mode-map lisp-interaction-mode-map lsp-mode-map)
    "K" #'im-peek-doc)

  (general-def
    :states 'normal
    :keymaps 'im-peek-mode-map
    (kbd "K") #'im-peek-remove)

  (defvar im-peek--buffer nil)
  (defvar im-peek--string nil)
  (defvar im-peek--pos 0)
  (defconst im-peek--line-count 30)

  (defun im-peek-jump ()
    (interactive nil im-peek-mode)
    (im-peek-remove)
    (switch-to-buffer-other-window im-peek--buffer))

  (defun im-peek-mode-scroll-down (&optional lines)
    (interactive nil im-peek-mode)
    (quick-peek-hide)
    (quick-peek-show
     (->>
      (s-lines im-peek--string)
      (-drop (setq im-peek--pos (+ (or lines 1) im-peek--pos)))
      (s-join "\n"))
     nil nil im-peek--line-count))

  (defun im-peek-mode-scroll-up (&optional lines)
    (interactive nil im-peek-mode)
    (quick-peek-hide)
    (quick-peek-show
     (->>
      (s-lines im-peek--string)
      (-drop (setq im-peek--pos (max 0 (+ (- (or lines 1)) im-peek--pos))))
      (s-join "\n"))
     nil nil im-peek--line-count))

  (define-minor-mode im-peek-mode
    "Elisp popup documentation mode."
    :lighter " ElPopDoc"
    :global t
    :keymap (let ((map (make-sparse-keymap)))
              (define-key map (kbd "M-j") #'im-peek-mode-scroll-down)
              (define-key map (kbd "M-k") #'im-peek-mode-scroll-up)
              (define-key map (kbd "C-g") #'im-peek-remove)
              (define-key map (kbd "M-RET") #'im-peek-jump)
              map)
    (setf (alist-get #'im-peek-mode minor-mode-overriding-map-alist)
          im-peek-mode-map)
    (evil-normalize-keymaps))

  (defun im-peek-remove ()
  (interactive nil im-peek-mode)
  (setq im-peek--pos 0)
  (im-peek-mode -1)
  (quick-peek-hide)
  (setq minor-mode-overriding-map-alist
        (assq-delete-all #'im-peek-mode
                         minor-mode-overriding-map-alist)))

  (defun im-peek-doc--elisp ()
    (let ((help-xref-following t))
      (helpful-symbol (symbol-at-point))
      (current-buffer)))

  (defun im-peek-doc--lsp ()
    (let ((result
           ;; Taken from lsp-describe-thing-at-point
           (-some->> (lsp--text-document-position-params)
             (lsp--make-request "textDocument/hover")
             (lsp--send-request)
             (lsp:hover-contents)
             (funcall (-flip #'lsp--render-on-hover-content) t)
             (string-trim-right))))
      (unless result
        (user-error "No doc at point"))
      (with-current-buffer (get-buffer-create "*im-lsp-md-doc*")
        (erase-buffer)
        (insert result)
        (current-buffer))))

  ;; TODO support fn returning a string instead of a buffer. Create a
  ;; temp buffer when jump is called
  (defun im-peek (fn)
    "TODO: document this"
    (let ((buffer (save-window-excursion (funcall fn))))
      (setq im-peek--buffer buffer)
      ;; `run-at-time' function is useful for forcing the following code
      ;; to run in main event loop. This helps when `im-peek' is called
      ;; in an async context.
      (run-at-time
       0 nil
       (lambda ()
         (let ((str (setq im-peek--string
                          (with-current-buffer buffer
                            (font-lock-ensure)
                            (buffer-string)))))
           ;; Center the current point if the remaining line count is low
           (when (and
                  (< (im-line-count-below-cursor) (length (s-lines str)))
                  (< (im-line-count-below-cursor) (- (window-height) 10)))
             (recenter 10))
           (quick-peek-show str nil nil im-peek--line-count))
         (im-peek-mode +1)))))

  ;; Special peek functions

  (use-package google-translate)

  (defun im-peek-translate (source target str)
    "Translate STR from SOURCE to TARGET.

  When called interactively, it expects input in form of :

    source:target thing to translate

  source:target part can appear anywhere in the input.

  A future history is already provided so that you can change SOURCE and
  TARGET quickly."
    (interactive
     (let* ((s (im-region-or 'word))
            (match (s-match
                    "\\(.*\\)\\([a-z]\\{2\\}\\):\\([a-z]\\{2\\}\\)\\(.*\\)"
                    (read-string
                     "Translate: "
                     (concat "en:tr " s)
                     nil
                     (concat "tr:en " s)))))
       (list
        (nth 2 match)
        (nth 3 match)
        (concat (s-trim (nth 1 match)) " " (s-trim (nth 4 match))))))
    (im-peek (lambda ()
               (let ((google-translate-pop-up-buffer-set-focus t))
                 (google-translate-translate source target str)
                 (current-buffer)))))

  (defun im-peek-sozluk ()
    "Show definition of the word at point (tr)."
    (interactive)
    (im-peek
     (lambda ()
       (call-interactively #'sozluk)
       (current-buffer))))

  (defun im-peek-dictionary ()
    "Show definition of the word at point (en)."
    (interactive)
    (im-peek
     (lambda ()
       (call-interactively #'wordnut-lookup-current-word)
       (current-buffer))))

  (defun im-peek-etimoloji ()
    "Show etymology of the word at point (tr)."
    (interactive)
    (im-peek
     (lambda ()
       (call-interactively #'sozluk-etymology)
       (current-buffer))))

  (defun im-peek-etymology ()
    "Show etymology of the word at point (en)."
    (interactive)
    (im-peek
     (lambda ()
       (call-interactively #'im-etymology-en)
       (current-buffer))))

  ;; TODO: If org mode, show link's text as peek
  (defun im-peek-doc ()
    "Show documentation at point."
    (interactive)
    (im-peek
     (cond
      ((symbol-value 'lsp-mode) #'im-peek-doc--lsp)
      ((-contains? '(emacs-lisp-mode lisp-interaction-mode) major-mode) #'im-peek-doc--elisp))))

  ;; TODO: Add lsp mode etc.
  (defun im-peek-source ()
    "Show source at point."
    (interactive)
    (let (pos)
      (im-peek
       (lambda ()
         (call-interactively #'xref-find-definitions)
         (setq pos (line-number-at-pos))
         (current-buffer)))
      (im-peek-mode-scroll-down (- pos 2))))
#+end_src

** im-weather
Just a wttr.in wrapper. Another piece in the name of using a web browser even less.
#+begin_src emacs-lisp
  (defun im-weather ()
    (interactive)
    (im-shell-command
     :command "curl wttr.in"
     :buffer-name "*im-weather*"))
#+end_src
** im-gpt
#+begin_src emacs-lisp
  (defvar im-gpt-prompts
    '((:prompt "Summarize following section." :region t)
      (:prompt "Add documentation to the following code." :region t)
      (:prompt "Add documentation to the following Elisp code."
       :system "You are an Emacs lisp and documentation expert. You add inline documentation to given code by complying with Emacs lisp documentation conventions (refer parameters in UPPERCASE style without quoting them, use `this' style quoting for other Elisp objects/references). Refer to \"Tips for Documentation Strings\" in Emacs manual. ONLY return the documentation string in quotes, without repeating the code."
       :region t)
      (:prompt "Add documentation testing to the following Elisp code."
       :system "You are an Emacs lisp and documentation expert. You create tests for given function and add them into the documentation string of the function in the following format:

  >> <TEST-CODE>
  => <TEST-RESULT>

  Where <TEST-CODE> is the test itself, like (+ 1 1), and <TEST-RESULT> is the result of calling <TEST-CODE>, like 2."
       :region t)
      (:prompt "Explain following code." :region t))
    "A list of prompts for the `im-gpt' function.

  Each element is a property list with the following keys:
  - PROMPT: The user prompt.
  - SYSTEM: (Optional) The system prompt for the AI assistant.
  - REGION: (Optional) A boolean indicating whether to include the
    selected region when calling `im-gpt' with the prompt.")

  (defconst im-gpt--buffer "*im-gpt*")

  ;; TODO: save to a file automatically?
  (cl-defun im-gpt (prompt
                    &key
                    (system "You are an AI assistant living inside Emacs. You answer concisely.")
                    (include-system t)
                    (model "gpt-3.5-turbo")
                    (callback))
    "Use the ChatGPT to generate responses to user prompts.

  - PROMPT is the user input to generate a response for.
  - SYSTEM is the system prompt for the AI assistant.
  - INCLUDE-SYSTEM, if non-nil, includes SYSTEM prompt to PROMPT.
    I found that it's more reliable to include system prompt to
    every message.
  - CALLBACK is a function that takes the prompt and the generated
    response as an argument and performs custom actions with it. It
    defaults to a function that displays the response in a separate
    buffer using `markdown-mode' and switches to that buffer.

  When called interactively, this function prompts for PROMPT and
  lets you customize SYSTEM and CALLBACK. See `im-gpt-prompts' for
  predefined prompts.

  Version: 2023-07-16"
    (interactive
     (let* ((selection (im-completing-read
                        "Prompt: "
                        (--filter (if (use-region-p)
                                      (plist-get it :region)
                                    (not (plist-get it :region)))
                                  im-gpt-prompts)
                        :formatter (lambda (it) (plist-get it :prompt))))
            (prompt (or (plist-get selection :prompt) selection))
            (system (plist-get selection :system)))
       (list
        (if-let (region (im-region-or nil))
            (format "%s\n\n```\n%s\n```\n" prompt region)
          prompt)
        :system (or system
                    "You are an AI assistant living inside Emacs. You answer concisely."))))
    (setq prompt
          (if include-system
              (concat system "\n\n" prompt)
            prompt))
    (cond
     ;; If called interactively, delegate to `org-ai-prompt' with given
     ;; prompt and system prompt. This automatically streams to
     ;; `im-gpt--buffer'.
     ((called-interactively-p 'interactive)
      (org-ai-prompt
       prompt
       :follow t
       :sys-prompt system
       :output-buffer (let ((buffer (get-buffer-create im-gpt--buffer)))
                        (with-current-buffer buffer
                          (goto-char (point-max))
                          (insert (format "* %s\n" (format-time-string "%Y-%m-%d %a %H:%M")))
                          (insert "#+begin_ai markdown\n")
                          (insert (format "[SYS]: %s\n\n" system))
                          (insert (format "[ME]: %s\n" prompt))
                          (insert (format "[AI]: " prompt))
                          (let ((pt (point)))
                            (insert "\n#+end_ai\n")
                            (if-let (window (get-buffer-window im-gpt--buffer))
                                (set-window-point window pt)
                              (goto-char pt))))
                        (switch-to-buffer-other-window buffer)
                        buffer)
       :callback (lambda ()
                   (with-current-buffer (get-buffer-create im-gpt--buffer)
                     (if-let (window (get-buffer-window im-gpt--buffer))
                         (set-window-point window (point-max))
                       (goto-char (point-max)))
                     (insert "\n")
                     (font-lock-ensure)))))
     (t
      (org-ai-chat-request
       :messages `[(:role system :content ,system)
                   (:role user :content ,prompt)]
       :model model
       :callback (lambda (content role usage)
                   (funcall callback prompt content))))))
#+end_src
* Operating system related
** Sound output chooser
#+begin_src emacs-lisp
  (defun im-osx-select-audio-output ()
    ;; This is required: https://github.com/deweller/switchaudio-osx
    ;; brew install switchaudio-osx
    (im-output-select
     :cmd "SwitchAudioSource -a"
     :prompt (let ((current (im-shell-command-to-string "SwitchAudioSource -c")))
               (format "Select audio source (%s): " current))
     :do (shell-command-to-string (format "SwitchAudioSource -s '%s'" it))))

  (defun im-linux-select-audio-output ()
    (let ((sink
           (->>
            (shell-command-to-string
             "pactl list sinks | grep -E 'Name|device.description' | cut -d: -f2 | cut -d= -f2 | tr -d '\"'")
            (s-trim)
            (s-split "\n")
            (mapcar #'s-trim)
            (-partition 2)
            (mapcar #'nreverse)
            (im-alist-completing-read "Select sink: ")
            car)))
      ;; Set default sink
      (shell-command-to-string (format "pactl set-default-sink %s" sink))
      ;; Move inputs to the new sink
      (->>
       (shell-command-to-string "pactl list short sink-inputs | cut -d'\t' -f1")
       (s-trim)
       (s-split "\n")
       (--map (shell-command-to-string (format "pactl move-sink-input %s %s" it sink))))))

  (defun im-select-audio-output ()
    (interactive)
    (funcall
     (pcase system-type
       ('darwin #'im-osx-select-audio-output)
       ('gnu/linux #'im-linux-select-audio-output))))

  (im-leader
    "ea" #'im-select-audio-output)
#+end_src

** Bluetooth device connector
#+begin_src emacs-lisp
  (defun im-osx-connect-paired-bluetooth-device ()
    (interactive)
    (im-output-select
     :prompt "Select Bluetooth device: "
     :cmd "blueutil --paired"
     :formatter (->> it
                   (s-split ", ")
                   (--map (s-split ":" it))
                   (--find (equal (car it) "name"))
                   cadr
                   (s-replace "\"" "")
                   s-trim)
     :filter (s-contains? "not connected" it)
     :keep-order nil
     :do (let ((id (->> (s-split "," it) car (s-split ":") cadr s-trim)))
           (message ">> Connecting to %s..." id)
           (shell-command-to-string (format "blueutil --connect %s" id))
           (message ">> Connecting to %s...Connected." id))))

  (defun im-linux-connect-paired-bluetooth-device ()
    (interactive)
    (let* ((paired-devices (->>
                            (shell-command-to-string "bluetoothctl devices Paired")
                            (s-trim)
                            (s-split "\n")))
           (connected-devices (->>
                               (shell-command-to-string "bluetoothctl devices Connected")
                               (s-trim)
                               (s-split "\n")))
           (device
            (->>
             (-difference paired-devices connected-devices)
             (--map (->>
                     (s-split-up-to " " it 2)
                     (-drop 1)
                     (nreverse)))
             (im-alist-completing-read "Select bluetooth device to connect: ")
             (car))))
      (set-process-filter
       (start-process "im-connect-bluetooth" nil "bluetoothctl" "connect" device)
       (lambda (proc out)
         (cond
          ((s-matches? "Failed to connect" out) (message "%s" out))
          ((s-matches? "Connection successful" out) (message "%s" out)))))))

  (defun im-connect-paired-bluetooth-device ()
    (interactive)
    (funcall
     (pcase system-type
       ('darwin #'im-osx-connect-paired-bluetooth-device)
       ('gnu/linux #'im-linux-connect-paired-bluetooth-device))))

  (im-leader
    "eb" #'im-connect-paired-bluetooth-device)
#+end_src
** Switch next monitor input
#+begin_src emacs-lisp
  (defun im-ddcutil-toggle/switch-monitor-input (monitor)
    "Switch to other monitor, USBC or HDMI."
    (interactive (list (intern (completing-read "Monitor: " '(usbc hdmi dp)))))
    (let* ((addresses '((hdmi . "0x11")
                        (dp . "0x0f")
                        (usbc . "0x1b")))
           (cmd (format
                 "ddcutil -b $(ddcutil detect | grep I2C | cut -d- -f2 | tail -n 1) setvcp 0x60 %s"
                 (alist-get monitor addresses))))
      (shell-command-to-string
       (if (workpc?)
           (format "ssh x220 '%s'" cmd)
         cmd))))
#+end_src
* Postamble
#+begin_src emacs-lisp
  ;; Load the remaining external files that I want to be loaded
  (--each
      (directory-files im-load-path t (rx ".el" eos))
    (load it))

  (unless (daemonp)
   ;; This is good for the cases where emacsclient may be called inside
   ;; emacs (from vterm etc.). Otherwise Emacs acts weird about the
   ;; window placement.
    (setq server-window #'pop-to-buffer)
    (server-start))

  (message ">>> Started in %s" (emacs-init-time))
#+end_src

;; Local Variables:
;; eval: (add-hook 'after-save-hook (lambda () (if (y-or-n-p "Tangle?") (org-babel-tangle))) nil t)
;; End:
