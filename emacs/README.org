#+TITLE: Emacs configuration file
#+AUTHOR: İsa Mert Gürbüz
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes :noweb yes
#+STARTUP: overview

* Introduction
This is my emacs configuration. My main focus is sanity. I'm a person who get frustrated pretty easily. So instead of optimizing the time spent on doing things, I try to find ways of doing things that does not make me frustrated. Most of the time you get speed boost as a byproduct.

#+begin_src emacs-lisp
  ;;; settings.el --- isamert's configuration -*- lexical-binding: t; -*-

  ;;; Commentary:

  ;; isamert's configuration

  ;;; Code:
#+end_src

* Usage notes
** General notes and conventions
- This configuration is meant to be used with /emacs daemon/, so I don't really care about the startup time etc.
- I try to split package configurations into multiple org src blocks and unify them using ~noweb~ references under a single =use-package= directive.
- I try to put things in way that easily copyable from the configuration. An example would be using multiple =(setq ...)= lines instead of having one =(setq ... ...)= call and setting multiple variables in one go.
- I make use of =use-package= features quite minimally. See [[id:3d974e67-11fc-4f07-8cd4-ec6fd63152c4][here]] for more information that. This is generally related with the item above and future-proofing.
- I use =verbatim text= and ~code text~ completely randomly.
- I try to prefer built-in packages or packages that enhances built-in ones where possible. I'm also trying to simplify my configuration, so another goal is to reduce the package number. Although I intend to keep packages that enhances the overall experience with no special configuration (just install and forget type of packages).

** Updating packages
Currently, I don't use an external package manager, =package.el= satisfies my needs. Here is how I do the updates:
- =package-refresh-contents=
- =list-packages=
- Hit =U= to mark all packages that needs updating.
- Hit =X= to update all those packages.

I do this quite infrequently. If everything is working fine as it is, I tend to not update anything.

* Preparation
** Package repos
Add ~melpa~ and ~org~ package archives and update them if needed.

#+BEGIN_SRC emacs-lisp
  (require 'package)

  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
  (add-to-list 'package-archives '("nongnu" . "http://elpa.nongnu.org/nongnu/"))

  (package-initialize)

  ;; Update the packages
  (unless package-archive-contents
    (package-refresh-contents))
#+END_SRC

** Installing packages with ~use-package~
:PROPERTIES:
:ID:       3d974e67-11fc-4f07-8cd4-ec6fd63152c4
:END:
I use =use-package= to install packages and configure them but I do absolute minimal usage of it.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  (eval-when-compile
    (require 'use-package))
#+END_SRC

I tend to not use the =use-package= goodies while configuring my packages, meaning that I don't use =:hook=, =:bind= etc. as they have relatively simpler alternatives in Emacs and using =use-package= alternatives of these makes copy/pasting harder. Here are the keywords that I use the most:
- =:init= :: This gets called before the package gets initialized.
- =:config= :: This gets called after the package is initialized.
- =:after= :: This makes the current definition to wait the loading of listed packages, like =:after (evil org)= makes it wait for the =evil= and =org= packages to be loaded.
- =:if= :: Loads the package conditionally, like =:if (eq system-type 'darwin)=.

*** Installing packages from other sources using =quelpa= (like GitHub/GitLab/Web file etc.)
I use =quelpa= for this.
- Use =quelpa-upgrade= and select a package or use =quelpa-upgrade-all= for updating all packages.

#+BEGIN_SRC emacs-lisp
  (use-package quelpa-use-package
    :ensure t
    :init (setq quelpa-update-melpa-p nil)
    :config (quelpa-use-package-activate-advice))
#+END_SRC

Here is an example that shows you how to install a package from Github:

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package PACKAGE-NAME
    :ensure t
    :diminish
    :quelpa (PACKAGE-NAME
             :fetcher github
             :branch "WIP" ;; Optional
             :repo "yyoncho/company-box"))
#+END_SRC

*** Hiding mode indicators from modeline
~diminish.el~ provides a way to hide mode indicators from mode line. Either pass ~:diminish t~ to use-package while installing or just call ~(diminish 'x-mode)~.

#+BEGIN_SRC emacs-lisp
  (use-package diminish :ensure t)
#+END_SRC

Currently I use [[mini-modeline]] as my modeline and it already hides minor mode indicators from the modeline. So this package is not needed but better have it as I might change my modeline in the future.

** Essential packages
I use =s.el= and =dash.el= extensively. They already come as a dependency with other packages but I may use them before loading any package, so:

#+begin_src emacs-lisp
  (use-package dash :ensure t)
  (use-package s :ensure t)
#+end_src

** Variables and functions
Some basic variable and function definitions that will be used in configuration.

#+BEGIN_SRC emacs-lisp
  (defun isamert/mkdir-if-not (dir)
    "Create the DIR if it does not exist return DIR."
    (unless (file-exists-p dir)
      (make-directory dir))
    dir)

  (defun isamert/font-exists-p (font)
    "Check if FONT exists."
    (x-list-fonts font))

  (defun isamert/assoc-regexp (key list &optional fn)
    "Like `assoc` but uses `string-match (car pair) KEY` for
  comparasion and returns all the matching pairs. FN is applied to
  the keys before matching, if present."
    (seq-filter
     (lambda (pair)
       (when (string-match-p (if fn (funcall fn (car pair)) (car pair)) key)
         pair))
     list))

  (defun isamert/region-or (what)
    "Returns currently selected string or WHAT-at-point
  string. WHAT can be 'symbol 'word etc."
    (if (use-region-p)
        (buffer-substring-no-properties (region-beginning) (region-end))
      (thing-at-point what t)))

  (defun isamert/define-key (&rest k+c)
    "Simple wrapper around `define-key' that let's you define-keys
  multiple times in one call."
    (let ((mode (car k+c)))
    (setq k+c (cdr k+c))
      (while k+c
        (define-key mode (car k+c) (cadr k+c))
        (setq k+c (cddr k+c)))))
#+END_SRC

** Load path
Add =~/.emacs.d/load/= to =load-path=. I have extra configuration kept in this path.

#+begin_src emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/load/")
#+end_src

Also load ~isamert-secrets~ from =load-path=. I'll be utilizing some variables defined here throughout my configuration. It contains some api-keys, some tokens or some passwords etc. that I don't want to leak into public. Instead of doing mutations on an external hidden script, I define variables in this external hidden script and reference them in the configuration. This way the logic stays in the public configuration file so that everyone can take a look, but only the variable itself will be hidden from the public.

#+begin_src emacs-lisp
  (load "isamert-secrets")
#+end_src

* Basics
** Sane defaults
#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold 100000000)
  ;; ^ Better than default
  (setq read-process-output-max (* 1024 1024))
  ;; ^ Better than default
  (setq confirm-kill-processes nil)
  ;; ^ When exitting, kill processes withouh asking
  (setq ring-bell-function 'ignore)
  ;; ^ This completely disables alarms
  (setq column-number-mode t)
  ;; ^ Show column number
  (setq create-lockfiles nil)
  ;; ^ These just clutter the filesystem

  ;; Ask y/n instead of yes/no
  (fset 'yes-or-no-p 'y-or-n-p)

  ;; Wrap long lines
  (global-visual-line-mode t)
  (diminish 'visual-line-mode)
#+END_SRC

Some sources about the variables that I changed:
- https://github.com/emacs-lsp/lsp-mode#performance

** Recent files
Save recent files. Also exclude package files that appears after installing a package or after an update from recent list.

#+BEGIN_SRC emacs-lisp
  (recentf-mode t)
  (add-to-list
   'recentf-exclude
   (format "%s/\\.emacs\\.d/elpa/.*" (getenv "HOME")))
#+END_SRC

** Save minibuffer, kill-ring, search-ring history
#+begin_src emacs-lisp
  (setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
  (setq savehist-file "~/.emacs.d/savehist")
  (savehist-mode 1)
#+end_src

** Better scrolling
*** Better settings for mouse scroll
#+BEGIN_SRC emacs-lisp
  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
  (setq mouse-wheel-progressive-speed nil)            ;; don't accelerate scrolling
  (setq mouse-wheel-follow-mouse 't)                  ;; scroll window under mouse
#+END_SRC

*** Mouse shortcuts for zooming
- Ctrl-Scroll to zoom in and out

#+BEGIN_SRC emacs-lisp
  (global-set-key [C-mouse-4] 'text-scale-increase)
  (global-set-key [C-mouse-5] 'text-scale-decrease)
  (global-set-key (kbd "C-+") 'text-scale-increase)
  (global-set-key (kbd "C-=") 'text-scale-decrease)
#+END_SRC

*** Conservative scrolling
If the cursor is at the end of the file, when you scroll emacs does a strange jump. This fixes it.

#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 100) ;; When cursor reaches end, just scroll line-by-line
#+END_SRC

** Backups
Instead of having a file that ends with ~ or '# files in same directory, save all backup files in =~/.emacs.d/backups=.

#+BEGIN_SRC emacs-lisp
  (defconst backup-dir (isamert/mkdir-if-not"~/.emacs.d/backups/"))

  (setq backup-directory-alist `((".*" . ,backup-dir)))
  (setq auto-save-file-name-transforms `((".*" ,backup-dir t)))

  (setq backup-by-copying t)
  ;; ^ Don't delink hardlinks
  (setq version-control t)
  ;; ^ Use version numbers on backups
  (setq delete-old-versions t)
  ;; ^ Automatically delete excess backups
  (setq kept-new-versions 20)
  ;; ^ How many of the newest versions to keep
  (setq kept-old-versions 5)
  ;; ^ How many of the old versions to keep
#+END_SRC

** Undo tree (Persistent undo and stuff)
- ~undo-tree~ gives a persistent undo.
- Also it keeps undo history as a tree instead of a linear history. ~undo-tree-visualize~ may help.

#+BEGIN_SRC emacs-lisp
  (defconst isamert/undo-dir
    (isamert/mkdir-if-not "~/.emacs.d/undo/"))

  (use-package undo-tree
    :diminish undo-tree-mode
    :ensure t
    :init
    (setq undo-tree-auto-save-history t)
    (setq undo-tree-history-directory-alist `(("." . ,isamert/undo-dir)))
    (setq undo-tree-enable-undo-in-region nil) ;; this fixes something?
    ;; Use undo-tree for evil
    (setq evil-undo-system 'undo-tree)

    :config
    (global-undo-tree-mode))
#+END_SRC

** Remove trailing space before save
#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

** Automatically run some commands after saving specific files
This is like =autocmd BufWritePost= of vim. When a particular file is edited, I want to make sure a command runs after the save.

#+BEGIN_SRC emacs-lisp
  (defvar isamert/run-after-save-alist
    '(("~/.\\(Xresources\\|Xdefaults\\)" . "xrdb %; notify-send 'xrdb updated'")
      ("~/.Xresources.d/.*"              . "xrdb ~/.Xresources; notify-send 'xrdb updated'")
      ("~/.config/sxhkd/sxhkdrc"         . "pkill -USR1 -x sxhkd; notify-send 'sxhkd updated'")
      ("~/.config/skhd/skhdrc"           . "skhd --reload; osascript -e 'display notification \"skhd updated\"'"))
    "File association list with their respective command.")

  (add-hook 'after-save-hook #'isamert/post-save-run-command)
  (add-hook 'org-babel-post-tangle-hook #'isamert/post-save-run-command)

  (defun isamert/post-save-run-command ()
    "Execute the specified command after saving specified file."
    (let* ((fname (buffer-file-name))
           (match (isamert/assoc-regexp fname isamert/run-after-save-alist #'expand-file-name)))
      (when match
        (mapcar (lambda (pair) (shell-command (s-replace "%" fname (cdr pair)))) match))))
#+END_SRC

* Visuals
** General
Hide menubar and toolbar and replace blinking cursor with nice static box cursor.

#+BEGIN_SRC emacs-lisp
  (menu-bar-mode 0)                ;; Disable menubar
  (tool-bar-mode 0)                ;; Disable toolbar
  (blink-cursor-mode 0)            ;; Disable blinking cursor
  (scroll-bar-mode -1)             ;; Disable scrollbars
  (global-hl-line-mode t)          ;; Highlight current line
  (setq inhibit-startup-message t) ;; Close startup screen
  (setq frame-resize-pixelwise t)  ;; Fix gap issues with tiling WMs
#+END_SRC

Disable global-hl-line-mode in eshell, ansi-term, vterm

#+begin_src emacs-lisp
  (mapcar
    (lambda (mode) (add-hook mode (lambda () (setq-local global-hl-line-mode nil))))
    '(eshell-mode-hook term-mode-hook vterm-mode-hook))
#+end_src

** Fonts and theme
#+BEGIN_SRC emacs-lisp
  (use-package doom-themes
    :ensure t
    :defer t)

  (defconst isamert/font-height 120)
  (defconst isamert/fonts '("Iosevka Nerd Font"))

  (defun isamert/set-font-and-theme-config ()
    "Configure font and theme."
    (interactive)
    ;; Set the first avilable font from the `isamert/fonts' list
    (--each-r-while
        isamert/fonts #'isamert/font-exists-p
      (set-face-attribute 'default nil
                          :font it
                          :weight 'normal
                          :width 'normal
                          :height isamert/font-height))
    ;; ...and load the theme
    (load-theme 'doom-gruvbox-light t))

  (defun isamert/set-font-and-theme-config-in-frame (frame)
    (with-selected-frame frame
      (isamert/set-font-and-theme-config)))

  (if (daemonp)
      ;; Following sets font/font-size for each emacsclients frame
      (add-hook
       'after-make-frame-functions
       #'isamert/set-font-and-theme-config-in-frame)
    ;; Not in daemon mode, set theme etc directly
    (isamert/set-font-and-theme-config))
#+END_SRC

** all-the-icons
You should run =all-the-icons-install-fonts= command after this.

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons :ensure t)
#+END_SRC

** fira-code-mode (font ligatures)
This adds Fira Code ligatures into Emacs, meaning that it prettifies well-known code symbols. This mode also saves the length of the chars, so it does not break spacing.
- After the first install, you need to call =fira-code-mode-install-fonts= and then maybe restart Emacs etc.

  #+begin_src emacs-lisp
    (use-package fira-code-mode
      :ensure t
      :config
      (global-fira-code-mode))
  #+end_src

** prettify-symbols-mode
I make use of this mode quite frequently throughout the configuration.

#+begin_src emacs-lisp
  (use-package prog-mode
    :config
    (setq prettify-symbols-unprettify-at-point t))

  (defmacro isamert/prettify-mode (mode pairs)
    "Prettify given PAIRS in given MODE.
    Just a simple wrapper around `prettify-symbols-mode`"
    `(add-hook
      ,mode
      (lambda ()
        (mapc (lambda (pair)
                (push pair prettify-symbols-alist))
              ,pairs)
        (prettify-symbols-mode 1))))
#+end_src
** Frame title
Make window title contain buffer name so it's easier to identify windows. I use ~rofi~ to switch between windows in my DE, so it helps to have buffer name in window title.

#+BEGIN_SRC emacs-lisp
(setq frame-title-format "%b - emacs")
#+END_SRC

** Parentheses
*** Matching
Just enable parenthesis matching.

#+BEGIN_SRC emacs-lisp
  (setq show-paren-style 'parenthesis)
  (show-paren-mode 1)
#+END_SRC

*** Rainbow
Colors parentheses depending on their dept.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

** Highlight trailing spaces
- Following highlights trailing spaces. Also see: [[Remove trailing space before save]]

#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :ensure t
    :diminish global-whitespace-mode
    :config
    (setq whitespace-style '(face empty tabs trailing))
    (setq whitespace-global-modes '(not org-mode markdown-mode vterm-mode magit-log-mode))
    (global-whitespace-mode t))

  (defun isamert/whitespace-mode-toggle ()
    "Toggle between more and less agressive whitespace modes.
  Toggles between showing every whitespace (tabs, spaces, newlines
  etc.) and only showing trailing spaces and tabs.  By default I use
  the latter but sometimes I want to see everything and the
  function helps me go between these modes easily."
    (interactive)
    (if (member 'spaces whitespace-style)
        (setq whitespace-style '(face empty tabs trailing))
      (setq whitespace-style '(face tabs spaces trailing lines space-before-tab newline indentation empty space-after-tab space-mark tab-mark newline-mark)))
    (whitespace-mode 0)
    (whitespace-mode 1))
#+END_SRC

** Spaces instead of tabs
#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 4)
  (setq-default indent-tabs-mode nil)
#+END_SRC

** Shackle windows
Make some temproary windows appear at bottom. This makes buffer management so much easier. Buffers that will match given regex will appear at bottom while covering the given amount of screen.

#+BEGIN_SRC emacs-lisp
  ;; SOURCE: https://www.reddit.com/r/emacs/comments/345vtl/make_helm_window_at_the_bottom_without_using_any/
  (defun isamert/shackle-window (name size)
    "Make the buffer NAME appear at bottom of the window, filling
    SIZE percent of the window."
    (add-to-list 'display-buffer-alist
                 `(,name
                   (display-buffer-in-side-window)
                   (inhibit-same-window . t)
                   (window-height . ,size))))

  (isamert/shackle-window "\\*Help\\*" 0.4)
  (isamert/shackle-window "\\*Warnings*\\*" 0.2)
  (isamert/shackle-window "\\*Backtrace*\\*" 0.4)
  (isamert/shackle-window "\\*Flycheck.*" 0.4)
  (isamert/shackle-window "\\*Org Src.*\\*" 0.4)
  (isamert/shackle-window "\\*Agenda Commands\\*" 0.4)
  (isamert/shackle-window "\\*Org Agenda\\*" 0.4)
  (isamert/shackle-window "\\*Org Select\\*" 0.4)
  (isamert/shackle-window "CAPTURE-*" 0.4)
  (isamert/shackle-window "magit.*" 0.7)
  (isamert/shackle-window "\\*xref\\*" 0.4)
  (isamert/shackle-window "\\*Org-Babel Error Output\\*" 0.4)
  (isamert/shackle-window "\\*curl error\\*" 0.4)
  (isamert/shackle-window "\\*helpful.*\\*" 0.4)
#+END_SRC

** Miscellaneous packages
Some small packages that enriches editing experience visually. I don't enable all of them by default, I enable most of them whenever I need the functionality. I utilize an appearance [[Hydra]] to quickly toggle the functionality I need.

#+begin_src emacs-lisp
  ;; Show column guidelines
  (use-package fill-column-indicator
    :ensure t)

  ;; By default Emacs scales fonts with text-scale-{increase,decrease}
  ;; per buffer. This scales fonts with
  ;; default-text-scale-{increase,decrease} globally.
  (use-package default-text-scale
    :ensure t)

  ;; Highlights changed lines in git. You need to save the buffer to see
  ;; the changes.
  (use-package diff-hl
    :ensure t)

  ;; It helps you to find your cursor when you change buffers/windows
  ;; etc with a little animation.
  (use-package beacon
    :ensure t
    :config
    (beacon-mode 1)
    (setq beacon-blink-duration 0.5
          beacon-push-mark 50
          beacon-color "#9F72D9"))

  ;; This shows some indent guides and it's highly configurable.
  (use-package highlight-indent-guides
    :ensure t
    :config
    (set-face-background 'highlight-indent-guides-odd-face "darkgray")
    (set-face-background 'highlight-indent-guides-even-face "dimgray")
    (set-face-foreground 'highlight-indent-guides-character-face "dimgray")
    (setq highlight-indent-guides-method 'bitmap)
    (setq highlight-indent-guides-bitmap-function 'highlight-indent-guides--bitmap-line))
#+end_src

* evil-mode
** Basic configuration
#+BEGIN_SRC emacs-lisp
  ;; Disable evil bindings in insert mode. This needs to be called
  ;; before loading evil mode
  (setq evil-disable-insert-state-bindings t)

  (use-package evil
    :ensure t
    :config
    ;; But I want some default evil bindings in insert mode, so just
    ;; remap them
    (evil-define-key 'insert 'global
      (kbd "C-d") #'evil-shift-left-line
      (kbd "C-t") #'evil-shift-right-line
      (kbd "C-n") #'evil-complete-next
      (kbd "C-p") #'evil-complete-previous
      (kbd "C-o") #'evil-execute-in-normal-state)

    (evil-define-key 'normal 'global
      "Q" #'evil-quit)

    (setq evil-want-integration t)
    (setq evil-want-keybinding t)
    ;; When I paste something in visual mode, I don't want it to take
    ;; over the kill ring I also use evil-exchange, which eliminates the
    ;; need for this totally
    (setq evil-kill-on-visual-paste nil)
    ;; ^ Over the time I found myself utilizing emacs C-u more and more,
    ;; so disable this
    (setq evil-want-C-u-scroll nil)

    ;; Make horizontal movement cross lines
    (setq-default evil-cross-lines t)

    ;; Move between visual lines instead of real lines
    (evil-define-key 'normal 'global
      (kbd "<remap> <evil-next-line>") #'evil-next-visual-line
      (kbd "<remap> <evil-previous-line>") #'evil-previous-visual-line)
    (evil-define-key 'motion 'global
      (kbd "<remap> <evil-next-line>") #'evil-next-visual-line
      (kbd "<remap> <evil-previous-line>") #'evil-previous-visual-line)

    ;; Change cursor colors based on current mode.
    (setq evil-normal-state-cursor '("green" box)
          evil-visual-state-cursor '("orange" box)
          evil-emacs-state-cursor '("purple" box)
          evil-insert-state-cursor '("pink" bar)
          evil-replace-state-cursor '("red" bar)
          evil-operator-state-cursor '("red" hollow))

    (evil-mode 1))
#+END_SRC

** evil-leader
Enable leader key and bind some keys.

#+BEGIN_SRC emacs-lisp
  (use-package evil-leader
    :ensure t
    :after evil
    :config
    (global-evil-leader-mode)

    (evil-leader/set-leader "SPC")
    (evil-leader/set-key
      ;; generic
      ";"   'eval-last-sexp

      ;; buffers
      "bq" 'evil-quit
      "bd" 'evil-delete-buffer))
#+END_SRC

** evil-mc
Multiple cursors for evil.

- Basics
  - =C-n= / =C-p= are used for creating cursors
  - =A= and =I= creates cursors in visual selection mode as you may expect.
  - =gkk= to clear all cursors.

- To be able to create cursors at arbitrary positions:
  - =gkp= to pause all cursors. (Your main cursors moves freely while mc cursors stays still)
  - =gkr= to resume paused cursors.
  - =gkh= create a cursor at the point of main cursor. (Use after =gkp=).

#+BEGIN_SRC emacs-lisp
  (use-package evil-mc
    :ensure t
    :after evil
    :diminish evil-mc-mode
    :config
    ;; I use "gr" (which is the default key combination that brings up evil-mc commands) for something else
    ;; So remove "gr" binding
    (evil-define-key* '(normal visual) evil-mc-key-map (kbd "gr") nil)
    (evil-define-key* '(normal visual) evil-mc-key-map (kbd "M-p") nil)

    ;; Add my bindings using "gk"
    (evil-define-key 'normal evil-mc-key-map
      (kbd "gkk") #'evil-mc-undo-all-cursors
      (kbd "gkp") #'evil-mc-pause-cursors
      (kbd "gkr") #'evil-mc-resume-cursors
      (kbd "gkh") #'evil-mc-make-cursor-here)

    (evil-define-key 'visual evil-mc-key-map
      "A" #'evil-mc-make-cursor-in-visual-selection-end
      "I" #'evil-mc-make-cursor-in-visual-selection-beg)
    (global-evil-mc-mode 1))
#+END_SRC

** evil-surround
Change surroundings. Do =cs"'= to turn ="Hello world!"= into ='Hello world!'=.
- ='Hello world!'= ~cs'<q>~ =<q>Hello world!</q>=
- =Hel|lo= ~ysiw"~ ="Hello"= (| is the cursor position.)
- =Hello= ~ysw{~ ={ Hello }=  (~{[(~ adds spaces)
- =Hello= ~ysw}~ ={Hello}=    (~}])~ does not add spaces)

#+BEGIN_SRC emacs-lisp
  (use-package evil-surround
    :ensure t
    :after evil
    :init
    (global-evil-surround-mode 1))
#+END_SRC

** evil-escape
Return back to normal mode using ~jk~ from anywhere. It does not play well with multiple cursors, so use ~ESC~ to when using evil-mc related stuff.

#+BEGIN_SRC emacs-lisp
  (use-package evil-escape
    :diminish
    :after evil
    :ensure t
    :config
    (setq evil-escape-key-sequence "jk"
          evil-escape-delay 0.2)
    (evil-escape-mode 1))
#+END_SRC

** evil-matchit
Jump between matching tags using ~%~, like =<div>...</div>=, ={...}= etc. =ci%=, =da%= etc. works as expected.

#+BEGIN_SRC emacs-lisp
  (use-package evil-matchit
    :diminish
    :after evil
    :ensure t
    :config
    (global-evil-matchit-mode 1))
#+END_SRC

** evil-goggles
~evil-goggles~ gives nice visual feedbacks while editing with evil-mode. When you do =dd=, =yw=, =ciw= or something similar, it will give a visual feedback for the selection. Feels kinda natural to have this.

#+BEGIN_SRC emacs-lisp
  (use-package evil-goggles
    :ensure t
    :after evil
    :diminish
    :config
    (setq evil-goggles-duration 0.20
          evil-goggles-pulse nil
          evil-goggles-enable-change t
          evil-goggles-enable-delete t
          evil-goggles-enable-indent t
          evil-goggles-enable-yank t
          evil-goggles-enable-join t
          evil-goggles-enable-fill-and-move t
          evil-goggles-enable-paste t
          evil-goggles-enable-shift t
          evil-goggles-enable-surround t
          evil-goggles-enable-commentary t
          evil-goggles-enable-nerd-commenter t
          evil-goggles-enable-replace-with-register t
          evil-goggles-enable-set-marker t
          evil-goggles-enable-undo t
          evil-goggles-enable-redo t)
    (evil-goggles-mode)
    (evil-goggles-use-diff-faces))

#+END_SRC

** evil-snipe
- Overall better =f/F/t/T= and . Nice visual feedbacks.

#+BEGIN_SRC emacs-lisp
  (use-package evil-snipe
    :ensure t
    :after evil
    :diminish evil-snipe-local-mode
    :config
    ;; (evil-snipe-mode 1) ;; This enables s/S bindings. I use those keys with avy
    (evil-snipe-override-mode 1) ;; This overrides default f/F, t/T bindings
    (setq evil-snipe-scope 'visible)
    (setq evil-snipe-skip-leading-whitespace nil)
    ;; ^ See https://github.com/hlissner/evil-snipe/issues/72
    (add-hook 'magit-mode-hook 'turn-off-evil-snipe-override-mode))
#+END_SRC

** evil-unimpaired
This section is inspired by the unimpaired vim package.
  - ~[<SPC>~ ~]<SPC>~ Insert newline above/below.
  - ~[b~ ~]b~ Go to prev/next buffer.
  - ~[p~, ~]p~ Paste up/down.
  - ~[r~, ~]r~ Move line up/down.
  - ~[d~, ~]d~ Delete line above/below.

Also (defined elsewhere):
 - ~[e~ ~]e~ Go to prev/next error.
 - ~[t~ ~]t~ Go to prev/next TODO.

#+begin_src emacs-lisp
  (evil-define-key 'normal 'global
    (kbd "[r") #'isamert/move-line-up
    (kbd "]r") #'isamert/move-line-down

    (kbd "[d") #'isamert/delete-line-above
    (kbd "]d") #'isamert/delete-line-below

    (kbd "[p") #'isamert/paste-above
    (kbd "]p") #'isamert/paste-below

    (kbd "[ SPC") #'isamert/insert-space-above
    (kbd "] SPC") #'isamert/insert-space-below)

  (defun isamert/move-line-up ()
    "Move current line up."
    (interactive)
    (transpose-lines 1)
    (forward-line -2))

  (defun isamert/move-line-down ()
    "Move current line down."
    (interactive)
    (next-line 1)
    (transpose-lines 1)
    (forward-line -1))

  (defun isamert/delete-line-above ()
    "Move current line down."
    (interactive)
    (save-excursion
      (previous-line 1)
      (beginning-of-line)
      (kill-line)
      (kill-line)))

  (defun isamert/delete-line-below ()
    "Move current line down."
    (interactive)
    (save-excursion
      (next-line 1)
      (beginning-of-line)
      (kill-line)
      (kill-line)))

  ;; I just copied some of the functions and changed slightly from
  ;; https://github.com/zmaas/evil-unimpaired

  (defun isamert/paste-above ()
    "Paste text above current line."
    (interactive)
    (evil-insert-newline-above)
    (evil-paste-after 1 evil-this-register))

  (defun isamert/paste-below ()
    "Paste text below current line."
    (interactive)
    (evil-insert-newline-below)
    (evil-paste-after 1 evil-this-register))

  (defun isamert/insert-space-above (count)
    "Insert COUNT newlines above current line."
    (interactive "p")
    (dotimes (_ count) (save-excursion (evil-insert-newline-above))))

  (defun isamert/insert-space-below (count)
    "Insert COUNT newlines below current line."
    (interactive "p")
    (dotimes (_ count) (save-excursion (evil-insert-newline-below))))
#+end_src
** evil-exchange
Change two parts of the text.
- Mark some text in visual mode and do =gx=.
- Mark some other text in visual mode and do =gx= again to exchange two parts.
- You can use ~gx<motion>~ instead of visual mode too.

#+begin_src emacs-lisp
  (use-package evil-exchange
    :ensure t
    :config
    (evil-exchange-install))
#+end_src
** goto-chg
- =g;= goes to the last change. (repeatable)
- There is also =gv= which selects the last selection. Not related to this package, it's a default functionality but I wanted to mention.

#+BEGIN_SRC emacs-lisp
  (use-package goto-chg
    :after evil
    :ensure t)
#+END_SRC

* org-mode
** org-plus-contrib
#+begin_src emacs-lisp
  (use-package org
    :ensure org-plus-contrib
    :config
    (setq org-src-fontify-natively t)
    ;; ^ Enable code highlighting in ~SRC~ blocks.
    (setq org-hierarchical-todo-statistics t)
    ;; ^ Show all children in todo statistics [1/5]
    (setq org-imenu-depth 7)
    ;; ^ include up to 7-depth headers in imenu search
    (setq org-image-actual-width nil)
    ;; ^ Disable showing inline images in full width. Now you can add `#+ATTR_*: :width 300` to resize inline images
    (setq org-ellipsis "⤵")
    ;; ^ Replace ... with ⤵ in collapsed sections
    (setq org-habit-show-habits-only-for-today t)
    ;; ^ If a TODO item has the ':STYLE: habit' property, then show it only on todays agenda, does not show recurring times.
    (setq org-log-into-drawer t)
    ;; ^ Log into LOGBOOK drawer instead of directly loging under the heading

    (add-to-list 'org-modules 'org-habit t)
    ;; ^ Enable habit tracking

    ;; http://www.foldl.me/2012/disabling-electric-indent-mode/
    (defun isamert/disable-electric-indent ()
      (set (make-local-variable 'electric-indent-functions)
           (list (lambda (arg) 'no-indent))))

    (add-hook 'org-mode-hook #'isamert/disable-electric-indent))
#+end_src

** Keybindings
#+begin_src emacs-lisp
  (evil-leader/set-key
    "oo"  #'org-open-at-point
    "op"  #'org-set-property
    "oi"  #'org-toggle-inline-images
    "or"  #'org-mode-restart
    "os"  #'org-schedule
    "oa"  #'org-agenda
    "on"  #'org-toggle-narrow-to-subtree
    "ow"  #'widen

    ;; link stuff
    "oyy" #'org-store-link
    "oyi" #'org-copy-id

    ;; org-clock
    "occ" #'org-clock-in
    "ocC" #'org-clock-cancel
    "ocl" #'org-clock-in-last
    "oco" #'org-clock-out
    "ocg" #'org-clock-goto

    "o#" #'org-insert-structure-template)

  (evil-define-key 'normal org-mode-map
    "[[" #'outline-previous-visible-heading
    "]]" #'org-next-visible-heading
    "[{" #'isamert/outline-up-heading-or-backward-same-level
    "]}" #'isamert/outline-up-level-then-forward
    "-"  #'org-cycle-list-bullet

    (kbd "H-h") 'org-shiftleft
    (kbd "H-j") 'org-shiftdown
    (kbd "H-k") 'org-shiftup
    (kbd "H-l") 'org-shiftright

    ;; Hyper for macos is C-M-s
    (kbd "C-M-s-h") 'org-shiftleft
    (kbd "C-M-s-j") 'org-shiftdown
    (kbd "C-M-s-k") 'org-shiftup
    (kbd "C-M-s-l") 'org-shiftright

    ;; FIXME: mac hyper already contains shift
    (kbd "M-H") 'org-shiftmetaleft
    (kbd "M-J") 'org-shiftmetadown
    (kbd "M-K") 'org-shiftmetaup
    (kbd "M-L") 'org-shiftmetaright

    ;; FIXME: M-h,j,k,l conflicts with split swithcing shourtcuts
    ;; so I just prefixed them with Hyper but this does not feel natural.
    ;; FIXME: find a solution for M-H-{h,j,k,l} in macOS
    (kbd "M-H-h") 'org-metaleft
    (kbd "M-H-j") 'org-metadown
    (kbd "M-H-k") 'org-metaup
    (kbd "M-H-l") 'org-metaright
  )

  (evil-leader/set-key-for-mode 'org-mode
    "d" 'org-babel-remove-result
    "D" 'isamert/org-babel-remove-all-results)

  (defun isamert/outline-up-level-then-forward ()
    "Up one level and then go to next header with same level."
    (interactive)
    (ignore-errors (outline-up-heading 1))
    (outline-forward-same-level 1))

  (defun isamert/outline-up-heading-or-backward-same-level ()
    "Go to one level up or go back same level."
    (interactive)
    (condition-case nil
        (outline-up-heading 1)
      (error (outline-backward-same-level 1))))
#+end_src

** Some vars
#+BEGIN_SRC emacs-lisp
  (when (file-directory-p "~/Documents/notes")
    (defconst life-org "~/Documents/notes/life.org")
    (defconst bullet-org "~/Documents/notes/bullet.org")
    (defconst reality-org "~/Documents/notes/reality.org")
    (defconst projects-org "~/Documents/notes/projects.org")
    (defconst people-org "~/Documents/notes/people.org")
    (defconst work-org "~/Documents/notes/trendyol.org")

    ;; Put archive files under an archive/ directory
    ;; I don't want them to pollute my directory
    (setq org-archive-location "archive/%s_archive::")
    (setq org-directory "~/Documents/notes"
          org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id
          ;; ^ org-store-link creates an ID for header only if called interactively and if there is no custom id
          org-agenda-files `(,life-org ,bullet-org ,projects-org ,reality-org ,work-org ,people-org))

    ;; With the following, I can call functions inside this file in other org files
    (org-babel-lob-ingest "~/Documents/notes/utils.org"))
#+END_SRC

** Auto indent subsections
Automatically invoke ~org-indent-mode~ which gives nice little indentation under subsections. It makes reading easier. This does not add any spaces/tabs to the text file, the indentation is only visually apparent in Emacs.

#+BEGIN_SRC emacs-lisp
  (add-hook
   'org-mode-hook
   (lambda ()
     (org-indent-mode t)
     (diminish 'org-indent-mode))
   t)
#+END_SRC

** Babel
#+begin_src emacs-lisp
  ;; Http request in org-mode babel.
  ;; You can get the generated curl command after executing the code
  ;; block, from *curl command history* buffer
  (use-package ob-http :ensure t)

  ;; Typescript
  (use-package ob-typescript :ensure t)

  ;; Allow these languages to run in code blocks
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (scheme . t)
     (python . t)
     (haskell . t)
     (js . t)
     (sql . t)
     (shell . t)
     (R . t)
     (typescript . t)
     (http . t)))

  ;; Don't ask permissions for evaluating code blocks
  (setq org-confirm-babel-evaluate nil)

  ;; Make certain files exacutable when tangled
  ;; Source: https://lists.gnu.org/archive/html/emacs-orgmode/2011-02/msg00465.html
  (defun isamert/make-tangled-files-executable ()
    (when (or (string-match-p  "\\.\\(sh\\|py\\)$" (buffer-file-name))
              (string-match-p  "\\(python\\|sh\\)$" (symbol-name major-mode)))
      (set-file-modes (buffer-file-name) #o755)))
  (add-hook 'org-babel-post-tangle-hook 'isamert/make-tangled-files-executable)

  (defun isamert/org-babel-tangle-current-block ()
    (interactive)
    (let ((current-prefix-arg '(16)))
    ;;     ^ '(4) only tangles current file, '(16) tangles all code
    ;;     blocks related to current tangle file target
      (call-interactively 'org-babel-tangle)))

  (evil-leader/set-key
    "ot" 'isamert/org-babel-tangle-current-block)
#+end_src

** Exporting
*** HTML
#+BEGIN_SRC emacs-lisp
(use-package htmlize :ensure t)
#+END_SRC

*** iCalendar settings
#+BEGIN_SRC emacs-lisp
(setq org-icalendar-store-UID t
      org-icalendar-alarm-time 15
      org-icalendar-use-scheduled '(todo-start event-if-todo)
      org-icalendar-use-deadline '(todo-due event-if-todo))
#+END_SRC

** Agenda
#+BEGIN_SRC emacs-lisp
  (when (fboundp 'life-org)
    (setq org-agenda-use-time-grid t
          org-agenda-time-grid '((today remove-match)
                                 (800 900 1000 1100 1200 1300 1400 1500 1600 1700 1800 1900 2000 2100 2200 2300 2400) "......" "----------------")))

    (evil-set-initial-state 'org-agenda-mode 'normal)
    (evil-define-key 'normal org-agenda-mode-map
      (kbd "<RET>") 'org-agenda-switch-to
      (kbd "\t") 'org-agenda-goto
      "s" 'org-agenda-schedule
      "w" 'org-agenda-week-view
      "d" 'org-agenda-day-view
      "t" 'org-agenda-todo
      "L" 'org-agenda-log-mode
      "q" 'org-agenda-quit
      "R" 'org-agenda-clockreport-mode
      "r" 'org-agenda-redo)
#+END_SRC

** ToDo keywords
#+BEGIN_SRC emacs-lisp
  ;; Add this to org files if you need:
  ;; #+TODO: TODO PROG WAITING DONE
  ;; OR
  (setq org-todo-keywords
    '((sequence "TODO(t)" "PROG(p)" "WAIT(w)" "DONE(d)")))
  ;; Now you can do C-c C-t {t,p,w,d} to set the state directly

  (setq org-todo-keyword-faces
        '(("WAIT" . (:foreground "yellow" :weight bold))
          ("PROG" . (:foreground "magenta" :weight bold :underline t))))

  (defun isamert/org-set-faces ()
    (set-face-attribute 'org-headline-done nil :strike-through t))

  (add-hook 'org-mode-hook #'isamert/org-set-faces)
#+END_SRC

** Presentation (org-tree-slide)
- =C->= → next heading
- =C-<= → prev heading

#+BEGIN_SRC emacs-lisp
  (use-package org-tree-slide
    :ensure t
    :config
    (add-hook 'org-tree-slide-mode-hook (lambda () (beacon-mode -1))))
#+END_SRC

** Fancy/pretty stuff
#+begin_src emacs-lisp
  (setq org-tags-column 0)
  ;; ^ This does not work well with combination of org-fancy-priorities and org-pretty tags, so I disable it
  ;; And it also makes sense to disable this because it restricts yyour heading char limit.

  ;; Make headings look better with nice bullets.
  ;; It also adjusts the size of headings according to their level.
  (use-package org-bullets
    :ensure t
    :hook (org-mode . org-bullets-mode))

  (use-package org-fancy-priorities
    :diminish
    :ensure t
    :hook (org-mode . org-fancy-priorities-mode)
    :config
    (setq org-fancy-priorities-list '("🅰" "🅱" "🅲" "🅳" "🅴")))

  ;; Pretty nice website to find unicode stuff: unicode-table.com
  (use-package org-pretty-tags
    :diminish org-pretty-tags-mode
    :ensure t
    :config
    (setq org-pretty-tags-surrogate-strings
          '(("work"  . "⚒")
            ("meeting" . "☎")
            ("side"  . "❄")
            ("learning" . "♢")
            ("must"  . "✠")
            ("rutin" . "♟")
            ("study" . "☣")))
    (org-pretty-tags-global-mode))


  (isamert/prettify-mode 'org-mode-hook
                         '(("[ ]" . "☐")
                           ("[X]" . "☑" )
                           ("[-]" . "❍" )
                           ("#+begin_src" . "»" )
                           ("#+end_src" . "«" )
                           ("#+BEGIN_SRC" . "»" )
                           ("#+END_SRC" . "«" )))
#+end_src

** org-clock
#+begin_src emacs-lisp
  ;; For Linux:
  (defun isamert/org-clock-today-all ()
    "Return todays all clocked hours."
    (with-current-buffer "bullet.org"
      (save-excursion
        (save-restriction
          (isamert/bullet-focus-today)
          (let ((range (org-clock-special-range 'untilnow)))
            (format
             "%s %s%s"
             (or (and (org-clocking-p) "") "")
             (org-minutes-to-clocksum-string (org-clock-sum (car range) (cadr range)))
             (or (and (org-clocking-p) (format " (%s)" (org-duration-from-minutes (org-clock-get-clocked-time)))) "")))))))

  ;; For macOS
  ;; https://github.com/koddo/org-clock-statusbar-app

  (defun isamert/org-clock-statusbar-clock-in ()
    (interactive)
    (if (eq system-type 'darwin)
        (call-process "/usr/bin/osascript" nil 0 nil "-e"
                      (concat "tell application \"org-clock-statusbar\" to clock in \""
                              (replace-regexp-in-string "\"" "\\\\\"" org-clock-current-task)
                              "\""))))

  (defun isamert/org-clock-statusbar-clock-out ()
    (interactive)
    (call-process "/usr/bin/osascript" nil 0 nil "-e"
                  "tell application \"org-clock-statusbar\" to clock out"))

  (when (eq system-type 'darwin)
    (add-hook 'org-clock-in-hook #'isamert/org-clock-statusbar-clock-in)
    (add-hook 'org-clock-out-hook #'isamert/org-clock-statusbar-clock-out))
#+end_src

** org-ql
#+BEGIN_SRC emacs-lisp
(use-package org-ql :ensure t)
#+END_SRC

** Inserting links and images from clipboard
Insert links/images more intelligently,
- if region is selected and there is a url in the clipboard, convert it to a link directly.
- if nothing is selected and there is a link in clipboard, just insert it as a link with the link's own title.
- if clipboard has in image in it, save that into a file that you interactively select and then insert it into the buffer.
- otherwise call ~org-insert-link~

#+begin_src emacs-lisp
  (evil-leader/set-key "oP" #'isamert/org-insert-dwim)

  (defun isamert/org-insert-dwim ()
    "Like `org-insert-link' but improved with dwim features.
      Based on: https://xenodium.com/emacs-dwim-do-what-i-mean/"
    (interactive)
    (let* ((point-in-link (org-in-regexp org-link-any-re 1))
           (clipboard-url (when (string-match-p "^http" (current-kill 0))
                            (current-kill 0)))
           (region-content (when (region-active-p)
                             (buffer-substring-no-properties (region-beginning)
                                                             (region-end)))))
      (cond
       ((isamert/has-clipboard-image)
        (call-interactively 'isamert/org-attach-image-from-clipboard))
       ((and region-content clipboard-url (not point-in-link))
        (delete-region (region-beginning) (region-end))
        (insert (org-make-link-string clipboard-url region-content)))
       ((and clipboard-url (not point-in-link))
        (insert (org-make-link-string
                 clipboard-url
                 (read-string "title: "
                              (with-current-buffer (url-retrieve-synchronously clipboard-url)
                                (dom-text (car
                                           (dom-by-tag (libxml-parse-html-region
                                                        (point-min)
                                                        (point-max))
                                                       'title))))))))
       (t
        (call-interactively 'org-insert-link)))))

  (defun isamert/clipboard-command ()
    "Get clipboard command for current system.
      The returned command directly puts the image data into stdout."
    (cond
     ((locate-file "xclip" exec-path) "xclip -selection clipboard -target image/png -out")
     ((locate-file "pngpaste" exec-path) "pngpaste -")))

  (defun isamert/org-attach-image-from-clipboard (&optional file-path)
    "Attach the image in the clipboard into your org-buffer.
      This function saves the image file into the FILE-PATH or
      if it's not provided then it saves the image into ~/.cache."
    (interactive "FSave file to (leave empty to create a temp file): ")
    (let ((file (if (and file-path (not (string-empty-p file-path)))
                    file-path
                  (make-temp-file "~/.cache/org_temp_image_" nil ".png"))))
      (if (shell-command (format "%s > %s" (isamert/clipboard-command) file))
          (insert (format "#+ATTR_ORG: :width 400\n[[file:%s]]" file))
        (user-error "Can't create image file from clipboard contents"))))

  (defun isamert/has-clipboard-image ()
    "Check whether the clipboard has image or not."
    (eq (shell-command (format "%s &>/dev/null" (isamert/clipboard-command))) 0))
#+end_src

* Other packages
** Hydra
Hydra creates a menu for quickly calling/toggling functions/modes in a visually easy way. My main use case for it right now is grouping bunch of appearance related functions/modes that I use infrequently. I believe for hydra's are not very useful for commands that you use frequently, it makes things slower than a plain keybinding but it's quite useful for the stuff that you forget or use infrequently.

#+begin_src emacs-lisp
   (use-package hydra
     :ensure t
     :config)

   (use-package use-package-hydra
     :after hydra
     :ensure t)

   (use-package pretty-hydra
     :after hydra
     :ensure t
     :config
     (pretty-hydra-define appearance
       (:foreign-keys warn :title "Appearance" :quit-key "q" :color amaranth)
       ("Display"
        (("W" writeroom-mode "Writeroom mode" :toggle t)
         ("n" display-line-numbers-mode "Line numbers" :toggle t)
         ("+" default-text-scale-increase "Zoom In")
         ("-" default-text-scale-decrease "Zoom Out"))
        "Highlighting"
        (("g" diff-hl-mode "Highlight git diff" :toggle t)
         ("d" rainbow-delimiters-mode "Rainbow parens" :toggle t)
         ("=" global-hl-line-mode "Highlight current line" :toggle t)
         ("b" beacon-mode "Cursor trailer (baecon)" :toggle t)
         ("w" isamert/whitespace-mode-toggle "Whitespaces"))
        "Miscellaneous"
        (("l" visual-line-mode "Wrap lines" :toggle t)
         ("i" highlight-indent-guides-mode "Indent Guides" :toggle t)
         ("f" fci-mode "Fill column" :toggle t)
         ("<SPC>" nil "Quit" :color blue))))

     (evil-leader/set-key
       "a" #'appearance/body))
#+end_src
** dired
It just doesn't feel like ranger, I still resort to it. This configuration just mimics ranger to a limited extend. If I need to do some complicated file-management, I just fire up ranger.

#+begin_src emacs-lisp
  (defun isamert/dired-up-directory ()
    "Like `dired-up-directory' but it does not create a new frame.
    Uses the existing one."
    (interactive)
    (find-alternate-file ".."))

  (setq dired-dwim-target t
        ls-lisp-dirs-first t
        ls-lisp-use-insert-directory-program nil)
  (put 'dired-find-alternate-file 'disabled nil)

  (evil-define-key 'normal dired-mode-map
    "h" 'isamert/dired-up-directory
    "l" 'dired-find-alternate-file
    "gg" 'evil-goto-first-line
    "G" 'evil-goto-line)
#+end_src
** image-mode
I want to be able to kill image buffers with simply hitting =q=. This does that.

#+begin_src emacs-lisp
  (evil-set-initial-state 'image-mode 'normal)
  (evil-define-key 'normal image-mode-map
    "q" #'evil-delete-buffer)
#+end_src

** tramp
#+begin_src emacs-lisp
  (setq tramp-default-method "ssh"
        tramp-verbose 2
        ;; ^ only show errors and warnings
        vc-handled-backends '(Git))
        ;; ^ only try to handle git, this speeds up things a little bit
#+end_src

** treemacs
#+BEGIN_SRC emacs-lisp
  (use-package treemacs
    :ensure t
    :defer t
    :config
    (setq treemacs-show-hidden-files nil
          treemacs-width 34
          treemacs-space-between-root-nodes nil
          treemacs-indentation 2)
    (add-to-list 'treemacs-ignored-file-predicates (lambda (filename abspath) (string-equal filename "node_modules")))

    (evil-define-key 'treemacs treemacs-mode-map
      ;; Treemacs has it's own mode, named treemacs.
      (kbd "M-f") 'treemacs
      (kbd "M-l") 'evil-window-right
      (kbd "\\") 'treemacs-visit-node-horizontal-split
      (kbd "-") 'treemacs-visit-node-vertical-split
      (kbd "W") 'treemacs-switch-workspace
      (kbd "E") 'treemacs-edit-workspaces
      (kbd "l") 'treemacs-TAB-action
      (kbd "h") 'treemacs-TAB-action
      (kbd "D") 'treemacs-delete
      (kbd "]]") 'treemacs-next-neighbour
      (kbd "[[") 'treemacs-previous-neighbour
      (kbd "]p") 'treemacs-next-project
      (kbd "[p") 'treemacs-previous-project
      (kbd "zm") 'treemacs-collapse-all-projects
      (kbd "za") 'treemacs-toggle-node)

    (evil-define-key 'normal 'global
      (kbd "M-f") #'treemacs))

  (use-package treemacs-evil
    :after treemacs evil
    :ensure t)

  (use-package treemacs-projectile
    :after treemacs projectile
    :ensure t)

  (use-package treemacs-icons-dired
    :after treemacs dired
    :ensure t
    :config (treemacs-icons-dired-mode -1))

  (use-package treemacs-magit
    :after treemacs magit
    :ensure t)

  (defun aorst/treemacs-setup-title ()
    (let ((bg (face-attribute 'default :background))
          (fg (face-attribute 'default :foreground)))
      (face-remap-add-relative 'header-line
                               :background bg :foreground fg
                               :box `(:line-width ,(/ (line-pixel-height) 2) :color ,bg)))
    (setq header-line-format
          '((:eval
             (let* ((text (treemacs-workspace->name (treemacs-current-workspace)))
                    (extra-align (+ (/ (length text) 2) 1))
                    (width (- (/ (window-width) 2) extra-align)))
               (concat (make-string width ?\s) text))))))
#+END_SRC

** winner-mode
This mode allows you to do /undo/ /redo/ operations on window layout changes. My most frequent use case is that sometimes I just want to focus on one window for a while and then return back to my old layout setup. These keybindings allows me to do that.

#+BEGIN_SRC emacs-lisp
  (setq winner-dont-bind-my-keys t)
  (winner-mode t)
  (evil-define-key 'normal 'global
    (kbd "C-w 1") 'delete-other-windows
    (kbd "C-w r") 'winner-redo
    (kbd "C-w u") 'winner-undo)
#+END_SRC

** ace-window
- =SPC ws= to swap windows.
- Some shortcuts, after doing =SPC ww=:
  - x - delete window
  - m - swap windows
  - M - move window
  - c - copy window
  - j - select buffer
  - n - select the previous window
  - u - select buffer in the other window
  - c - split window fairly, either vertically or horizontally
  - v - split window vertically
  - b - split window horizontally
  - o - maximize current window
  - ? - show these command bindings

#+begin_src emacs-lisp
  (use-package ace-window
    :ensure t
    :config
    (custom-set-faces
     '(aw-leading-char-face
       ((t (:foreground "deep sky blue" :bold t :height 3.0)))))
    (evil-leader/set-key "ww" #'ace-window)
    (evil-leader/set-key "ws" #'ace-swap-window))
#+end_src

** which-key
A package that shows key combinations. (for example press C-x and wait) It also works with ~evil-leader~, just press leader key and wait to see your options. I made a few adjustment so that it's more compact and you can see full function names (most of the time) and it shows up at the top center instead of bottom left corner. This mostly eliminates the need for creating a [[Hydra]].

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :diminish which-key-mode
    :config
    (setq which-key-min-display-lines 5)
    (setq which-key-max-display-columns 5)
    (setq which-key-max-description-length 70)
    (which-key-mode))

  (use-package which-key-posframe
    :ensure t
    :after (which-key mini-frame)
    :diminish
    :quelpa (which-key-posframe
             :fetcher github
             :repo "yanghaoxie/which-key-posframe")
    :config
    (set-face-attribute 'which-key-posframe nil :background "#373b43")
    (set-face-attribute 'which-key-posframe-border nil :background "#373b43")
    ;; Obtained the "#373b43" by calling `(mini-frame-get-background-color)'

    (setq which-key-posframe-border-width 12)
    (setq which-key-posframe-poshandler 'posframe-poshandler-frame-top-center)
    (which-key-posframe-mode))
#+END_SRC

** magit & forge
*** Installation
- Read this for some useful status mode keymaps: https://endlessparentheses.com/it-s-magit-and-you-re-the-magician.html
  - y :: Branch viewer (delete branches with ~k~)
  - ll :: Log current
  - bs :: Branch spin-off; create and checkout to a new branch, carry over the ongoing changes. It also undoes the changes in the current branch
  - bc :: Branch create; you can directly create new branch from *origin/develop* for instance

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :config
    ;; Following snippet is needed to update modeline after a checkout happens
    (defun isamert/vc-refresh-state-advice (a &optional b)
      "Refresh VC state after a checkout."
      (vc-refresh-state))
    (advice-add 'magit-checkout :after #'isamert/vc-refresh-state-advice)

    (isamert/define-key magit-status-mode-map
     "["  'magit-section-backward
     "]"  'magit-section-forward
     "("  'magit-section-backward-sibling
     ")"  'magit-section-forward-sibling
     "za" 'magit-section-toggle
     "zm" 'magit-section-show-level-1
     "zR" 'magit-section-show-level-4
     "zA" 'magit-section-toggle-children
     "j"  'next-line
     "k"  'previous-line
     "v"  'set-mark-command
     "V"  'set-mark-command
     "o"  'magit-diff-visit-file
     "K"  'magit-discard)

    (isamert/define-key magit-log-mode-map
     "["  'magit-section-backward
     "]"  'magit-section-forward
     "("  'magit-section-backward-sibling
     ")"  'magit-section-forward-sibling
     "za" 'magit-section-toggle
     "zm" 'magit-section-show-level-1
     "zR" 'magit-section-show-level-4
     "zA" 'magit-section-toggle-children
     "j"  'next-line
     "k"  'previous-line
     "v"  'set-mark-command
     "V"  'set-mark-command
     "o"  'magit-diff-visit-file
     "K"  'magit-discard)

    (evil-leader/set-key
      ;; magit/git
      "gs" 'magit-status
      "gf" 'magit-file-dispatch
      "gp" 'magit-pull
      "gP" 'magit-push
      "gr" 'magit-reset
      "gcc" 'magit-checkout
      "gcf" 'magit-file-checkout
      "gb" 'magit-branch))
#+END_SRC

*** magit-todos
Show TODO/FIXME etc in magit-status buffer.
#+BEGIN_SRC emacs-lisp
  (use-package magit-todos
    :ensure t
    :init (magit-todos-mode 1)
    :bind
    (:map magit-todos-section-map
      ("["  . 'magit-section-backward)
      ("]"  . 'magit-section-forward)
      ("("  . 'magit-section-backward-sibling)
      (")"  . 'magit-section-forward-sibling)
      ("za" . 'magit-section-toggle)
      ("zm" . 'magit-section-show-level-1)
      ("zR" . 'magit-section-show-level-4)
      ("zA" . 'magit-section-toggle-children)
      ("j"  . 'next-line)
      ("k"  . 'previous-line))
    (:map magit-todos-item-section-map
      ("j" . 'next-line)
      ("k" . 'previous-line)))
#+END_SRC

** perspective.el
Although I like eyebrowse, what I really want is to have isolated workspaces because buffer management just gets pretty complicated. I like to combine perspective.el and eyebrowse and I saw that spacemacs has a layer called layouts that does exactly what I want but I haven't had the time to figure it out and apply to my config.

#+BEGIN_SRC emacs-lisp
  (use-package perspective
    :ensure t
    :config
    (setq persp-state-default-file "~/.emacs.d/perspective-state")
    (setq persp-modestring-short t)
    ;; ^ By default the modestring is too long

    (evil-leader/set-key
      "ll" #'persp-switch-last
      "ls" #'persp-switch
      "lk" #'persp-kill
      "lS" #'persp-state-save
      "lL" #'persp-state-load
      "lr" #'persp-rename
      "li" #'isamert/initialize-perspectives
      "lm" #'isamert/persp-toggle-modestring)
    ;; Manually saving is probably a better idea
    ;; (add-hook 'kill-emacs-hook #'persp-state-save)
    (persp-mode t))

  (defun isamert/persp-toggle-modestring ()
    (interactive)
    (if persp-show-modestring
        (persp-turn-off-modestring)
      (persp-turn-on-modestring)))

  (defun isamert/initialize-perspectives ()
    "Open my default perspectives with some buffers in them."
    (interactive)
    (message ">> Perspectives are opening...")
    (progn
      (persp-new "dotfiles")
      (persp-switch "dotfiles")
      (find-file "~/Workspace/projects/dotfiles/README.org")
      (split-window-horizontally)
      (other-window 1)
      (find-file "~/Workspace/projects/dotfiles/emacs/README.org"))
    (progn
      (persp-new "planning")
      (persp-switch "planning")
      (find-file "~/Documents/notes/bullet.org")
      (isamert/bullet-focus-today)
      (split-window-horizontally)
      (other-window 1)
      (find-file "~/Documents/notes/life.org"))
    (progn
      (persp-new "notes")
      (persp-switch "notes")
      (find-file "~/Documents/notes/engineering.org"))
    (persp-switch "main")
    (message ">> Perspectives are opening... Done."))
#+END_SRC

** avy
avy is very similar to ~vim-easymotion~. It simply jumps to a visible text using a given char.
- =s= for jumping to beginning of a word
- =S= for jumping any part of the text
- =gl= for going into beginning of a line

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :config
    (setq avy-keys '(?q ?w ?e ?r ?t ?a ?s ?d ?f ?j ?k ?l ?u ?i ?o ?p)
          ;; ^ Only use these for jumping.
          avy-case-fold-search nil
          ;; ^ Case-sensetive (smart case) search
          avy-all-windows nil)
          ;; ^ Only do search in current window
    (evil-define-key 'normal 'global
      (kbd "S") 'avy-goto-char-2 ;; Go to any char
      (kbd "s") 'avy-goto-word-1 ;; Go to beginning of a word
      (kbd "gl") 'avy-goto-line))
#+END_SRC

** selectrum
A nice, fast minibuffer narrowing framework. It works well with quite a lot of package.
- =prescient.el= brings history and more intelligent filtering to selectrum.
- =marginalia.el= brings annotations to selectrum, ie. it adds current keybinding of a command, summary of command to M-x.
  - =C-M-a= cycles the detail level.
- =miniframe.el= shows all selectrum prompts in a nice mini popup frame.
- [[embark]]

Keybindings:
- =SPC hh= to repeat/open last selectrum window you closed.

Some shortcuts you can use on any selectrum window:
- =M-y= kill current candidates text. (=isamert/selectrum-kill-current-candidate=)
- =M-q= changes display style. (=selectrum-cycle-display-style=)
- =M-m= shows chars in each line (like [[avy]]), hitting on that chars selects the candidate. (=selectrum-quick-select=)
- =M-{n,p}= goes {back,forward} in minibuffer history.
- =TAB= inserts the current candidate (into minibuffer).
See =selectrum-minibuffer-map= for full list.

#+begin_src emacs-lisp
  (use-package selectrum
    :ensure t
    :config
    (setq selectrum-extend-current-candidate-highlight t)
    (define-key selectrum-minibuffer-map (kbd "M-y") #'isamert/selectrum-kill-current-candidate)
    (evil-leader/set-key "hh" #'selectrum-repeat)
    (selectrum-mode))

  (use-package selectrum-prescient
    :ensure t
    :after selectrum
    :config
    (prescient-persist-mode +1)
    (selectrum-prescient-mode +1))

  (use-package marginalia
    :ensure t
    :after selectrum
    :bind (:map minibuffer-local-map
                ("C-M-a" . marginalia-cycle))

    :init
    (marginalia-mode)
    ;; Refresh selectrum when `marginalia-cycle' is called.
    (advice-add
     #'marginalia-cycle
     :after
     (lambda ()
       (when (bound-and-true-p selectrum-mode)
         (selectrum-exhibit)))))

  (use-package mini-frame
    :ensure t
    :config
    (setq mini-frame-show-parameters
          '((top . 0.15)
            (width . 0.55)
            (left . 0.5))
          mini-frame-color-shift-step 15)
    (mini-frame-mode +1))

  (defun isamert/selectrum-kill-current-candidate ()
    "Kill current candidates text in selectrum minibuffer and close it."
    (interactive)
    (let ((candidate (selectrum-get-current-candidate))
          (prompt (minibuffer-prompt)))
      (kill-new
       (cond
        ((s-contains? "grep" prompt) (s-join ":" (-drop 2 (s-split ":" candidate))))
        ;; ^ Strip `filename:line-number:` from the text
        ((s-matches? "\\(Go to line\\|Switch to\\)" prompt) (substring candidate 1))
        ;; ^ `consult-line' and `consult-buffer' has an unrecognizable char at the beginning of every candidate, strip them
        (t candidate))))
    (keyboard-escape-quit))
#+end_src

** consult
Some key points:
- =SPC RET= brings up =consult-buffer=.
  - Typing =SPC {p,f,b,m}= narrows the list into {project files, files, buffers, bookmarks}.
  - Also see: [[id:90769b1b-7baf-4285-80f9-153ae07d73ab][Perspective integration for consult]]
- =M-y= brings up =consult-yank=, where you can select from clipboard history and paste.
- =C-f= does fuzzy search on current file lines.
- Do =M-,= on a candidate to preview it.
- Also don't forget to utilize =M-a= (=embark-act=) in consult windows.

#+begin_src emacs-lisp
  (use-package consult
    :ensure t
    :config
    (advice-add #'register-preview :override #'consult-register-window)

    (setq consult-preview-key (kbd "M-,"))
    ;; ^ When you do M-, on a candidate, it previews it

    (evil-leader/set-key
      "hy"  #'consult-yank
      "gg"  #'consult-git-grep
      "RET" #'consult-buffer)

    (evil-define-key 'normal 'global
      (kbd "M-i") 'consult-imenu
      (kbd "C-f") 'consult-line)

    <<consult-project-management>>
    <<consult-perspective-buffers>>
    <<consult-perspective-switch-buffers>>)
#+end_src

*** Project management
Some functionality for project management. I do some fine-tuning for =find= and =ripgrep= commands that consult uses.

#+name: consult-project-management
#+begin_src emacs-lisp :tangle no
  (evil-leader/set-key
    "hr"  #'isamert/consult-ripgrep-current-directory
    "pg" #'isamert/consult-ripgrep)

  (setq
   consult-find-command "fd --ignore-file '.git/' --hidden --full-path ARG OPTS"
   consult-ripgrep-command "rg --ignore-file '.git' --hidden --null --line-buffered --color=always --max-columns=500 --no-heading --smart-case --line-number . -e ARG OPTS"
   consult-project-root-function #'isamert/current-project-root)

  (defun isamert/consult-ripgrep (&optional path)
    "`consult-ripgrep' in current project.
  `consult-ripgrep' with `consult-project-root-function' shows full path of the
  file in the results.  I don't want that."
    (interactive)
    (consult-ripgrep (or path (isamert/current-project-root))))

  (defun isamert/consult-ripgrep-current-directory ()
    "Do ripgrep in `default-directory'."
    (interactive)
    (consult-ripgrep default-directory))
#+end_src

*** Perspective integration
:PROPERTIES:
:ID:       90769b1b-7baf-4285-80f9-153ae07d73ab
:END:
I use =(consult-buffer)= function for switching between buffers/files/marks etc. Here I add two sources for =(consult-buffer)=:
- One that only contains buffers for current perspective. This is quite useful for having a visual reference for current perspectives buffers.
- Another that adds list of my frequently used files. This is also handy in a way that =(consult-buffer)= becomes my go-to place for switching to anything.

#+name: consult-perspective-buffers
#+begin_src emacs-lisp
  (defvar isamert/consult-source-perspective-buffers
    `(:name     "Perspective buffers"
      :narrow   ?P
      :category buffer
      :face     consult-buffer
      :history  buffer-name-history
      :state    ,#'consult--buffer-state
      :default  t
      :items ,#'persp-current-buffer-names)
    "Current persp buffer candidate source for `consult-buffer'.")

  (defvar isamert/consult-source-files
    `(:name     "My files"
      :narrow   ?F
      :category file
      :face     consult-file
      :history  file-name-history
      :state    ,#'consult--file-state
      :default  t
      :items
      ,(lambda ()
         (let ((ht (consult--cached-buffer-file-hash)))
           (mapcar #'abbreviate-file-name
                   (seq-remove (lambda (x) (gethash x ht)) (isamert/my-files))))))
    "My frequently accessed files source for `consult-buffer'.")

  (setq
   consult-buffer-sources
   `(isamert/consult-source-perspective-buffers
     consult--source-buffer
     consult--source-file
     isamert/consult-source-files
     consult--source-bookmark
     consult--source-project-buffer
     consult--source-project-file))

  (defun isamert/my-files ()
    "Return list of all files I frequently use."
    (mapcar
     (lambda (file) (expand-file-name (concat org-directory "/" file)))
     (if (file-directory-p org-directory)
         (directory-files org-directory nil "^\\w+.*.org$")
       '())))
#+end_src

I also change =consult--buffer-display= function so that if I select a buffer from another perspective inside =(consult-buffers)=, I automatically jump into that perspective instead of pulling that buffer into the current perspective and messing things up.

#+name: consult-perspective-switch-buffers
#+begin_src emacs-lisp :tangle no
  (setq consult--buffer-display #'isamert/persp-switch-to-buffer)

  (defun isamert/persp-switch-to-buffer (buffer-or-name &optional norecord force-same-window)
    "Same as `persp-switch-to-buffer'"
    (ignore norecord force-same-window)
    (persp-switch-to-buffer buffer-or-name))
#+end_src

** embark
=embark.el= provides contextual command maps.
  - =M-a= activates command mode. Next key should be command. Do =C-h= to list all commands with their keybindings.
  - Commands are context specific, ie. the commands is based on if currently selected item is a file, folder, buffer etc.
  - It's mostly used within the minnibuffer, some example functions:
    - =M-a w= (~embark-save~) saves the current candidate's text into kill-ring. (Although I have another solution for this, =M-y=. See [[selectrum]])
    - =M-a i= (~embark-insert~) like the one above but instead of saving to the kill-ring, it directly inserts it to the buffer.
    - =M-a S= (~embark-collect-snapshot~) creates a buffer containing all the candidates.

#+begin_src emacs-lisp
  (use-package embark
    :ensure t
    :after selectrum
    :config
    (bind-key (kbd "M-a") #'embark-act)
    (setq embark-prompter #'embark-completing-read-prompter)
    ;; ^ This directly shows the actions in a completing read window.
    ;; By default, it is set to `embark-keymap-prompter' and you need to
    ;; hit `C-h' to bring this menu up.
    )

  (use-package embark-consult
    :ensure t
    :after (embark consult))
#+end_src

** ~project.el~ and project management
I was using projectile earlier but [[consult]] functions are just more than enough for project management. I only use couple of functions from =project.el= which is already built-in to Emacs.

#+begin_src emacs-lisp
  (defun isamert/current-project-root ()
    "Return the root path of current project."
    (interactive)
    ;; `project-current' is a function from project.el
    (cdr (project-current)))
#+end_src

I have all my projects under =~/Workspace/projects=. Some of them are groupped under another directory. This functions loops trough all of the directories and finds the ones without =.git= folder and adds those folders to project paths. Consider this:
#+begin_src
~/Workspace/projects
 ├── groupped_projects
 ├   ├── project3
 ├   └── project4
 ├── project1
 ├   └── .git
 └── project2
     └── .git
#+end_src

#+begin_src emacs-lisp
  (defconst isamert/projects-root "~/Workspace/projects")

  (defun isamert/project-paths ()
    "Find every project dir under `isamert/projects-root'.
  Every folder without a \".git\" folder is considered to be a project group folder."
    (append `(,isamert/projects-root)
            (-flatten (-map (lambda (dir) (if (file-directory-p (concat dir "/.git")) '() `(,dir)))
                            (directory-files isamert/projects-root t "^[^.]")))))

  (defun isamert/find-file-in (dir)
    "Find file in DIR.
  fd is already fast enough, no need for `consult-find's async approach."
    (interactive "D")
    (let ((default-directory dir))
      (->> (shell-command-to-string "fd .")
           (s-split "\n")
           (completing-read "Open file: ")
           (find-file))))

  (defun isamert/find-file-in-current-dir ()
    "Find file in current directory."
    (interactive)
    (isamert/find-file-in default-directory))

  (defun isamert/find-file-in-current-project ()
    "Find file in current project.
  If currently not in a project, switch to a project first and then
  find file."
    (interactive)
    (isamert/find-file-in
     (or (isamert/current-project-root) (isamert/switch-to-project))))

  (defun isamert/switch-to-project ()
    "List all projects found under `isamert/project-paths' and switch to selected."
    "Switch to project: "
    (->> (isamert/project-paths)
         (--map (shell-command-to-string (format "fd --exact-depth 1 --type d . %s" it)))
         (-reduce #'concat)
         (s-split "\n")
         (--map (s-replace (expand-file-name "~") "~" it))
         (completing-read "Switch to project: ")))

  (defun isamert/switch-to-project-and-find-file ()
    (interactive)
    (isamert/find-file-in (isamert/switch-to-project)))

  (defun isamert/switch-to-project-and-grep ()
    (interactive)
    (isamert/consult-ripgrep (isamert/switch-to-project)))

  (evil-leader/set-key
    "pp" #'isamert/switch-to-project-and-find-file
    "pP" #'isamert/switch-to-project-and-grep
    "pf" #'isamert/find-file-in-current-project
    "pF" #'consult-find
    "hf" #'isamert/find-file-in-current-dir)
#+end_src

** flycheck
- Use =ge= (=consult-flycheck=) to list and jump any of the errors/warnings in the buffer.
  - Write ~i SPC~, ~w SPC~, ~e SPC~ to show infos, warnings, errors only in the =consult-flycheck=

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :diminish
    :ensure t
    :init (global-flycheck-mode)
    :config
    (setq flycheck-idle-change-delay 1
          flycheck-check-syntax-automatically '(save new-line mode-enabled))
         ;; ^ Alternatives are (save idle-change new-line mode-enabled)

    (use-package consult-flycheck
      :ensure t)

    (evil-define-key 'normal flycheck-mode-map
      (kbd "ge") #'consult-flycheck
      (kbd "]e") #'flycheck-next-error
      (kbd "[e") #'flycheck-previous-error))
#+END_SRC

** company
An in-buffer completion framework. Works nicely with =lsp-mode= and bunch of other stuff.
- =company-box= :: Nice company front-end with icons and very nice documentation on hover thing.
- =company-fuzzy= :: Do fuzzy search in completion, instead of prefix or initials matching. Works quite well with every other backend.
  - Seems to make things slow tho
- =company-org-block= :: Triggers completion when '<' is typed. Also completes block arguments with ':'.

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :init
    :config
    (setq company-selection-wrap-around t)
    ;; ^ Return to first completion after the last one (cycles)
    (setq company-global-modes '(not erc-mode message-mode help-mode gud-mode eshell-mode shell-mode markdown-mode))
    ;; ^ Disable on some modes
    (setq company-minimum-prefix-length 1)
    ;; ^ Start completing after 1 char

    (define-key company-active-map (kbd "<tab>") nil)
    ;; ^ Disable tab key, so yasnippet and tab-out works nicely within company mode
    (evil-define-key 'insert 'global (kbd "C-SPC") 'company-complete)
    ;; ^ C-SPC force triggers company completion at point
    (define-key company-active-map (kbd "<return>") 'company-complete-selection)
    ;; ^ Enter simply applies the current selection

    (add-hook 'after-init-hook 'global-company-mode))

  (use-package company-box
    :ensure t
    :after company
    :hook (company-mode . company-box-mode))

  ;; (use-package company-fuzzy
  ;;   :ensure t
  ;;   :after company
  ;;   :config
  ;;   (setq company-require-match nil)
  ;;   ;; ^ Don't require match, so you can still move your cursor as expected.
  ;;   (setq company-tooltip-align-annotations t)
  ;;   ;; ^ Align annotation to the right side.
  ;;   (global-company-fuzzy-mode 1))


  (use-package company-org-block
    :ensure t
    :config
    (setq company-org-block-edit-style 'auto) ;; 'auto, 'prompt, or 'inline
    (add-hook 'org-mode-hook
              (lambda ()
                (add-to-list (make-local-variable 'company-backends)
                             'company-org-block))))
#+END_SRC

** origami-mode
This seems working better than =hs-minor-mode= and also it's supposedly works with =lsp-mode=.

#+BEGIN_SRC emacs-lisp
(use-package origami
  :ensure t
  :hook ((web-mode js-mode yaml-mode) . origami-mode))
#+END_SRC

** lsp-mode
- See: https://emacs-lsp.github.io/lsp-mode/tutorials/how-to-turn-off/

#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :commands lsp
    :hook ((web-mode . lsp)
           (js-mode . lsp)
           (typescript-mode . lsp)
           (dhall-mode . lsp)
           (haskell-mode . lsp)
           (rust-mode . lsp)
           (java-mode . lsp))
    :init
    (setq lsp-use-native-json t
          lsp-enable-xref t
          lsp-enable-links t
          lsp-enable-folding t
          lsp-enable-symbol-highlighting t
          lsp-enable-indentation nil
          lsp-enable-on-type-formatting nil
          lsp-before-save-edits nil
          lsp-eldoc-render-all nil
          lsp-headerline-breadcrumb-enable nil
          lsp-enable-snippet t)

    (evil-define-key 'normal lsp-mode-map
      "gr" 'lsp-ui-peek-find-references
      "gd" 'lsp-ui-peek-find-definitions
      "gi" 'lsp-ui-peek-find-implementation
      "ga" 'lsp-execute-code-action))

  ;; ^ Disable eldoc, popup documentation is enough.

  (use-package lsp-ui
    :ensure t
    :after (lsp-mode)
    :commands lsp-ui-mode
    :config
    (setq lsp-ui-sideline-show-code-actions nil))

  (use-package lsp-treemacs
    :ensure t
    :after (lsp-mode)
    :commands lsp-treemacs
    :config
    (lsp-treemacs-sync-mode 1))

  (use-package dap-mode
    :ensure t
    :after (lsp-mode)
    :config
    (dap-mode t)
    (dap-ui-mode t))
#+END_SRC

** vterm
Also check out =~/.zshrc= and =~/.config/zsh/emacs.sh=. These files contains some helpful commands that enriches ~vterm~ usage.

- Use =C-z= to go in/out (you can also use =jk= to go back into normal mode from emacs mode) emacs state so that you can make use of use vi-mode in zsh.

#+BEGIN_SRC emacs-lisp
  (defun evil-collection-vterm-escape-stay ()
    "Go back to normal state but don't move cursor backwards.
    Moving cursor backwards is the default vim behavior but
    it is not appropriate in some cases like terminals."
    (setq-local evil-move-cursor-back nil))

  (use-package vterm
    :ensure t
    :config
    (define-key vterm-mode-map (kbd "C-u") 'vterm-send-C-u)
    (evil-define-key 'insert vterm-mode-map
      (kbd "C-]") 'vterm-send-escape
      (kbd "C-w") 'vterm-send-C-w
      (kbd "C-t") 'vterm-send-C-t
      (kbd "C-c") 'vterm-send-C-c
      (kbd "C-r") 'vterm-send-C-r
      (kbd "M-\\") 'vterm-send-M-\\
      (kbd "M--") 'vterm-send-M--)
    (evil-define-key 'normal vterm-mode-map
      "p"  'vterm-yank
      "a"  'evil-emacs-state
      "i"  'evil-emacs-state)

    (evil-leader/set-key
      "tt" 'isamert/vterm-toggle-dedicated
      "tj" 'isamert/jump-to-visible-vterm
      "tl" 'isamert/run-last-command-on-visible-vterm
      "ty" 'isamert/send-selected-text-to-visible-vterm
      "tr" 'isamert/run-command-on-visible-vterm-with-history)
    (setq vterm-kill-buffer-on-exit t)
    (add-hook 'vterm-mode-hook #'evil-collection-vterm-escape-stay)
    (add-hook 'vterm-mode-hook #'evil-emacs-state))
#+END_SRC

*** Utility functions
#+begin_src emacs-lisp
  (defun vterm-send-M-\\ ()
    (interactive)
    (vterm-send-key "\\" nil t nil))

  (defun vterm-send-M-- ()
    (interactive)
    (vterm-send-key "-" nil t nil))

  ;; FIXME: only apply first found, dont use --map
  ;; FIXME: return true if window found
  (defun isamert/select-window-with-buffer (buffer-name)
    (--map (-as-> (window-buffer it) buffer
                  (buffer-name buffer)
                  (when (string-match buffer-name buffer)
                    (select-window it)))
           (window-list)))

  (defmacro isamert/with-visible-vterm-window (&rest body)
    `(with-selected-window (selected-window)
       (when (isamert/select-window-with-buffer ".*vterm.*")
         ,@body)))

  (defun isamert/run-command-on-visible-vterm (cmd)
    (isamert/with-visible-vterm-window
     (vterm-send-string cmd)
     (vterm-send-return)
     cmd))

  (defun isamert/send-selected-text-to-visible-vterm (start end)
    (interactive "r")
    (when (use-region-p)
      (isamert/run-command-on-visible-vterm (buffer-substring start end))))

  (defvar isamert/vterm-run-history '())
  (defvar isamert/jump-to-vterm-last-window nil)
  (defconst isamert/vterm-dedicated-buffer-name "*vterm-dedicated*")

  ;; FIXME: shackle does not work, it doesnt respect the 40
  (isamert/shackle-window isamert/vterm-dedicated-buffer-name 40)

  (defun isamert/vterm-toggle-dedicated ()
    "Open/toggle a dedicated vterm buffer."
    (interactive)
    (cond
     ((isamert/buffer-visible-p isamert/vterm-dedicated-buffer-name) (isamert/remove-window-with-buffer isamert/vterm-dedicated-buffer-name))
     ((get-buffer isamert/vterm-dedicated-buffer-name) (switch-to-buffer-other-window isamert/vterm-dedicated-buffer-name))
     (t (vterm isamert/vterm-dedicated-buffer-name))))

  (defun isamert/run-last-command-on-visible-vterm ()
    "Run last command on the currently visible vterm window and return back to current window."
    (interactive)
    (isamert/with-visible-vterm-window
     (vterm-send-up)
     (vterm-send-return)))

  (defun isamert/jump-to-visible-vterm ()
    "Jump to the visible vterm window.
  When invoked in a vterm window, return back to last window that this command is invoked from"
    (interactive)
    (cond
     ((string-match ".*vterm.*" (buffer-name (window-buffer (selected-window))))
      (select-window isamert/jump-to-vterm-last-window))
     (t
      (setq isamert/jump-to-vterm-last-window (selected-window))
      (isamert/select-window-with-buffer ".*vterm.*"))))

  (defun isamert/run-command-on-visible-vterm-with-history ()
    (interactive)
    (let ((cmd (isamert/run-command-on-visible-vterm
                (completing-read "Run new command" isamert/vterm-run-history))))
      (when cmd
        (setq isamert/vterm-run-history (cons cmd (delete cmd isamert/vterm-run-history))))))

  (defvar isamert/auto-focus-tmux-window t)
  (defvar isamert/tmux-session nil)
  (defun isamert/select-tmux-session ()
    "Select a tmux session for other tmux commands to use."
    (interactive)
    (->> (shell-command-to-string "tmux list-sessions")
      (s-split "\n")
      (--filter (not (s-blank? it)))
      (completing-read "TMUX session: ")
      (s-split ":")
      (car)
      (setq isamert/tmux-session)))

  (defun isamert/select-tmux-session-if-needed ()
    (interactive)
    (when (not isamert/tmux-session)
      (isamert/select-tmux-session)))

  (defun isamert/tmux-focus-perspective-window ()
    "Focus to the tmux window that has the same name with current perspective.
  Tmux session is infered from isamert/select-tmux-session"
    (interactive)
    (isamert/select-tmux-session-if-needed)
    (--> (persp-name (persp-curr))
         (format "tmux list-windows -t%s | grep %s" isamert/tmux-session it)
         (shell-command-to-string it)
         (car (split-string it ":"))
         (format "tmux select-window -t%s:%s" isamert/tmux-session it)
         (shell-command-to-string it)))

  (defun isamert/auto-focus-tmux-advice-after (old-function &rest arguments)
    (apply old-function arguments)
    (when isamert/auto-focus-tmux-window
      (isamert/tmux-focus-perspective-window)))

  (defun isamert/auto-focus-tmux-advice-before (old-function &rest arguments)
    (when isamert/auto-focus-tmux-window
      (isamert/tmux-focus-perspective-window))
    (apply old-function arguments))

  ;; Focus to perspectives tmux pane before
  (advice-add 'isamert/vterm-toggle-dedicated
              :around #'isamert/auto-focus-tmux-advice-after)
  (advice-add 'isamert/run-last-command-on-visible-vterm
              :around #'isamert/auto-focus-tmux-advice-before)
  (advice-add 'isamert/run-command-on-visible-vterm-with-history
              :around #'isamert/auto-focus-tmux-advice-before)
#+end_src

** moodline modeline
Light weight and nice modeline.

#+begin_src emacs-lisp
  (use-package mood-line
    :ensure t
    :diminish
    :quelpa (mood-line
             :fetcher gitlab
             :repo "jessieh/mood-line")
    :config (mood-line-mode))
#+end_src

** TODO mini-modeline
- Moves modeline to the minibuffer and disables modeline in all windows.
- FIXME: does not work with [[moodline modeline]]

#+begin_src
  (use-package mini-modeline
    :quelpa (mini-modeline :repo "kiennq/emacs-mini-modeline" :fetcher github)
    :after mood-line
    :config
    (setq mini-modeline-enhance-visual nil)
    ;; ^ Otherwise it breaks the color of completion menu popup.
    (setq mini-modeline-update-interval 0.5)
    ;; ^ Not sure
    (mini-modeline-mode t))
#+end_src
** howdoyou
When you search for something, it opens the results in an org-mode buffer. Results are fetched from SX (stack-exchange, stackoverflow etc) sites.
- =SPC hs= or =howdoyou-query= :: search function
- =C-M-Left= :: prev answer
- =C-M-Right= :: next answer

#+BEGIN_SRC emacs-lisp
  (use-package howdoyou
    :ensure t
    :config
    (setq howdoyou-switch-to-answer-buffer t
          howdoyou-number-of-answers 5)
    (evil-leader/set-key
      "hs" 'howdoyou-query))
#+END_SRC

** yasnippets and yankpad
I use yankpad to manage my snippets. [[./yankpad.org][The file]] has more information on that. =yasnippet= is used while expanding the snippets defined in =yankpad= so that I can utilize all the goodies =yasnippet= offers.

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :config
    (yas-global-mode))

  (use-package yankpad
    :ensure t
    :after yasnippet
    :config
    (setq yankpad-file (concat org-directory "/snippets.org"))
    (add-to-list 'hippie-expand-try-functions-list #'yankpad-expand)
    (evil-leader/set-key
      "sr" #'yankpad-reload
      "sc" #'yankpad-set-category
      "se" #'yankpad-edit
      "ss" #'yankpad-map
      "sm" #'yankpad-map)

    (evil-define-key 'insert 'global
      (kbd "M-s") #'yankpad-insert
      (kbd "M-e") #'yankpad-expand))
#+END_SRC

** git-link
#+begin_src emacs-lisp
  (use-package git-link
    :ensure
    :config
    (setq git-link-open-in-browser t)
    (evil-leader/set-key
      "gll" 'git-link
      "glh" 'git-link-homepage
      "glc" 'git-commit))

  (defun isamert/git-link-homepage ()
    "Like git-link-homepage itself but it does not open in browser, simply returns the address as string."
    (interactive)
    (let ((git-link-open-in-browser nil))
      (call-interactively 'git-link-homepage)
      (car kill-ring)))
#+end_src

** bufler
#+begin_src emacs-lisp
  (use-package bufler
    :ensure t
    :config
    (evil-define-key 'normal bufler-list-mode-map
      (kbd "K") 'bufler-list-buffer-kill
      (kbd "<return>") 'bufler-list-buffer-switch
      (kbd "q") 'quit-window
      (kbd "p") 'bufler-list-buffer-peek))
#+end_src

** tab-out
When you press tab, jump out from the current enclosing parens/quotes etc. When there is no enclosing stuff, TAB key automatically fallbacks to it's default behavior.

#+begin_src emacs-lisp
  (use-package tab-jump-out
    :ensure t
    :diminish
    :quelpa (tab-jump-out
             :fetcher github
             :repo "zhangkaiyulw/tab-jump-out")
    :config
    ;; This is not defined as a global minor mode, so define one and enable it
    (define-globalized-minor-mode global-tab-jump-out-mode tab-jump-out-mode
      (lambda ()
        (tab-jump-out-mode)
        (push "/" tab-jump-out-delimiters)
        (push "=" tab-jump-out-delimiters)))
    (global-tab-jump-out-mode 1))
#+end_src

** completing-read-xref
Provides an interface to xref based on completing-read. Works well with [[selectrum]].

#+begin_src emacs-lisp
  (use-package completing-read-xref
    :ensure t
    :diminish
    :quelpa (completing-read-xref
             :fetcher github
             :repo "travitch/completing-read-xref.el")
    :config
    (setq xref-show-definitions-function 'completing-read-xref-show-defs))
#+end_src
** helpful and elisp-demos
- helpful :: Better help dialogs with syntax highlighting, references, source etc.
- elisp-demos :: Adds code examples into function help buffers.
  - Code examples are maintained [[https://github.com/xuchunyang/elisp-demos/blob/master/elisp-demos.org][here]], don't forget to contribute!
  - Call ~elisp-demos-add-demo~ to add a demo locally.

#+begin_src emacs-lisp
  (use-package helpful
    :ensure t
    :config
    ;; Override default help bindings
    (global-set-key (kbd "C-h f") #'helpful-callable)
    (global-set-key (kbd "C-h v") #'helpful-variable)
    (global-set-key (kbd "C-h k") #'helpful-key)
    (global-set-key (kbd "C-h p") #'helpful-at-point)

    (evil-define-key 'normal helpful-mode-map
          "q" 'evil-delete-buffer))

  (use-package elisp-demos
    :ensure t
    :after helpful
    :config
    (advice-add 'helpful-update :after #'elisp-demos-advice-helpful-update))
#+end_src

** expand-region
#+begin_src emacs-lisp
  (use-package expand-region
    :ensure t
    :config
    (evil-define-key 'normal 'global
      (kbd "M-w") #'er/expand-region))
#+end_src
** xmodmap-mode
Simple mode for editing =~/.Xmodmap= file.
- [[https://www.emacswiki.org/emacs/XModMapMode][Source]]

#+begin_src emacs-lisp
  (define-generic-mode 'xmodmap-mode
    '(?!)
    '("add" "clear" "keycode" "keysym" "pointer" "remove")
    nil
    '("[xX]modmap\\(rc\\)?\\'")
    nil
    "Simple mode for xmodmap files.")
#+end_src
* Editing
** Breaking long texts/comments into multiple lines
I use =M-q= (=fill-paragraph=) to break long texts into multiple
lines. It also works well within comment sections. 80 col length is
quite readable. See how this item is formatted, it's done
automatically by the usage of =M-q=.

  #+begin_src emacs-lisp
    (setq fill-column 80)
  #+end_src

** Spell checking
- Use =flyspell-mode= to start spell checking.
- Use =ispell-change-dictonary= to change dictionaries.
- ~z=~ or ~zw~ to correct current spelling mistake.
  - ~C-u zw~ to correct all mistakes in order.

*** Configuration
See [[https://isamert.net/2021/01/31/emacs-te-turkce-imla-denetimi.html][this]] for rationale behind the following configuration.

#+BEGIN_SRC emacs-lisp
  (setq ispell-program-name "hunspell"
        ispell-local-dictionary "en_US"
        ispell-local-dictionary-alist
        '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)
          ("tr_TR" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "tr_TR") nil utf-8)))

  (add-hook 'org-mode-hook 'flyspell-mode)
  (add-hook 'markdown-mode-hook 'flyspell-mode)
#+END_SRC

*** flyspell-correct
Better way to correct spelling mistakes. By default it uses completing-read, so it's compatible with selectrum. This also makes it easy to save words into personal dictonary or silence warnings for session because it shows these options in the correction menu.
#+begin_src emacs-lisp
  (use-package flyspell-correct
    :ensure t
    :config
    ;; Rebind default evil ispell keys to flyspell-correct ones
    (evil-define-key 'normal 'global
      (kbd "z=") #'flyspell-correct-at-point
      (kbd "zw") #'flyspell-correct-wrapper))
      ;; ^ This goes to nearest spelling mistake.
      ;; If called with C-u, it goes into rapid mode where you correct all mistakes in order.
#+end_src

** string-inflection
- In the case of =string-inflection-ruby-style-cycle=   : ~emacs_lisp => EMACS_LISP => EmacsLisp => emacs_lisp~
- In the case of =string-inflection-python-style-cycle= : ~emacs_lisp => EMACS_LISP => EmacsLisp => emacs_lisp~
- In the case of =string-inflection-java-style-cycle=   : ~emacsLisp => EMACS_LISP => EmacsLisp => emacsLisp~
- In the case of =string-inflection-all-cycle=          : ~emacs_lisp => EMACS_LISP => EmacsLisp => emacsLisp => emacs-lisp => Emacs_Lisp => emacs_lisp~

#+begin_src emacs-lisp
  (use-package string-inflection
    :ensure t
    :config
    (evil-define-key 'normal 'global (kbd "M-c") #'string-inflection-all-cycle))
#+end_src

** smartparens
#+begin_src emacs-lisp
  (use-package smartparens
    :ensure t
    :config
    (require 'smartparens-config)
    (evil-define-key 'visual sp-keymap
      "S("  #'sp-wrap-round
      "S["  #'sp-wrap-square
      "S'"  #'sp-wrap-quote-single
      "S`"  #'sp-wrap-backtick
      "S<"  #'sp-wrap-angle
      "S\"" #'sp-wrap-quote-double
      "S="  #'sp-wrap-equal
      "S{"  #'sp-wrap-curly
      "S/"  #'sp-wrap-slash
      "S*"  #'sp-wrap-star
      "S+"  #'sp-wrap-plus
      "S#"  #'sp-wrap-star
      "S~"  #'sp-wrap-tilda)

    (sp-local-pair 'org-mode "=" "=" :actions :rem)

    (evil-define-key*
     '(normal insert) sp-keymap
     (kbd "M-[") #'sp-forward-barf-sexp
     (kbd "M-]") #'sp-forward-slurp-sexp
     (kbd "M-{") #'sp-backward-slurp-sexp
     (kbd "M-}") #'sp-backward-barf-sexp)

    (smartparens-global-mode))

  ;; TODO: do stuff like these
  (sp-with-modes '(php-mode)
    (sp-local-pair "/*." ".*/" :post-handlers '(("| " "SPC")))
    (sp-local-pair "{" nil :post-handlers '(("||\n[i]" "RET") my-php-wrap-handler))
    (sp-local-pair "(" nil :prefix "\\(\\sw\\|\\s_\\)*"))

  (defun sp-wrap-quote-double () (interactive) (sp-wrap-with-pair "\""))
  (defun sp-wrap-quote-single () (interactive) (sp-wrap-with-pair "'"))
  (defun sp-wrap-backtick () (interactive) (sp-wrap-with-pair "`"))
  (defun sp-wrap-angle () (interactive) (sp-wrap-with-pair "<"))
  (defun sp-wrap-equal () (interactive) (sp-wrap-with-pair "="))
  (defun sp-wrap-tilda () (interactive) (sp-wrap-with-pair "~"))
  (defun sp-wrap-slash () (interactive) (sp-wrap-with-pair "/"))
  (defun sp-wrap-star () (interactive) (sp-wrap-with-pair "*"))
  (defun sp-wrap-plus () (interactive) (sp-wrap-with-pair "+"))
#+end_src

** writeroom-mode
Gives you a nice, uncluttered editing experience by removing all unneeded visual clutter and by justifying the text in the middle.
- =SPC W= to enable it.

#+begin_src emacs-lisp
  (use-package writeroom-mode
    :ensure t
    :config
    (setq writeroom-width 150) ;; Better for org-mode
    (evil-leader/set-key
      "W" 'writeroom-mode))
#+end_src

* Dummy IDE mode
I try to use ~lsp-mode~ and other language-specific packages for the languages I use (see [[Language specific]]), but sometimes either they are too slow or the computer I'm currently working on requires some extra setup or I just don't want to use them for some reason. For those cases, I use a collection of packages that gives you the power of IDEs but in some dummy/restricted way.

- highlight-thing :: Automatically highlights the all instances of the symbol under the cursor in the buffer. Simply use evils ~*~ and ~#~ to jump between them.
- devdocs-lookup :: Opens the documentation of current thing in devdocs.io.
- dumb-jump :: Jumps to definition by using predefined-regexps, generally works fine. Use =gd=.
  - To debug why it's not working: M-x ~set-variable dumb-jump-debug t~, then go to *Messages* buffer.
- tree-sitter :: This is a generic parser for bunch of languages. You can also inspect the syntax tree on the fly and do whatever you want to do with it. Best feature so far is just better (like, miles ahead better) syntax highlighting for some languages. Especially for JS/TS and Rust. See [[https://ubolonton.github.io/emacs-tree-sitter/][this page]] for more information.
- hl-todo :: Highlight TODO/FIXME etc.
  - Use ~]t~ and ~[t~ to go next/prev TODO/FIXME item.

#+begin_src emacs-lisp
  (use-package dumb-jump
    :ensure t
    :config
    ;; https://github.com/jacktasia/dumb-jump/issues/376
    ;; (setq dumb-jump-prefer-searcher 'rg)
    (setq dumb-jump-force-searcher 'ag
          dumb-jump-ignore-context t
          dumb-jump-fallback-search nil)
    (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))

  (use-package devdocs-lookup
    :ensure t
    :diminish
    :quelpa (devdocs-lookup
             :fetcher github
             :repo "skeeto/devdocs-lookup")
    :config
    (devdocs-setup))

  (use-package highlight-thing
    :ensure t
    :after evil
    :config
    (setq-default evil-symbol-word-search t)
    ;; ^ highlight-thing highlights symbols, not words. # and * searches for
    ;; symbols if you set this to true, otherwise they search for words.

    (set-face-attribute 'highlight-thing nil :background "dark violet" :foreground "white")
    ;; ^ Default one with my theme makes some text quite unreadable

    (setq highlight-thing-prefer-active-region nil
          ;; ^ Don't highlight the selected text in visual mode
          highlight-thing-ignore-list '("False" "True" "->" "::" "defun" "def"))
    (add-hook 'prog-mode-hook 'highlight-thing-mode))

  (use-package tree-sitter
    :ensure t
    :config
    (global-tree-sitter-mode)
    (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode))

  (use-package tree-sitter-langs
    :after tree-sitter
    :ensure t)

  (use-package hl-todo
    :ensure t
    :hook (prog-mode . hl-todo-mode)
    :config
    (setq hl-todo-keyword-faces
          '(("TODO"   . "#FF0000")
            ("FIXME"  . "#FF0000")
            ("DEBUG"  . "#A020F0")
            ("GOTCHA" . "#FF4500")
            ("STUB"   . "#1E90FF")))

    (evil-define-key 'normal 'global
      (kbd "]t") #'hl-todo-next
      (kbd "[t") #'hl-todo-previous))
#+end_src

* Media/feed/IRC
I try to maximize my Emacs usage which brings it's own benefits and downsides which I will not go over here. Here are some packages and configurations that are not related to programming/editing.

** elfeed (RSS feeds)
#+begin_src emacs-lisp
  ;; TODO: experiment with custom faces
  ;; (defface elfeed-comic
  ;;   '((t :foreground "#BFF"))
  ;;   "Marks comics in Elfeed."
  ;;   :group 'elfeed)
  ;;
  ;; (push '(comic elfeed-comic)
  ;;       elfeed-search-face-alist)

  (defun isamert/elfeed-auto-tag-url (pairs)
    "Takes a list of url-regex and tag-list pairs and adds a new entry hook for each of them."
    (--map
     (add-hook 'elfeed-new-entry-hook
               (elfeed-make-tagger :feed-url (car it)
                                   :add (cdr it)))
     pairs))

  (defun isamert/elfeed-auto-tag-title (pairs)
    "Takes a list of title-regex and tag-list pairs and adds a new entry hook for each of them."
    (--map
     (add-hook 'elfeed-new-entry-hook
               (elfeed-make-tagger :entry-title (car it)
                                   :add (cdr it)))
     pairs))

  ;; https://github.com/skeeto/.emacs.d/blob/master/etc/feed-setup.el
  (defvar youtube-feed-format
    '(("^UC" . "https://www.youtube.com/feeds/videos.xml?channel_id=%s")
      ("^PL" . "https://www.youtube.com/feeds/videos.xml?playlist_id=%s")
      (""    . "https://www.youtube.com/feeds/videos.xml?user=%s")))

  (defun isamert/elfeed--expand (listing)
    "Expand feed URLs depending on their tags."
    (cl-destructuring-bind (url . tags) listing
      (cond
       ((member 'youtube tags)
        (let* ((case-fold-search nil)
               (test (lambda (s r) (string-match-p r s)))
               (format (cl-assoc url youtube-feed-format :test test)))
          (cons (format (cdr format) url) tags)))
       ((member 'reddit tags) (cons (format "https://www.reddit.com/r/%s/.rss" url) tags))
       (listing))))

  (use-package elfeed
    :ensure t
    :config
    ;; When adding tags, don't add any hierarchical tags like (blog blog-software), or (metal metal-black)
    ;; Just use something like: (blog software) and (metal black)

    (load "feeds")
    (setq elfeed-curl-extra-arguments '("--netrc"))
    (setq elfeed-feeds (mapcar #'isamert/elfeed--expand isamert/feeds))
    (isamert/elfeed-auto-tag-url '(("youtube\\.com" youtube)))
    (isamert/elfeed-auto-tag-title '(("youtube\\.com" youtube)
                                     ("c\\+\\+"  (programming c++))
                                     ("python"   (programming python))
                                     ("haskell"  (programming haskell))))


    ;; To apply hooks to all existing entries, use: elfeed-apply-hooks-now

    (evil-define-key 'normal elfeed-search-mode-map
      (kbd "RET") 'elfeed-search-show-entry
      (kbd "S-<return>") 'elfeed-search-browse-url
      "o" 'elfeed-search-browse-url
      "y" 'elfeed-search-yank

      ;; refresh
      "R" 'elfeed-search-fetch
      "r" 'elfeed-search-update--force

      ;; filter
      ;;   - examples:
      ;;     - +tag OR -tag (unread is also a tag)
      ;;     - #number-of-entries-limit (like #20)
      ;;     - !inverse-regex (!x?emacs will filter out titles containing x?emacs regex)
      ;;     - =regex (entries that contains the regex will be shown)
      ;;     - +unread +youtube =emacs #10 @5-months-ago
      "s" 'elfeed-search-live-filter
      "S" 'elfeed-search-set-filter

      "q" 'elfeed-search-quit-window)

    (evil-define-key '(normal visual) elfeed-search-mode-map
      "+" 'elfeed-search-tag-all
      "-" 'elfeed-search-untag-all
      "t" 'elfeed-search-tag-all
      "T" 'elfeed-search-untag-all
      "A" 'elfeed-search-tag-all-unread
      "a" 'elfeed-search-untag-all-unread
      "U" 'elfeed-search-tag-all-unread
      "u" 'elfeed-search-untag-all-unread)

    (evil-define-key 'normal elfeed-show-mode-map
      (kbd "S-<return>") 'elfeed-show-visit
      "go" 'elfeed-show-visit

      (kbd "<tab>") 'elfeed-show-next-link

      ;; filter
      "s" 'elfeed-show-new-live-search

      ;; +/- like the tag search syntax
      "+" 'elfeed-show-tag
      "-" 'elfeed-show-untag
      "t" 'elfeed-show-tag
      "T" 'elfeed-show-untag

      "]]" 'elfeed-show-next
      "[[" 'elfeed-show-prev
      "gj" 'elfeed-show-next
      "gk" 'elfeed-show-prev

      ;; refresh
      "gr" 'elfeed-show-refresh

      ;; quit
      "q" 'elfeed-kill-buffer))
#+end_src

** empv (music/media/radio/youtube management)
Manage media and streams through =completing-read=.

#+begin_src emacs-lisp
  (use-package empv
    :ensure t
    :diminish
    :quelpa (empv
             :fetcher github
             :repo "isamert/empv.el")
    :config
    (load "radio-channels")
    (setq empv-radio-channels isamert/radio-channels)
    (setq empv-base-directory "~/Music")
    (setq empv-invidious-instance "https://invidious.tube/api/v1" )
    ;; ^ alt: https://invidious.exonip.de/api/v1
    (add-to-list 'empv-mpv-args "--ytdl-format=best")
    (evil-leader/set-key
      "erp" #'empv-play
      "ert" #'empv-toggle
      "err" #'empv-play-radio
      "erR" #'empv-play-random-channel
      "erv" #'empv-toggle-video
      "ery" #'consult-empv-youtube
      "erk" #'empv-display-current
      "erl" #'isamert/empv-log-current-radio-song-name
      "era" #'empv-play-audio
      "erA" #'empv-play-audio-multiple
      "ers" #'empv-exit))

  (defun isamert/empv-log-current-radio-song-name ()
    "Log current radio song name to songs.org."
    (interactive)
    (empv--cmd
     'get_property 'metadata
     (when-let ((title (alist-get 'icy-title it)))
       (shell-command (format "echo '* %s' >> ~/Documents/notes/songs.org" title))
       (message "%s" title))))

  (defun isamert/export-radio-channels-as-m3u (file)
    "Export radio list into an M3U FILE."
    (interactive
     (list
      (read-file-name
       "Where to save the .vcf file?"
       "~/Documents/sync/"
       "radiolist.m3u")))
    (with-temp-file file
      (->> isamert/radio-channels
        (--map
         (format
          "#EXTINF:0, %s\n%s"
          (car it)
          ;; Replace http:// with icyx://, because VLC on Android can't
          ;; retrieve song name if the stream is on http://
          (if (s-contains? "radcap.ru" (car it))
              (s-replace "http://" "icyx://" (cdr it))
            (cdr it))))
        (--reduce (format "%s\n%s" acc it))
        (s-prepend "#EXTM3U\n")
        (insert))))
#+end_src

** orgmdb (movies & shows)
#+begin_src emacs-lisp
  (use-package orgmdb
    :ensure t
    :diminish
    :quelpa (orgmdb
             :fetcher github
             :repo "isamert/orgmdb.el")
    :config
    (setq orgmdb-omdb-apikey isamert/orgmdb-omdb-apikey))
#+end_src
** erc (IRC client)
IRC client for Emacs.

- Some shortcuts:
  - C-c C-b :: switch between channels
  - C-c C-j :: join channel

- TODO items:
  - Autologin
  - Autojoin channels
  - Notifications
  - Add registration notes here
  - Colors?

#+begin_src elisp
  (use-package erc
    :ensure t
    :config

    ;; More compact and cleaner look, nicks and messages are in seperate
    ;; column and total length for nicks are 15 cols
    (setq erc-fill-function 'erc-fill-static)
    (setq erc-fill-static-center 15)

    ;; The rest is from https://www.emacswiki.org/emacs/ErcNickColors
    ;; It's the Option 5

    (defmacro unpack-color (color red green blue &rest body)
      `(let ((,red   (car ,color))
             (,green (car (cdr ,color)))
             (,blue  (car (cdr (cdr ,color)))))
         ,@body))

    (defun rgb-to-html (color)
      (unpack-color color red green blue
                    (concat "#" (format "%02x%02x%02x" red green blue))))

    (defun hexcolor-luminance (color)
      (unpack-color color red green blue
                    (floor (+ (* 0.299 red) (* 0.587 green) (* 0.114 blue)))))

    (defun invert-color (color)
      (unpack-color color red green blue
                    `(,(- 255 red) ,(- 255 green) ,(- 255 blue))))

    (defun erc-get-color-for-nick (nick dark)
      (let* ((hash     (md5 (downcase nick)))
             (red      (mod (string-to-number (substring hash 0 10) 16) 256))
             (blue     (mod (string-to-number (substring hash 10 20) 16) 256))
             (green    (mod (string-to-number (substring hash 20 30) 16) 256))
             (color    `(,red ,green ,blue)))
        (rgb-to-html (if (if dark (< (hexcolor-luminance color) 85)
                           (> (hexcolor-luminance color) 170))
                         (invert-color color)
                       color))))

    (defun erc-highlight-nicknames ()
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward "\\w+" nil t)
          (let* ((bounds (bounds-of-thing-at-point 'symbol))
                 (nick   (buffer-substring-no-properties (car bounds) (cdr bounds))))
            (when (erc-get-server-user nick)
              (put-text-property
               (car bounds) (cdr bounds) 'face
               (cons 'foreground-color (erc-get-color-for-nick nick 't))))))))

    (add-hook 'erc-insert-modify-hook 'erc-highlight-nicknames))
#+end_src
* Keybindings
Keybindings are generally set in-place, following have no context, so they are here.

** macOS
#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    ;; I set the following in Linux using xmodmap but it's kinda
    ;; impossible to do it in OSX I guess.

    ;; I use an external keyboard, this makes AltGr and Meta (Alt) work as expected
    ;; I have also inverted Meta and Control keys system-wide or something, so
    ;; this setting is done according to that.
    (setq ns-option-modifier 'meta
          ns-right-alternate-modifier 'none)

    ;; (define-key key-translition-map ...) is better than (global-define-key ...)
    ;; because this just remaps key everywhere to given key so that the mappings
    ;; works in command mode, isearch etc.
    ;; AltGr + k -> Up
    ;; AltGr + j -> Down
    ;; AltGr + l -> Right
    ;; AltGr + h -> Left
    (define-key key-translation-map (kbd "˚") (kbd "<up>"))
    (define-key key-translation-map (kbd "∆") (kbd "<down>"))
    (define-key key-translation-map (kbd "¬") (kbd "<right>"))
    (define-key key-translation-map (kbd "˙") (kbd "<left>"))

    (define-key key-translation-map (kbd "") (kbd "S-<up>"))
    (define-key key-translation-map (kbd "Ô") (kbd "S-<down>"))
    (define-key key-translation-map (kbd "Ò") (kbd "S-<right>"))
    (define-key key-translation-map (kbd "Ó") (kbd "S-<left>"))

    ;; AltGr + [ -> (
    ;; AltGr + ] -> )
    (define-key key-translation-map (kbd "“") (kbd "("))
    (define-key key-translation-map (kbd "‘") (kbd ")")))
#+end_src

** Some general keybindings

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)

  (evil-define-key 'normal 'global
    (kbd "C-s") #'save-buffer)

  (evil-define-key 'normal prog-mode-map
    (kbd "M-;") 'comment-dwim
    "gd" 'xref-find-definitions
    "gr" 'xref-find-references)
#+END_SRC

** Better split management
- A-- splits below, A-\ splits right.
- A-h,j,k,l to switch between splits.
- A-H,J,K,L shrink, enlarge split.

#+BEGIN_SRC emacs-lisp
  (defun isamert/split-window-right-vterm ()
    (interactive)
    (split-window-right)
    (other-window 1)
    (vterm t))

  (defun isamert/split-window-below-vterm ()
    (interactive)
    (split-window-below)
    (other-window 1)
    (vterm t))

  (defun isamert/split-window-below ()
    (interactive)
    (split-window-below)
    (other-window 1))

  (defun isamert/split-window-right ()
    (interactive)
    (split-window-right)
    (other-window 1))

  (evil-define-key 'normal 'global
    (kbd "M-\\") 'isamert/split-window-right
    (kbd "M-|")  'isamert/split-window-right-vterm
    (kbd "M--")  'isamert/split-window-below
    (kbd "M-_")  'isamert/split-window-below-vterm
    (kbd "M-J")  'enlarge-window
    (kbd "M-K")  'shrink-window
    (kbd "M-L")  'enlarge-window-horizontally
    (kbd "M-H")  'shrink-window-horizontally)

  ;; This is needed to override other modes mappings
  (define-minor-mode movement-map-mode "Overrides all major and minor mode keys" t)

  (defvar movement-map (make-sparse-keymap "movement-map")
    "Override all major and minor mode keys")

  (evil-define-key '(normal motion emacs) movement-map
    (kbd "M-j") 'evil-window-down
    (kbd "M-k") 'evil-window-up
    (kbd "M-h") 'evil-window-left
    (kbd "M-l") 'evil-window-right)

  (evil-define-key 'normal treemacs-mode-map
    (kbd "M-j") 'evil-window-down
    (kbd "M-k") 'evil-window-up
    (kbd "M-h") 'evil-window-left
    (kbd "M-l") 'evil-window-right)

  (evil-make-intercept-map movement-map)

  (add-to-list
   'emulation-mode-map-alists
   `((movement-map-mode . ,movement-map)))
#+END_SRC

* Language specific
** markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :mode
  (("README\\.md\\'" . gfm-mode)
   ("\\.md\\'" . markdown-mode)
   ("\\.markdown\\'" . markdown-mode))
  :init
  (setq markdown-command "multimarkdown")
  :config
  (evil-define-key 'normal markdown-mode-map
    (kbd "TAB") 'markdown-cycle
    (kbd "]]") 'markdown-outline-next
    (kbd "[[") 'markdown-outline-previous))
#+END_SRC

** haskell
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :ensure t)

  (use-package lsp-haskell
    :ensure t
    :config
    (setq lsp-haskell-process-path-hie "ghcide"
          lsp-haskell-process-args-hie '()))

  (use-package ormolu
    :ensure t
    :hook (haskell-mode . ormolu-format-on-save-mode)
    :bind
    (:map haskell-mode-map
          ("C-c r" . ormolu-format-buffer)))
#+END_SRC

** rust
#+BEGIN_SRC emacs-lisp
(use-package rust-mode
  :ensure t
  :after (lsp-mode)
  (setq lsp-rust-server 'rust-analyzer
        lsp-rust-clippy-preference 'on))
;; (setq lsp-rust-server 'rls)
#+END_SRC

** javascript
*** Use ~eslint~ from ~node_modules~
#+BEGIN_SRC emacs-lisp
  (defun isamert/use-eslint-from-node-modules ()
    "Set the eslint exacutable to the one that is found in node_modules and enable flycheck with eslint as the checker."
    (interactive)
    (--> (or (buffer-file-name) default-directory)
         (locate-dominating-file it "node_modules")
         (expand-file-name "node_modules/.bin/eslint" it)
         (if (file-executable-p it)
             (progn
               (setq-local flycheck-javascript-eslint-executable it)
               (flycheck-mode t)
               (flycheck-select-checker 'javascript-eslint))
           (message "eslint not found."))))

  (add-hook 'js-mode-hook #'isamert/use-eslint-from-node-modules)
#+END_SRC

*** jsdoc.el
This is a package I wrote for inserting JSDoc comments easily. Check out the [[https://github.com/isamert/jsdoc.el][README]].

#+begin_src emacs-lisp
  (use-package jsdoc
    :ensure t
    :diminish
    :quelpa ((jsdoc
             :fetcher github
             :repo "isamert/jsdoc.el")))
#+end_src

*** subword-mode
The following enables =CamelCase= aware editing operations.
#+begin_src emacs-lisp
(add-hook 'js-mode-hook 'subword-mode)
#+end_src

** java
=lsp-java= automatically installs =eclipse.jdt.ls= to get lsp.
#+BEGIN_SRC emacs-lisp
(use-package lsp-java :ensure t :after lsp
  :config (add-hook 'java-mode-hook 'lsp))

(use-package dap-java :after (lsp-java))
#+END_SRC

** emmet-mode
Hit <C-j> after these and get:
- =a= ~<a href="|">|</a>~
- =.x= ~<div class="x"></div>~
- =br/= ~<br />~
- =p.x.y.z= ~<p className="x y z"></p>~ (Works well with JSX)
- ~input[type=text]~ ~<input type="text" name="" value=""/>~
- =a>b>c= ~<a href=""><b><c></c></b></a>~
- =b*3= ~<b></b><b></b><b></b>~
#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :ensure t
  :hook (js-mode css-mode sgml-mode web-mode)
  :init
  (setq emmet-expand-jsx-className? t
        emmet-self-closing-tag-style " /"))
#+END_SRC

** r
#+BEGIN_SRC emacs-lisp
(use-package ess :ensure t)
#+END_SRC

** kotlin
#+BEGIN_SRC emacs-lisp
(use-package kotlin-mode :ensure t)
#+END_SRC

** gradle/groovy
#+BEGIN_SRC emacs-lisp
(use-package groovy-mode
  :ensure t
  :config
  (add-to-list 'auto-mode-alist '("\\.gradle\\'" . groovy-mode)))
#+END_SRC

** yaml
#+begin_src emacs-lisp
(use-package yaml-mode :ensure t)
#+end_src

** typescript
#+begin_src emacs-lisp
  (use-package typescript-mode
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("\\.tsx\\'" . typescript-mode)))
#+end_src

** json
#+begin_src emacs-lisp
  (use-package json-mode
    :ensure t)

  (defun isamert/jsons-print-path-python ()
    (interactive)
    (let ((jsons-path-printer 'jsons-print-path-python))
      (jsons-print-path)))

  (defun isamert/jsons-print-path-javascript-js-jq ()
    (interactive)
    (let ((jsons-path-printer 'jsons-print-path-jq))
      (jsons-print-path)))

  ;;  Provides jsons-print-path function, it simply kills the path to the key under point
  (use-package json-snatcher
    :ensure t
    :config
    ;; Copies paths like:.definition.summary.pastGroup.trackingResults[0].trackingItemReferenceId
    ;; I've created two functions above for the variations
    (setq jsons-path-printer 'jsons-print-path-jq))
#+end_src

** elisp
#+begin_src emacs-lisp
  (isamert/prettify-mode 'emacs-lisp-mode-hook
                         '((">="     . ?≥)
                           ("<="     . ?≤)
                           ("defun"  . ?ƒ)
                           ("lambda" . ?λ)))
#+end_src

** dhall
#+begin_src emacs-lisp
  (use-package dhall-mode
    :ensure t
    :diminish dhall-format-on-save-mode
    :mode "\\.dhall\\'"
    :config
    ;; I use dhall-lsp-server, so I don't need this
    (setq dhall-use-header-line nil))
#+end_src

** nix
#+begin_src emacs-lisp
  (use-package nix-mode
    :ensure t
    :mode "\\.nix\\'")

  (defun isamert/import-env-from-nix-shell ()
    (interactive)
    (let ((default-directory (isamert/current-project-root)))
      (when (not (and (file-exists-p "shell.nix") (executable-find "nix-shell")))
        (error "Failed to find shell.nix or nix-shell"))
      (--> (shell-command-to-string "nix-shell --quiet --run 'env'")
        (split-string it "\n")
        (--map (-let (((name val) (s-split-up-to "=" it 1)))
                 (setenv name val)
                 (when (string-equal name "PATH")
                   (setq exec-path (split-string val path-separator)))
                 `(,name ,val))
               it))
      (message "Done.")))
#+end_src

** swift
#+begin_src emacs-lisp
  (use-package swift-mode
    :ensure t)
#+end_src

** scheme
#+begin_src emacs-lisp
  ;; Scheme
  (use-package geiser
    :ensure t
    :config
    (setq geiser-default-implementation 'guile))

  (use-package geiser-guile
    :after geiser
    :ensure t)
#+end_src

** Docker stuff
#+begin_src emacs-lisp
  (use-package dockerfile-mode
    :ensure t
    :mode "Dockerfile\\'")
  (use-package docker-compose-mode
    :ensure t
    :mode "docker-compose\\'")
#+end_src
* Misc functions
** My Android phone and Emacs
I have an Android phone that is running [[https://termux.com/][Termux]] all the time. If you install Termux through [[https://www.f-droid.org/][F-Droid]] you can also install [[https://f-droid.org/en/packages/com.termux.api/][Termux:API]] package which brings bunch of commands like =termux-clipboard-set=, =termux-sms-list= etc. Much of the commands requires to be called in foreground, so they are not very useful over SSH but you can work around that by starting a =tmux= session on the phone and executing commands on that tmux session through SSH. This way I can send arbitrary text to my phones clipboard using the commands below.

#+begin_src emacs-lisp
  (defvar isamert/phone-hostname
    "mia3"
    "Hostname or local address to connect to my phone by SSH.")

  (defun company/send-text-to-my-phone (text)
    "Send TEXT to my phones clipboard."
    (interactive "sText: ")
    (shell-command-to-string (format "ssh %s \"tmux pipe-pane -t0 'echo \\\"%s\\\" | termux-clipboard-set'\"" isamert/phone-hostname text)))

  (defun company/send-clipboard-to-my-phone ()
    "Send current clipboard content to my phones clipboard."
    (interactive)
    (company/send-text-to-my-phone (current-kill 0)))
#+end_src

** people.org - Contact management
Please see [[https://isamert.net/2021/04/21/managing-your-contacts-in-org-mode-and-syncing-them-to-your-phone-android-ios-whatever-.html][this post]] for further information.

#+begin_src emacs-lisp
  (defun isamert/build-contact-item (template-string contact-property)
    (if-let ((stuff (org-entry-get nil contact-property)))
        (concat (format template-string stuff) "\n")
      ""))

  (defun isamert/export-contacts-as-vcard (file-name)
    "Create a .vcf file containing all contact information."
    (interactive
     (list
      (read-file-name
       "Where to save the .vcf file?"
       "~/Documents/sync/"
       "contacts.vcf")))
    (write-region
     (string-join
      (org-map-entries
       (lambda ()
         (string-join
          `("BEGIN:VCARD\nVERSION:2.1\n"
            ,(isamert/build-contact-item "FN:%s" "ITEM")
            ,(isamert/build-contact-item "TEL;CELL:%s" "PHONE")
            ,(isamert/build-contact-item "EMAIL:%s" "EMAIL")
            ,(isamert/build-contact-item "ORG:%s" "GROUP")
            ,(isamert/build-contact-item "ADR;HOME:;;%s" "ADDRESS_HOME")
            ,(isamert/build-contact-item "ADR;WORK:;;%s" "ADDRESS_WORK")
            ,(format "REV:%s\n" (format-time-string "%Y-%m-%dT%T"))
            "END:VCARD")
          ""))
       "LEVEL=1")
      "\n")
     nil
     file-name))
#+end_src
** Google search
#+begin_src emacs-lisp
  (defun isamert/google-this ()
    "Search selected region or current word in Google. Let's you edit the query beforehand."
    (interactive)
    (browse-url
     (format
      "https://google.com/search?q=%s"
      (read-string
       "Googling: "
       (isamert/region-or 'word)))))

  (evil-leader/set-key
    "/g"   'isamert/google-this)
#+end_src

** Google translate
#+begin_src emacs-lisp
  (defun isamert/google-translate-this (from to)
    "Translate selected region or current word from FROM to TO.
  Let's you edit the query beforehand.  Result is printed into minibuffer.
  You need to install `translate-shell' to make this work."
    (interactive
     `(,(read-string "From: " "en") ,(read-string "To: " "tr")))
    (message
     (shell-command-to-string
      (format
       "trans %s:%s \"%s\""
       from to
       (read-string
        "Translating: "
        (isamert/region-or 'word))))))

  (defun isamert/google-translate-this-en-to-tr ()
    (interactive)
    (isamert/google-translate-this "en" "tr"))

  (defun isamert/google-translate-this-tr-to-en ()
    (interactive)
    (isamert/google-translate-this "tr" "en"))

  (evil-leader/set-key
    "/tt"   'isamert/google-translate-this-en-to-tr
    "/te"   'isamert/google-translate-this-tr-to-en)
#+end_src

** TODO org-mode enhancements
I need to rewrite these functions using [[https://github.com/isamert/marks][marks]] for both speed and accuracy.

#+begin_src emacs-lisp
  ;; Keybindings

  (evil-leader/set-key
    "ol" 'isamert/org-link-header
    ;; TODO: rewrite this:
    ;;"oL" 'isamert/org-backlinks
  )

  ;;
  ;; Utility
  ;;

  (defun isamert/org-header-line-to-title (line)
    "Remove TODO/*/unnecessary whitespace from given LINE.
  Then return the title of given `org-mode` header.
  Just like (org-entry-get nil \"ITEM\") but works on given string."
    (->> line
      (s-replace-regexp "\\(\\*\\|TODO\\|PROG\\|DONE\\|WAIT\\)" "") ;; Remove TODO states
      (s-replace-regexp "\\(\\[#.\\{1\\}\\]\\\)" "") ;; Remove priorities
      (s-replace-regexp ":\\(\\w+:\\)+$"  "") ;; Remove tags
      (replace-regexp-in-string "\\[\\[.*\\]\\[\\(.*\\)\\]\\]"  "\\1") ;; Fix links
      (replace-regexp-in-string "\\[\\[\\(.*\\)\\]\\]"  "\\1") ;; Fix links
      (s-trim)))

  (defun isamert/org-file-get-header-id (file-path header-line)
    "Return the id of given header at HEADER-LINE in FILE-PATH."
    (interactive)
    (save-excursion
      (with-current-buffer (let ((enable-local-variables nil)) (find-file-noselect file-path))
        (goto-char 0)
        (forward-line header-line)
        (org-id-get nil 'create)
        (save-buffer)
        (org-id-get nil 'create))))

  (defun isamert/org-all-headers ()
    "Return all headers in `org-directory'."
    (->> (concat "cd " org-directory "; "
                 "rg"
                 " --no-heading" " --with-filename"
                 " --line-number" " -t org"
                 " " "\"^\\*+ \" ")
      (shell-command-to-string)
      (s-split "\n")
      (--filter (not (s-blank? it)))
      (--map
       (-let* (((fname line . content) (split-string it ":"))
               (header (isamert/org-header-line-to-title (string-join content ":"))))
         `(,(format
             "%s:%s %s %s"
             (propertize fname 'face '(:foreground "plum"  :slant italic))
             (propertize line 'face '(:slant italic :weight thin))
             (propertize "»" 'face '(:foreground "green"))
             (propertize header 'face '(:foreground "sky blue" :weight bold)))
           .
           (:fname ,fname :line ,(1- (string-to-number line)) :header ,header))))))

  (defun isamert/org-link-header ()
    "Interactively select a header and insert it as a link into the buffer.
  Headers are gathered from all the org files found in `org-directory'."
    (interactive)
    (let* ((headers (isamert/org-all-headers))
           (selected (cdr (assoc-string (completing-read "Select header:" headers) headers)))
           (link-name (read-string "Enter link text: " (plist-get selected :header)))
           (header-id (isamert/org-file-get-header-id (plist-get selected :fname) (plist-get selected :line)))
           (selected-link (concat "[[id:" header-id "][" link-name "]]")))
      (insert selected-link)))

  ;; TODO Removed backlinks implementation, I will implement it once
  ;; minimal functionality within "marks" is done
#+end_src

** bullet.org
I have a ~bullet.org~ file that I keep my daily journal and here are some utility functions that use with it. I may document this later (or even publish it as a package?)

#+begin_src emacs-lisp
  ;; Keybindings

  (evil-leader/set-key
    "obb" 'isamert/bullet-focus-non-day-header
    "oby" 'isamert/bullet-focus-yesterday
    "obt" 'isamert/bullet-focus-today
    "obf" 'isamert/bullet-focus-given-day
    "obr" 'isamert/bullet-focus-recurring)

  ;;
  ;; Date utils
  ;;

  (defun isamert/today ()
    "Get todays date in format YYYY-MM-DD Day."
    (format-time-string "%Y-%m-%d %a"))

  (defun isamert/u ()
    "Get day of week as number."
    (string-to-number (format-time-string "%u")))

  (defun isamert/date (date)
    "Display the time described by DATE.
  DATE can be 'now', 'yesterday', 'two days ago' etc."
    (s-trim-right
     (shell-command-to-string
      (concat (locate-file "date" exec-path) " --date='" date "' +'%Y-%m-%d %a'"))))

  ;;
  ;; Create utils
  ;;

  (defun isamert/bullet-create-a-day (date)
    "Create given DATE heading in bullet.org in the appropriate place..
  DATE should be in the form of YYYY-MM-DD."
    (when-let ((point (isamert/bullet-find-a-day date)))
      (goto-char point)
      (user-error "The day already exists"))
    (widen)
    (goto-char (point-max))
    (loop
     (when (not (re-search-backward "^* \\[\\([0-9]+-[0-9]+-[0-9]+\\)\\( \\w+\\)?\\].*" nil t))
       (return))
     (when (time-less-p
            (date-to-time (concat (match-string 1) "T000"))
            (date-to-time (concat date "T000")))
       (org-insert-heading-after-current)
       (insert (format "[%s %s] [/]" date (format-time-string "%a")))
       (org-narrow-to-subtree)
       (return))))

  ;;
  ;; Focus a day
  ;;

  (defun isamert/bullet-find-a-day (day)
    (save-excursion
      (widen)
      (goto-char (point-max))
      (when (re-search-backward (concat "^* \\[" day "\\( \\w+\\)?\\]") nil t)
        (point-marker))))

  (defun isamert/bullet-focus-a-day (day)
    "Focus to given DAY."
    (widen)
    (when-let ((day-entry (isamert/bullet-find-a-day day)))
      (goto-char day-entry)
      (beginning-of-line)
      (org-narrow-to-subtree)
      t))

  (defun isamert/bullet-focus-given-day (date)
    "Focus given DATE's header.
  If it does not exists, create it."
    (interactive
     (list (org-read-date)))
    (when (not (isamert/bullet-focus-a-day date))
      (isamert/bullet-create-a-day date)))

  (defun isamert/bullet-focus-today ()
    "Focus todays header.
  If it does not exists, create it."
    (interactive)
    (let ((today (format-time-string "%Y-%m-%d")))
      (when (not (isamert/bullet-focus-a-day today))
        (isamert/bullet-create-a-day today))))

  (defun isamert/bullet-focus-yesterday ()
    "Focus yesterdays header."
    (interactive)
    (isamert/bullet-focus-a-day (isamert/date "yesterday")))

  ;;
  ;; Focus non-day
  ;;

  (defun isamert/bullet-get-all-non-day-headers ()
    "Return all non-day header names.
  This function assumes all the non-day headers are at the top."
    (save-excursion
      (save-match-data
        (let ((headers '()))
          (widen)
          (goto-char 0)
          (loop
           (when (not (re-search-forward "^* \\(.*\\)" nil t))
             (return))
           (if (s-prefix? "[" (match-string 1))
               (return)
             (push (match-string 1) headers)))
          headers))))

  (defun isamert/bullet-focus-non-day-header (text)
    "Interactively select and focus a non-day header."
    (interactive
     (thread-last (isamert/bullet-get-all-non-day-headers)
       (completing-read "Select header: ")
       (list)))
    (widen)
    (goto-char (org-find-exact-headline-in-buffer text))
    (org-narrow-to-subtree))
#+end_src

** Scratch/temporary buffers in side windows
Here I define two important functions and their helpers.  The following functions are pretty useful for quick note taking or evaluating elisp. Having these buffers in a side window makes them immune to some window commands which is what I want.

- isamert/display-side-scratch-buffer :: This one opens (or closes if it's open) the *scratch* buffer in a side window, on the right. This is nice for quickly evaluating elisp, taking elisp related notes.
- isamert/display-side-temp-org-buffer :: This one opens (or closes if it's open) the ~temp.org~ file in a in a side window, on the right. This is nice for taking some quick notes, writing some temporary todos etc.

#+begin_src emacs-lisp
  (defun isamert/buffer-visible-p (buffer)
   "Check if given BUFFER is visible or not.  BUFFER is a string representing the buffer name."
    (or (eq buffer (window-buffer (selected-window))) (get-buffer-window buffer)))

  (defun isamert/display-buffer-in-side-window (buffer)
    "Just like `display-buffer-in-side-window` but only takes a BUFFER and rest of the parameters are for my taste."
    (set-window-dedicated-p
     ;; ^ Setting this to nil so that `pop-to-buffer-same-window' calls works in this window
     ;;   otherwise it'll set `window-dedicated-p' to `side' and this will cause `pop-to-buffer-same-window'
     ;;   to open stuff in another window.
     (select-window
      (display-buffer-in-side-window
       buffer
       (list (cons 'side 'right)
             (cons 'slot 0)
             (cons 'window-width 84)
             (cons 'window-parameters (list (cons 'no-delete-other-windows t)
                                            (cons 'no-other-window nil))))))
     nil))

  (defun isamert/remove-window-with-buffer (the-buffer-name)
    "Remove window containing given THE-BUFFER-NAME."
    (mapc (lambda (window)
            (when (string-equal (buffer-name (window-buffer window)) the-buffer-name)
              (delete-window window)))
          (window-list (selected-frame))))

  (defun isamert/toggle-side-buffer-with-file (file-path)
    "Toggle FILE-PATH in a side buffer. The buffer is opened in side window so it can't be accidentaly removed."
    (interactive)
    (let ((fname (file-name-nondirectory file-path)))
    (if (isamert/buffer-visible-p fname)
        (isamert/remove-window-with-buffer fname)
      (isamert/display-buffer-in-side-window
       (save-window-excursion
         (find-file file-path)
         (current-buffer))))))

  (defun isamert/toggle-side-scratch-buffer ()
    "Toggle the scratch buffer in side window.  The buffer is opened in side window so it can't be accidentaly removed."
    (interactive)
    (if (isamert/buffer-visible-p "*scratch*")
        (isamert/remove-window-with-buffer "*scratch*")
      (isamert/display-buffer-in-side-window (get-buffer "*scratch*"))))

  (defun isamert/toggle-side-temp-org-buffer ()
    "Toggle `temp.org` in a side buffer for quick note taking.  The buffer is opened in side window so it can't be accidentaly removed."
    (interactive)
    (isamert/toggle-side-buffer-with-file "~/Documents/notes/temp.org"))

  (defun isamert/toggle-side-bullet-org-buffer ()
    "Toggle `bullet.org` in a side buffer for quick note taking.  The buffer is opened in side window so it can't be accidentaly removed."
    (interactive)
    (isamert/toggle-side-buffer-with-file "~/Documents/notes/bullet.org"))

  (defun isamert/toggle-side-projects-buffer ()
    "Toggle `projects.org` in a side buffer for quick note taking.  The buffer is opened in side window so it can't be accidentaly removed."
    (interactive)
    (isamert/toggle-side-buffer-with-file "~/Documents/notes/projects.org"))

    ;; Toggle temproary buffers
    (evil-leader/set-key
      "ts" 'isamert/toggle-side-scratch-buffer
      "to" 'isamert/toggle-side-temp-org-buffer
      "th" 'isamert/toggle-side-bullet-org-buffer
      "tp" 'isamert/toggle-side-projects-buffer
      "tf" 'treemacs)
#+end_src

** org-babel extension functions
#+BEGIN_SRC emacs-lisp
  (defun isamert/org-babel-remove-all-results nil
    (interactive)
    (goto-char 1)
    (let ((total-removed 0))
      (while (org-babel-next-src-block)
        (when (org-babel-remove-result)
          (setq total-removed (+ total-removed 1))))
      (message (format "%d result blocks are removed." total-removed))))
#+END_SRC

** Functions for easy indentation switching
- http://blog.binchen.org/posts/easy-indentation-setup-in-emacs-for-web-development.html

#+BEGIN_SRC emacs-lisp
(defun isamert/setup-indent (n)
  (interactive "nHow many spaces do you want? ")
  (setq-local tab-width n)
  ;; java/c/c++
  (setq-local c-basic-offset n)
  ;; web development
  (setq-local coffee-tab-width n) ; coffeescript
  (setq-local javascript-indent-level n) ; javascript-mode
  (setq-local js-indent-level n) ; js-mode
  ;;(setq-local js2-basic-offset n) ; js2-mode, in latest js2-mode, it's alias of js-indent-level
  (setq-local web-mode-markup-indent-offset n) ; web-mode, html tag in html file
  (setq-local web-mode-css-indent-offset n) ; web-mode, css in html file
  (setq-local web-mode-code-indent-offset n) ; web-mode, js code in html file
  (setq-local css-indent-offset n) ; css-mode
  (setq-local typescript-indent-level n) ; typescript-mode
  (message "OK!"))
#+END_SRC

** Current file functionality
Sometimes I just want to delete/rename/move etc. the current file without resorting to dired or any other file manager. Here are some interactive functions to do that.

#+begin_src emacs-lisp
  ;; Slightly modified from:
  ;; http://steve.yegge.googlepages.com/my-dot-emacs-file
  (defun isamert/rename-current-file-name-and-buffer (new-name)
    "Renames both current buffer and file it's visiting to NEW-NAME."
    (interactive "FNew name: ")
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (when (not filename)
        (user-error "Buffer '%s' is not visiting a file!" name))
      (when (get-buffer new-name)
        (user-error "A buffer named '%s' already exists!" new-name))
      (rename-file filename new-name 1)
      (rename-buffer new-name)
      (set-visited-file-name new-name)
      (set-buffer-modified-p nil)))

  ;; Slightly modified version of: http://www.ergoemacs.org/emacs/elisp_delete-current-file.html
  (defun isamert/delete-current-file ()
    "Delete the current file and copy it's content to `kill-ring'."
    (interactive)
    (when (y-or-n-p (format "Do you really want to remove this: \"%s\"?" (buffer-file-name)))
      (kill-new (buffer-string))
      (message "Buffer content copied to kill-ring.")
      (when (and (buffer-file-name) (file-exists-p (buffer-file-name)))
        (delete-file (buffer-file-name))
        (message "Deleted file: 「%s」." (buffer-file-name)))
      (let ((buffer-offer-save nil))
        (set-buffer-modified-p nil)
        (kill-buffer (current-buffer)))))
#+end_src

** xah-open-file-at-cursor
This is better than =find-file-at-point= because it takes line numbers etc. into account.

#+begin_src emacs-lisp
  (defun xah-open-file-at-cursor ()
    "Open the file path under cursor.
  If there is text selection, uses the text selection for path.
  If the path starts with “http://”, open the URL in browser.
  Input path can be {relative, full path, URL}.
  Path may have a trailing “:‹n›” that indicates line number, or “:‹n›:‹m›” with line and column number. If so, jump to that line number.
  If path does not have a file extension, automatically try with “.el” for elisp files.
  This command is similar to `find-file-at-point' but without prompting for confirmation.

  URL `http://ergoemacs.org/emacs/emacs_open_file_path_fast.html'
  Version 2020-10-17"
    (interactive)
    (let* (
           ($inputStr
            (if (use-region-p)
                (buffer-substring-no-properties (region-beginning) (region-end))
              (let ($p0 $p1 $p2
                        ;; chars that are likely to be delimiters of file path or url, e.g. whitespace, comma. The colon is a problem. cuz it's in url, but not in file name. Don't want to use just space as delimiter because path or url are often in brackets or quotes as in markdown or html
                        ($pathStops "^  \t\n\"`'‘’“”|[]{}「」<>〔〕〈〉《》【】〖〗«»‹›❮❯❬❭〘〙·。\\"))
                (setq $p0 (point))
                (skip-chars-backward $pathStops)
                (setq $p1 (point))
                (goto-char $p0)
                (skip-chars-forward $pathStops)
                (setq $p2 (point))
                (goto-char $p0)
                (buffer-substring-no-properties $p1 $p2))))
           ($path
            (replace-regexp-in-string
             "^file:///" "/"
             (replace-regexp-in-string
              ":\\'" "" $inputStr))))
      (if (string-match-p "\\`https?://" $path)
          (if (fboundp 'xahsite-url-to-filepath)
              (let (($x (xahsite-url-to-filepath $path)))
                (if (string-match "^http" $x )
                    (browse-url $x)
                  (find-file $x)))
            (progn (browse-url $path)))
        (progn ; not starting “http://”
          (if (string-match "#" $path )
              (let (
                    ( $fpath (substring $path 0 (match-beginning 0)))
                    ( $fractPart (substring $path (1+ (match-beginning 0)))))
                (if (file-exists-p $fpath)
                    (progn
                      (find-file $fpath)
                      (goto-char 1)
                      (search-forward $fractPart ))
                  (when (y-or-n-p (format "file no exist: 「%s」. Create?" $fpath))
                    (find-file $fpath))))
            (if (string-match "^\\`\\(.+?\\):\\([0-9]+\\)\\(:[0-9]+\\)?\\'" $path)
                (let (
                      ($fpath (match-string 1 $path))
                      ($line-num (string-to-number (match-string 2 $path))))
                  (if (file-exists-p $fpath)
                      (progn
                        (find-file $fpath)
                        (goto-char 1)
                        (forward-line (1- $line-num)))
                    (when (y-or-n-p (format "file no exist: 「%s」. Create?" $fpath))
                      (find-file $fpath))))
              (if (file-exists-p $path)
                  (progn ; open f.ts instead of f.js
                    (let (($ext (file-name-extension $path))
                          ($fnamecore (file-name-sans-extension $path)))
                      (if (and (string-equal $ext "js")
                               (file-exists-p (concat $fnamecore ".ts")))
                          (find-file (concat $fnamecore ".ts"))
                        (find-file $path))))
                (if (file-exists-p (concat $path ".el"))
                    (find-file (concat $path ".el"))
                  (when (y-or-n-p (format "file no exist: 「%s」. Create?" $path))
                    (find-file $path ))))))))))

(define-key evil-normal-state-map (kbd "gf") 'xah-open-file-at-cursor)
#+end_src

** xah-{escape,unescape}-quotes
#+begin_src emacs-lisp
  (defun xah-escape-quotes (@begin @end)
    "Replace 「\"」 by 「\\\"」 in current line or text selection.
    See also: `xah-unescape-quotes'

    URL `http://ergoemacs.org/emacs/elisp_escape_quotes.html'
    Version 2017-01-11"
    (interactive
     (if (use-region-p)
         (list (region-beginning) (region-end))
       (list (line-beginning-position) (line-end-position))))
    (save-excursion
      (save-restriction
        (narrow-to-region @begin @end)
        (goto-char (point-min))
        (while (search-forward "\"" nil t)
          (replace-match "\\\"" "FIXEDCASE" "LITERAL")))))

  (defun xah-unescape-quotes (@begin @end)
    "Replace  「\\\"」 by 「\"」 in current line or text selection.
  See also: `xah-escape-quotes'

  URL `http://ergoemacs.org/emacs/elisp_escape_quotes.html'
  Version 2017-01-11"
    (interactive
     (if (use-region-p)
         (list (region-beginning) (region-end))
       (list (line-beginning-position) (line-end-position))))
    (save-excursion
      (save-restriction
        (narrow-to-region @begin @end)
        (goto-char (point-min))
        (while (search-forward "\\\"" nil t)
          (replace-match "\"" "FIXEDCASE" "LITERAL")))))
#+end_src

** eksisozluk gundem
#+begin_src emacs-lisp
  (defun isamert/eksi-gundem-sirali ()
    "Eksi gundemini entry sayisina gore sirala ve `completing-read' yap."
    (interactive)
    (let* ((selectrum-should-sort nil)
           (results (->> (shell-command-to-string "curl --silent https://eksisozluk.com/basliklar/gundem | grep '?a=popular' | sed -E 's/[ ]*href=\"(.*)\">(.*) <small>(.*)<\\/small>(.*)/(\\3) \\2|||\\1/' | sort -V -r | uniq")
                      (s-split "\n")
                      (--map (s-split "|||" it))
                      (--map `(,(car it) . ,(cadr it))))))
      (->> results
        (completing-read "Baslik: ")
        (funcall (-flip 'assoc-string) results)
        (cdr)
        (format "https://eksisozluk.com/%s")
        (browse-url))))
#+end_src
* WELL
Company/work related stuff.

#+begin_src emacs-lisp
  (defun company/is-company ()
    "Return if current computer is Well computer or not."
    (string= (treemacs-workspace->name (treemacs-current-workspace)) "seller-ads"))
#+end_src

** Automatically insert issue numbers into commit messages
#+begin_src emacs-lisp
  ;; TODO: maybe find all changed functions/files and append them into
  ;; the buffer as default message so that I can simply construct my
  ;; commit message based on those
  (defun company/git-commit-message-setup ()
    "Insert the JIRA ticket number in front of the commit message.
  If it already exists (like for example when you use --amend),
  does not do anything."
    (let* ((issue-prefix (--> (magit-get-current-branch)
                           (s-chop-prefix "feature/" it)
                           (split-string it "-")
                           (string-join (-take 2 it) "-")
                           (format "%s - " it)))
           (issue-prefix-exists (save-excursion
                                  (goto-char (point-min))
                                  (search-forward issue-prefix nil t))))
      (when (not issue-prefix-exists)
        (goto-char (point-min))
        (insert issue-prefix))))

  (when (company/is-company)
    (add-hook 'git-commit-setup-hook 'company/git-commit-message-setup))
#+end_src

** Open MR page
#+begin_src emacs-lisp
  (defun isamert/git-link-my-merge-requests ()
    "Open all of my merge requests in browser for the current repository."
    (interactive)
    (browse-url (format "%s/-/merge_requests?scope=all&utf8=✓&state=opened&author_username=%s" (isamert/git-link-homepage) "isamert.gurbuz")))

  (evil-leader/set-key
    "glm" 'isamert/git-link-my-merge-requests)
#+end_src

** JS env setup
LSP does not work well with UI projects. So I use tide for UI projects and LSP for backend projects.

#+begin_src emacs-lisp
  (defun company/setup-tide-mode ()
    (interactive)
    (lsp-mode -1)
    (tide-setup)
    (flycheck-mode +1)
    (setq flycheck-check-syntax-automatically '(save mode-enabled))
    (flycheck-add-next-checker 'python-flake8 'python-pylint)
    (eldoc-mode +1)
    (highlight-thing-mode -1)
    (tide-hl-identifier-mode +1)
    (lsp-ui-mode +1)
    (company-mode +1))

  (defun company/setup-js ()
    "If it's an UI project, run tide.  Otherwise run lsp."
    (interactive)
    (if (string-match "/ui/" (or (isamert/current-project-root) ""))
        (progn (isamert/setup-indent 2)
               (company/setup-tide-mode))
      (lsp)))

  (when (company/is-company)
    (remove-hook 'js-mode-hook 'lsp)
    (add-hook 'js-mode-hook 'company/setup-js))
#+end_src

** Misc bindings
#+begin_src emacs-lisp
  (defun isamert/toggle-side-trendyol-org-buffer ()
    "Toggle `well.org` in a side buffer for quick note taking.  The buffer is opened in side window so it can't be accidentaly removed."
    (interactive)
    (isamert/toggle-side-buffer-with-file "~/Documents/notes/trendyol.org"))

  (evil-leader/set-key
    "tw" 'isamert/toggle-side-trendyol-org-buffer)
#+end_src

** Jira

#+begin_src emacs-lisp
  (evil-leader/set-key "oj" #'isamert/open-jira-issue-at-point)

  ;;
  ;; Actions for JIRA items using embark
  ;;

  (use-package embark
    :config
    (embark-define-keymap isamert/embark-jira-actions
      "Actions for JIRA issues."
      ("o" isamert/open-jira-issue)
      ("b" isamert/jira-ticket-to-branch))
    (add-to-list 'embark-keymap-alist '(isamert/jira . isamert/embark-jira-actions)))

  ;;
  ;; Install required JIRA client
  ;;

  (use-package jiralib2
    :ensure t
    :config
    (setq jiralib2-url "https://jtracker.trendyol.com")
    (setq jiralib2-auth 'basic)
    (setq jiralib2-user-login-name "isamert.gurbuz")
    (setq jiralib2-token nil))

  ;;
  ;; My completing-read based JIRA utilities
  ;;

  (defvar isamert/jira-projects '(("SA" . 1000))
    "List of projects that I enrolled in JIRA.
  CDR of each item defines which ticket number the caching should
  start.")

  (defvar isamert/jira-base-branch "master"
    "Brach to create feature branches from.")

  (defvar isamert/jira-feature-branch-prefix "feature/"
    "Prefix to prepend feature branch names.")

  ;; Internal state

  (defvar isamert/jira-my-issues '()
    "All of my issues")
  (defvar isamert/jira-new-issues '()
    "New jira issues")

  ;; Functions

  (defun isamert/open-jira-issue (issue-number)
    "Open given Jira ISSUE-NUMBER."
    (interactive "sIssue: ")
    (browse-url (format "%s/browse/%s" jiralib2-url (car (s-split " " issue-number)))))

  (defun isamert/open-jira-issue-at-point ()
    "Open issue at point."
    (interactive)
    (isamert/open-jira-issue (thing-at-point 'symbol)))

  (defun isamert/jira-refresh-issue-lists ()
    (interactive)
    (message ">> Updating my issues...")
    (setq isamert/jira-my-issues (jiralib2-jql-search "assignee = currentUser()"))
    (message ">> Updating new issues...")
    (setq isamert/jira-new-issues '())
    (mapcar
     (lambda (project)
       (setq
        isamert/jira-new-issues
        (thread-last (format "project = \"%s\" AND issuekey >= \"%s-%s\""
                             (car project) (car project) (cdr project))
          (jiralib2-jql-search)
          (append isamert/jira-new-issues))))
     isamert/jira-projects)
    (message ">> Updating new issues... Done."))

  (defun isamert/jira-list-issues ()
    (interactive)
    (thread-last (pcase (completing-read "Issue list: " '("My issues" "New issues"))
                   ("My issues" isamert/jira-my-issues)
                   ("New issues" isamert/jira-new-issues))
      (--map (cons (format "%s - %s" (cdr (assoc 'key it)) (cdr (assoc 'summary (assoc 'fields it)))) it))
      ((lambda (items) (consult--read items :category 'isamert/jira)))))

  (defun isamert/jira-ticket-to-branch (issue-name)
    (interactive "sIssue name: ")
    (let ((branch-name (thread-last issue-name
                         (s-replace-all '((" " . "-") (":" . "-") ("\"" . "") ("/" . "-") ("&" . "") ("(" . "-") (")" . "-")))
                         (s-replace "---" "-")
                         (s-replace "--" "-")
                         (s-downcase)
                         (isamert/s-upcase-until "-")
                         (s-prepend isamert/jira-feature-branch-prefix)
                         (read-string "Branch name: "))))
      (message "Updating...")
      (magit-branch-checkout isamert/jira-base-branch)
      (magit-pull-from-upstream nil)
      (message "Creating branch...")
      (magit-branch-and-checkout branch-name isamert/jira-base-branch)
      (message "Currently on %s." (magit-get-current-branch))))

  ;; Utility

  (defun isamert/s-upcase-until (until s)
    (let ((end (s-index-of until s)))
      (concat
       (s-upcase (substring s 0 end))
       (substring s end))))
#+end_src

** Token management
- ~DEPRECATED~

#+begin_src emacs-lisp
  ;; Setup:
  ;;   (company/switch-{development,integration,validation})
  ;;   (company/set-refresh-token)
  ;;
  ;; Getting:
  ;;   (company/access-token)
  ;;   (company/auth-token)


  ;; Customization

  (defcustom company/internal-auth-util-path
    "~/Workspace/projects/shared/awslibrary/lib/auth/InternalAuthUtil.js"
    "Path to InternalAuthUtil.js, see: https://wellco.atlassian.net/wiki/spaces/HA/pages/1344962568/Getting+admin+tokens")

  ;; State

  (defvar company/token-last-update
    nil)

  ;; Code

  (defun company/switch-env (env)
    (setenv "AWS_PROFILE" env)
    (setenv "CI_ENVIRONMENT_NAME" env)
    (when (not (getenv "REFRESH_TOKEN"))
      (company/set-refresh-token)))

  (defun company/switch-development ()
    (interactive)
    (company/switch-env "development"))

  (defun company/switch-integration ()
    (interactive)
    (company/switch-env "integration"))

  (defun company/switch-validation ()
    (interactive)
    (company/switch-env "validation"))

  (defun company/set-refresh-token ()
    (interactive)
    (setenv "REFRESH_TOKEN" (read-string "REFRESH_TOKEN: ")))

  (defun company/refresh-tokens ()
    (interactive)
    (-let [tokens (shell-command-to-string (format "node %s useTokens" company/internal-auth-util-path))]
      (setenv "ACCESS_TOKEN" (cadr (s-match "accessToken:[ \n\t]+'\\(.*\\)'" tokens)))
      (setenv "AUTH_TOKEN" (cadr (s-match "authToken:[ \n\t]+'\\(.*\\)'" tokens)))
      (setq company/token-last-update (string-to-number (format-time-string "%s")))))

  (defun company/tokens ()
    (interactive)
    (when (or (not company/token-last-update)
              (< (+ company/token-last-update 290) (string-to-number (format-time-string "%s"))))
      (company/refresh-tokens))
    `(,(getenv "ACCESS_TOKEN") . ,(getenv "AUTH_TOKEN")))

  (defun company/access-token ()
    (interactive)
    (car (company/tokens)))

  (defun company/auth-token ()
    (interactive)
    (cdr (company/tokens)))
#+end_src
