#+TITLE: Emacs configuration file
#+AUTHOR: İsa Mert Gürbüz
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes

* Introduction
This is my emacs configuration. My main focus is sanity. I'm a person who get frustrated pretty easily. So instead of optimizing the time spent on doing things, I try to find ways of doing things that does not make me frustrated. Most of the time you get speed boost as a byproduct.

* Preparation
** Load path
Define the load path. It's for auto-loading =.el= files. Any =.el= file that you put under this path will be loaded by emacs at startup.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/load")
#+END_SRC

** Variables and functions
Some basic variable and function definitions that will be used in configuration.

#+BEGIN_SRC emacs-lisp
  (defun isamert/mkdir-if-not (dir)
    "Create the DIR if it does not exist return DIR."
      (unless (file-exists-p dir)
              (make-directory dir))
      dir)

  ;; SOURCE: https://www.reddit.com/r/emacs/comments/345vtl/make_helm_window_at_the_bottom_without_using_any/
  (defun isamert/shackle-window (name size)
    "Make the buffer NAME appear at bottom of the window, filling SIZE percent of the window."
    (add-to-list 'display-buffer-alist
                 `(,name
                    (display-buffer-in-side-window)
                    (inhibit-same-window . t)
                    (window-height . ,size))))


  (defmacro isamert/prettify-mode (mode pairs)
    "Prettify given PAIRS in given MODE."
    `(add-hook ,mode (lambda ()
                     (mapc (lambda (pair)
                               (push pair prettify-symbols-alist))
                             ,pairs)
                     (prettify-symbols-mode))))

  ;; SOURCE: https://github.com/azzamsa/scripts.el#kill-all-buffers
  (defun isamert/kill-all-other-buffers nil
    "Kill all buffers but current buffer and special buffers.
  Buffers that start with '*' and white space ignored"
    (interactive)
    (when (y-or-n-p "Really kill all other buffers? ")
      (let ((killed-bufs 0))
        (dolist (buffer (delq (current-buffer) (buffer-list)))
          (let ((name (buffer-name buffer)))
            (when (and name (not (string-equal name ""))
                       (/= (aref name 0) ?\s)
                       (string-match "^[^\*]" name))
              (cl-incf killed-bufs)
              (funcall 'kill-buffer buffer))))
        (message "Killed %d buffer(s)" killed-bufs))))

  ;; Like =delq= but removes more than just one item.
  (defun isamert/delq* (list &rest elems)
    "Remove ELEMS from LIST"
    (let ((l list))
      (mapc (lambda (item) (setq l (delq item l))) elems)
      l))

  (defun isamert/font-exists-p (font)
    "Check if FONT exists"
    (if (null (x-list-fonts font)) nil t))

  (defun isamert/flatten (list-of-lists) (apply #'append list-of-lists))
  (defun isamert/flatmapcar (fun list) (isamert/flatten (mapcar fun list)))

  (defun isamert/assoc-regexp (key list &optional fn)
    "Like `assoc` but uses `string-match (car pair) KEY` for comparasion and returns all the matching pairs. FN is applied to the keys before matching, if present."
    (seq-filter (lambda (pair) (when (string-match (if fn (funcall fn (car pair)) (car pair)) key) pair)) list))

  ;; SOURCE: https://stackoverflow.com/a/17325791
  (defun isamert/replace-string (in what with)
    (replace-regexp-in-string (regexp-quote what) with in nil 'literal))

  (defun isamert/replace-string-regexp (in what with)
    (replace-regexp-in-string what with in nil 'literal))

  (defun isamert/s-trim-left (s c)
    "Remove C's at the beginning of S."
    (if (string-match (concat "\\`[" c "]+") s)
        (replace-match "" t t s)
      s))

  (defun isamert/s-trim-right (s c)
    "Remove C's at the end of S."
    (if (string-match (concat "[" c "]+\\'") s)
        (replace-match "" t t s)
      s))

  (defun isamert/s-trim (s c)
    "Remove whitespace at the beginning and end of S."
    (s-trim-left (s-trim-right s c) c))


  (defun isamert/find-all (regex str)
    "Find all occurences of REGEX in given STR."
    (let ((matches))
      (with-temp-buffer
        (insert str)
        (goto-char (point-min))
        (while (re-search-forward regex (point-max) t)
          (push (match-string 1) matches)))
      matches))
#+END_SRC

#+RESULTS:
: isamert/find-all

** Package repos
Add ~melpa~ package archive.

#+BEGIN_SRC emacs-lisp
(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
(package-initialize)
(unless package-archive-contents (package-refresh-contents)) ;; Update archives
#+END_SRC

** use-package
Install ~use-package~. From now on I will use ~use-package~ to install and configure packages.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package) (package-install 'use-package))
#+END_SRC

*** quelpa
Helps you to install packages from other sources, like github etc.
#+BEGIN_SRC emacs-lisp
(use-package quelpa-use-package
  :ensure t
  :init (setq quelpa-update-melpa-p nil)
  :config (quelpa-use-package-activate-advice))
#+END_SRC

Here is an example that shows you how to install a package from github:
#+BEGIN_SRC
(use-package PACKAGE-NAME
  :ensure t
  :diminish
  :quelpa (PACKAGE-NAME
           :fetcher github
           :branch "WIP" ;; Optional
           :repo "yyoncho/company-box"))
#+END_SRC

*** diminish
diminish.el provides a way to hide mode indicators from mode line. Either pass ~:diminish t~ to use-package while installing or just call ~diminish 'x-mode)~.

#+BEGIN_SRC emacs-lisp
(use-package diminish :ensure t)
#+END_SRC

* Basics
** Sane defaults
#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold 100000000           ;; Better than default
        read-process-output-max (* 1024 1024) ;; Better than default
        confirm-kill-processes nil            ;; When exitting, kill processes withouh asking
        ring-bell-function 'ignore             ;; This completely disables alarms
        column-number-mode t                   ;; Show column number
        create-lockfiles nil)                  ;; These just clutter the filesystem

  (global-visual-line-mode t)                  ;; Wrap long lines
  (diminish 'visual-line-mode)
  (fset 'yes-or-no-p 'y-or-n-p)                ;; Ask y/n instead of yes/no
#+END_SRC

Some sources about the variables that I changed:
- https://github.com/emacs-lsp/lsp-mode#performance

** Recent files
Save recent files. Also exclude package files that appears after installing a package or after an update from recent list.

#+BEGIN_SRC emacs-lisp
(recentf-mode t)
(add-to-list 'recentf-exclude (format "%s/\\.emacs\\.d/elpa/.*" (getenv "HOME")))
#+END_SRC

** Better scrolling
*** Better settings for mouse scroll
#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed nil)            ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse 't)                  ;; scroll window under mouse
#+END_SRC

*** Mouse shortcuts for zooming
- Ctrl-Scroll to zoom in and out

#+BEGIN_SRC emacs-lisp
(global-set-key [C-mouse-4] 'text-scale-increase)
(global-set-key [C-mouse-5] 'text-scale-decrease)
(global-set-key (kbd "C-+") 'text-scale-increase)
(global-set-key (kbd "C-=") 'text-scale-decrease)
#+END_SRC

*** Conservative scrolling
If the cursor is at the end of the file, when you scroll emacs does a strange jump. This fixes it.

#+BEGIN_SRC emacs-lisp
(setq scroll-conservatively 100) ;; When cursor reaches end, just scroll line-by-line
#+END_SRC

** Place all backup files in same directory
Instead of having a file that ends with ~ or '# files in same directory, save all backup files in =~/.emacs.d/backups=.

#+BEGIN_SRC emacs-lisp
  (defconst backup-dir (isamert/mkdir-if-not"~/.emacs.d/backups/"))

  (setq backup-directory-alist `((".*" . ,backup-dir)))
  (setq auto-save-file-name-transforms `((".*" ,backup-dir t)))
#+END_SRC

** Undo tree (Persistent undo and stuff)
- ~undo-tree~ gives a persistent undo.
- Also it keeps undo history as a tree instead of a linear history. ~undo-tree-visualize~ may help.
#+BEGIN_SRC emacs-lisp
(defconst undo-dir (isamert/mkdir-if-not "~/.emacs.d/undo/"))


(use-package undo-tree
  :diminish undo-tree-mode
  :ensure t
  :init
    (setq undo-tree-auto-save-history t
          undo-tree-history-directory-alist `(("." . ,undo-dir))
          undo-tree-enable-undo-in-region nil) ;; this fixes something?
  :config
  (global-undo-tree-mode))
#+END_SRC

** Remove trailing space before save
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook
          'delete-trailing-whitespace)
#+END_SRC

** Automatically run some commands after saving specific files
This is like =autocmd BufWritePost= of vim. When a particular file is edited, I want to make sure a command runs after the save.

#+BEGIN_SRC emacs-lisp
(defvar run-after-save-alist
  '(("~/.(Xresources|Xdefaults)" . "xrdb %; notify-send 'xrdb updated'")
    ("~/.Xresources.d/.*"        . "xrdb ~/.Xresources; notify-send 'xrdb updated'")
    ("~/.config/sxhkd/sxhkdrc"   . "pkill -USR1 -x sxhkd; notify-send 'sxhkd updated'"))
  "File association list with their respective command.")
#+END_SRC

*** Implementation
#+BEGIN_SRC emacs-lisp
  (defun isamert/post-save-run-command ()
    "Execute the specified command after saving specified file."
    (let* ((fname (buffer-file-name))
           (match (isamert/assoc-regexp fname run-after-save-alist 'expand-file-name)))
      (when match
        (mapcar (lambda (pair) (shell-command (isamert/replace-string (cdr pair) "%" fname))) match))))

  (add-hook 'after-save-hook 'isamert/post-save-run-command)
#+END_SRC

** Disable shift select mode
This needs a little bit of explanation. So, I have remapped =AltGr + {h,j,k,l}= to arrow keys, using =xmodmap=. That means I can use h,j,k,l as directional keys in insert mode too, with the help of AltGr. This is quite helpful for quick/little movements and pretty easy to get used to. As a natural extension, I've remapped =AltGr + Shift + {h,j,k,l}= to =Home, PageDown, PageUp, End= but there is a little bit of problem with that, remapping also registers the shift key so that when I do =AltGr + Shift + h=, it is registered as =Shift + Home= but I just want it to register as =Home=. I haven't able to fix this in using =xmodmap= so I'm simply disabling the shift selection mode in emacs to get my desired result.

#+begin_src emacs-lisp
(setq shift-select-mode nil)
#+end_src

* Visuals
** General
Hide menubar and toolbar and replace blinking cursor with nice static box cursor.

#+BEGIN_SRC emacs-lisp
(menu-bar-mode 0)                ;; Disable menubar
(tool-bar-mode 0)                ;; Disable toolbar
(blink-cursor-mode 0)            ;; Disable blinking cursor
(scroll-bar-mode -1)             ;; Disable scrollbars
(setq inhibit-startup-message t) ;; Close startup screen
(global-hl-line-mode t)          ;; Highlight current line

;; Disable global-hl-line-mode in eshell, ansi-term, vterm
(mapcar
  (lambda (mode) (add-hook mode (lambda () (setq-local global-hl-line-mode nil))))
  '(eshell-mode-hook term-mode-hook vterm-mode-hook))
#+END_SRC

** Fonts
#+BEGIN_SRC emacs-lisp
  ;; TODO: make this a list and then use whichever font exists in the list
  (defconst my-font "Sarasa Mono J")

  (add-hook
   'after-make-frame-functions
   (lambda (frame)
     (with-selected-frame frame
       (when (isamert/font-exists-p my-font)
         (set-face-attribute 'default nil
                             :font my-font
                             :weight 'normal
                             :width 'normal
                             :height 120)))))
#+END_SRC

** all-the-icons
You should run =all-the-icons-install-fonts= command after this.

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons :ensure t)
#+END_SRC

** Theme
Set a nicer theme.

#+BEGIN_SRC emacs-lisp
(add-hook 'after-make-frame-functions
  (lambda (frame)
    (with-selected-frame frame
      (use-package doom-themes ;; spacemacs-theme
        :ensure t
        :defer t
        :init
        (load-theme 'doom-one t)))))
#+END_SRC

** Frame title
Make window title contain buffer name so it's easier to identify windows. I use ~rofi~ to switch between windows in my DE, so it helps to have buffer name in window title.

#+BEGIN_SRC emacs-lisp
(setq frame-title-format "%b - emacs")
#+END_SRC

** Parentheses
*** Matching
Just enable parenthesis matching.

#+BEGIN_SRC emacs-lisp
(setq show-paren-style 'parenthesis)
(show-paren-mode 1)
#+END_SRC

*** Rainbow
Colors parantheses depending on their dept.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

** 120 column line limit and trailing spaces
This code highlights the portion of line that exceeds 120 columns and trailing spaces.

#+BEGIN_SRC emacs-lisp
(setq whitespace-style '(face empty tabs trailing)) ;; lines-tail
(setq whitespace-global-modes '(not org-mode markdown-mode vterm-mode)) ;; Disable in org-mode and markdown-mode
(global-whitespace-mode t)
(diminish 'global-whitespace-mode)
#+END_SRC

** Shackle windows
Make some temproary windows appear at bottom.

#+BEGIN_SRC emacs-lisp
(isamert/shackle-window "\\*Help\\*" 0.4)
(isamert/shackle-window "\\*Warnings*\\*" 0.2)
(isamert/shackle-window "\\*Backtrace*\\*" 0.4)
(isamert/shackle-window "\\*Flycheck.*" 0.4)
(isamert/shackle-window "\\*Org Src.*\\*" 0.4)
(isamert/shackle-window "\\*Agenda Commands\\*" 0.4)
(isamert/shackle-window "\\*Org Agenda\\*" 0.4)
(isamert/shackle-window "\\*Org Select\\*" 0.4)
(isamert/shackle-window "CAPTURE-*" 0.4)
(isamert/shackle-window "magit.*" 0.7)
(isamert/shackle-window "\\*xref\\*" 0.4)
(isamert/shackle-window "\\*Org-Babel Error Output\\*" 0.4)
(isamert/shackle-window "\\*curl error\\*" 0.4)
#+END_SRC

** Spaces instead of tabs
#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4)
(setq-default indent-tabs-mode nil)
#+END_SRC

* evil-mode
** Install
#+BEGIN_SRC emacs-lisp
(use-package evil
  :ensure t
  :init
  (setq evil-want-integration t
        evil-want-keybinding nil ;; Do not load evil-keybindings for now
        evil-want-C-i-jump nil   ;; Makes tab key work as expected in terminal
        evil-want-C-u-scroll t)
  :config
  (evil-mode 1))
#+END_SRC

** evil-leader
Enable leader key and bind some keys.
#+BEGIN_SRC emacs-lisp
  (defun execute-C-c-C-c ()
    (interactive)
    (execute-kbd-macro (kbd "C-c C-c")))

  (use-package evil-leader
    :ensure t
    :init
    (global-evil-leader-mode)
    :config
    (evil-leader/set-leader "SPC")
    (evil-leader/set-key
      ;; generic
      ";"   'eval-last-sexp
      "f"   'projectile-find-file
      "c"   'execute-C-c-C-c

      ;; buffers
      "bq" 'evil-quit
      "bd" 'evil-delete-buffer
      "bb" 'bufler-switch-buffer))
#+END_SRC

** evil-mc
Multiple cursors for evil. =C-n= to create a cursor on next match. =A= and =I= creates cursors in visual selection mode as you may expect.

#+BEGIN_SRC emacs-lisp
(use-package evil-mc
  :ensure t
  :diminish evil-mc-mode
  :config
  (progn
    (evil-define-key 'visual evil-mc-key-map
      "A" #'evil-mc-make-cursor-in-visual-selection-end
      "I" #'evil-mc-make-cursor-in-visual-selection-beg)
    (global-evil-mc-mode 1)))
#+END_SRC

** evil-surround
Change surroundings. Do =cs"'= to turn ="Hello world!"= into ='Hello world!'=.
- ='Hello world!'= ~cs'<q>~ =<q>Hello world!</q>=
- =Hel|lo= ~ysiw"~ ="Hello"= (| is the cursor position.)
- =Hello= ~ysw{~ ={ Hello }=  (~{[(~ adds spaces)
- =Hello= ~ysw}~ ={Hello}=    (~}])~ does not add spaces)

#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  :ensure t
  :init
  (global-evil-surround-mode 1))
#+END_SRC

** evil-escape
Return back to normal mode using ~jk~ from anywhere. It does not play well with multiple cursors, so use ~ESC~ to when using evil-mc related stuff.

#+BEGIN_SRC emacs-lisp
(use-package evil-escape
  :diminish
  :ensure t
  :init
  (setq evil-escape-key-sequence "jk"
        evil-escape-delay 0.2)
  :config
  (evil-escape-mode 1))
#+END_SRC

** evil-matchit
Jump between matching tags using ~%~, like =<div>...</div>=, ={...}= etc. =ci%=, =da%= etc. works as expected.

#+BEGIN_SRC emacs-lisp
(use-package evil-matchit
  :diminish
  :ensure t
  :config
  (global-evil-matchit-mode 1))
#+END_SRC

** evil-goggles
~evil-goggles~ gives nice visual feedbacks while editing with evil-mode. When you do =dd=, =yw=, =ciw= or something similar, it will give a visual feedback for the selection. Feels kinda natural to have this.

#+BEGIN_SRC emacs-lisp
(use-package evil-goggles
  :ensure t
  :diminish
  :config
  (setq evil-goggles-duration 0.20
        evil-goggles-pulse nil
        evil-goggles-enable-change t
        evil-goggles-enable-delete t
        evil-goggles-enable-indent t
        evil-goggles-enable-yank t
        evil-goggles-enable-join t
        evil-goggles-enable-fill-and-move t
        evil-goggles-enable-paste t
        evil-goggles-enable-shift t
        evil-goggles-enable-surround t
        evil-goggles-enable-commentary t
        evil-goggles-enable-nerd-commenter t
        evil-goggles-enable-replace-with-register t
        evil-goggles-enable-set-marker t
        evil-goggles-enable-undo t
        evil-goggles-enable-redo t)
  (evil-goggles-mode)
  (evil-goggles-use-diff-faces))

#+END_SRC

** evil-snipe
Overall better =f/F/t/T= and . Nice visual feedbacks. I don't use two-char searching, just using the f-override mode. I'm =avy= for more precise jumps.

#+BEGIN_SRC emacs-lisp
(use-package evil-snipe
  :ensure t
  :diminish evil-snipe-local-mode
  :init
  (evil-snipe-mode 1)
  (evil-snipe-override-mode 1)
  (setq evil-snipe-scope 'visible)
  (add-hook 'magit-mode-hook 'turn-off-evil-snipe-override-mode))
#+END_SRC

** Visual line movement
To move between visual lines instead of real lines:
#+BEGIN_SRC emacs-lisp
(setq-default evil-cross-lines t) ;; Make horizontal movement cross lines
(define-key evil-normal-state-map (kbd "<remap> <evil-next-line>") 'evil-next-visual-line)
(define-key evil-normal-state-map (kbd "<remap> <evil-previous-line>") 'evil-previous-visual-line)
(define-key evil-motion-state-map (kbd "<remap> <evil-next-line>") 'evil-next-visual-line)
(define-key evil-motion-state-map (kbd "<remap> <evil-previous-line>") 'evil-previous-visual-line)
#+END_SRC

** Change cursor color according to mode
#+BEGIN_SRC emacs-lisp
(setq evil-normal-state-cursor '("green" box)
      evil-visual-state-cursor '("orange" box)
      evil-emacs-state-cursor '("red" box)
      evil-insert-state-cursor '("red" bar)
      evil-replace-state-cursor '("red" bar)
      evil-operator-state-cursor '("red" hollow))
#+END_SRC

* org-mode
** keybindings
#+begin_src emacs-lisp
  (evil-leader/set-key
    "oi" 'org-toggle-inline-images
    "or" 'org-mode-restart
    "oa" 'org-agenda
    "on" 'org-toggle-narrow-to-subtree
    "ow" 'widen)

  (defun outline-up-heading-or-backward-heading-same-level ()
    "Focus the previous upper level heading or if it does not exist go backwards on same heading level."
    (interactive)
    (condition-case nil
      (progn (outline-up-heading 1) (message "ye"))
      (error (org-backward-heading-same-level 1))))

  (defun outline-up-heading-forward-or-forward-heading-same-level ()
    "Focus the next upper level heading or if it does not exist go forward on same heading level."
    (interactive)
    (condition-case nil
      (progn (outline-up-heading 1) (org-forward-heading-same-level 1) (message "ye"))
      (error (org-forward-heading-same-level 1))))

  (outline-up-heading-or-backward-heading-same-level)
  (evil-define-key 'normal org-mode-map
    "[" 'org-previous-visible-heading
    "]" 'org-next-visible-heading
    "(" 'outline-up-heading-or-backward-heading-same-level
    ")" 'outline-up-heading-forward-or-forward-heading-same-level
    "-" 'org-cycle-list-bullet
    (kbd "H-h") 'org-shiftleft
    (kbd "H-j") 'org-shiftdown
    (kbd "H-k") 'org-shiftup
    (kbd "H-l") 'org-shiftright
    (kbd "M-H") 'org-shiftmetaleft
    (kbd "M-J") 'org-shiftmetadown
    (kbd "M-K") 'org-shiftmetaup
    (kbd "M-L") 'org-shiftmetaright

  ;; FIXME: M-h,j,k,l conflicts with split swithcing shourtcuts
  ;; so I just prefixed them with Hyper but this does not feel natural.
    (kbd "M-H-h") 'org-metaleft
    (kbd "M-H-j") 'org-metadown
    (kbd "M-H-k") 'org-metaup
    (kbd "M-H-l") 'org-metaright

    "t" 'org-todo
    "T" 'org-set-tags-command
    "E" 'org-ctrl-c-ctrl-c
    "O" 'org-open-at-point
    "Y" 'org-store-link)

  (evil-leader/set-key-for-mode 'org-mode
    "d" 'org-babel-remove-result
    "D" 'my/org-babel-remove-all-results)
#+end_src

*** evil bindings for org-agenda
#+BEGIN_SRC emacs-lisp
(add-hook 'org-agenda-mode-hook
  (lambda ()
    (define-key org-agenda-mode-map "j" 'evil-next-line)
    (define-key org-agenda-mode-map "k" 'evil-previous-line)))
#+END_SRC

** some vars
#+BEGIN_SRC emacs-lisp
(when (file-directory-p "~/Documents/notes")
  (setq life-org "~/Documents/notes/life.org")
  (setq bullet-org "~/Documents/notes/bullet.org")
  (setq org-directory "~/Documents/notes")
  (setq org-agenda-files `(,life-org ,bullet-org)))
#+END_SRC

** better defaults
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t             ;; Enable code highlighting in ~SRC~ blocks.
      org-hierarchical-todo-statistics t     ;; Show all children in todo statistics [1/5]
      org-imenu-depth 7                      ;; include up to 7-depth headers in imenu search
      org-image-actual-width nil             ;; Disable showing inline images in full width. Now you can add `#+ATTR_*: :width 300` to resize inline images
      org-ellipsis "..⤵"                     ;; Replace ... with ..↯ in collapsed sections
      org-habit-show-habits-only-for-today t ;; If a TODO item has the ':STYLE: habit' property, then show it only on todays agenda, does not show recurring times.
)
#+END_SRC

** auto indent subsections
Automatically invoke ~org-indent-mode~ which gives nice little indentation under subsections. It makes reading easier.
#+BEGIN_SRC emacs-lisp
  (add-hook
   'org-mode-hook
   (lambda ()
     (org-indent-mode t)
     (diminish 'org-indent-mode))
   t)
#+END_SRC

** babel
#+begin_src emacs-lisp
;; Http request in org-mode babel.
(use-package ob-http :ensure t)

;; Typescript
(use-package ob-typescript :ensure t)

;; Scheme
(use-package geiser
  :ensure t
  :init
  (setq geiser-default-implementation 'guile))

;; Allow these languages to run in code blocks
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (scheme . t)
   (python . t)
   (js . t)
   (sql . t)
   (shell . t)
   (R . t)
   (typescript . t)
   (http . t)))

(setq org-confirm-babel-evaluate nil) ;; Don't ask permissions for evaluating code blocks
#+end_src

** exports
*** HTML
#+BEGIN_SRC emacs-lisp
(use-package htmlize :ensure t)
#+END_SRC

*** iCalendar settings
#+BEGIN_SRC emacs-lisp
(setq org-icalendar-store-UID t
      org-icalendar-alarm-time 15
      org-icalendar-use-scheduled '(todo-start event-if-todo)
      org-icalendar-use-deadline '(todo-due event-if-todo))
#+END_SRC

** agenda
#+BEGIN_SRC emacs-lisp
(when (fboundp 'life-org)
  (setq org-agenda-files `(,life-org)
        org-agenda-use-time-grid t
        org-agenda-time-grid '((weekly today require-timed remove-match)
                               (800 1000 1200 1400 1600 1800 2000 2200) "......" "----------------")))
#+END_SRC
** todo keywords
#+BEGIN_SRC emacs-lisp
;; Add this to org files if you need:
;; #+TODO: TODO IN-PROGRESS WAITING DONE
;; OR
;; (setq org-todo-keywords
;;   '((sequence "TODO" "IN-PROGRESS" "WAITING" "DONE")))

(setq org-todo-keyword-faces
      '(("WAITING" . (:foreground "yellow" :weight bold))
        ("IN-PROGRESS" . (:foreground "magenta" :weight bold))))
#+END_SRC

** presentation
#+BEGIN_SRC emacs-lisp
(use-package org-tree-slide
  :ensure t)
#+END_SRC

** fancy/pretty stuff
#+begin_src emacs-lisp
  ;; Make headings look better with nice bullets.
  ;; It also adjusts the size of headings according to their level.
  (use-package org-bullets
    :ensure t
    :hook (org-mode . org-bullets-mode))

  (use-package org-fancy-priorities
    :diminish
    :ensure t
    :hook (org-mode . org-fancy-priorities-mode)
    :config
    (setq org-fancy-priorities-list '("🅰" "🅱" "🅲" "🅳")))

  ;; This causes some aligning problems when used with the above one
  (use-package org-pretty-tags
    :diminish org-pretty-tags-mode
    :ensure t
    :config
    (setq org-pretty-tags-surrogate-strings
          '(("work"  . "⚒")
            ("side"  . "❄")
            ("must"  . "✠")
            ("rutin" . "♟")
            ("study" . "☣")))

    (org-pretty-tags-global-mode))


  (isamert/prettify-mode 'org-mode-hook
                         '(("[ ]" . "☐")
                           ("[X]" . "☑" )
                           ("[-]" . "❍" )))
#+end_src
** org-ql
#+BEGIN_SRC emacs-lisp
(use-package org-ql :ensure t)
#+END_SRC
** TODO org-capture
- [ ] Add a shortcut.
- [ ] Add more templates.
- [ ] Maybe add a way to call it outside of emacs.

#+BEGIN_SRC emacs-lisp
;; (setq org-capture-templates
;;      '(("t" "Todo" entry (file+headline life-org "Current")
;;         "* TODO %?\n  %i\n  %a")))
#+END_SRC

** TODO org-alert
#+begin_src emacs-lisp
;; (use-package org-alert
  ;; :ensure t
  ;; :config
  ;; (setq alert-default-style 'libnotify
        ;; alert-fade-time 10)
  ;; (org-alert-enable))
#+end_src
* Other packages
** tramp
#+begin_src emacs-lisp
(setq tramp-default-method "ssh"
      tramp-verbose 2            ;; only show errors and warnings
      vc-handled-backends '(Git) ;; only try to handle git, this speeds up things a little bit
)
#+end_src
** winner-mode
This mode allows you to do /undo/ /redo/ operations on window layout changes. My most frequent use case is that sometimes I just want to focus on one window for a while and then return back to my old layout setup. These keybindings allows me to do that.

#+BEGIN_SRC emacs-lisp
(setq winner-dont-bind-my-keys t)
(winner-mode t)
(evil-define-key 'normal 'global
  (kbd "C-w 1") 'delete-other-windows
  (kbd "C-w r") 'winner-redo
  (kbd "C-w u") 'winner-undo)
#+END_SRC
** which-key
A package that shows key combinations. (for example press C-x and wait) It also works with ~evil-leader~, just press leader key and wait to see your options.
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :diminish which-key-mode
  :config
  (which-key-mode))
#+END_SRC
** magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind
    (:map magit-status-mode-map
          ("j" . 'next-line)
          ("k" . 'previous-line))
    :config
    ;; Following snippet is needed to update modeline after a checkout happens
    (advice-add 'magit-checkout :after (lambda (a) (vc-refresh-state)))
    (defun isamert/git-commit-setup ()
      (when (string= (treemacs-workspace->name (treemacs-current-workspace)) "Work")
        (insert (shell-command-to-string "~/.local/bin/huawei commit-msg"))))

    (evil-leader/set-key
      ;; magit/git
      "gs" 'magit-status
      "gg" 'my/helm-grep-git-grep-current-project
      "gp" 'magit-pull
      "gP" 'magit-push
      "gr" 'magit-reset
      "gcc" 'magit-checkout
      "gcf" 'magit-file-checkout
      "gbb" 'magit-branch
      "gbc" 'magit-branch-create)

    (add-hook 'git-commit-setup-hook 'isamert/git-commit-setup))
#+END_SRC

*** magit-todos
Show TODO/FIXME etc in magit-status buffer.
#+BEGIN_SRC emacs-lisp
(use-package magit-todos
  :ensure t
  :init (magit-todos-mode 1)
  :bind
  (:map magit-todos-section-map
    ("j" . 'next-line)
    ("k" . 'previous-line))
  (:map magit-todos-item-section-map
    ("j" . 'next-line)
    ("k" . 'previous-line)))
#+END_SRC

** goto-chg
=g;= goes to the last change. (repeatable)

#+BEGIN_SRC emacs-lisp
(use-package goto-chg
  :ensure t)
#+END_SRC

** perspective.el
Although I like eyebrowse, what I really want is to have isolated workspaces because buffer management just gets pretty complicated. I like to combine perspective.el and eyebrowse and I saw that spacemacs has a layer called layouts that does exactly what I want but I haven't had the time to figure it out and apply to my config.

#+BEGIN_SRC emacs-lisp
  (use-package perspective
    :ensure t
    :config
    (evil-define-key 'normal persp-mode-map
      (kbd "M-,") 'persp-prev
      (kbd "M-.") 'persp-next)
    (evil-leader/set-key
      "ll" 'persp-switch-last
      "ls" 'persp-switch
      "lk" 'persp-kill
      "lm" 'persp-toggle-modestring)
    (add-hook 'kill-emacs-hook #'persp-state-save)
    (persp-mode t))

  (defun persp-toggle-modestring ()
    (interactive)
    (if persp-show-modestring
        (persp-turn-off-modestring)
      (persp-turn-on-modestring)))
#+END_SRC

** avy
avy is very similar to ~vim-easymotion~. It simply jumps to a visible text using a given char. Hit ~M-s~ and the char you want to jump.

#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :init
  (setq avy-keys '(?q ?w ?e ?r ?t ?a ?s ?d ?f ?j ?k ?l ?u ?i ?o ?p)) ;; Only use these for jumping.
  :config
  (define-key evil-normal-state-map (kbd "M-s") 'avy-goto-char)   ;; Go to any char
  (define-key evil-normal-state-map (kbd "M-S") 'avy-goto-word-1)) ;; Go to beginning of a word
#+END_SRC

** helm
*** Enable and set defaults
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :ensure t
    :diminish helm-mode
    :init
    (setq helm-mode-fuzzy-match t
          helm-completion-in-region-fuzzy-match t
          helm-candidate-number-limit 100
          projectile-completion-system 'helm
          helm-buffer-skip-remote-checking t) ;; This disables file-exist-p check for TRAMP files, otherwise buffer listing has huge delay.
    :config
    (evil-leader/set-key
      ;; helm
      "SPC" 'helm-M-x
      "RET" 'helm-mini
      "hh" 'helm-resume
      "hr" 'helm-rg
      "hp" 'my/helm-projectile-rg-current-project
      "hm" 'helm-my-files
      "ho" 'helm-org-rifle-org-directory)
    (helm-mode 1)
    (isamert/shackle-window "\\*[hH]elm*" 0.35) ;; make helm windows appear at bottom
    (helm-adaptive-mode 1))
#+END_SRC

*** Better selection
Set ~<tab>~ for selecting next result and ~<backtab>~ for selecting previous result.

#+BEGIN_SRC emacs-lisp
(define-key helm-map (kbd "M-`") 'helm-select-action)
(define-key helm-map (kbd "M-a") 'helm-select-action)
(define-key helm-map (kbd "M-RET") 'helm-execute-persistent-action)
(define-key helm-map (kbd "TAB") 'helm-next-line)
(define-key helm-map (kbd "<backtab>") 'helm-previous-line)
#+END_SRC
*** helm-rg (ripgrep)
=rip-grep= is a pretty fast grep replacement. This is a helm ui for ripgrep.

#+BEGIN_SRC emacs-lisp
(use-package helm-rg
  :ensure t)
#+END_SRC

*** helm-org-rifle
Search in my org files, takes headers into account while searching. =helm-org-rifle-org-directory= is very useful(I set org-directory while configuring org).

#+BEGIN_SRC emacs-lisp
(use-package helm-org-rifle
  :ensure t)
#+END_SRC

*** helm-my-files
A quick access menu for the files that I frequently open.

#+BEGIN_SRC emacs-lisp
(defun isamert/org-files ()
  (mapcar
    (lambda (file) (concat org-directory "/" file))
    (if (file-directory-p org-directory)
        (directory-files org-directory nil "^\\w+.*.org$")
         '())))

(defun isamert/dotfiles ()
  (let* ((output (shell-command-to-string "git --git-dir=$HOME/.dotfiles/ --work-tree=$HOME ls-tree --full-tree -r HEAD | cut -f2"))
         (files (mapcar (lambda (file) (concat "~/" file)) (split-string output "\n" t))))
    files))

(defun isamert/files ()
  (append (isamert/org-files) (isamert/dotfiles)))

(defun helm-my-files ()
  "List my files"
  (interactive)
  (let ((selected-file
        (helm :buffer "*helm-my-files*"
              :sources (helm-build-sync-source "isamert/files"
                         :candidates (isamert/files)
                         :fuzzy-match t))))
    (find-file selected-file)))
#+END_SRC
** projectile
A project management tool. I set a project path below and make sure projectile scans that directory for projects.
*** Groupped projects
I have all my projects under =~/Workspace/projects=. Some of them are groupped under another directory. This functions loops trough all of the directories and finds the ones without =.git= folder and adds those folders to project paths. Consider this:
#+BEGIN_QUOTE
~/Workspace/projects
 ├── groupped_projects
 ├   ├── project3
 ├   └── project4
 ├── project1
 ├   └── .git
 └── project2
     └── .git
#+END_QUOTE

This function adds =groupped_projects= to =projectile-project-search= path.
#+BEGIN_SRC emacs-lisp
(defconst isamert/projects-root "~/Workspace/projects")

(defun isamert/projectile-project-paths ()
  (append `(,isamert/projects-root)
    (isamert/flatmapcar (lambda (dir) (if (file-directory-p (concat dir "/.git")) '() `(,dir)))
                (directory-files isamert/projects-root t directory-files-no-dot-files-regexp))))
#+END_SRC

*** Better project names
I have manually set up names for projects in treemacs, because it was fairly easy. You just need to edit an org file, it's simple as that. So whenever a custom name is available in treemacs, I also want to use it as the project name in projectile. Here I replace the projectile's project name function with mine to do that.

#+BEGIN_SRC emacs-lisp
(defun isamert/treemacs-project-name-from-path (path)
  "Returns treemacs project name for given project in PATH. If not found, returns nil."
  (let ((path-stripped (isamert/s-trim-right path "\/")))
    (car (mapcar
          'treemacs-project->name
          (seq-filter
           (lambda (project)
             (when (string= path-stripped
                            (isamert/s-trim-right (treemacs-project->path project) "/"))
               project))
           (isamert/flatmapcar 'treemacs-workspace->projects (treemacs-workspaces)))))))

(defun isamert/projectile-custom-project-name (project-root)
  (or (isamert/treemacs-project-name-from-path project-root)
      (projectile-default-project-name project-root)))
#+END_SRC

*** Load
#+BEGIN_SRC emacs-lisp
  (defun isamert/projectile-discover-projects ()
    (setq projectile-project-search-path (isamert/projectile-project-paths))
    (projectile-discover-projects-in-search-path))

  (use-package projectile
    :ensure t
    :diminish projectile-mode
    :init
    (setq projectile-completion-system 'helm
          projectile-enable-caching t
          projectile-project-search-path (isamert/projectile-project-paths))
    :config
    (projectile-discover-projects-in-search-path)
    (setq projectile-globally-ignored-files (append '("Cargo.lock" ".tern-port"))
          projectile-globally-ignored-directories (append '(".stack-work" "target" "node_modules" "build" "dist"))
          projectile-globally-ignored-file-suffixes (append '("~" ".rs.bk"))
          projectile-project-name-function 'isamert/projectile-custom-project-name)
    (projectile-mode)

    (evil-leader/set-key
      "pp" 'projectile-switch-project
      "pf" 'projectile-find-file-in-known-projects
      "pc" 'projectile-invalidate-cache
      "pd" 'isamert/projectile-discover-projects
      "pr" 'projectile-recentf))
#+END_SRC

** flycheck
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :diminish
  :ensure t
  :init (global-flycheck-mode)
  :config
  (setq flycheck-idle-change-delay 1
        flycheck-check-syntax-automatically '(save new-line mode-enabled))) ;; (save idle-change new-line mode-enabled)
#+END_SRC

** company
*** Install and configure

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :init
    (setq company-selection-wrap-around t  ;; return to first completion after the last one (cycles)
          company-global-modes '(not erc-mode message-mode help-mode gud-mode eshell-mode shell-mode)
          company-minimum-prefix-length 1) ;; start completing after 1 char
    :config
    (add-hook 'after-init-hook 'global-company-mode)
    (company-tng-configure-default)   ;; cycle trough suggestions using tab

    (evil-define-key 'insert 'global
      (kbd "C-SPC") 'company-complete)
    (define-key company-active-map
      (kbd "<return>") 'company-complete-selection))

  ;; TODO: Nice icons for completions (works with company-lsp)
  ;; (use-package company-box
  ;;   :ensure t
  ;;   :diminish
  ;;   :quelpa (company-box
  ;;            :fetcher github
  ;;            :branch "WIP"
  ;;            :repo "yyoncho/company-box")
  ;;   :hook (company-mode . company-box-mode))
#+END_SRC
*** quickhelp
Shows a nice tooltip while idling on a completion.
#+BEGIN_SRC emacs-lisp
(use-package company-quickhelp
  :ensure t
  :config
  (progn
    (company-quickhelp-mode))
    (eval-after-load 'company '(define-key company-active-map (kbd "M-p") 'company-quickhelp-manual-begin))) ;; Alt-p shows the popup manually
#+END_SRC
** origami-mode
This seems working better than =hs-minor-mode= and also it's supposedly works with =lsp-mode=.
#+BEGIN_SRC emacs-lisp
(use-package origami
  :ensure t
  :hook ((web-mode . origami-mode)
          (js-mode . origami-mode)))
#+END_SRC
** lsp-mode
#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :commands lsp
  :hook ((web-mode . lsp)
         (js-mode . lsp)
         (typescript-mode . lsp)
         (dhall-mode . lsp)
         (java-mode . lsp))
  :init
  (setq lsp-prefer-flymake nil
        lsp-use-native-json t
        lsp-enable-xref t
        lsp-enable-links t
        lsp-enable-folding t
        lsp-enable-symbol-highlighting t
        lsp-enable-indentation nil
        lsp-enable-on-type-formatting nil
        lsp-before-save-edits nil
        lsp-enable-indentation nil
        lsp-eldoc-render-all nil
        ;;lsp-enable-completion-at-point nil
        lsp-enable-snippet t))

(use-package lsp-ui
  :ensure t
  :commands lsp-ui-mode
  :config
  (setq lsp-ui-sideline-show-code-actions nil))

(use-package company-lsp
  :ensure t
  :commands company-lsp
  :config
  (setq company-lsp-cache-candidates 'auto)
  :init
  (push 'company-lsp company-backends))

(use-package helm-lsp
  :ensure t
  :commands helm-lsp-workspace-symbol)

(use-package lsp-treemacs
  :ensure t
  :commands lsp-treemacs
  :config
  (lsp-treemacs-sync-mode 1))

(use-package dap-mode
  :ensure t :after lsp-mode
  :config
  (dap-mode t)
  (dap-ui-mode t))
#+END_SRC

** eshell
*** aliases
Get bash aliases and update eshell aliases. My aliases are in a file called =~/.config/aliases= in bash format. I convert them to abbreviations in fish/zsh shell and I convert them to eshell aliases in here.
#+BEGIN_SRC emacs-lisp
(defun eshell-update-aliases-if-needed nil
  (interactive)
  (when (file-newer-than-file-p "~/.config/aliases" eshell-aliases-file)
      (progn
          (shell-command-to-string
            (concat
              "grep -vE '^(#|$)' ~/.config/aliases"
              "|"
              "sed -r 's/=/ /; s/(.*)\".*/\\1 $*/; s/\"//;' "
              ">"
              eshell-aliases-file
              ))
          (eshell-read-aliases-list))))

(when (file-exists-p "~/.config/aliases")
  (add-hook 'eshell-mode-hook 'eshell-update-aliases-if-needed))
#+END_SRC

*** clear
#+BEGIN_SRC emacs-lisp
(defun eshell-clear-buffer ()
  "Clear terminal"
  (interactive)
  (let ((inhibit-read-only t))
    (erase-buffer)))

(defun eshell/clear nil
  (eshell-clear-buffer))
#+END_SRC

** vterm
Also check out =~/.zshrc= and =~/.config/zsh/emacs.sh=. These files contains some helpful commands that enriches ~vterm~ usage.

#+BEGIN_SRC emacs-lisp
  (defun evil-collection-vterm-escape-stay ()
    "Go back to normal state but don't move cursor backwards.
  Moving cursor backwards is the default vim behavior but
  it is not appropriate in some cases like terminals."
    (setq-local evil-move-cursor-back nil))

  (use-package vterm
    :ensure t
    :config
    (evil-define-key 'insert vterm-mode-map
      (kbd "C-]") 'vterm-send-escape
      (kbd "C-w") 'vterm-send-C-w
      (kbd "C-t") 'vterm-send-C-t
      (kbd "C-c") 'vterm-send-C-c
      (kbd "C-r") 'vterm-send-C-r)
    (evil-define-key 'normal vterm-mode-map
      (kbd "[") 'vterm-previous-prompt
      (kbd "]") 'vterm-next-prompt
      (kbd "u") 'vterm-undo
      (kbd "u") 'vterm-undo
      (kbd "p") 'vterm-yank)
    (setq vterm-kill-buffer-on-exit t)
    (add-hook 'vterm-mode-hook #'evil-collection-vterm-escape-stay))

  (defconst isamert/vterm-dedicated-buffer-name "*vterm-dedicated*")
  (isamert/shackle-window isamert/vterm-dedicated-buffer-name 40)

  (defun isamert/vterm-dedicated ()
    "Open/toggle a dedicated vterm buffer."
    (interactive)
    (cond
     ((isamert/buffer-visible-p isamert/vterm-dedicated-buffer-name) (isamert/remove-window-with-buffer isamert/vterm-dedicated-buffer-name))
     ((get-buffer isamert/vterm-dedicated-buffer-name) (switch-to-buffer-other-window isamert/vterm-dedicated-buffer-name))
     (t (vterm isamert/vterm-dedicated-buffer-name))))
#+END_SRC

** ispell
- Use =flyspell-mode= to start spell checking.
#+BEGIN_SRC emacs-lisp
(setq ispell-program-name "hunspell"
      ispell-local-dictionary "en_US"
      ispell-local-dictionary-alist
      '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)))

(add-hook 'org-mode-hook 'flyspell-mode)
(add-hook 'markdown-mode-hook 'flyspell-mode)
#+END_SRC

** treemacs
#+BEGIN_SRC emacs-lisp
  (use-package treemacs
    :ensure t
    :defer t
    :config
    (setq treemacs-show-hidden-files nil
          treemacs-width 34
          treemacs-space-between-root-nodes nil
          treemacs-indentation 2)
    ;; (set-face-attribute 'treemacs-root-face nil
    ;; :foreground (face-attribute 'default :foreground)
    ;;                     :height 1.1
    ;;                     :weight 'normal)
    (add-to-list 'treemacs-ignored-file-predicates (lambda (filename abspath) (string-equal filename "node_modules")))
    (evil-define-key 'treemacs treemacs-mode-map ;; Treemacs has it's own mode, named treemacs. (https://github.com/Alexander-Miller/treemacs/issues/484#issuecomment-509909312)
      (kbd "M-f") 'treemacs
      (kbd "M-l") 'evil-window-right
      (kbd "W") 'treemacs-switch-workspace
      (kbd "E") 'treemacs-edit-workspaces
      (kbd "l") 'treemacs-TAB-action
      (kbd "h") 'treemacs-TAB-action
      (kbd "D") 'treemacs-delete
      (kbd "]") 'treemacs-next-project
      (kbd "[") 'treemacs-previous-project))

  (use-package treemacs-evil
    :after treemacs evil
    :ensure t)

  (use-package treemacs-projectile
    :after treemacs projectile
    :ensure t)

  (use-package treemacs-icons-dired
    :after treemacs dired
    :ensure t
    :config (treemacs-icons-dired-mode))

  (use-package treemacs-magit
    :after treemacs magit
    :ensure t)

  (defun aorst/treemacs-setup-title ()
    (let ((bg (face-attribute 'default :background))
          (fg (face-attribute 'default :foreground)))
      (face-remap-add-relative 'header-line
                               :background bg :foreground fg
                               :box `(:line-width ,(/ (line-pixel-height) 2) :color ,bg)))
    (setq header-line-format
          '((:eval
             (let* ((text (treemacs-workspace->name (treemacs-current-workspace)))
                    (extra-align (+ (/ (length text) 2) 1))
                    (width (- (/ (window-width) 2) extra-align)))
               (concat (make-string width ?\s) text))))))
#+END_SRC

** ace-window
Quickly switch between windows/kill them or swap them with each other.
#+begin_src emacs-lisp
(use-package ace-window
  :ensure t
  :config
  (setq aw-dispatch-always t)                   ;; show selection even if window count is < 3
  (setq aw-keys '(?a ?d ?f ?g ?h ?j ?k ?l))     ;; window selection keys
  (add-to-list 'aw-dispatch-alist '(?s aw-swap-window "Swap Windows")) ;; <ace-window>s => swap window with
  (global-set-key (kbd "M-q") 'ace-window)
)
#+end_src

** telephone-line
#+BEGIN_SRC emacs-lisp
  ;; Color settings
  ;; I just extracted these 2 functions from the telephone-line source.
  ;; and only switched their colors.
  (defface telephone-line-evil-insert
    '((t (:background "red" :inherit telephone-line-evil)))
    "Face used in evil color-coded segments when in Insert state."
    :group 'telephone-line-evil)

  (defface telephone-line-evil-normal
    '((t (:background "dark slate blue" :inherit telephone-line-evil)))
    "Face used in evil color-coded segments when in Normal state."
    :group 'telephone-line-evil)

  (use-package telephone-line
    :ensure t
    :config
      (progn
        ;; Separator settings
        ;; FIXME: if I set theese here, non-gui emacs fail to show modeline
        (setq telephone-line-primary-left-separator 'telephone-line-flat
              telephone-line-secondary-left-separator 'telephone-line-flat
              telephone-line-primary-right-separator 'telephone-line-flat
              telephone-line-secondary-right-separator 'telephone-line-flat)

         (setq telephone-line-evil-use-short-tag t)

        ;; Define segments
        (setq telephone-line-lhs
            '((evil   . (telephone-line-evil-tag-segment))
              (accent . (telephone-line-vc-segment
                         telephone-line-process-segment))
              (nil    . (telephone-line-buffer-segment))))

        (setq telephone-line-center-rhs
            '((nil    . (telephone-line-flycheck-segment))))

        (setq telephone-line-rhs
            '((nil    . (telephone-line-misc-info-segment))
              (accent . (telephone-line-major-mode-segment))
              (evil   . (telephone-line-airline-position-segment))))

        ;; Misc settings
        (setq telephone-line-height 20)
        (telephone-line-mode t)))
#+END_SRC

** expand-region
Select the nearest meaningful region with a keybinding. When you repeat it, it selects the next bigger meaningful region. Look [[*Keybindings][Keybindings]] for the binding.
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t)
#+END_SRC

** howdoyou
When you search for something, it opens the results in an org-mode buffer. Results are fetched from SX sites.
- =howdoyou-query= :: search function
- =C-M-Right= :: next answer
- =C-M-Left= :: prev answer
#+BEGIN_SRC emacs-lisp
  (use-package howdoyou
    :ensure t
    :config
    (with-eval-after-load "helm-net"
      (push (cons "How Do You"  (lambda (candidate) (howdoyou-query candidate)))
            helm-google-suggest-actions))
    (setq howdoyou-switch-to-answer-buffer t
          howdoyou-number-of-answers 5))
#+END_SRC

** yasnippets
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :config
    (setq yas-snippet-dirs '("~/.emacs.d/snippets"))
    (yas-global-mode 1)

    (evil-leader/set-key "s" 'yas-insert-snippet)
    (evil-define-key 'insert 'global
      (kbd "M-s") 'company-yasnippet))
#+END_SRC

** ranger.el
- You can add/remove parent windows with using =z+= or =z-=.
- Use =zP= to toggle between minimal (deer) and full ranged mode.

#+BEGIN_SRC emacs-lisp
(use-package ranger
  :ensure t
  :config
  (setq ranger-max-preview-size 10 ;; MB
        ranger-cleanup-on-disable t
        ranger-width-preview 0.45
        ranger-show-literal nil)) ;; Toggle between literal and non-literal previews with zi
#+END_SRC

** bufler.el
#+BEGIN_SRC emacs-lisp
(use-package helm-bufler
  :quelpa (helm-bufler :fetcher github :repo "alphapapa/bufler.el"
                       :files ("helm-bufler.el")))
#+END_SRC

** helm-evil-markers
This brings up a helm menu when I hit ='= and lists all the local and global marks.

#+BEGIN_SRC emacs-lisp
  (use-package helm-evil-markers
    :quelpa (helm-evil-markers :fetcher github :repo "xueeinstein/helm-evil-markers"
                               :files ("helm-evil-markers.el"))
    :config
    (setq helm-evil-markers-exclusion-enabled t)
    (evil-leader/set-key
      "mm" 'helm-mark-ring
      "mg" 'helm-global-mark-ring
      "ma" 'helm-all-mark-rings)
    (helm-evil-markers-toggle))
#+END_SRC

** helpful
Better help dialogs with syntax highlighting, references, source etc.

#+begin_src emacs-lisp
(use-package helpful
  :ensure t
  :config
  (global-set-key (kbd "C-h f") #'helpful-callable)
  (global-set-key (kbd "C-h v") #'helpful-variable)
  (global-set-key (kbd "C-h k") #'helpful-key))
#+end_src

* Keybindings
- For leader key bindings, see: [[*evil-leader][evil-leader]]
- For avy        bindings, see: [[*Bindings][avy/bindings]]
** Some general keybindings
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)

  (evil-define-key 'normal 'global
    "?"  'helm-semantic-or-imenu
    (kbd "M-e") 'er/expand-region
    (kbd "M-f") 'treemacs
    (kbd "C-f") 'helm-occur
    (kbd "C-s") 'save-buffer)

  (evil-define-key 'normal prog-mode-map
    (kbd "M-;") 'comment-line
    (kbd "M-:") 'comment-dwim
    "gd" 'xref-find-definitions
    "gf" 'xref-find-references)

  (evil-define-key 'normal lsp-mode-map
    "gf" 'lsp-ui-peek-find-references
    "gd" 'lsp-ui-peek-find-definitions
    "gi" 'lsp-ui-peek-find-implementation
    "ga" 'lsp-execute-code-action)
#+END_SRC

** Better split management
- A-- splits below, A-\ splits right.
- A-h,j,k,l to switch between splits.
- A-H,J,K,L shrink, enlarge split.
#+BEGIN_SRC emacs-lisp
(evil-define-key 'normal 'global
  (kbd "M-\\") 'split-window-right
  (kbd "M--") 'split-window-below
  (kbd "M-J") 'enlarge-window
  (kbd "M-K") 'shrink-window
  (kbd "M-L") 'enlarge-window-horizontally
  (kbd "M-H") 'shrink-window-horizontally)

;; This is needed to override other modes mappings
(define-minor-mode movement-map-mode
  "Overrides all major and minor mode keys" t)

(defvar movement-map (make-sparse-keymap "movement-map")
  "Override all major and minor mode keys")

(evil-define-key 'normal movement-map
  (kbd "M-j") 'evil-window-down
  (kbd "M-k") 'evil-window-up
  (kbd "M-h") 'evil-window-left
  (kbd "M-l") 'evil-window-right)

(evil-define-key 'normal treemacs-mode-map
  (kbd "M-j") 'evil-window-down
  (kbd "M-k") 'evil-window-up
  (kbd "M-h") 'evil-window-left
  (kbd "M-l") 'evil-window-right)

(evil-make-intercept-map movement-map)

(add-to-list 'emulation-mode-map-alists
  `((movement-map-mode . ,movement-map)))
#+END_SRC

* Language specific
** markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :mode
  (("README\\.md\\'" . gfm-mode)
   ("\\.md\\'" . markdown-mode)
   ("\\.markdown\\'" . markdown-mode))
  :init
  (setq markdown-command "multimarkdown")
  :config
  (evil-define-key 'normal markdown-mode-map
    (kbd "TAB") 'markdown-cycle
    (kbd "]") 'markdown-outline-next
    (kbd "[") 'markdown-outline-previous))
#+END_SRC

** python
#+BEGIN_SRC emacs-lisp
  ;; TODO: remove elpy, get the indendation thing that it uses and
  (use-package elpy
    :ensure t
    :init
    :config
    (progn
      (elpy-enable)
      (add-hook 'elpy-mode-hook (lambda nil (which-function-mode nil))) ;; This mode causes IPython to freeze
      (setq elpy-modules (isamert/delq* elpy-modules 'elpy-module-flymake 'elpy-modules-django))))

  ;; https://www.modernemacs.com/post/prettify-mode/
  ;; Also check this: http://www.modernemacs.com/post/python-infix/
  (isamert/prettify-mode
   'python-mode-hook
   '(;; Syntax
     ("def" .      ?ƒ)
     ("!=" .       ?≠)
     ("not" .      #x2757)
     ("in" .       #x2208)
     ("not in" .   #x2209)
     ("return" .   #x27fc)
     ("yield" .    #x27fb)
     ("for" .      #x2200)
     ;; Base Types
     ("int" .      #x2124)
     ("float" .    #x211d)
     ("str" .      #x1d54a)
     ("True" .     #x1d54b)
     ("False" .    #x1d53d)
     ;; Mypy
     ("Dict" .     #x1d507)
     ("List" .     #x2112)
     ("Tuple" .    #x2a02)
     ("Set" .      #x2126)
     ("Iterable" . #x1d50a)
     ("Any" .      #x2754)
     ("Union" .    #x22c3)))
#+END_SRC

** haskell
#+BEGIN_SRC emacs-lisp
(use-package haskell-mode :ensure t)
(use-package flycheck-haskell
  :ensure t
  :hook (haskell-mode . flycheck-haskell-setup))
(use-package lsp-haskell
  :ensure t)
#+END_SRC

** rust
#+BEGIN_SRC emacs-lisp
(use-package rust-mode :ensure t)
#+END_SRC

** javascript
#+BEGIN_SRC emacs-lisp
  ;; (defun use-eslint-from-node-modules ()
  ;;   (let* ((root (locate-dominating-file
  ;;                 (or (buffer-file-name) default-directory)
  ;;                 "node_modules"))
  ;;          (eslint (and root (expand-file-name "node_modules/.bin/eslint" root))))
  ;;     (when (and eslint (file-executable-p eslint))
  ;;       (setq-local flycheck-javascript-eslint-executable eslint))))

  ;; ;; Use eslint from node-modules
  ;; (add-hook 'js-mode-hook #'use-eslint-from-node-modules)

  ;; ;; Disable LSP-flycheck, because I'm using flycheck with eslint
  ;; (add-hook 'js-mode-hook (lambda () (setq-local lsp-prefer-flymake :none)))

  (use-package indium
    :ensure t)

  (evil-leader/set-key-for-mode 'js-mode
    "e" 'indium-eval-region)
  (evil-leader/set-key-for-mode 'org-mode
    "e" 'org-babel-execute-src-block)
  (evil-leader/set-key-for-mode 'emacs-lisp-mode
    "e" 'eval-last-sexp)

  ;; Mode specific REPL jumps
  (evil-leader/set-key-for-mode 'js-mode
    "r" 'indium-switch-to-repl-buffer)
#+END_SRC

** web-mode
I use web-mode for JSX, it's simply better than emacs 27 JSX mode and js2-mode.
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :mode ("\\.jsx\\'")
  :init
  (setq web-mode-enable-current-element-highlight t
        web-mode-enable-current-column-highlight t
        web-mode-enable-auto-pairing t
        web-mode-enable-auto-closing t
        web-mode-enable-auto-opening t)

  ;; Use eslint with web-mode for jsx files
  (flycheck-add-mode 'javascript-eslint 'web-mode)

  ;; Disable LSP-flycheck, because I'm using flycheck with eslint
  (add-hook 'js-mode-hook (lambda () (setq-local lsp-prefer-flymake :none)))

  :config
  ;; Change some colors and stuff
  (set-face-attribute 'web-mode-html-tag-face nil :weight 'bold)
  (set-face-attribute 'web-mode-keyword-face nil :weight 'bold)
  (set-face-attribute 'web-mode-function-call-face nil :weight 'normal :foreground "normal"))
#+END_SRC

** java
=lsp-java= automatically installs =eclipse.jdt.ls= to get lsp.
#+BEGIN_SRC emacs-lisp
(use-package lsp-java :ensure t :after lsp
  :config (add-hook 'java-mode-hook 'lsp))

(use-package dap-java :after (lsp-java))
#+END_SRC

** emmet-mode
Hit <C-j> after these and get:
- =a= ~<a href="|">|</a>~
- =.x= ~<div class="x"></div>~
- =br/= ~<br />~
- =p.x.y.z= ~<p className="x y z"></p>~ (Works well with JSX)
- ~input[type=text]~ ~<input type="text" name="" value=""/>~
- =a>b>c= ~<a href=""><b><c></c></b></a>~
- =b*3= ~<b></b><b></b><b></b>~
#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :ensure t
  :hook (web-mode css-mode sgml-mode)
  :init
  (setq emmet-expand-jsx-className? t
        emmet-self-closing-tag-style " /"))
#+END_SRC

** r
#+BEGIN_SRC emacs-lisp
(use-package ess :ensure t)
#+END_SRC

** kotlin
#+BEGIN_SRC emacs-lisp
(use-package kotlin-mode :ensure t)
#+END_SRC

** gradle/groovy
#+BEGIN_SRC emacs-lisp
(use-package groovy-mode
  :ensure t
  :config
  (add-to-list 'auto-mode-alist '("\\.gradle\\'" . groovy-mode)))
#+END_SRC

** yaml
#+begin_src emacs-lisp
(use-package yaml-mode :ensure t)
#+end_src

** typescript
#+begin_src emacs-lisp
(use-package typescript-mode :ensure t)
#+end_src

** json
#+begin_src emacs-lisp
(use-package json-mode :ensure t)
#+end_src

** elisp
#+begin_src emacs-lisp
  (isamert/prettify-mode 'emacs-lisp-mode-hook
                         '((">="     . ?≥)
                           ("<="     . ?≤)
                           ("defun"  . ?ƒ)
                           ("lambda" . ?λ)))

#+end_src

** dhall
#+begin_src emacs-lisp
  (use-package dhall-mode
    :ensure t
    :diminish dhall-format-on-save-mode
    :mode "\\.dhall\\'"
    :config
    ;; I use dhall-lsp-server, so I don't need this
    (setq dhall-use-header-line nil))
#+end_src

** nix
#+begin_src emacs-lisp
  (use-package nix-mode
    :ensure t
    :mode "\\.nix\\'")
#+end_src
* my/
** org-mode enhancements
#+begin_src emacs-lisp
  ;; TODO: create a function for detecting backlings for header under the cursor.

  (defun isamert/org-link-header ()
    "Interactively select a header and insert it as a link into the buffer.
  Headers are gathered from all the org files found in `org-directory`."
    (interactive)
    (let* ((cmd (concat "cd " org-directory "; " "rg -t org \"^\\*+\" "))
           (headers (split-string (shell-command-to-string cmd) "\n" t))
           (selected
            (helm :buffer "*helm-org-headers*"
                  :sources (helm-build-sync-source "headers"
                             :candidates headers
                             :fuzzy-match t)))
           (file-and-header (isamert/replace-string (isamert/replace-string-regexp selected "\\(\\*\\|TODO\\|IN-PROGRESS\\|DONE\\|WAITING\\)" "") ": "  "::*"))
           (link-name (read-string "Enter link text: " (cadr (split-string file-and-header "::\\*"))))
           (selected-link (concat "[[file:" file-and-header "][" link-name "]]")))
      (insert selected-link)))

#+end_src

** scratch/temporary buffers in side windows
Here I define two important functions and their helpers.  The following functions are pretty useful for quick note taking or evaluating elisp. Having these buffers in a side window makes them immune to some window commands which is what I want.

- isamert/display-side-scratch-buffer :: This one opens (or closes if it's open) the *scratch* buffer in a side window, on the right. This is nice for quickly evaluating elisp, taking elisp related notes.
- isamert/display-side-temp-org-buffer :: This one opens (or closes if it's open) the ~temp.org~ file in a in a side window, on the right. This is nice for taking some quick notes, writing some temporary todos etc.

#+begin_src emacs-lisp
  (defun isamert/buffer-visible-p (buffer)
   "Check if given BUFFER is visible or not.  BUFFER is a string representing the buffer name."
    (or (eq buffer (window-buffer (selected-window))) (get-buffer-window buffer)))

  (defun isamert/display-buffer-in-side-window (buffer)
    "Just like `display-buffer-in-side-window` but only takes a BUFFER and rest of the parameters are for my taste."
    (select-window
     (display-buffer-in-side-window
      buffer
      (list (cons 'side 'right)
            (cons 'slot 0)
            (cons 'window-parameters (list (cons 'no-delete-other-windows t)
                                           (cons 'no-other-window nil)))))))

  (defun isamert/remove-window-with-buffer (the-buffer-name)
    "Remove window containing given THE-BUFFER-NAME."
    (mapc (lambda (window)
            (when (string-equal (buffer-name (window-buffer window)) the-buffer-name)
              (delete-window window)))
          (window-list (selected-frame))))

  (defun isamert/toggle-side-scratch-buffer ()
    "Toggle the scratch buffer in side window.  The buffer is opened in side window so it can't be accidentaly removed."
    (interactive)
    (if (isamert/buffer-visible-p "*scratch*")
        (isamert/remove-window-with-buffer "*scratch*")
      (isamert/display-buffer-in-side-window (get-buffer "*scratch*"))))

  (defun isamert/toggle-side-temp-org-buffer ()
    "Toggle `temp.org` in a side buffer for quick note taking.  The buffer is opened in side window so it can't be accidentaly removed."
    (interactive)
    (if (isamert/buffer-visible-p "temp.org")
        (isamert/remove-window-with-buffer "temp.org")
      (isamert/display-buffer-in-side-window
       (save-window-excursion
         (find-file "~/Documents/notes/temp.org")
         (current-buffer)))))

    ;; Toggle temproary buffers
    (evil-leader/set-key
      "ts" 'isamert/toggle-side-scratch-buffer
      "to" 'isamert/toggle-side-temp-org-buffer
      "tt" 'isamert/vterm-dedicated)
#+end_src

** org-X-today
#+BEGIN_SRC emacs-lisp
(defun isamert/date (date)
  "Display the time described by DATE. DATE can be 'now', 'yesterday', 'two days ago' etc."
  (isamert/s-trim-right (shell-command-to-string (concat "date --date='" date "' +'%Y-%m-%d %a'")) "\n"))

(defun isamert/today nil
  (format-time-string "%Y-%m-%d %a"))

(defun isamert/insert-today nil
  (interactive)
  (insert (isamert/today)))

(defun isamert/org-x-today (x)
  (end-of-line)
  (newline)
  (insert (concat (upcase x) ": <" (isamert/today) ">")))

(defun isamert/org-deadline-today nil
  (interactive)
  (isamert/org-x-today "deadline"))

(defun isamert/org-schedule-today nil
  (interactive)
  (isamert/org-x-today "scheduled"))
#+END_SRC
** org-babel extension functions
#+BEGIN_SRC emacs-lisp
(defun my/org-babel-remove-all-results nil
  (interactive)
  (goto-char 1)
  (let ((total-removed 0))
    (while (org-babel-next-src-block)
      (when (org-babel-remove-result)
        (setq total-removed (+ total-removed 1))))
    (message (format "%d result blocks are removed." total-removed))))
#+END_SRC

** increment/decrement numbers
#+begin_src emacs-lisp
(defun increment-number-decimal (&optional arg)
  "Increment the number forward from point by 'arg'."
  (interactive "p*")
  (save-excursion
    (save-match-data
      (let (inc-by field-width answer)
        (setq inc-by (if arg arg 1))
        (skip-chars-backward "0123456789")
        (when (re-search-forward "[0-9]+" nil t)
          (setq field-width (- (match-end 0) (match-beginning 0)))
          (setq answer (+ (string-to-number (match-string 0) 10) inc-by))
          (when (< answer 0)
            (setq answer (+ (expt 10 field-width) answer)))
          (replace-match (format (concat "%0" (int-to-string field-width) "d")
                                 answer)))))))

(defun decrement-number-decimal (&optional arg)
  (interactive "p*")
  (increment-number-decimal (if arg (- arg) -1)))
#+end_src

** helm extensions
#+begin_src emacs-lisp
(defun my/helm-projectile-rg-current-project nil
  "Search in current project using ripgrep."
  (interactive)
  (setq-local helm-rg-default-directory (projectile-project-root))
  (helm-rg nil)
  (setq-local helm-rg-default-directory 'default))

(defun my/helm-projectile-rg-all-projects nil
  "Search in all projectile projects using ripgrep. If projectile-project-search-path contains multiple paths, only the first path is taken into account."
  (interactive)
  (setq-local helm-rg-default-directory (car projectile-project-search-path))
  (helm-rg nil)
  (setq-local helm-rg-default-directory 'default))

(defun my/helm-grep-ag-current-project (arg)
  "Search in current project using ag"
  (interactive "P")
  (helm-grep-ag (projectile-project-root) arg))

(defun my/helm-grep-git-grep-current-project (arg)
  "Search in current project using ag"
  (interactive "P")
  (helm-grep-git-1 (projectile-project-root) arg))
#+end_src

** functions for easy indentation switching
- http://blog.binchen.org/posts/easy-indentation-setup-in-emacs-for-web-development.html

#+BEGIN_SRC emacs-lisp
(defun isamert/setup-indent (n)
  (interactive "nHow many spaces do you want?")
  (setq-local tab-width n)
  ;; java/c/c++
  (setq-local c-basic-offset n)
  ;; web development
  (setq-local coffee-tab-width n) ; coffeescript
  (setq-local javascript-indent-level n) ; javascript-mode
  (setq-local js-indent-level n) ; js-mode
  (setq-local js2-basic-offset n) ; js2-mode, in latest js2-mode, it's alias of js-indent-level
  (setq-local web-mode-markup-indent-offset n) ; web-mode, html tag in html file
  (setq-local web-mode-css-indent-offset n) ; web-mode, css in html file
  (setq-local web-mode-code-indent-offset n) ; web-mode, js code in html file
  (setq-local css-indent-offset n) ; css-mode
  (setq-local typescript-indent-level n) ; typescript-mode
  (message "OK!"))
#+END_SRC

** create jsdoc string for typescript functions
#+begin_src emacs-lisp
  (defun isamert/create-jsdoc-string-template (ts)
    "Insterts a JSDOC template for a well typed function TypeScript function.
     If TS is true, simply outputs a TSDOC template."
    (interactive "P")
    (let ((str (thing-at-point 'line t))
          (paramsstr)
          (return-type)
          (params)
          (return-doc "")
          (param-docs))
      (save-match-data
        (string-match ".*(\\(\\(\\w+: .+,? ?\\)+\\))\\(?:: \\(.+\\)\\)? {" str)
        (setq paramsstr (match-string 1 str)
              return-type (match-string 3 str)
              params (isamert/find-all "\\([A-Za-z_]+: .+?\\)\\(?:,\\|$\\)" paramsstr)))

      (setq param-docs
            (mapcar (lambda (sig)
                      (let* ((sig-split (split-string sig ": "))
                             (name (nth 0 sig-split))
                             (full-type (nth 1 sig-split))
                             (has-default (string-match "=" full-type))
                             (type-and-val (split-string full-type "="))
                             (type (if has-default (nth 0 type-and-val) full-type))
                             (full-name (if has-default (format "[%s=%s]" name (nth 1 type-and-val)) name)))
                        (if ts
                          (format "* @param %s - \n" name)
                          (format "* @param {%s} %s - \n" type full-name))))
                    params))

      (when (not ts)
        (setq return-doc (format "* @return {%s}\n" return-type)))
      (forward-line -1)
      (mapcar (lambda (line)
                (indent-according-to-mode)
                (insert line)
                (indent-according-to-mode))
              (isamert/flatten `(("\n/**\n*\n") ,param-docs (,return-doc) ("*/"))))))


  (defun isamert/create-tsdoc-string-template ()
    (interactive)
    (isamert/create-jsdoc-string-template t))
#+end_src
** others
#+begin_src emacs-lisp
;; see this: https://github.com/emacs-evil/evil/issues/301
(defun evil-fix-map nil
  (evil-insert)
  (evil-normal))
#+end_src

** workflow
#+BEGIN_SRC emacs-lisp
(defun isamert/init-daily ()
  (interactive)
  (find-file life-org)
  (split-window-right)
  (other-window 1)
  (find-file bullet-org)
  (eyebrowse-switch-to-window-config-2)
  (org-agenda-list)
  (other-window 1)
  (delete-window)
  (eyebrowse-switch-to-window-config-5)
  (find-file "~/.emacs.d/settings.org")
  (eyebrowse-switch-to-window-config-1))
#+END_SRC
** TODO arrange
#+begin_src emacs-lisp
(defun isamert/time-stamp (arg)
  "Interactively select a datetime and return it as string"
  (with-temp-buffer
    (org-time-stamp arg)
    (buffer-string)))
#+end_src
** TODO outsiders
#+begin_src emacs-lisp
(defun bookmark-search ()
  (interactive)
  (find-file "~/Documents/notes/bookmarks.org")
  (setq helm-full-frame t)
  (goto-char (point-min))
  (helm-imenu)
  (setq helm-full-frame nil))
#+end_src
** bullet.org
I have a ~bullet.org~ file that I keep my daily journal and here are some utility functions that use with it. I may document this later (or even publish it as a package?)

#+begin_src emacs-lisp
  ;; FIXME: insert short day name while creating the day
  ;; TODO: archive functions: archive-montly, archive-yearly etc
  ;; TODO: minor mode: org-pretty-tags, org-fancy-priorities
  ;; TODO: Different header for recurring events and this should be automatically copied to todays view (with calling focus today?)
  ;; TODO: montly, yearly goals/logs/headers.
  ;;  -> Need some functions to quickly focus into current month logs, year logs etc.
  ;;  -> Also create migration functions for these.
  ;;  -> These should come before days of given month/year.

  ;;; Code:

  (defun isamert/insert-new-line-above (text)
    "Insert a line above the current line with given TEXT."
    (move-beginning-of-line nil)
    (insert "\n")
    (forward-line -1)
    (insert text))

  (defun isamert/insert-new-last-line (text)
    "Insert a new line at the end of the file with given TEXT."
    (goto-char (point-max))
    (if (= (current-column) 0)
        (insert (concat text "\n"))
      (insert (concat "\n" text "\n"))))

  (defun isamert/selected-region-text ()
    (buffer-substring-no-properties (region-beginning) (region-end)))

  (defun isamert/org-remove-subtree ()
    (org-mark-subtree)
    (delete-and-extract-region (region-beginning) (region-end)))



  (defun isamert/bullet-find-a-day (day)
    (let ((day-regex (concat "^\\[" day "\\( \\w+\\)?\\].*"))
          (day-point nil))
      (org-map-entries
       (lambda ()
         (let ((title (org-entry-get nil "ITEM")))
           (when (string-match day-regex title)
             (setq day-point (point-marker)))))
       "LEVEL=1")
      day-point))

  (defun isamert/bullet-find-today ()
    (isamert/bullet-find-a-day (isamert/today)))

  (defun isamert/bullet-create-a-day (date focus)
    (let ((day-entry (isamert/bullet-find-a-day date))
          (day-regex "^\\[\\([0-9]+-[0-9]+-[0-9]+\\)\\( \\w+\\)?\\].*")
          (is-last-older nil)
          (result-date nil)
          (given-date (date-to-time (concat date "T000")))
          (content (concat "* [" date "] [/]")))
      (if day-entry
          (goto-char day-entry)
        (progn
          (org-map-entries
           (lambda ()
             (let ((title (org-entry-get nil "ITEM")))
               (save-match-data
                 (when (string-match day-regex title)
                   (let ((current-date (date-to-time (concat (match-string 1 title) "T000"))))
                     (when (and (not result-date) (time-less-p given-date current-date))
                       (setq result-date (point-marker))
                       ))))))
           "LEVEL=1")
          (if result-date
              (progn
                (goto-char result-date)
                (isamert/insert-new-line-above content))
            (isamert/insert-new-last-line content))
          (when focus
            (org-narrow-to-subtree))))))

  (defun isamert/bullet-create-given-day (focus)
    (interactive "P")
    (isamert/bullet-create-a-day (org-read-date) focus))

  (defun isamert/bullet-focus-a-day (day)
    "Focus to given DAY."
    (let ((day-entry (isamert/bullet-find-a-day day)))
      (when day-entry (progn (goto-char day-entry) (org-narrow-to-subtree)))
      day-entry))

  (defun isamert/bullet-focus-given-day ()
    "Focus given days header. If it does not exists, create it."
    (interactive)
    (let ((given-date (org-read-date)))
      (when (not (isamert/bullet-focus-a-day given-date))
        (isamert/bullet-create-a-day given-date t))))

  (defun isamert/bullet-focus-today ()
    "Focus todays header. If it does not exists, create it."
    (interactive)
    (when (not (isamert/bullet-focus-a-day (isamert/today)))
      (isamert/bullet-create-today t)))

  (defun isamert/bullet-focus-yesterday ()
    (interactive)
    (isamert/bullet-focus-a-day (isamert/date "yesterday")))

  (defun isamert/bullet-create-today (focus)
    (interactive "P")
    (isamert/bullet-create-a-day (isamert/today) focus))

  ;; TODO: new line fixes
  (defun isamert/bullet-move-todos-yesterday-to-today ()
    (interactive)
    (isamert/bullet-focus-yesterday)
    (let* ((item-points '())
           (items (org-map-entries
                   (lambda ()
                     (setq item-points (cons (point) item-points))
                     (org-mark-subtree)
                     (isamert/selected-region-text))
                   "LEVEL=2/TODO")))
      (mapcar (lambda (x)
                (goto-char x)
                (isamert/org-remove-subtree))
              item-points)
      (widen)
      (isamert/bullet-focus-today)
      (goto-char (point-max))
      (mapcar (lambda (item)
                (insert item))
              items)))

  ;; Keybindings
  (evil-leader/set-key
    "obt" 'isamert/bullet-focus-today
    "obm" 'isamert/bullet-move-todos-yesterday-to-today
    "oby" 'isamert/bullet-focus-yesterday
    "obf" 'isamert/bullet-focus-given-day
    "obc" 'isamert/bullet-create-given-day)
#+end_src
