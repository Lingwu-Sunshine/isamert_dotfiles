#+TITLE: Emacs configuration file
#+AUTHOR: İsa Mert Gürbüz
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes

* Introduction
This is my emacs configuration.
* Preparation
** Load path
Define the load path. (It's for auto-loading .el files)
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/load")
#+END_SRC
** Variables and functions
Some basic variable and function definitions that will be used in configuration.
*** mkdir-if-not
#+BEGIN_SRC emacs-lisp
(defun mkdir-if-not (dir)
"create the DIR if it does not exist"
    (unless (file-exists-p dir)
            (make-directory dir)))
#+END_SRC
*** shackle-window
Here is the [[https://www.reddit.com/r/emacs/comments/345vtl/make_helm_window_at_the_bottom_without_using_any/][source]].
#+BEGIN_SRC emacs-lisp
(defun shackle-window (name size)
"Make the buffer NAME appear at bottom of the window, filling SIZE percent of the window"
  (add-to-list 'display-buffer-alist
               `(,name
                  (display-buffer-in-side-window)
                  (inhibit-same-window . t)
                  (window-height . ,size))))
#+END_SRC
*** kill-all-buffers
source: https://github.com/azzamsa/scripts.el#kill-all-buffers
#+BEGIN_SRC emacs-lisp
(defun kill-all-other-buffers nil
  "Kill all buffers but current buffer and special buffers.
(Buffer that start with '*' and white space ignored)"
  (interactive)
  (when (y-or-n-p "Really kill all other buffers ? ")
    (let ((killed-bufs 0))
      (dolist (buffer (delq (current-buffer) (buffer-list)))
        (let ((name (buffer-name buffer)))
          (when (and name (not (string-equal name ""))
                     (/= (aref name 0) ?\s)
                     (string-match "^[^\*]" name))
            (cl-incf killed-bufs)
            (funcall 'kill-buffer buffer))))
      (message "Killed %d buffer(s)" killed-bufs))))
#+END_SRC
*** delq*
Like =delq= but removes more than just one item.
#+BEGIN_SRC emacs-lisp
(defun delq* (list &rest elems)
  "Remove ELEMS from LIST"
  (let ((l list))
    (mapc (lambda (item) (setq l (delq item l))) elems)
    l))
#+END_SRC
** Package repos
Add ~melpa~ package archive.
#+BEGIN_SRC emacs-lisp
(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
(package-initialize)
(unless package-archive-contents (package-refresh-contents)) ;; Update archives
#+END_SRC
** use-package
Install ~use-package~. From now on I will use ~use-package~ to install and configure packages.
#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package) (package-install 'use-package))
#+END_SRC
*** diminish
diminish.el provides a way to hide mode indicators from mode line. Either pass ~:diminish t~ to use-package while installing or just call ~diminish 'x-mode)~.
#+BEGIN_SRC emacs-lisp
(use-package diminish :ensure t)
#+END_SRC
* Basics
** Sane defaults
#+BEGIN_SRC emacs-lisp
(global-visual-line-mode t)      ;; Wrap long lines
(diminish 'visual-line-mode)
(fset 'yes-or-no-p 'y-or-n-p)    ;; Ask y/n instead of yes/no
(setq ring-bell-function 'ignore ;; this completely disables alarms
      column-number-mode t       ;; Show column number
      make-backup-files nil)     ;; Disable backup files
#+END_SRC

Save recent files.
#+BEGIN_SRC emacs-lisp
(recentf-mode 1)
#+END_SRC
** Better scrolling
*** Better settings for mouse scroll.
#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
#+END_SRC
*** Mouse shortcuts for zooming
#+BEGIN_SRC emacs-lisp
(global-set-key [C-mouse-4] 'text-scale-increase)
(global-set-key [C-mouse-5] 'text-scale-decrease)
#+END_SRC
*** Conservative scrolling
If the cursor is at the end of the file, when you scroll emacs does a strange jump. This fixes it.
#+BEGIN_SRC emacs-lisp
(setq scroll-conservatively 100) ;; When cursor reaches end, just scroll line-by-line
#+END_SRC
** Place all backup files in same directory
Instead of having a file that ends with ~ or '# files in same directory, save all backup files in ~/.emacs.d/backups.
#+BEGIN_SRC emacs-lisp
(defconst backup-dir "~/.emacs.d/backups/")
(mkdir-if-not backup-dir)

(setq backup-directory-alist `((".*" . ,backup-dir)))
(setq auto-save-file-name-transforms `((".*" ,backup-dir t)))
#+END_SRC
** Undo tree (Persistent undo and stuff)
- ~undo-tree~ gives a persistent undo.
- Also it keeps undo history as a tree instead of a linear history. ~undo-tree-visualize~ may help.
#+BEGIN_SRC emacs-lisp
(defconst undo-dir "~/.emacs.d/undo/")
(mkdir-if-not undo-dir)

(use-package undo-tree
  :diminish undo-tree-mode
  :ensure t
  :init
    (setq undo-tree-auto-save-history t
          undo-tree-history-directory-alist `((".*" . ,undo-dir))
          undo-tree-enable-undo-in-region nil) ;; this fixes something?
  :config
  (global-undo-tree-mode))
#+END_SRC
** Remove trailing space before save
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook
          'delete-trailing-whitespace)
#+END_SRC
* Visuals
** General
Hide menubar and toolbar and replace blinking cursor with nice static box cursor.
#+BEGIN_SRC emacs-lisp
(menu-bar-mode 0)                ;; Disable menubar
(tool-bar-mode 0)                ;; Disable toolbar
(blink-cursor-mode 0)            ;; Disable blinking cursor
(scroll-bar-mode -1)             ;; Disable scrollbars
(setq inhibit-startup-message t) ;; Close startup screen
(global-hl-line-mode t)          ;; Highlight current line
#+END_SRC
** Fonts
#+BEGIN_SRC emacs-lisp
(add-hook 'after-make-frame-functions
  (lambda (frame)
    (with-selected-frame frame
      (set-face-attribute 'default nil
                          :font "IBM Plex Mono"
                          :weight 'normal
                          :width 'normal
                          :height 105))))
#+END_SRC
** Theme
Set a nicer theme.
#+BEGIN_SRC emacs-lisp
(add-hook 'after-make-frame-functions
  (lambda (frame)
    (with-selected-frame frame
      (use-package spacemacs-theme
        :ensure t
        :defer t
        :init
        (load-theme 'spacemacs-dark t)))))
#+END_SRC
** Frame title
Make window title contain buffer name so it's easier to identify windows. I use ~rofi~ to switch between windows in my DE, so it helps to have buffer name in window title.
#+BEGIN_SRC emacs-lisp
(setq frame-title-format "%b - emacs")
#+END_SRC
** Parentheses
*** Matching
Just enable parenthesis matching.
#+BEGIN_SRC emacs-lisp
(setq show-paren-style 'parenthesis)
(show-paren-mode 1)
#+END_SRC
*** Rainbow
Colors parantheses depending on their dept.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :config
  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC
** 80 column line limit and trailing spaces
This code highlights the portion of line that exceeds 80 columns and trailing spaces.
#+BEGIN_SRC emacs-lisp
(setq whitespace-line-column 80)
(setq whitespace-style '(face empty tabs lines-tail trailing))
(setq whitespace-global-modes '(not org-mode markdown-mode)) ;; Disable in org-mode and markdown-mode
(global-whitespace-mode t)
(diminish 'global-whitespace-mode)
#+END_SRC
** Shackle windows
Make some temproary windows appear at bottom.
#+BEGIN_SRC emacs-lisp
(shackle-window "\\*Help\\*" 0.4)
(shackle-window "\\*Warnings*\\*" 0.2)
(shackle-window "\\*Backtrace*\\*" 0.4)
(shackle-window "\\*Flycheck.*" 0.4)
(shackle-window "\\*Org Src.*\\*" 0.4)
(shackle-window "\\*Helm Swoop\\*" 0.4)
(shackle-window "\\*Agenda Commands\\*" 0.4)
(shackle-window "\\*Org Agenda\\*" 0.4)
#+END_SRC
** Spaces instead of tabs
#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4)
(setq-default indent-tabs-mode nil)
#+END_SRC
* evil-mode
** Install
#+BEGIN_SRC emacs-lisp
(use-package evil
  :ensure t
  :init
  (setq evil-want-integration t
        evil-want-keybinding nil
        evil-want-C-u-scroll t)
  :config
  (evil-mode 1))
#+END_SRC
*** Install evil keybindings for other modes
#+BEGIN_SRC emacs-lisp
(use-package evil-collection
  :ensure t
  :init
  (evil-collection-init))
#+END_SRC
** evil-leader
Enable leader key and bind some keys.
#+BEGIN_SRC emacs-lisp
(use-package evil-leader
  :ensure t
  :init
  (global-evil-leader-mode)
  :config
  (progn
    (evil-leader/set-leader "SPC")
    (evil-leader/set-key
      "SPC" 'helm-M-x
      "e" 'eval-last-sexp
      "r" 'helm-recentf
      "t" 'helm-elscreen
      "b" 'helm-buffers-list
      "g" 'projectile-find-file
      "RET" 'helm-mini)))
#+END_SRC
** evil-surround
#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  :ensure t
  :init
  (global-evil-surround-mode 1))
#+END_SRC
** Visual line movement
To move between visual lines instead of real lines:
#+BEGIN_SRC emacs-lisp
(setq-default evil-cross-lines t) ;; Make horizontal movement cross lines
(define-key evil-normal-state-map (kbd "<remap> <evil-next-line>") 'evil-next-visual-line)
(define-key evil-normal-state-map (kbd "<remap> <evil-previous-line>") 'evil-previous-visual-line)
(define-key evil-motion-state-map (kbd "<remap> <evil-next-line>") 'evil-next-visual-line)
(define-key evil-motion-state-map (kbd "<remap> <evil-previous-line>") 'evil-previous-visual-line)
#+END_SRC
** Change cursor color according to mode
#+BEGIN_SRC emacs-lisp
(setq evil-normal-state-cursor '("green" box))
(setq evil-visual-state-cursor '("orange" box))
(setq evil-emacs-state-cursor '("red" box))
(setq evil-insert-state-cursor '("red" bar))
(setq evil-replace-state-cursor '("red" bar))
(setq evil-operator-state-cursor '("red" hollow))
#+END_SRC
* org-mode
** Better defaults
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t) ;; Enable code highlighting in ~SRC~ blocks.
(setq org-ellipsis "..↯")         ;; Replace ... with ..↯ in collapsed sections
#+END_SRC
** Auto indent subsections
Automatically invoke ~org-indent-mode~ which gives nice little indentation under subsections. It makes reading easier.
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook (lambda () (org-indent-mode t)) t) ;; FIXME: theme
(diminish 'org-indent-mode)
#+END_SRC
** Nice bullets
Make headings look better with nice bullets. It also adjusts the size of headings according to their level.
#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :ensure t
  :init
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode t))))
#+END_SRC
** Babel
*** Load languages
These are the languages that can be run in codeblocks.
#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((scheme . t)
   (python . t)))
#+END_SRC
*** Don't ask permissions for evaluating code blocks
#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+END_SRC
*** Set default scheme implementation as ~guile~
#+BEGIN_SRC emacs-lisp
(use-package geiser
  :ensure t
  :init
  (setq geiser-default-implementation 'guile))
#+END_SRC
** Exports
#+BEGIN_SRC emacs-lisp
(use-package htmlize :ensure t)
#+END_SRC
** Helper functions
*** org-X-today
#+BEGIN_SRC emacs-lisp
(defun current-date nil
  (shell-command-to-string "sh -c 'echo -n $(date \"+%Y-%m-%d %a\")'"))

(defun insert-current-date nil
  (interactive)
  (insert (current-date)))

(defun org-x-today (x)
  (end-of-line)
  (newline)
  (insert (concat (upcase x) ": <" (current-date) ">")))

(defun org-deadline-today nil
  (interactive)
  (org-x-today "deadline"))

(defun org-schedule-today nil
  (interactive)
  (org-x-today "scheduled"))
#+END_SRC
** Agenda
   #+BEGIN_SRC emacs-lisp
(setq org-agenda-files '("~/Documents/notes/life.org"))

(setq org-agenda-use-time-grid t)
(setq org-agenda-time-grid '((weekly today require-timed remove-match)
                             (800 1000 1200 1400 1600 1800 2000 2200) "......" "----------------"))
   #+END_SRC
* Other packages
** which-key
A package that shows key combinations. (for example press C-x and wait) It also works with ~evil-leader~, just press leader key and wait to see your options.
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :diminish which-key-mode
  :config
  (which-key-mode))
#+END_SRC
** goto-chg
#+BEGIN_SRC emacs-lisp
(use-package goto-chg
  :ensure t)
#+END_SRC
** eyebrowse/tabs
#+BEGIN_SRC emacs-lisp
(use-package eyebrowse
  :ensure t
  :diminish eyebrowse-mode
  :init
  (setq eyebrowse-new-workspace t)
  :config
  (progn
    (define-key eyebrowse-mode-map (kbd "M-1") 'eyebrowse-switch-to-window-config-1)
    (define-key eyebrowse-mode-map (kbd "M-2") 'eyebrowse-switch-to-window-config-2)
    (define-key eyebrowse-mode-map (kbd "M-3") 'eyebrowse-switch-to-window-config-3)
    (define-key eyebrowse-mode-map (kbd "M-4") 'eyebrowse-switch-to-window-config-4)
    (define-key eyebrowse-mode-map (kbd "M-5") 'eyebrowse-switch-to-window-config-5)
    (define-key evil-normal-state-map (kbd "M-.") 'eyebrowse-next-window-config)
    (define-key evil-normal-state-map (kbd "M-,") 'eyebrowse-prev-window-config)
    (eyebrowse-mode t)))
#+END_SRC
** key-chord
*** Install and configure
#+BEGIN_SRC emacs-lisp
(use-package key-chord
  :ensure t
  :diminish key-chord-mode
  :init
  (setq key-chord-one-key-delay 0.3    ;; 0.3 secons delay for hitting same key (eg. aa)
        key-chord-two-keys-delay 0.25) ;; delay hitting two different keys (eg. jk)
  :config
  (key-chord-mode 1))
#+END_SRC
*** Bindings
#+BEGIN_SRC emacs-lisp
(key-chord-define evil-insert-state-map "jk" 'evil-normal-state) ;; jk returns to norman mode, from insert mode
(key-chord-define evil-normal-state-map "ff" 'evil-toggle-fold) ;; ff toggles folding
#+END_SRC
** avy
avy is very similar to ~vim-easymotion~. It simply jumps to a visible text using a given char.
#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :init
  (setq avy-keys '(?q ?w ?e ?r ?a ?s ?d ?f ?j ?k ?l ?u ?i ?o ?p)))
#+END_SRC
*** Bindings
#+BEGIN_SRC emacs-lisp
(define-key evil-normal-state-map (kbd "s") 'avy-goto-char)   ;; Go to any char
(define-key evil-normal-state-map (kbd "S") 'avy-goto-word-1) ;; Go to beginning of a word
#+END_SRC
** helm
*** Enable and set defaults
#+BEGIN_SRC emacs-lisp
(use-package helm
  :ensure t
  :diminish helm-mode
  :init
  (setq helm-mode-fuzzy-match t
        helm-completion-in-region-fuzzy-match t
        helm-candidate-number-limit 100
        projectile-completion-system 'helm)
  :config
  (progn
    (helm-mode 1)
    (helm-adaptive-mode 1)
    (shackle-window "\\*helm*" 0.35))) ;; make helm windows appear at bottom
#+END_SRC
*** Extension packages
#+BEGIN_SRC emacs-lisp
(use-package helm-swoop :ensure t)
#+END_SRC
*** Better selection
Set ~<tab>~ and ~Alt-j~ for selecting next result and ~<backtab>~ and ~Alt-k~ for selecting previous result.
#+BEGIN_SRC emacs-lisp
(define-key helm-map (kbd "TAB") 'helm-next-line)
(define-key helm-map (kbd "<backtab>") 'helm-previous-line)
(define-key helm-map (kbd "M-j") 'helm-next-line)
(define-key helm-map (kbd "M-k") 'helm-previous-line)
#+END_SRC
** projectile
A project management tool. I set a project path below and make sure projectile scans that directory for projects.
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :diminish projectile-mode
  :init
  (setq projectile-completion-system 'helm
        projectile-enable-caching t
        projectile-project-search-path '("~/Workspace/projects")) ;; This may take more paths as argument
  :config
  (progn
    (projectile-discover-projects-in-search-path)
    (setq projectile-globally-ignored-files (append '("Cargo.lock"))
          projectile-globally-ignored-directories (append '(".stack-work" "target"))
          projectile-globally-ignored-file-suffixes (append '("~" ".rs.bk")))
    (projectile-mode)))
;; FIXME: ignored stuff still showing up in projectile-find-file
#+END_SRC
** flycheck
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :init (global-flycheck-mode))

;; show errors in tooltip while hovering
(use-package flycheck-pos-tip
  :ensure t
  :config
  (with-eval-after-load 'flycheck (flycheck-pos-tip-mode)))
#+END_SRC
** company
*** Install and configure
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :init
  (setq company-selection-wrap-around t  ;; start completing after 1 char
        company-minimum-prefix-length 1) ;; return to first completion after the last one (cycles)
  :config
  (progn
    (add-hook 'after-init-hook 'global-company-mode)
    (company-tng-configure-default)))    ;; cycle trough suggestions using tab
#+END_SRC
*** quickhelp
Shows a nice tooltip while idling on a completion.
#+BEGIN_SRC emacs-lisp
(use-package company-quickhelp
  :ensure t
  :config
  (progn
    (company-quickhelp-mode))
    (eval-after-load 'company '(define-key company-active-map (kbd "M-p") 'company-quickhelp-manual-begin))) ;; Alt-p shows the popup manually
#+END_SRC
** TODO eshell
Get bash/fish aliases and update eshell aliases.
#+BEGIN_SRC emacs-lisp
(defun eshell-update-aliases-if-needed nil
  (interactive)
  (when (file-newer-than-file-p "~/.config/aliases" eshell-aliases-file)
      (progn
          (shell-command-to-string (concat "fish -c \"alias | sed 's/\\'//g; s/\\$/ \\$\\*/' > "
                                           eshell-aliases-file
                                           "\""))
          (eshell-read-aliases-list))))

(add-hook 'eshell-mode-hook 'eshell-update-aliases-if-needed)
#+END_SRC
** ispell
- Use =flyspell-mode= to start spell checking.
#+BEGIN_SRC emacs-lisp
(setq ispell-program-name "hunspell"
      ispell-local-dictionary "en_US"
      ispell-local-dictionary-alist
      '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)))

(add-hook 'org-mode-hook 'flyspell-mode)
(add-hook 'markdown-mode-hook 'flyspell-mode)
#+END_SRC
* Keybindings
- For leader key bindings, see: [[*evil-leader][evil-leader]]
- For key-chord  bindings, see: [[*Bindings][key-chord/bindings]]
- For avy        bindings, see: [[*Bindings][avy/bindings]]
** Some general keybindings
| Key   | Action              |
|-------+---------------------|
| <ESC> | quit current action |
| C-s   | save buffer         |

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
(global-set-key (kbd "C-s") 'save-buffer)
#+END_SRC
** Better split management
- A-- splits below, A-\ splits right.
- A-h,j,k,l to switch between splits.
- A-H,J,K,L shrink, enlarge split.
#+BEGIN_SRC emacs-lisp
(evil-define-key 'normal 'global
  (kbd "M-\\") 'split-window-right
  (kbd "M--") 'split-window-below
  (kbd "M-J") 'enlarge-window
  (kbd "M-K") 'shrink-window
  (kbd "M-L") 'enlarge-window-horizontally
  (kbd "M-H") 'shrink-window-horizontally)

;; This is needed to override other modes mappings
(define-minor-mode movement-map-mode
  "Overrides all major and minor mode keys" t)

(defvar movement-map (make-sparse-keymap "movement-map")
  "Override all major and minor mode keys")

(add-to-list 'emulation-mode-map-alists
  `((movement-map-mode . ,movement-map)))

(evil-define-key 'normal movement-map
  (kbd "M-j") 'evil-window-down
  (kbd "M-k") 'evil-window-up
  (kbd "M-h") 'evil-window-left
  (kbd "M-l") 'evil-window-right)

(evil-make-intercept-map movement-map)
#+END_SRC
** Move in insert mode
- Use A-h,j,k,l to move in insert mode.
- Some extra for ~eshell~:
  - A-j selects next matching input
  - A-k selects previous matching input
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert 'global
  (kbd "M-l") 'forward-char
  (kbd "M-h") 'backward-char
  (kbd "M-j") 'next-line
  (kbd "M-k") 'previous-line)

(evil-define-key 'insert eshell-mode-map
  (kbd "M-j") 'eshell-next-matching-input-from-input
  (kbd "M-k") 'eshell-previous-matching-input-from-input)

(evil-define-key 'insert geiser-repl-mode-map
  (kbd "M-j") 'comint-next-matching-input-from-input
  (kbd "M-k") 'comint-previous-matching-input-from-input)
#+END_SRC
** evil bindings for org-mode
#+BEGIN_SRC emacs-lisp
(evil-define-key 'normal org-mode-map
  "[" 'org-previous-visible-heading
  "]" 'org-next-visible-heading
  "-" 'org-cycle-list-bullet
  "H" 'org-shiftleft
  "J" 'org-shiftdown
  "K" 'org-shiftup
  "L" 'org-shiftright
  (kbd "M-H") 'org-shiftmetaleft
  (kbd "M-J") 'org-shiftmetadown
  (kbd "M-K") 'org-shiftmetaup
  (kbd "M-L") 'org-shiftmetaright

;; FIXME: M-h,j,k,l conflicts with split swithcing shourtcuts
;; so I just prefixed them with Hyper but this does not feel natural.
  (kbd "M-H-h") 'org-metaleft
  (kbd "M-H-j") 'org-metadown
  (kbd "M-H-k") 'org-metaup
  (kbd "M-H-l") 'org-metaright

  "t" 'org-todo
  "T" 'org-set-tags
  "E" 'org-ctrl-c-ctrl-c
  "O" 'org-open-at-point
  "Y" 'org-store-link)
#+END_SRC
** evil bindings for org-agenda
#+BEGIN_SRC emacs-lisp
(add-hook 'org-agenda-mode-hook
  (lambda ()
    (define-key org-agenda-mode-map "j" 'evil-next-line)
    (define-key org-agenda-mode-map "k" 'evil-previous-line)))
#+END_SRC
* Language specific
** markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :mode
  (("README\\.md\\'" . gfm-mode)
   ("\\.md\\'" . markdown-mode)
   ("\\.markdown\\'" . markdown-mode))
  :init
  (setq markdown-command "multimarkdown")
  :config
  (evil-define-key 'normal markdown-mode-map
    (kbd "TAB") 'markdown-cycle
    (kbd "]") 'markdown-outline-next
    (kbd "[") 'markdown-outline-previous))
#+END_SRC
** python
#+BEGIN_SRC emacs-lisp
(use-package elpy
  :ensure t
  :init
  :config
  (progn
    (elpy-enable)
    (add-hook 'elpy-mode-hook (lambda nil (which-function-mode nil))) ;; This mode causes IPython to freeze
    (setq elpy-modules (delq* elpy-modules 'elpy-module-flymake 'elpy-modules-django))))
#+END_SRC
** haskell
#+BEGIN_SRC emacs-lisp
(use-package haskell-mode :ensure t)
(use-package flycheck-haskell
  :ensure t
  :config
  (add-hook 'haskell-mode-hook #'flycheck-haskell-setup))
#+END_SRC
** rust
#+BEGIN_SRC emacs-lisp
(use-package rust-mode :ensure t)
#+END_SRC
