#+TITLE: Emacs configuration file
#+AUTHOR: İsa Mert Gürbüz
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes

* Introduction
This is my emacs configuration.
* Preparation
** Load path
Define the load path. (It's for auto-loading .el files)
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/load")
#+END_SRC
** Variables and functions
Some basic variable and function definitions that will be used in configuration.
*** mkdir-if-not
#+BEGIN_SRC emacs-lisp
(defun mkdir-if-not (dir)
"create the DIR if it does not exist"
    (unless (file-exists-p dir)
            (make-directory dir)))
#+END_SRC
*** shackle-window
Here is the [[https://www.reddit.com/r/emacs/comments/345vtl/make_helm_window_at_the_bottom_without_using_any/][source]].
#+BEGIN_SRC emacs-lisp
(defun shackle-window (name size)
"Make the buffer NAME appear at bottom of the window, filling SIZE percent of the window"
  (add-to-list 'display-buffer-alist
               `(,name
                  (display-buffer-in-side-window)
                  (inhibit-same-window . t)
                  (window-height . ,size))))
#+END_SRC
*** kill-all-buffers
source: https://github.com/azzamsa/scripts.el#kill-all-buffers
#+BEGIN_SRC emacs-lisp
(defun kill-all-other-buffers nil
  "Kill all buffers but current buffer and special buffers.
(Buffer that start with '*' and white space ignored)"
  (interactive)
  (when (y-or-n-p "Really kill all other buffers ? ")
    (let ((killed-bufs 0))
      (dolist (buffer (delq (current-buffer) (buffer-list)))
        (let ((name (buffer-name buffer)))
          (when (and name (not (string-equal name ""))
                     (/= (aref name 0) ?\s)
                     (string-match "^[^\*]" name))
            (cl-incf killed-bufs)
            (funcall 'kill-buffer buffer))))
      (message "Killed %d buffer(s)" killed-bufs))))
#+END_SRC
*** delq*
Like =delq= but removes more than just one item.
#+BEGIN_SRC emacs-lisp
(defun delq* (list &rest elems)
  "Remove ELEMS from LIST"
  (let ((l list))
    (mapc (lambda (item) (setq l (delq item l))) elems)
    l))
#+END_SRC
** Package repos
Add ~melpa~ package archive.
#+BEGIN_SRC emacs-lisp
(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
(package-initialize)
(unless package-archive-contents (package-refresh-contents)) ;; Update archives
#+END_SRC
** use-package
Install ~use-package~. From now on I will use ~use-package~ to install and configure packages.
#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package) (package-install 'use-package))
#+END_SRC
*** diminish
diminish.el provides a way to hide mode indicators from mode line. Either pass ~:diminish t~ to use-package while installing or just call ~diminish 'x-mode)~.
#+BEGIN_SRC emacs-lisp
(use-package diminish :ensure t)
#+END_SRC
* Basics
** Sane defaults
#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold 1600000)
(global-visual-line-mode t)      ;; Wrap long lines
(diminish 'visual-line-mode)
(fset 'yes-or-no-p 'y-or-n-p)    ;; Ask y/n instead of yes/no
(setq ring-bell-function 'ignore ;; this completely disables alarms
      column-number-mode t       ;; Show column number
      make-backup-files nil)     ;; Disable backup files
#+END_SRC

Save recent files.
#+BEGIN_SRC emacs-lisp
(recentf-mode t)
#+END_SRC
** Better scrolling
*** Better settings for mouse scroll.
#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
#+END_SRC
*** Mouse shortcuts for zooming
#+BEGIN_SRC emacs-lisp
(global-set-key [C-mouse-4] 'text-scale-increase)
(global-set-key [C-mouse-5] 'text-scale-decrease)
#+END_SRC
*** Conservative scrolling
If the cursor is at the end of the file, when you scroll emacs does a strange jump. This fixes it.
#+BEGIN_SRC emacs-lisp
(setq scroll-conservatively 100) ;; When cursor reaches end, just scroll line-by-line
#+END_SRC
** Place all backup files in same directory
Instead of having a file that ends with ~ or '# files in same directory, save all backup files in ~/.emacs.d/backups.
#+BEGIN_SRC emacs-lisp
(defconst backup-dir "~/.emacs.d/backups/")
(mkdir-if-not backup-dir)

(setq backup-directory-alist `((".*" . ,backup-dir)))
(setq auto-save-file-name-transforms `((".*" ,backup-dir t)))
#+END_SRC
** Undo tree (Persistent undo and stuff)
- ~undo-tree~ gives a persistent undo.
- Also it keeps undo history as a tree instead of a linear history. ~undo-tree-visualize~ may help.
#+BEGIN_SRC emacs-lisp
(defconst undo-dir "~/.emacs.d/undo/")
(mkdir-if-not undo-dir)

(use-package undo-tree
  :diminish undo-tree-mode
  :ensure t
  :init
    (setq undo-tree-auto-save-history t
          undo-tree-history-directory-alist `((".*" . ,undo-dir))
          undo-tree-enable-undo-in-region nil) ;; this fixes something?
  :config
  (global-undo-tree-mode))
#+END_SRC
** Remove trailing space before save
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook
          'delete-trailing-whitespace)
#+END_SRC
* Visuals
** General
Hide menubar and toolbar and replace blinking cursor with nice static box cursor.
#+BEGIN_SRC emacs-lisp
(menu-bar-mode 0)                ;; Disable menubar
(tool-bar-mode 0)                ;; Disable toolbar
(blink-cursor-mode 0)            ;; Disable blinking cursor
(scroll-bar-mode -1)             ;; Disable scrollbars
(setq inhibit-startup-message t) ;; Close startup screen
(global-hl-line-mode t)          ;; Highlight current line
#+END_SRC
** Fonts
#+BEGIN_SRC emacs-lisp
(add-hook 'after-make-frame-functions
  (lambda (frame)
    (with-selected-frame frame
      (set-face-attribute 'default nil
                          :font "Iosevka"
                          :weight 'normal
                          :width 'normal
                          :height 105))))
#+END_SRC
** Theme
Set a nicer theme.
#+BEGIN_SRC emacs-lisp
(add-hook 'after-make-frame-functions
  (lambda (frame)
    (with-selected-frame frame
      (use-package spacemacs-theme
        :ensure t
        :defer t
        :init
        (load-theme 'spacemacs-dark t)))))
#+END_SRC
** Frame title
Make window title contain buffer name so it's easier to identify windows. I use ~rofi~ to switch between windows in my DE, so it helps to have buffer name in window title.
#+BEGIN_SRC emacs-lisp
(setq frame-title-format "%b - emacs")
#+END_SRC
** Parentheses
*** Matching
Just enable parenthesis matching.
#+BEGIN_SRC emacs-lisp
(setq show-paren-style 'parenthesis)
(show-paren-mode 1)
#+END_SRC
*** Rainbow
Colors parantheses depending on their dept.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC
** 80 column line limit and trailing spaces
This code highlights the portion of line that exceeds 80 columns and trailing spaces.
#+BEGIN_SRC emacs-lisp
(setq whitespace-line-column 80)
(setq whitespace-style '(face empty tabs lines-tail trailing))
(setq whitespace-global-modes '(not org-mode markdown-mode)) ;; Disable in org-mode and markdown-mode
(global-whitespace-mode t)
(diminish 'global-whitespace-mode)
#+END_SRC
** Shackle windows
Make some temproary windows appear at bottom.
#+BEGIN_SRC emacs-lisp
(shackle-window "\\*Help\\*" 0.4)
(shackle-window "\\*Warnings*\\*" 0.2)
(shackle-window "\\*Backtrace*\\*" 0.4)
(shackle-window "\\*Flycheck.*" 0.4)
(shackle-window "\\*Org Src.*\\*" 0.4)
(shackle-window "\\*Agenda Commands\\*" 0.4)
(shackle-window "\\*Org Agenda\\*" 0.4)
(shackle-window "\\*Org Select\\*" 0.4)
(shackle-window "CAPTURE-*" 0.4)
(shackle-window "magit.*" 0.7)
(shackle-window "\\*xref\\*" 0.4)
(shackle-window "\\*Org-Babel Error Output\\*" 0.4)
(shackle-window "\\*curl error\\*" 0.4)
#+END_SRC
** Spaces instead of tabs
#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4)
(setq-default indent-tabs-mode nil)
#+END_SRC
* evil-mode
** Install
#+BEGIN_SRC emacs-lisp
(use-package evil
  :ensure t
  :init
  (setq evil-want-integration t
        evil-want-keybinding nil
        evil-want-C-u-scroll t)
  :config
  (evil-mode 1))
#+END_SRC
** evil-mc
Multiple cursors for evil. =C-n= to create a cursor on next match. =A= and =I= creates cursors in visual selection mode as you may expect.
#+BEGIN_SRC emacs-lisp
(use-package evil-mc
  :ensure t
  :diminish evil-mc-mode
  :config
  (progn
    (evil-define-key 'visual evil-mc-key-map
      "A" #'evil-mc-make-cursor-in-visual-selection-end
      "I" #'evil-mc-make-cursor-in-visual-selection-beg)
    (global-evil-mc-mode 1)))
#+END_SRC
** evil-surround
Change surroundings. Do =cs"'= to turn ="Hello world!"= into ='Hello world!'=.
- ='Hello world!'= ~cs'<q>~ =<q>Hello world!</q>=
- =Hel|lo= ~ysiw"~ ="Hello"= (| is the cursor position.)
- =Hello= ~ysw{~ ={ Hello }=  (~{[(~ adds spaces)
- =Hello= ~ysw}~ ={Hello}=    (~}])~ does not add spaces)
#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  :ensure t
  :init
  (global-evil-surround-mode 1))
#+END_SRC
** evil-escape
Return back to normal mode using ~jk~ from anywhere. It does not play well with multiple cursors, so use ~ESC~ to when using evil-mc related stuff.
#+BEGIN_SRC emacs-lisp
(use-package evil-escape
  :diminish
  :ensure t
  :init
  (setq evil-escape-key-sequence "jk"
        evil-escape-delay 0.2)
  :config
  (evil-escape-mode 1))
#+END_SRC
** evil-matchit
Jump between matching tags using ~%~, like =<div>...</div>=, ={...}= etc. =ci%=, =da%= etc. works as expected.
#+BEGIN_SRC emacs-lisp
(use-package evil-matchit
  :diminish
  :ensure t
  :config
  (global-evil-matchit-mode 1))
#+END_SRC
** Visual line movement
To move between visual lines instead of real lines:
#+BEGIN_SRC emacs-lisp
(setq-default evil-cross-lines t) ;; Make horizontal movement cross lines
(define-key evil-normal-state-map (kbd "<remap> <evil-next-line>") 'evil-next-visual-line)
(define-key evil-normal-state-map (kbd "<remap> <evil-previous-line>") 'evil-previous-visual-line)
(define-key evil-motion-state-map (kbd "<remap> <evil-next-line>") 'evil-next-visual-line)
(define-key evil-motion-state-map (kbd "<remap> <evil-previous-line>") 'evil-previous-visual-line)
#+END_SRC
** Change cursor color according to mode
#+BEGIN_SRC emacs-lisp
(setq evil-normal-state-cursor '("green" box)
      evil-visual-state-cursor '("orange" box)
      evil-emacs-state-cursor '("red" box)
      evil-insert-state-cursor '("red" bar)
      evil-replace-state-cursor '("red" bar)
      evil-operator-state-cursor '("red" hollow))
#+END_SRC
* org-mode
#+BEGIN_SRC emacs-lisp
(setq life-org "~/Documents/notes/life.org")
#+END_SRC
** Better defaults
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t         ;; Enable code highlighting in ~SRC~ blocks.
      org-ellipsis "..↯"                ;; Replace ... with ..↯ in collapsed sections
      org-hierarchical-todo-statistics t ;; Show all children in todo statistics [1/5]
)
#+END_SRC
** Auto indent subsections
Automatically invoke ~org-indent-mode~ which gives nice little indentation under subsections. It makes reading easier.
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook (lambda () (org-indent-mode t)) t)
(diminish 'org-indent-mode)
#+END_SRC
** Nice bullets
Make headings look better with nice bullets. It also adjusts the size of headings according to their level.
#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :ensure t
  :hook (org-mode . org-bullets-mode))
#+END_SRC
** Nice checkboxes
https://blog.jft.rocks/emacs/unicode-for-orgmode-checkboxes.html
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook (lambda ()
  "Beautify Org Checkbox Symbol"
  (push '("[ ]" . "☐") prettify-symbols-alist)
  (push '("[X]" . "☑" ) prettify-symbols-alist)
  (push '("[-]" . "❍" ) prettify-symbols-alist)
  (prettify-symbols-mode)))

(defface org-checkbox-done-text
  '((t (:foreground "#71696A" :strike-through t)))
  "Face for the text part of a checked org-mode checkbox.")
#+END_SRC
** Babel
*** Install extra languages
**** ob-http
- Http request in org-mode babel.
#+BEGIN_SRC emacs-lisp
(use-package ob-http
  :ensure t)
#+END_SRC
*** Load languages
These are the languages that can be run in codeblocks.
#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (scheme . t)
   (python . t)
   (js . t)
   (shell . t)
   (http . t)))
#+END_SRC
*** Don't ask permissions for evaluating code blocks
#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+END_SRC
*** Set default scheme implementation as ~guile~
#+BEGIN_SRC emacs-lisp
(use-package geiser
  :ensure t
  :init
  (setq geiser-default-implementation 'guile))
#+END_SRC
** Exports
*** HTML
#+BEGIN_SRC emacs-lisp
(use-package htmlize :ensure t)
#+END_SRC
*** iCalendar settings
#+BEGIN_SRC emacs-lisp
(setq org-icalendar-store-UID t
      org-icalendar-alarm-time 15
      org-icalendar-use-scheduled '(todo-start event-if-todo)
      org-icalendar-use-deadline '(todo-due event-if-todo))
#+END_SRC
** Helper functions
*** org-X-today
#+BEGIN_SRC emacs-lisp
(defun current-date nil
  (shell-command-to-string "sh -c 'echo -n $(date \"+%Y-%m-%d %a\")'"))

(defun insert-current-date nil
  (interactive)
  (insert (current-date)))

(defun org-x-today (x)
  (end-of-line)
  (newline)
  (insert (concat (upcase x) ": <" (current-date) ">")))

(defun org-deadline-today nil
  (interactive)
  (org-x-today "deadline"))

(defun org-schedule-today nil
  (interactive)
  (org-x-today "scheduled"))
#+END_SRC
** Agenda
#+BEGIN_SRC emacs-lisp
(setq org-agenda-files `(,life-org)
      org-agenda-use-time-grid t
      org-agenda-time-grid '((weekly today require-timed remove-match)
                             (800 1000 1200 1400 1600 1800 2000 2200) "......" "----------------"))
#+END_SRC
** todo keywords
#+BEGIN_SRC emacs-lisp
;; Add this to org files if you need:
;; #+TODO: TODO IN-PROGRESS WAITING DONE
;; OR
;; (setq org-todo-keywords
;;   '((sequence "TODO" "IN-PROGRESS" "WAITING" "DONE")))

(setq org-todo-keyword-faces
      '(("WAITING" . (:foreground "yellow" :weight bold))
        ("IN-PROGRESS" . (:foreground "magenta" :weight bold))))
#+END_SRC
** sticky headers
#+BEGIN_SRC
(use-package org-sticky-header
  :ensure t
  :hook (org-mode . org-sticky-header-mode))
#+END_SRC
** TODO org-capture
- [ ] Add a shortcut.
- [ ] Add more templates.
- [ ] Maybe add a way to call it outside of emacs.
#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
      '(("t" "Todo" entry (file+headline life-org "Current")
         "* TODO %?\n  %i\n  %a")))
#+END_SRC
* Other packages
** beacon
When you switch buffers/frames, it simply highlights the current line with a quick animation.
#+BEGIN_SRC emacs-lisp
(use-package beacon
  :ensure t
  :diminish beacon-mode
  :init
  (setq beacon-blink-duration 2)
  :config
  (beacon-mode 1))
#+END_SRC
** winner-mode
This mode allows you to do /undo/ /redo/ operations on window layout changes. My most frequent use case is that sometimes I just want to focus on one window for a while and then return back to my old layout setup. These keybindings allows me to do that.
#+BEGIN_SRC emacs-lisp
(setq winner-dont-bind-my-keys t)
(winner-mode t)
(evil-define-key 'normal 'global
  (kbd "C-w 1") 'delete-other-windows
  (kbd "C-w r") 'winner-redo
  (kbd "C-w u") 'winner-undo)
#+END_SRC
** which-key
A package that shows key combinations. (for example press C-x and wait) It also works with ~evil-leader~, just press leader key and wait to see your options.
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :diminish which-key-mode
  :config
  (which-key-mode))
#+END_SRC
** goto-chg
=g;= goes to the last change. (repeatable)
#+BEGIN_SRC emacs-lisp
(use-package goto-chg
  :ensure t)
#+END_SRC
** eyebrowse
Eyebrowse creates pre-defined workspaces. Don't use them like tabs, I generally use every workspace for different projects/different contexts.
#+BEGIN_SRC emacs-lisp
(use-package eyebrowse
  :ensure t
  :diminish eyebrowse-mode
  :init
  (setq eyebrowse-new-workspace t)
  :config
  (progn
    (define-key eyebrowse-mode-map (kbd "M-1") 'eyebrowse-switch-to-window-config-1)
    (define-key eyebrowse-mode-map (kbd "M-2") 'eyebrowse-switch-to-window-config-2)
    (define-key eyebrowse-mode-map (kbd "M-3") 'eyebrowse-switch-to-window-config-3)
    (define-key eyebrowse-mode-map (kbd "M-4") 'eyebrowse-switch-to-window-config-4)
    (define-key eyebrowse-mode-map (kbd "M-5") 'eyebrowse-switch-to-window-config-5)
    (define-key evil-normal-state-map (kbd "M-.") 'eyebrowse-next-window-config)
    (define-key evil-normal-state-map (kbd "M-,") 'eyebrowse-prev-window-config)
    (eyebrowse-mode t)))
#+END_SRC
** avy
avy is very similar to ~vim-easymotion~. It simply jumps to a visible text using a given char. Hit ~s~ and the char you want to jump.
#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :init
  (setq avy-keys '(?q ?w ?e ?r ?t ?a ?s ?d ?f ?j ?k ?l ?u ?i ?o ?p ?1 ?2 ?3 ?4 ?5))) ;; Only use these for jumping.
#+END_SRC
*** Bindings
#+BEGIN_SRC emacs-lisp
(define-key evil-normal-state-map (kbd "s") 'avy-goto-char)   ;; Go to any char
(define-key evil-normal-state-map (kbd "S") 'avy-goto-word-1) ;; Go to beginning of a word
#+END_SRC
** helm
*** Enable and set defaults
#+BEGIN_SRC emacs-lisp
(use-package helm
  :ensure t
  :diminish helm-mode
  :init
  (setq helm-mode-fuzzy-match t
        helm-completion-in-region-fuzzy-match t
        helm-candidate-number-limit 100
        projectile-completion-system 'helm)
  :config
  (progn
    (helm-mode 1)
    (helm-adaptive-mode 1)
    (shackle-window "\\*[hH]elm*" 0.35))) ;; make helm windows appear at bottom
#+END_SRC
*** Better selection
Set ~<tab>~ and ~Alt-j~ for selecting next result and ~<backtab>~ and ~Alt-k~ for selecting previous result.
#+BEGIN_SRC emacs-lisp
(define-key helm-map (kbd "M-`") 'helm-select-action)
(define-key helm-map (kbd "M-RET") 'helm-execute-persistent-action)
(define-key helm-map (kbd "TAB") 'helm-next-line)
(define-key helm-map (kbd "<backtab>") 'helm-previous-line)
(define-key helm-map (kbd "M-j") 'helm-next-line)
(define-key helm-map (kbd "M-k") 'helm-previous-line)
#+END_SRC
*** helm-rg (ripgrep)
#+BEGIN_SRC emacs-lisp
(use-package helm-rg
  :ensure t)
#+END_SRC
** projectile
A project management tool. I set a project path below and make sure projectile scans that directory for projects.
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :diminish projectile-mode
  :init
  (setq projectile-completion-system 'helm
        projectile-enable-caching t
        projectile-project-search-path '("~/Workspace/projects")) ;; This may take more paths as argument
  :config
  (progn
    (projectile-discover-projects-in-search-path)
    (setq projectile-globally-ignored-files (append '("Cargo.lock" ".tern-port"))
          projectile-globally-ignored-directories (append '(".stack-work" "target" "node_modules"))
          projectile-globally-ignored-file-suffixes (append '("~" ".rs.bk")))
    (projectile-mode)))
#+END_SRC
** flycheck
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :diminish
  :ensure t
  :init (global-flycheck-mode)
  :config
  (setq flycheck-idle-change-delay 1
        flycheck-check-syntax-automatically '(save new-line mode-enabled))) ;; (save idle-change new-line mode-enabled)

;; show errors in tooltip while hovering
(use-package flycheck-pos-tip
  :ensure t
  :after flycheck
  :hook (flycheck-mode . flycheck-pos-tip-mode)
  :init
  (setq flycheck-pos-tip-timeout 15)) ;; Show tooltip for 15 seconds
#+END_SRC

** company
*** Install and configure
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :init
  (setq company-selection-wrap-around t  ;; return to first completion after the last one (cycles)
        company-minimum-prefix-length 1) ;; start completing after 1 char
  :config
  (progn
    (add-hook 'after-init-hook 'global-company-mode)
    (company-tng-configure-default)   ;; cycle trough suggestions using tab
    (evil-define-key 'insert 'global
      (kbd "M-i") 'company-complete)))
#+END_SRC
*** quickhelp
Shows a nice tooltip while idling on a completion.
#+BEGIN_SRC emacs-lisp
(use-package company-quickhelp
  :ensure t
  :config
  (progn
    (company-quickhelp-mode))
    (eval-after-load 'company '(define-key company-active-map (kbd "M-p") 'company-quickhelp-manual-begin))) ;; Alt-p shows the popup manually
#+END_SRC
** origami-mode
This seems working better than =hs-minor-mode= and also it's supposedly works with =lsp-mode=.
#+BEGIN_SRC emacs-lisp
(use-package origami
  :hook ((web-mode . origami-mode)
          (js-mode . origami-mode)))
#+END_SRC
** lsp-mode
#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :commands lsp
  ;;:hook ((web-mode . lsp)
  ;;       (js-mode . lsp))
  :init
  (setq lsp-prefer-flymake :none
        lsp-use-native-json t
        lsp-enable-xref t
        lsp-enable-links t
        lsp-enable-folding t
        lsp-enable-symbol-highlighting t
        lsp-enable-indentation nil
        lsp-enable-on-type-formatting nil
        lsp-before-save-edits nil
        lsp-enable-indentation nil
        ;;lsp-enable-completion-at-point nil
        lsp-enable-snippet nil))

;; FIXME: lsp-prefer-flymake :none disables both flymake and flycheck. Set it to nil to use flycheck. Also set to :none for only web-mode and js-mode because I use eslint there.

;;(use-package lsp-ui :commands lsp-ui-mode)
;; (use-package company-lsp
;;   :ensure t
;;   :commands company-lsp)

;; FIXME: (wrong-type-argument overlayp nil)
;; (use-package lsp-origami
;;   :ensure t
;;   :hook ((origami-mode . lsp-origami-mode)))

(use-package helm-lsp
  :ensure t
  :commands helm-lsp-workspace-symbol)

(use-package dap-mode
  :ensure t :after lsp-mode
  :config
  (dap-mode t)
  (dap-ui-mode t))
#+END_SRC

#+RESULTS:

** eshell
*** aliases
Get bash aliases and update eshell aliases. My aliases are in a file called =~/.config/aliases= in bash format. I convert them to abbreviations in fish shell and I convert them to eshell aliases in here.
#+BEGIN_SRC emacs-lisp
(defun eshell-update-aliases-if-needed nil
  (interactive)
  (when (file-newer-than-file-p "~/.config/aliases" eshell-aliases-file)
      (progn
          (shell-command-to-string
            (concat
              "grep -vE '^(#|$)' ~/.config/aliases"
              "|"
              "sed -r 's/=/ /; s/(.*)\".*/\\1 $*/; s/\"//;' "
              ">"
              eshell-aliases-file
              ))
          (eshell-read-aliases-list))))

(add-hook 'eshell-mode-hook 'eshell-update-aliases-if-needed)
#+END_SRC
*** clear
#+BEGIN_SRC emacs-lisp
(defun eshell-clear-buffer ()
  "Clear terminal"
  (interactive)
  (let ((inhibit-read-only t))
    (erase-buffer)))

(defun eshell/clear nil
  (eshell-clear-buffer))
#+END_SRC
** ispell
- Use =flyspell-mode= to start spell checking.
#+BEGIN_SRC emacs-lisp
(setq ispell-program-name "hunspell"
      ispell-local-dictionary "en_US"
      ispell-local-dictionary-alist
      '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)))

(add-hook 'org-mode-hook 'flyspell-mode)
(add-hook 'markdown-mode-hook 'flyspell-mode)
#+END_SRC
** treemacs
#+BEGIN_SRC emacs-lisp
(use-package treemacs
  :ensure t
  :defer t
  :config
  (progn
    (setq treemacs-show-hidden-files nil)
    (add-to-list 'treemacs-ignored-file-predicates (lambda (filename abspath) (string-equal filename "node_modules"))))
  :bind
  (:map global-map
    ("M-f" . treemacs)
    ("M-j" . evil-window-down)
    ("M-l" . evil-window-right)))

(use-package treemacs-evil
  :after treemacs evil
  :ensure t)

(use-package treemacs-projectile
  :after treemacs projectile
  :ensure t)

(use-package treemacs-icons-dired
  :after treemacs dired
  :ensure t
  :config (treemacs-icons-dired-mode))

(use-package treemacs-magit
  :after treemacs magit
  :ensure t)
#+END_SRC

** telephone-line
#+BEGIN_SRC emacs-lisp
;; Color settings
;; I just extracted these 2 functions from the telephone-line source.
;; and only switched their colors.
(defface telephone-line-evil-insert
  '((t (:background "tomato" :inherit telephone-line-evil)))
  "Face used in evil color-coded segments when in Insert state."
  :group 'telephone-line-evil)

(defface telephone-line-evil-normal
  '((t (:background "dark slate blue" :inherit telephone-line-evil)))
  "Face used in evil color-coded segments when in Normal state."
  :group 'telephone-line-evil)

(use-package telephone-line
  :ensure t
  :config
    (progn
      ;; Separator settings
      (setq telephone-line-primary-left-separator 'telephone-line-cubed-left
            telephone-line-secondary-left-separator 'telephone-line-cubed-hollow-left
            telephone-line-primary-right-separator 'telephone-line-cubed-right
            telephone-line-secondary-right-separator 'telephone-line-cubed-hollow-right)

      ;; Define segments
      (setq telephone-line-lhs
          '((evil   . (telephone-line-evil-tag-segment))
            (accent . (telephone-line-vc-segment
                       telephone-line-process-segment))
            (nil    . (telephone-line-buffer-segment
                       telephone-line-minor-mode-segment))))

      (setq telephone-line-center-rhs
          '((nil    . (telephone-line-flycheck-segment))))

      (setq telephone-line-rhs
          '((nil    . (telephone-line-misc-info-segment))
            (accent . (telephone-line-major-mode-segment))
            (evil   . (telephone-line-airline-position-segment))))

      ;; Misc settings
      (setq telephone-line-height 20)
      (telephone-line-mode t)))
#+END_SRC
** expand-region
Select the nearest meaningful region with a keybinding. When you repeat it, it selects the next bigger meaningful region. Look [[*Keybindings][Keybindings]] for the binding.
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t)
#+END_SRC
** TODO orgmode #+completion stuff
** yasnippets
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :hook (prog-mode . yas-minor-mode)
  :config
  (progn
    (yas-reload-all)
    (setq yas-snippet-dirs
      '("~/.emacs.d/snippets"                   ;; personal snippets
        ))))
#+END_SRC
** sx
StackExchange package.
#+BEGIN_SRC emacs-lisp
(use-package sx
  :ensure t)
#+END_SRC

* Keybindings
- For leader key bindings, see: [[*evil-leader][evil-leader]]
- For avy        bindings, see: [[*Bindings][avy/bindings]]
** Some general keybindings
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)

(evil-define-key 'normal 'global
  "?"  'helm-semantic-or-imenu
  (kbd "M-e") 'er/expand-region
  (kbd "M-f") 'treemacs
  (kbd "C-f") 'helm-occur
  (kbd "C-s") 'save-buffer)

(evil-define-key 'normal prog-mode-map
  (kbd "M-;") 'comment-line
  (kbd "M-:") 'comment-dwim
  "gd" 'xref-find-definitions
  "gf" 'xref-find-references)

(evil-define-key 'insert prog-mode-map
  (kbd "M-s") 'company-yasnippet)
#+END_SRC
** evil-leader
Enable leader key and bind some keys.
#+BEGIN_SRC emacs-lisp
(defun execute-C-c-C-c ()
  (interactive)
  (execute-kbd-macro (kbd "C-c C-c")))

(use-package evil-leader
  :ensure t
  :init
  (global-evil-leader-mode)
  :config
  (progn
    (evil-leader/set-leader "SPC")
    (evil-leader/set-key
      ;; generic
      "SPC" 'helm-M-x
      "RET" 'helm-mini
      ";"   'eval-last-sexp
      "f"   'projectile-find-file
      "s"   'yas-insert-snippet
      "c"   'execute-C-c-C-c

      ;; magit
      "gg" 'magit-status
      "gp" 'magit-push

      ;; helm
      "hh" 'helm-resume
      "hr" 'helm-rg
      "hp" 'helm-projectile-rg

      ;; bookmarks
      "bb" 'helm-bookmarks
      "bs" 'bookmarks-set

      ;; projectile/project
      "pp" 'projectile-browse-dirty-projects
      "pf" 'projectile-find-file
      "ps" 'projectile-switch-project
      "pr" 'projectile-recentf)

      ;; Mode specific deletions
      (evil-leader/set-key-for-mode 'org-mode
        "d" 'org-babel-remove-result
        "D" 'my/org-babel-remove-all-results)

      ;; Mode specific evals
      (evil-leader/set-key-for-mode 'js-mode
        "e" 'indium-eval-region)
      (evil-leader/set-key-for-mode 'org-mode
        "e" 'org-babel-execute-src-block)
      (evil-leader/set-key-for-mode 'emacs-lisp-mode
        "e" 'eval-last-sexp)

      ;; Mode specific REPL jumps
      (evil-leader/set-key-for-mode 'js-mode
        "r" 'indium-switch-to-repl-buffer)
))
#+END_SRC
** Better split management
- A-- splits below, A-\ splits right.
- A-h,j,k,l to switch between splits.
- A-H,J,K,L shrink, enlarge split.
#+BEGIN_SRC emacs-lisp
(evil-define-key 'normal 'global
  (kbd "M-\\") 'split-window-right
  (kbd "M--") 'split-window-below
  (kbd "M-J") 'enlarge-window
  (kbd "M-K") 'shrink-window
  (kbd "M-L") 'enlarge-window-horizontally
  (kbd "M-H") 'shrink-window-horizontally)

;; This is needed to override other modes mappings
(define-minor-mode movement-map-mode
  "Overrides all major and minor mode keys" t)

(defvar movement-map (make-sparse-keymap "movement-map")
  "Override all major and minor mode keys")

(evil-define-key 'normal movement-map
  (kbd "M-j") 'evil-window-down
  (kbd "M-k") 'evil-window-up
  (kbd "M-h") 'evil-window-left
  (kbd "M-l") 'evil-window-right)

(evil-define-key 'normal treemacs-mode-map
  (kbd "M-j") 'evil-window-down
  (kbd "M-k") 'evil-window-up
  (kbd "M-h") 'evil-window-left
  (kbd "M-l") 'evil-window-right)

(evil-make-intercept-map movement-map)

(add-to-list 'emulation-mode-map-alists
  `((movement-map-mode . ,movement-map)))
#+END_SRC
** Move in insert mode
- Use A-h,j,k,l to move in insert mode.
- Some extra for ~eshell~:
  - A-j selects next matching input
  - A-k selects previous matching input
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert 'global
  (kbd "M-l") 'forward-char
  (kbd "M-h") 'backward-char
  (kbd "M-j") 'next-line
  (kbd "M-k") 'previous-line)

(evil-define-key 'insert eshell-mode-map
  (kbd "M-j") 'eshell-next-matching-input-from-input
  (kbd "M-k") 'eshell-previous-matching-input-from-input)

(evil-define-key 'insert geiser-repl-mode-map
  (kbd "M-j") 'comint-next-matching-input-from-input
  (kbd "M-k") 'comint-previous-matching-input-from-input)
#+END_SRC
** evil bindings for org-mode
#+BEGIN_SRC emacs-lisp
(evil-define-key 'normal org-mode-map
  "[" 'org-previous-visible-heading
  "]" 'org-next-visible-heading
  "-" 'org-cycle-list-bullet
  "H" 'org-shiftleft
  "J" 'org-shiftdown
  "K" 'org-shiftup
  "L" 'org-shiftright
  (kbd "M-H") 'org-shiftmetaleft
  (kbd "M-J") 'org-shiftmetadown
  (kbd "M-K") 'org-shiftmetaup
  (kbd "M-L") 'org-shiftmetaright

;; FIXME: M-h,j,k,l conflicts with split swithcing shourtcuts
;; so I just prefixed them with Hyper but this does not feel natural.
  (kbd "M-H-h") 'org-metaleft
  (kbd "M-H-j") 'org-metadown
  (kbd "M-H-k") 'org-metaup
  (kbd "M-H-l") 'org-metaright

  "t" 'org-todo
  "T" 'org-set-tags
  "E" 'org-ctrl-c-ctrl-c
  "O" 'org-open-at-point
  "Y" 'org-store-link)
#+END_SRC
*** evil bindings for org-agenda
#+BEGIN_SRC emacs-lisp
(add-hook 'org-agenda-mode-hook
  (lambda ()
    (define-key org-agenda-mode-map "j" 'evil-next-line)
    (define-key org-agenda-mode-map "k" 'evil-previous-line)))
#+END_SRC
** TODO Install evil keybindings for other modes
#+BEGIN_SRC
(use-package evil-collection
  :after evil
  :ensure t
  :config
  (evil-collection-init))
#+END_SRC
* Language specific
** git
#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :bind
  (:map magit-status-mode-map
    ("j" . 'next-line)
    ("k" . 'previous-line)))
#+END_SRC
** markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :mode
  (("README\\.md\\'" . gfm-mode)
   ("\\.md\\'" . markdown-mode)
   ("\\.markdown\\'" . markdown-mode))
  :init
  (setq markdown-command "multimarkdown")
  :config
  (evil-define-key 'normal markdown-mode-map
    (kbd "TAB") 'markdown-cycle
    (kbd "]") 'markdown-outline-next
    (kbd "[") 'markdown-outline-previous))
#+END_SRC
** python
#+BEGIN_SRC emacs-lisp
(use-package elpy
  :ensure t
  :init
  :config
  (progn
    (elpy-enable)
    (add-hook 'elpy-mode-hook (lambda nil (which-function-mode nil))) ;; This mode causes IPython to freeze
    (setq elpy-modules (delq* elpy-modules 'elpy-module-flymake 'elpy-modules-django))))
#+END_SRC
** haskell
#+BEGIN_SRC emacs-lisp
(use-package haskell-mode :ensure t)
(use-package flycheck-haskell
  :ensure t
  :hook (haskell-mode . flycheck-haskell-setup))
#+END_SRC
** rust
#+BEGIN_SRC emacs-lisp
(use-package rust-mode :ensure t)
#+END_SRC
** js
*** flycheck: use eslint executable from project dir
#+BEGIN_SRC emacs-lisp
(defun use-eslint-from-node-modules ()
  (let* ((root (locate-dominating-file
                (or (buffer-file-name) default-directory)
                "node_modules"))
         (eslint (and root (expand-file-name "node_modules/.bin/eslint" root))))
    (when (and eslint (file-executable-p eslint))
      (setq-local flycheck-javascript-eslint-executable eslint))))

(add-hook 'flycheck-mode-hook #'use-eslint-from-node-modules)
#+END_SRC
** java
#+BEGIN_SRC emacs-lisp
(use-package lsp-java :ensure t :after lsp
  :config (add-hook 'java-mode-hook 'lsp))

(use-package dap-java :after (lsp-java))
#+END_SRC
** web-mode
I use web-mode for JSX, it's simply better than emacs 27 JSX mode and js2-mode.
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :mode ("\\.jsx\\'")
  :init
  (setq web-mode-enable-current-element-highlight t
        web-mode-enable-current-column-highlight t
        web-mode-enable-auto-pairing t
        web-mode-enable-auto-closing t
        web-mode-enable-auto-opening t)

  ;; Use eslint with web-mode for jsx files
  (flycheck-add-mode 'javascript-eslint 'web-mode)

  :config
  ;; Change some colors and stuff
  (set-face-attribute 'web-mode-html-tag-face nil :weight 'bold)
  (set-face-attribute 'web-mode-keyword-face nil :weight 'bold)
  (set-face-attribute 'web-mode-function-call-face nil :weight 'normal :foreground "normal"))
#+END_SRC
** emmet-mode
Hit <C-j> after these and get:
- =a= ~<a href="|">|</a>~
- =.x= ~<div class="x"></div>~
- =br/= ~<br />~
- =p.x.y.z= ~<p className="x y z"></p>~ (Works well with JSX)
- ~input[type=text]~ ~<input type="text" name="" value=""/>~
- =a>b>c= ~<a href=""><b><c></c></b></a>~
- =b*3= ~<b></b><b></b><b></b>~
#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :ensure t
  :hook (web-mode css-mode sgml-mode)
  :init
  (setq emmet-expand-jsx-className? t
        emmet-self-closing-tag-style " /"))
#+END_SRC

* my/
#+BEGIN_SRC emacs-lisp
(defun my/org-babel-remove-all-results nil
  (interactive)
  (goto-char 1)
  (let ((total-removed 0))
    (while (org-babel-next-src-block)
      (when (org-babel-remove-result)
        (setq total-removed (+ total-removed 1))))
    (message (format "%d result blocks are removed." total-removed))))

;; see this: https://github.com/emacs-evil/evil/issues/301
(defun evil-fix-map nil
  (evil-insert)
  (evil-normal))

(defun helm-projectile-rg nil
  (interactive)
  (setq-local helm-rg-default-directory (projectile-project-root))
  (helm-rg nil)
  (setq-local helm-rg-default-directory 'default))
#+END_SRC
