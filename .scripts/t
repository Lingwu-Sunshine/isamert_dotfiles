#!/bin/bash

TF="$HOME/.tasks"
TPF="$HOME/.tasks_past"
INDENT=4
STR_UNDONE="- [ ] "
STR_DONE="- [X] "
DATE_FORMAT="+%d/%m/%y" # This should be something that `date` command recognizes

F_RED="$(tput setaf 9)" ;    F_GREEN="$(tput setaf 10)"
F_YELLOW="$(tput setaf 11)"; F_BLUE="$(tput setaf 12)"
F_MAGENTA="$(tput setab 13)"; F_CYAN="$(tput setab 14)"
F_DRED="$(tput setaf 1)" ;    F_DGREEN="$(tput setaf 2)"
F_DYELLOW="$(tput setaf 3)"; F_DBLUE="$(tput setaf 4)"
B_DMAGENTA="$(tput setab 5)"; B_DCYAN="$(tput setab 6)"

BOLD=$(tput bold)
R="$(tput sgr0)" # Reset

# #############################################################################
# Utility functions
# #############################################################################
function __is-number {
    case $1 in
        ''|*[!0-9]*) false ;;
        *) true ;;
    esac
}

function __starts-with {
    case $1 in
        "$2"*) true ;;
        *) false ;;
    esac
}

function __contains {
    case $1 in
        *$2*) false ;;
        *) true ;;
    esac
}

function __uppercase {
  tr 'a-z' 'A-Z'
}

function __lowercase {
  tr 'A-Z' 'a-z'
}

function __capitalize-word {
    echo "$(echo ${1:0:1} | __uppercase)${1:1}"
}

function __echon {
    if [ -n "$1" ] ; then echo "$@"; fi
}

function __split-at {
    delim="$1"; shift
    str="$@"
    if __contains "$str" "$delim"; then return; fi
    echo "${str#*"$delim"}"
}

function __escape {
    sed 's/[][`~!@#$%^&*()-_=+{}\|;:",<.>/?'"'"']/\\&/g' <<< "$1"
}

function __spaces {
    local count=$1
    if ((count<1)); then return; fi
    printf " %0.s" $(seq -s " " 1 $((count)))
}

function __count {
    str=$@
    if [[ -z "$str" ]]; then echo 0; else echo $(wc -l <<< $str); fi
}

function __prompt {
    question="$@"
    read -p "$question (y/N) " prompt
    [[ $prompt == "y" || $prompt == "Y" || $prompt == "yes" || $prompt == "Yes" ]] && return
    false
}

# #############################################################################
# Private functions
# #############################################################################
function __prop {
    local prop="$1"; shift
    local str="$@"
    echo "$(__split-at "-$prop:" "$str" | cut -d"-" -f1)"
}

function __prop-build {
    local prop="$1"
    local value="$2"
    echo "-$prop:$value-"
}

function __prop-escaped {
    echo $(__escape "$(__prop-build "$1" "$2")")
}

function __is-done {
    case "$@" in
        *"$STR_DONE"*) true ;;
        *) false ;;
    esac
}

function __fresh-id {
    # TODO: give lowest aviable
    local lines
    readarray -t lines < $TF
    for i in "${!lines[@]}"; do
        local line="${lines[$i]}"
        lines[$i]=$(__prop id "$line")
    done
    local IFS=$'\n'
    local result=$(echo "${lines[*]}" | sort -nr | head -n1)
    echo $((result+1))
}

function __id-line {
    local id="$1"
    echo "$(grep "$(__prop-escaped id $id)" $TF)"
}

function __id-exists {
    if [[ -z $(__id-line $1) ]]; then false; else true; fi
}

function __id-is-done {
    return $(__is-done "$(__id-line $1)")
}

function __leading-spaces {
    local line="$@"
    if __starts-with "$line" "#"; then echo -1; return; fi # TODO: to make it nested under # Stuff, change -1 to 0
    local spaces=$(echo "$line" | cut -d- -f1 | wc -c)
    echo $spaces
}

function __id-indent-level {
    id=$1
    local spaces=$(__leading-spaces "$(__id-line $id)")
    if [ $spaces -eq -1 ]; then echo -1; return; fi
    local result=$((spaces/INDENT))
    echo $result
}

function __id-line-no {
    id=$1
    local line_no=$(grep -n "$(__prop-escaped id $id)" $TF | cut -d: -f1)
    echo $line_no
}

function __id-property {
    id=$1
    local line_no=$(grep -n "$(__prop-escaped id $id)" $TF | cut -d: -f1)
    echo $((line_no))
}

function __id-children {
    local id=$1
    local opt=$2 # first or all
    local line_no=$(__id-line-no $id)
    local indent_level=$(__id-indent-level $id)
    local rest="$(tail -n +$((line_no+1)) $TF)"

    local children=()
    local IFS=$'\n'
    while read -r child; do
        local spaces="$(__leading-spaces "$child")"
        local child_indent_level=$((spaces/INDENT))
        if [[ $opt = "first" ]]; then
            if [ $child_indent_level -eq $((indent_level+1)) ]; then
                children+=("$child")
            else break; fi
        elif [[ $opt = "all" ]]; then
            if [ $child_indent_level -gt $indent_level ]; then children+=("$child")
            else break; fi
        else
            echo "Wrong arg, __id-children"
        fi
    done <<< "$rest"

    if [[ ${#children[@]} = 0 ]]; then
        return
    else
        printf '%s\n' "${children[@]}"
    fi
}

function __id-percent {
    local id=$1
    local children="$(__id-children $id first)"
    local total_child=$(__count "$children")
    local done_total="0"

    if [ $total_child -eq 0 ]; then
        if __id-is-done $id; then echo 100; else echo 0; fi
        return
    else
        while read -r child; do
            local current_percent=$(__id-percent $(__prop id "$child"))
            done_total=$((done_total+current_percent))
        done <<< "$children"
    fi

    echo $((done_total/total_child))
}

function __id-remove {
    local id="$1"
    local line_no=$(__id-line-no $id)
    local children="$(__id-children $id all)"
    local child_count=$(__count "$children")
    if [ $child_count -gt 0 ]; then
        if __prompt "This entry has children. Proceed?"; then
            while read -r child; do
                sed -i "/$(__escape "$child")/d" $TF
            done <<< "$children"
            sed -i "$line_no""d" $TF
        fi
    else
        sed -i "$line_no""d" $TF
    fi
}

function __id-replace {
    local IDS=""
    local IFS=','
    read -ra IDS <<< "$1"
    for id in "${IDS[@]}"; do
        line=$(__id-line-no $id)
        [[ -z $line ]] && return 1
        sed -i "$line""s/$(__escape "$2")/$(__escape "$3")/" $TF
    done
}

function __process {
    local str="$@"
    local date_str="$(__prop due "$str")"
    if [[ -n $date_str ]]; then
        date_fixed="$(date -d"$date_str" $DATE_FORMAT)"
        str=$(sed "s/$(__prop-escaped due "$date_str")/$(__prop-escaped due "$date_fixed")/" <<< $str)
    fi

    echo $str
}

function __get-decorator-id {
    case $1 in
        "@"*)
            local decor="$(echo $1 | sed "s/@/# /")"
            # FIXME: find more reliable way:
            # There is a space at the and so that full word gets matched:
            local id="$(__prop id $(grep -i "^$decor " $TF))"
            echo $id
            ;;
    esac
}

function __decorator-children {
    local decor_id="$1"
    local line_start=$(__id-line-no $decor_id)
    local line_end_relative=$(tail -n +$((line_start+1)) $TF | grep -Enm 1 '(^$|^#)'| cut -d: -f1)
    local line_end=$((line_start+line_end_relative-1)) # -1 because do not include blank|# line
    [[ -z $line_end_relative ]] && line_end=$(cat $TF | wc -l)
    sed -n "$line_start,$line_end""p;$((line_end+1))q" $TF | tail -n +2
}

function __maintain-today {
    local today_id=$(__get-decorator-id @today)
    local today_line="$(__id-line $today_id)"
    local today_day=$(echo "$today_line" | cut -d"(" -f2 | cut -d")" -f1)
    [[ "$today_day" = "$(date -dtoday $DATE_FORMAT)" ]] && return

    # Reset day
    local line_start=$(__id-line-no $today_id)
    sed -i "$line_start""s/$(__escape "($today_day)")/$(__escape "$(date -dtoday $DATE_FORMAT)")/" $TF

    # Backup
    local children="$(__decorator-children $today_id)"
    [ -z "$children" ] && return
    echo "# $today_day" >> $TPF
    echo "$children" >> $TPF
    echo "" >> $TPF

    # Remove
    while read -r child; do
        sed -i "/$(__escape "$child")/d" $TF
    done <<< "$children"
}

function __modify-decor-summary {
    # FIXME: change today,yestarday etc to local ones (if there are any)

    # If needed, call __process
    local decor=$1
    local summary="$2"
    notify-send $decor
    case $decor in
        "@today")
            summary="$(__process "$summary $(__prop-build due today)")"
            ;;
        "@daily")
            # TODO: maybe check if there is a -due prop and if so, fail
            ;;
        "@weekly")
            # TODO: check if there is a -due:day- prop
            ;;
    esac

    echo "$summary"
}

function __filter {
    local date="$1"; shift
    local param="$2"; shift
    local rest="$@"

    # TODO: add daily, check and add weekly
    local day_prop="$(__process "$(__prop-build due $date)")"
    term="$(__escape "$day_prop")"

    # Print daily
    __echon "$(__prettify "$(__decorator-children $(__get-decorator-id @daily))")"

    # Print weekly (of $date's)
    local day_name="$(date -d$date "+%A" | __lowercase)"
    __echon "$(__prettify "$(__decorator-children $(__get-decorator-id @weekly) | grep "\-due:$day_name\-")")"

    # Run search
    __echon "$(__prettify "$(grep "$term"  "$TF" | sed "s/^[ \t]*//")")"
}

function __prettify {
    local str="$@"
    local id_colored="$(echo "$str" | sed -r "s/^(.*)($(__escape "$STR_UNDONE")|$(__escape "$STR_DONE"))(.*)\-id:([^\s\-]+)\-(.*)/\1\2${BOLD}${F_DBLUE}\4${R} \3\5/")"
    local id_hidden="$(echo "$id_colored" | sed "s/\-id:.*\-//" | sed -r "s/\-([a-z]+):([^\s\-]+)\-/${F_DYELLOW}\1${R}:\2/g")"
    local bold_headers="$(echo "$id_hidden" | sed -r "s/^# (.*)/# ${BOLD}\1${R}/" )"
    echo "$bold_headers"
}

# #############################################################################
# Functions
# #############################################################################
function add {
    local id=$(__fresh-id)
    if __is-number $1 || __starts-with $1 "@" ; then
        local parent_id=$1
        shift
        local summary="$@"

        local parent_last_child=""
        if __starts-with $parent_id "@"; then
            summary="$(__modify-decor-summary "$parent_id" "$summary")"
            parent_id=$(__get-decorator-id $parent_id)
            parent_last_child="$(__decorator-children $parent_id all | tail -n -1)"
        else
            summary="$(__process "$summary")"
            parent_last_child="$(__id-children $parent_id all | tail -n -1)"
        fi

        if ! __id-exists $parent_id; then return 1; fi

        local parent_line=$(__id-line-no $parent_id)
        local parent_indent_level=$(__id-indent-level $parent_id)
        local spaces=$(__spaces $(((parent_indent_level+1)*INDENT)))
        local result="$(__escape  "$spaces$STR_UNDONE$summary $(__prop-build id $id)")"

        local line_to_insert
        if [[ -z $parent_last_child ]]; then
            line_to_insert=$((parent_line+1))
        else
            line_to_insert=$(($(__id-line-no $(__prop id "$parent_last_child"))+1))
        fi

        [ $line_to_insert -gt "$(echo $TF | wc -l)" ] && echo "" >> $TF
        sed -i "$line_to_insert""i\\$(echo "$result")" $TF
    else
        local result="$STR_UNDONE$(__process "$@ $(__prop-build id $id)")"
        local line_to_insert=$(grep -Enm 1 '(^$|^#)' $TF | cut -d: -f1)
        sed -i "$line_to_insert""i$(__escape "$result")" $TF
    fi

    # TODO: really need this? (maybe an extra function: clean, maintanence)
    # Remove trailing and leading blank lines
    sed -i -e :a -e '/./,$!d;/^\n*$/{$d;N;};/\n$/ba' $TF
}

function mark-done {
    __id-replace $1 "$STR_UNDONE" "$STR_DONE"
}

function mark-undone {
    __id-replace $1 "$STR_DONE" "$STR_UNDONE"
}

function remove {
    if __is-number ${1:0:1}; then
        # Remove based on ids
        local IDS
        local IFS=','
        read -ra IDS <<< "$1"
        for id in "${IDS[@]}"; do
            if __id-exists $id; then __id-remove $id; fi
        done
    else
        # TODO: Remove based on predicate
        local pred="$@"
        #sed -i "/$(__escape "$pred")/d"
    fi
}

function list {
    # TODO: make prop's colorful and stuff
    #sed 's/\-id:.//' $TF
    echo "$(__prettify "$(cat $TF)")"
}

function filter {
    local param="$1"; shift
    local rest="$@"

    local term
    case "$param" in
        "yesterday"|"today"|"tomorrow") __filter $param ;;
        "week")  __filter "week" ;;
        "@"*)
            local result="$(__decorator-children $(__get-decorator-id $param))"
            echo "# $(__capitalize-word ${param:1})"
            __echon "$result"
            ;;
        *)
            # TODO: check for exact dates
            #       filter summaries/notes etc.
            ;;
    esac
}

function modify {
    echo "xd"
}

# FIXME: more efficent way to do this? instead of checking everytime
# or just make the checking more efficent.
__maintain-today

param="$1"; shift
case "$param" in
    ""|"ls"|"list") list ;;
    "add") add "$@" ;;
    "remove"|"rm") remove "$@" ;;
    "done"|"d") mark-done "$@" ;;
    "undone"|"u") mark-undone "$@" ;;
    "filter"|"f") filter "$@" ;;
    "modify"|"m") modify "$@" ;;
    *) filter "$param" $@ ;;
esac

# TODO: add notes to TODOs
# TODO: modify -prop:xd- if it exists change, otherwise append
# TODO: Repeating tasks (Daily, Weekly, Monthly, Yearly), show them on `filter today, week etc.` (week may be next 7 days)
# TODO: column view (look for column command (ls -1 | column -c 100)
