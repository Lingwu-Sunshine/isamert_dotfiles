#!/bin/bash

TF="$HOME/.tasks"
TPF="$HOME/.tasks_past"
INDENT=4
STR_UNDONE="- [ ] "
STR_DONE="- [X] "
DATE_FORMAT="+%d/%m/%y" # This should be something that `date` command recognizes

F_RED="$(tput setaf 9)" ;    F_GREEN="$(tput setaf 10)"
F_YELLOW="$(tput setaf 11)"; F_BLUE="$(tput setaf 12)"
F_MAGENTA="$(tput setab 13)"; F_CYAN="$(tput setab 14)"
F_DRED="$(tput setaf 1)" ;    F_DGREEN="$(tput setaf 2)"
F_DYELLOW="$(tput setaf 3)"; F_DBLUE="$(tput setaf 4)"
B_DMAGENTA="$(tput setab 5)"; B_DCYAN="$(tput setab 6)"

BOLD=$(tput bold)
R="$(tput sgr0)" # Reset

# #############################################################################
# Utility functions
# #############################################################################
function __is_number {
    case $1 in
        ''|*[!0-9]*) false ;;
        *) true ;;
    esac
}

function __starts_with {
    case $1 in
        "$2"*) true ;;
        *) false ;;
    esac
}

function __contains {
    case $1 in
        *$2*) false ;;
        *) true ;;
    esac
}

function __uppercase {
  tr 'a-z' 'A-Z'
}

function __lowercase {
  tr 'A-Z' 'a-z'
}

function __capitalize_word {
    local str=${@:-$(</dev/stdin)}
    echo "$(echo ${str:0:1} | __uppercase)${str:1}"
}

function __echon {
    if [[ -n "$1" ]] ; then echo "$@"; fi
}

function __split_at {
    delim="$1"; shift
    str="$@"
    if __contains "$str" "$delim"; then return; fi
    echo "${str#*"$delim"}"
}

function __escape {
    local str=${@:-$(</dev/stdin)}
    sed 's/[][`~!@#$%^&*()-_=+{}\|;:",<.>/?'"'"']/\\&/g' <<< "$str"
}

function __spaces {
    local count=$1
    if ((count<1)); then return; fi
    printf " %0.s" $(seq -s " " 1 $((count)))
}

function __count {
    str=$@
    if [[ -z "$str" ]]; then echo 0; else echo $(wc -l <<< $str); fi
}

function __prompt {
    question="$@"
    read -p "$question (y/N) " prompt
    [[ $prompt == "y" || $prompt == "Y" || $prompt == "yes" || $prompt == "Yes" ]] && return
    false
}

function __trim {
    local var=${@:-$(</dev/stdin)}
    var="${var#"${var%%[![:space:]]*}"}"
    var="${var%"${var##*[![:space:]]}"}"
    echo -n "$var"
}

# #############################################################################
# Private functions
# #############################################################################
function __prop {
    local prop="$1"; shift
    local str="$*"
    __split_at "-$prop:" "$str" | cut -d"-" -f1
}

function __prop_build {
    local prop="$1"
    local value="$2"
    echo "-$prop:$value-"
}

function __prop_escaped {
    echo $(__escape "$(__prop_build "$1" "$2")")
}

function __is_done {
    case "$@" in
        *"$STR_DONE"*) true ;;
        *) false ;;
    esac
}

function __fresh_id {
    local lines
    readarray -t lines < $TF
    for i in "${!lines[@]}"; do
        local line="${lines[$i]}"
        lines[$i]=$(__prop id "$line")
    done

    local IFS=$'\n'; local numbers=($(echo "${lines[*]}" | sort -n))
    local number
    for  (( i = 0; i < $((${#numbers[@]}-1)); i++ )); do
        if [[ $((${numbers[$i]}+1)) != ${numbers[$(($i + 1))]} ]] ;then
            number="$((${numbers[$i]}+1))"
            break
        fi
    done

    [[ -z $number ]] && let number=${numbers[-1]}+1
    echo $number
}

function __id_line {
    local id="$1"
    echo "$(grep "$(__prop_escaped id $id)" $TF)"
}

function __id_exists {
    if [[ -z $(__id_line $1) ]]; then false; else true; fi
}

function __id_is_done {
    return $(__is_done "$(__id_line $1)")
}

function __leading_spaces {
    local line="$@"
    if __starts_with "$line" "#"; then echo -1; return; fi # TODO: to make it nested under # Stuff, change -1 to 0
    local spaces=$(echo "$line" | cut -d- -f1 | wc -c)
    echo $spaces
}

function __id_indent_level {
    id=$1
    local spaces=$(__leading_spaces "$(__id_line $id)")
    if [ $spaces -eq -1 ]; then echo -1; return; fi
    local result=$((spaces/INDENT))
    echo $result
}

function __id_line_no {
    id=$1
    local line_no=$(grep -n "$(__prop_escaped id $id)" $TF | cut -d: -f1)
    echo $line_no
}

function __id_property {
    local id=$1
    local line_no=$(grep -n "$(__prop_escaped id $id)" $TF | cut -d: -f1)
    echo $((line_no))
}

function __id_is_decorator {
    __starts_with "$(__id_line $1)" "#"
}

function __id_children {
    local id=$1
    if __id_is_decorator $id; then
        __decorator_children $id
        return
    fi

    local opt=$2 # first or all
    local line_no=$(__id_line_no $id)
    local indent_level=$(__id_indent_level $id)
    local rest="$(tail -n +$((line_no+1)) $TF)"

    local children=()
    local IFS=$'\n'
    while read -r child; do
        local spaces="$(__leading_spaces "$child")"
        local child_indent_level=$((spaces/INDENT))
        if [[ $opt = "first" ]]; then
            if [ $child_indent_level -eq $((indent_level+1)) ]; then
                children+=("$child")
            else break; fi
        elif [[ $opt = "all" ]]; then
            if [ $child_indent_level -gt $indent_level ]; then children+=("$child")
            else break; fi
        else
            echo "Wrong arg, __id_children"
        fi
    done <<< "$rest"

    if [[ ${#children[@]} = 0 ]]; then
        return
    else
        printf '%s\n' "${children[@]}"
    fi
}

function __id_percent {
    local id=$1
    local children="$(__id_children $id first)"
    local total_child=$(__count "$children")
    local done_total="0"

    if [ $total_child -eq 0 ]; then
        if __id_is_done $id; then echo 100; else echo 0; fi
        return
    else
        while read -r child; do
            local current_percent=$(__id_percent $(__prop id "$child"))
            done_total=$((done_total+current_percent))
        done <<< "$children"
    fi

    echo $((done_total/total_child))
}

function __id_remove {
    local id="$1"
    local line_no=$(__id_line_no $id)
    local children="$(__id_children $id all)"
    local child_count=$(__count "$children")
    if [ $child_count -gt 0 ]; then
        if __prompt "This entry has children. Proceed?"; then
            while read -r child; do
                sed -i "/$(__escape "$child")/d" $TF
            done <<< "$children"
            sed -i "$line_no""d" $TF
        fi
    else
        sed -i "$line_no""d" $TF
    fi
}

function __id_replace {
    local IDS=""
    local IFS=','
    read -ra IDS <<< "$1"
    for id in "${IDS[@]}"; do
        line=$(__id_line_no $id)
        [[ -z $line ]] && return 1
        sed -i "$line""s/$(__escape "$2")/$(__escape "$3")/" $TF
    done
}

function __process {
    local str="$@"
    local date_str="$(__prop due "$str")"
    if [[ -n $date_str ]] && [[ $date_str =~ ^[a-zA-Z\ ]*$ ]]; then
        date_fixed="$(date -d"$date_str" $DATE_FORMAT)"
        str=$(sed "s/$(__prop_escaped due "$date_str")/$(__prop_escaped due "$date_fixed")/" <<< $str)
    fi

    echo $str
}

function __get_decorator_id {
    case $1 in
        "@"*)
            local decor="$(echo $1 | sed "s/@/# /")"
            # FIXME: find more reliable way:
            # There is a space at the and so that full word gets matched:
            local id="$(__prop id $(grep -i "^$decor " $TF))"
            echo $id
            ;;
    esac
}

function __decorator_children {
    local decor_id="$1"
    local decor_name="$2"
    local line_start
    if [[ -n "$decor_name" ]]; then
        line_start=$(grep -n "# $decor_name" "$TF" | cut -d":" -f1)
    else
        line_start=$(__id_line_no $decor_id)
    fi
    local line_end_relative=$(tail -n +$((line_start+1)) "$TF" | grep -Enm 1 '(^$|^#)'| cut -d: -f1)
    local line_end=$((line_start+line_end_relative-1)) # -1 because do not include blank|# line
    [[ -z $line_end_relative ]] && line_end=$(cat $TF | wc -l)
    sed -n "$line_start,$line_end""p;$((line_end+1))q" "$TF" | tail -n +2
}

function __maintain_today {
    local today_id=$(__get_decorator_id @today)
    local today_line="$(__id_line $today_id)"
    local today_day=$(echo "$today_line" | cut -d"(" -f2 | cut -d")" -f1)
    [[ "$today_day" = "$(date -dtoday $DATE_FORMAT)" ]] && return

    # Reset day
    local line_start=$(__id_line_no $today_id)
    sed -i "$line_start""s/$(__escape "($today_day)")/$(__escape "$(date -dtoday $DATE_FORMAT)")/" $TF

    # Backup
    local children="$(__decorator_children $today_id)"
    [ -z "$children" ] && return
    echo "# $today_day" >> $TPF
    echo "$children" >> $TPF
    echo "" >> $TPF

    # Remove
    while read -r child; do
        sed -i "/$(__escape "$child")/d" $TF
    done <<< "$children"
}

function __modify_decor_summary {
    # FIXME: change today,yestarday etc to local ones (if there are any)

    local decor=$1
    local summary="$2"
    case $decor in
        "@today")
            summary="$(__process "$summary $(__prop_build due today)")"
            ;;
    esac

    echo "$summary"
}

function __filter_date {
    # TODO: next week -> list next week's stuff
    local date="$@"

    local day_prop="$(__process "$(__prop_build due "$date")")"
    term="$(__escape "$day_prop")"

    # TODO: include recurring tasks
    # Print daily
    #__echon "$(__decorator_children $(__get_decorator_id @daily) | __prettify)"

    # Print weekly (of $date's)
    #local day_name="$(date -d$date "+%A" | __lowercase)"
    #__echon "$(__decorator_children $(__get_decorator_id @weekly) | grep "\-due:$day_name\-" | __prettify)"

    # Run search
    __echon "$(grep "$term"  "$TF" | sed "s/^[ \t]*//" | __prettify)"
}

function __prettify {
    # TODO: make STR_DONE green, make STR_UNDONE yellow, if due date is passed make it red
    local str=${@:-$(</dev/stdin)}
    local id_colored="$(echo "$str" | sed -r "s/^(.*)($(__escape "$STR_UNDONE")|$(__escape "$STR_DONE"))(.*)\-id:([^\s\-]+)\-(.*)/\1\2${BOLD}${F_DBLUE}\4${R} \3\5/")"
    local id_hidden="$(echo "$id_colored" | sed "s/\-id:.*\-//" | sed -r "s/\-([a-z]+):([^\s\-]+)\-/${F_DYELLOW}\1${R}:\2/g")"
    local bold_headers="$(echo "$id_hidden" | sed -r "s/^# (.*)/# ${BOLD}\1${R}/" )"
    echo "$bold_headers"
}

# #############################################################################
# Functions
# #############################################################################
function add {
    local id=$(__fresh_id)
    if __is_number $1 || __starts_with $1 "@" ; then
        local parent_id=$1
        shift
        local summary="$@"

        local parent_last_child=""
        if __starts_with $parent_id "@"; then
            summary="$(__modify_decor_summary "$parent_id" "$summary")"
            name="$parent_id"
            parent_id=$(__get_decorator_id $parent_id)
            if [[ -z $parent_id ]]; then
                if [[ -n $(tail -n 1 $TF) ]]; then echo "" >> $TF; fi
                echo "# $(__capitalize_word "${name:1}") $(__prop_build id $id)" >> "$TF"
                return
            fi
            parent_last_child="$(__decorator_children $parent_id | tail -n -1)"
        else
            summary="$(__process "$summary")"
            parent_last_child="$(__id_children $parent_id all | tail -n -1)"
        fi

        if ! __id_exists $parent_id; then return 1; fi

        local parent_line=$(__id_line_no $parent_id)
        local parent_indent_level=$(__id_indent_level $parent_id)
        local spaces=$(__spaces $(((parent_indent_level+1)*INDENT)))
        local result="$(__escape  "$spaces$STR_UNDONE$summary $(__prop_build id $id)")"

        local line_to_insert
        if [[ -z $parent_last_child ]]; then
            line_to_insert=$((parent_line+1))
        else
            line_to_insert=$(($(__id_line_no $(__prop id "$parent_last_child"))+1))
        fi

        (( line_to_insert > "$(cat $TF | wc -l)" )) && echo "" >> $TF
        sed -i "$line_to_insert""i\\$(echo "$result")" $TF
    else
        local result="$STR_UNDONE$(__process "$@ $(__prop_build id $id)")"
        local line_to_insert=$(grep -Enm 1 '(^$|^#)' $TF | cut -d: -f1)
        sed -i "$line_to_insert""i$(__escape "$result")" $TF
    fi

    echo "${BOLD}$id${R}"

    # TODO: really need this? (maybe an extra function: clean, maintanence)
    # Remove trailing and leading blank lines
    #sed -i -e :a -e '/./,$!d;/^\n*$/{$d;N;};/\n$/ba' $TF
}

function mark-done {
    __id_replace $1 "$STR_UNDONE" "$STR_DONE"
}

function mark-undone {
    __id_replace $1 "$STR_DONE" "$STR_UNDONE"
}

function remove {
    if __is_number ${1:0:1} || __starts_with "$1" "@"; then
        # Remove based on ids
        local id
        local IDS
        local IFS=','
        read -ra IDS <<< "$1"
        for id in "${IDS[@]}"; do
            if __starts_with "$1" "@"; then
                id=$(__get_decorator_id $1)
            fi
            if __id_exists $id; then __id_remove $id; fi
        done
    else
        # TODO: Remove based on predicate
        local pred="$@"
        #sed -i "/$(__escape "$pred")/d"
    fi
}

function list {
    cat $TF | __prettify
}

function filter {
    local param="$1"; shift
    local rest="$@"

    local term
    case "$param" in
        "week"|"yesterday"|"today"|"tomorrow"|"next")
            __filter_date "$param $rest" ;;
        "@yest"*)
            local temp="$TF"
            TF="$TPF"
            local result="$(__decorator_children "" "$(date -dyesterday "$DATE_FORMAT")")"
            echo "# $(__capitalize_word ${param:1})" | __prettify
            __echon "$result" | __prettify
            TF="$temp"
            ;;
        "@"*)
            local result="$(__decorator_children $(__get_decorator_id $param))"
            echo "# $(__capitalize_word ${param:1})" | __prettify
            __echon "$result" | __prettify
            ;;
        *)
            # TODO: check for exact dates
            #       filter summaries/notes etc.
            ;;
    esac
}

function __props {
    str="$@"
    echo "$str" | grep -oe "-[^ :]*:[^-]*-" | sed "s/^-//;s/-$//"
}

function __prop_replace {
    local prop="$1";
    local prop_new_value="$2";
    shift 2
    local str="$@"
    echo "$str" | sed -r "s/-$prop:[^-]*-/-$prop:$prop_new_value-/g"
}

function __clear_props {
    str="$@"
    echo "$str" | sed -r "s/ ?-[^:]*:[^-]*-//g"
}

function modify {
    local id=$1; shift
    local str="$@"
    local line_no=$(__id_line_no $id)
    local line=$(__id_line $id)

    # Replace props with new ones
    while read -r prop_pair; do
        local prop_name="$(echo "$prop_pair" | cut -d":" -f1)"
        local prop_value="$(echo "$prop_pair" | cut -d":" -f2)"
        line="$(__prop_replace "$prop_name" "$prop_value"  "$line")"
    done <<< "$(__props "$str")"

    local summary="$(__clear_props "$str" | __trim)"
    if [[ -n "$summary" ]]; then
        line="$summary $(__props "$line" | sed -r "s/(.*)/-\1-/" | paste -sd" ")"
    fi

    line="$(__process "$line" | __escape)"
    sed -i -r "${line_no}s/( *)($(__escape "$STR_DONE")|$(__escape "$STR_UNDONE")|\# ).*/\1\2$line/" "$TF"
}

__maintain_today

param="$1"; shift

case "$param" in
    ""|"ls"|"list") list ;;
    "add") add "$@" ;;
    "remove"|"rm") remove "$@" ;;
    "done"|"d") mark-done "$@" ;;
    "undone"|"u") mark-undone "$@" ;;
    "filter"|"f") filter "$@" ;;
    "modify"|"m") modify "$@" ;;
    *) filter "$param" $@ ;;
esac

# TODO: add notes to TODOs
# TODO: modify -prop:xd- if it exists change, otherwise append
# TODO: Repeating tasks (Daily, Weekly, Monthly, Yearly), show them on `filter today, week etc.` (week may be next 7 days)
# TODO: column view (look for column command (ls -1 | column -c 100)
